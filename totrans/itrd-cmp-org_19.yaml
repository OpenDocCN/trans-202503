- en: '**19'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**19'
- en: FRACTIONAL NUMBERS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**分数值**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: 'We have been using only integral values—integers and characters—in our programs
    so far. In this chapter, we’ll look at how computers represent fractional numbers.
    You’ll learn about two ways to represent fractional values: fixed point and floating
    point.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的程序只使用了整数值——整数和字符。在本章中，我们将了解计算机如何表示分数值。你将学习两种表示分数值的方法：定点和浮点。
- en: I’ll start with fixed-point numbers, to show you how fractional values are represented
    in binary. As you will see, using some of the bits for the fractional part of
    a number reduces the number of bits left for the integer part, thus reducing the
    range of numbers we can represent. Including a fractional part only allows us
    to divide that range into smaller portions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从定点数开始，向你展示分数值如何在二进制中表示。正如你将看到的那样，使用一些位来表示数字的小数部分，会减少剩余位数给整数部分，这样就减少了我们能表示的数字范围。包含小数部分只能将该范围划分为更小的部分。
- en: This limitation on the range will lead us to a discussion of floating-point
    numbers, which allow for a much larger range but introduce other limitations.
    I’ll show you the format and properties of floating-point representation and then
    discuss the most common floating-point binary standard, IEEE 754\. I’ll end the
    chapter with a brief look at how floating-point numbers are processed in the A64
    architecture.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这个范围限制将引导我们讨论浮点数，它们允许更大的范围，但也带来其他限制。我将向你展示浮点数表示法的格式和特性，然后讨论最常见的浮点二进制标准 IEEE
    754。我将在本章末简要介绍 A64 架构中浮点数的处理方式。
- en: '**Fractional Values in Binary**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**二进制中的分数值**'
- en: Let’s start by looking at the mathematics of fractional values. Recall from
    [Chapter 2](ch02.xhtml) that a decimal integer, *N*, is expressed in binary as
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从分数值的数学表达开始。回顾一下[第2章](ch02.xhtml)，我们知道十进制整数 *N* 可以用二进制表示为
- en: '![Image](../images/pg438_Image_291.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg438_Image_291.jpg)'
- en: where each *d[i]* = `0` or `1`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 其中每个 *d[i]* = `0` 或 `1`。
- en: We can extend this to include a fractional part, *F*, such that
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展它以包括一个分数部分 *F*，使得
- en: '![Image](../images/pg438_Image_292.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg438_Image_292.jpg)'
- en: 'where each *d[i]* = `0` or `1`. Note the *binary point* between *d*[0] and
    *d*[–1] on the right-hand side of this equation. All the terms to the right of
    the binary point are inverse powers of two, so this portion of the number sums
    to a fractional value. Like the decimal point on the left-hand side, the binary
    point separates the fractional part from the integral part of the number. Here’s
    an example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 其中每个 *d[i]* = `0` 或 `1`。注意此方程右侧 *d*[0] 和 *d*[-1] 之间的 *二进制点*。所有二进制点右侧的项都是二的负次幂，因此这一部分数字的和就是分数值。就像左侧的十进制点一样，二进制点将数字的小数部分与整数部分分开。这里有一个例子：
- en: '![Image](../images/pg438_Image_293.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg438_Image_293.jpg)'
- en: Although any integer can be represented as a sum of powers of two, an exact
    representation of fractional values in binary is limited to sums of *inverse*
    powers of two. For example, consider an 8-bit representation of the fractional
    value 0.9\. From the equalities
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管任何整数都可以表示为二的幂的和，但二进制中分数值的精确表示仅限于二的*负*次幂的和。例如，考虑分数值 0.9 的 8 位表示。根据以下等式
- en: '![Image](../images/pg438_Image_294.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg438_Image_294.jpg)'
- en: 'we get the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到如下结果：
- en: '![Image](../images/pg438_Image_295.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg438_Image_295.jpg)'
- en: In fact,
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，
- en: '![Image](../images/pg438_Image_296.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg438_Image_296.jpg)'
- en: where ![Image](../images/pg438_Image_297.jpg) means this bit pattern repeats
    indefinitely.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 ![Image](../images/pg438_Image_297.jpg) 表示该位模式无限重复。
- en: To round a fractional value to the nearest value, check the bits to the right
    of the rounding place. If the next bit to the right is `0`, drop all the bits
    to the right of the bit position where you’re rounding. If the next bit to the
    right is `1` and any of the bits following it are `1`, add `1` to the bit position
    where you’re rounding.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要将分数值四舍五入到最近的值，请检查四舍五入位置右侧的位。如果右侧的下一个位是 `0`，则丢弃四舍五入位置右侧的所有位。如果右侧的下一个位是 `1` 且其后跟随的任何位都是
    `1`，则在四舍五入的位置加 `1`。
- en: If the next bit to the right is `1` and all the bits following it are `0`, use
    the *ties-to-even* rule. If the bit you’re rounding to is `0`, simply drop all
    the bits to the right of your rounding place. If the bit you’re rounding to is
    `1`, add `1` to it and drop all the bits to the right of your rounding place.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果右边的下一个位是`1`，且所有后续位都是`0`，则使用*舍入到偶数*规则。如果你要舍入的位是`0`，直接丢弃舍入位右边的所有位。如果你要舍入的位是`1`，则将其加`1`，然后丢弃舍入位右边的所有位。
- en: Let’s round 0.9 to 8 bits. Earlier, you saw that the ninth bit to the right
    of the binary point is `0`, so we drop all the bits to the right of the eighth
    bit position. Thus, we use
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将0.9四舍五入到8位。前面你已经看到，在二进制点右边的第九位是`0`，所以我们将丢弃第八位之后的所有位。于是我们使用
- en: '![Image](../images/pg439_Image_298.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/pg439_Image_298.jpg)'
- en: 'which gives a rounding error as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致如下的舍入误差：
- en: '![Image](../images/pg439_Image_299.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/pg439_Image_299.jpg)'
- en: The AArch64 architecture supports other floating-point rounding algorithms.
    These are discussed in the *Arm Architecture Reference Manual for A-Profile Architecture*,
    available at *[https://developer.arm.com/documentation/ddi0487/latest](https://developer.arm.com/documentation/ddi0487/latest)*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: AArch64架构支持其他浮动点舍入算法。这些内容在*《A-Profile架构的Arm架构参考手册》中*有详细讨论，手册可在*[https://developer.arm.com/documentation/ddi0487/latest](https://developer.arm.com/documentation/ddi0487/latest)*找到。
- en: We typically write numbers in decimal, with a decimal point in a fixed location
    in the number to separate the fractional part from the integer part. Let’s see
    how this works in binary.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常以十进制表示数字，数字中有一个固定位置的小数点，用来将分数部分与整数部分分开。让我们看看这种方法在二进制中是如何工作的。
- en: '**Fixed-Point Numbers**'
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**定点数**'
- en: A *fixed-point number* is essentially a scaled integer representation in which
    the scaling is shown by the location of the *radix point*, which separates the
    fractional part of a number from the integral part. We call it the *decimal point*
    in decimal numbers and the *binary point* in binary numbers. English-speaking
    countries commonly use a period; other regions typically use a comma.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*定点数*本质上是一个缩放的整数表示，其中缩放通过*基数点*的位置显示，基数点将数字的分数部分与整数部分分开。在十进制中，我们称其为*小数点*，在二进制中，我们称其为*二进制点*。讲英语的国家通常使用句点，其他地区通常使用逗号。'
- en: For example, 1,234.5[10] represents 12,345[10] scaled by 1/10, and the binary
    10011010010.1[2] is 100110100101[2] scaled by a factor of 1/2\. When performing
    computations with fixed-point numbers, you need to be mindful of the location
    of the radix point.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，1,234.5[10]表示12,345[10]按1/10进行缩放，二进制的10011010010.1[2]是100110100101[2]按1/2的比例缩放。当使用定点数进行计算时，你需要注意小数点的位置。
- en: In the first part of this section, we’ll look at scaling numbers with a fractional
    part that is an inverse power of two, in which case the fractional part can be
    represented exactly. Then, we’ll look at scaling fractional numbers in decimal
    to avoid the rounding errors described earlier.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的第一部分，我们将研究具有分数部分是二的倒数次幂的数字缩放情况，在这种情况下分数部分可以精确表示。然后，我们将研究如何将十进制中的分数数字进行缩放，以避免之前描述的舍入误差。
- en: '***When the Fractional Part Is a Sum of Inverse Powers of Two***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***当分数部分是二的倒数次幂的和时***'
- en: I’ll start with a program that adds two measurements that are specified to the
    nearest sixteenth. An example would be measuring a length in inches. The fractional
    parts of inches are often specified in inverse powers of two (1/2, 1/4, 1/8, and
    so forth), which can be represented exactly in the binary system.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从一个程序开始，它将添加两个指定到最近十六分之一的测量值。一个例子是测量英寸的长度。英寸的分数部分通常以二的倒数次幂（1/2、1/4、1/8等）表示，这些可以在二进制系统中精确表示。
- en: Our program uses lengths to the nearest sixteenth, so we’ll multiply each value
    by 16 to give us an integral number of sixteenths. The program will first read
    the integer part of a length from the keyboard and then read the number of sixteenths.
    [Listing 19-1](ch19.xhtml#ch19list1) shows how we scale the integer part of the
    number and then add in the fractional part as they’re read from the keyboard.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序使用到最接近的十六分之一长度，因此我们将每个值乘以16，以便得到一个完整的十六分之一数字。程序首先从键盘读取长度的整数部分，然后读取十六分之一的数量。[列表
    19-1](ch19.xhtml#ch19list1)展示了我们如何缩放数字的整数部分，然后将分数部分按读取顺序加上。
- en: '*get_length.s*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*get_length.s*'
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 19-1: A function to read a number in inches and sixteenths of an inch
    from the keyboard*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 19-1：一个从键盘读取英寸和十六分之一英寸的数字的函数*'
- en: We allocate 32 bits for both the number of inches and the number of sixteenths
    of an inch, each to be read as integers from the keyboard. Notice that we’re using
    the `get_uint` function to read each unsigned `int` ❶. You were asked to write
    this function in “Your Turn” [exercise 16.9](ch16.xhtml#ch16exe9) on [page 358](ch16.xhtml#ch16you2).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为英寸数和英寸的十六分之一数分配了32位，每个值都作为整数从键盘读取。请注意，我们使用了`get_uint`函数来读取每个无符号`int`❶。你在“你的挑战”[练习
    16.9](ch16.xhtml#ch16exe9)中被要求编写这个函数，见[第358页](ch16.xhtml#ch16you2)。
- en: We shift the integral part 4 bits to the left to multiply it by 16 ❷. After
    adding the fractional part, we have the total number of sixteenths in our value.
    For example, 5 9/16 would be stored as the integer 5 × 16 + 9 = 89.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将整数部分左移4位，以便将其乘以16❷。在加上分数部分后，我们得到该值的总十六分之一数。例如，5 9/16 将存储为整数 5 × 16 + 9 =
    89。
- en: The scaling leaves 28 bits for the integral part. This limits the range of our
    numbers to be 0 to 268,435,455 15/16\. This is 16 times less than the 0 to 4,294,967,295
    range of a 32-bit unsigned integer, but the resolution is to the nearest 1/16.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放操作为整数部分保留了28位。这限制了我们的数字范围为0到268,435,455 15/16。这个范围是32位无符号整数0到4,294,967,295范围的1/16，但分辨率为最接近的1/16。
- en: Our function to display these measurements, shown in [Listing 19-2](ch19.xhtml#ch19list2),
    displays both the integral and fractional parts.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来显示这些测量值的函数，如[清单 19-2](ch19.xhtml#ch19list2)所示，显示了整数部分和分数部分。
- en: '*display_length.s*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*display_length.s*'
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 19-2: A function to display a number to the nearest sixteenth*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 19-2：一个显示数字到最接近十六分之一的函数*'
- en: We shift the number 4 bits to the right so we can display the integral part
    as an integer ❷. Using a 4-bit mask ❶, we mask off the integral part and display
    the fractional part as another integer ❸. We add some text to show that this second
    integer is the fractional part ❹.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将数字右移4位，以便将整数部分显示为一个整数❷。使用一个4位的掩码❶，我们屏蔽掉整数部分，将分数部分显示为另一个整数❸。我们添加一些文本以显示这个第二个整数是分数部分❹。
- en: '[Listing 19-3](ch19.xhtml#ch19list3) shows a `main` function that adds two
    numbers to the nearest sixteenth.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 19-3](ch19.xhtml#ch19list3)展示了一个`main`函数，它将两个数字加到最接近的十六分之一。'
- en: '*add_lengths.s*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*add_lengths.s*'
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 19-3: A program to add two lengths to the nearest sixteenth*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 19-3：一个将两长度加到最接近的十六分之一的程序*'
- en: If you look at the equation for representing fractional values in binary on
    [page 410](ch19.xhtml#page_410), you can probably convince yourself that the integer
    `add` instruction will work for the entire number, including the fractional part
    ❶.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看[第410页](ch19.xhtml#page_410)中表示分数值的二进制方程，你可能会说服自己，整数`add`指令将适用于整个数字，包括分数部分❶。
- en: Let’s think about how we’ve handled the fractional part in our fixed-point format
    here. When we read the integer part from the keyboard, we shifted it four bit
    positions to the left to multiply by 16\. This left room to add the number of
    sixteenths of the fractional part to this `int`. We effectively created a 32-bit
    number with the binary point between the fifth and fourth bits (bits 4 and 3).
    This works because the fractional part is a sum of inverse powers of two.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下在这里如何处理分数部分的定点格式。当我们从键盘读取整数部分时，我们将其左移了四个位位置，以便乘以16。这为加上分数部分的十六分之一数留出了空间。我们实际上创建了一个32位的数字，其中二进制点位于第五和第四位之间（位4和位3）。这是有效的，因为分数部分是二的负幂的和。
- en: This example works nicely with binary numbers, but we mostly use decimal numbers
    in computations. As you saw earlier in this chapter, most fractional decimal numbers
    can’t be converted to a finite number of bits and need to be rounded. In the next
    section, I’ll discuss how to avoid rounding errors when representing fractional
    decimal numbers in binary.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例在二进制数字上工作得很好，但在计算中我们主要使用十进制数字。正如你在本章前面看到的，大多数分数十进制数字无法转换为有限的位数，需要四舍五入。在下一节中，我将讨论如何避免在将分数十进制数字表示为二进制时出现四舍五入错误。
- en: '***When the Fractional Part Is in Decimal***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***当分数部分是十进制时***'
- en: I’ll use a program that adds two US dollar values to the nearest cent as an
    example of using fractional values in decimal. As with the measurement adding
    program in [Listings 19-1](ch19.xhtml#ch19list1) to [19-3](ch19.xhtml#ch19list3),
    we’ll start with the function to read money values from the keyboard, `get_money`,
    shown in [Listing 19-4](ch19.xhtml#ch19list4).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用一个程序，作为示例来说明如何将两个美元值加到最接近的分，这就是在十进制中使用分数值的方式。与[清单 19-1](ch19.xhtml#ch19list1)到[19-3](ch19.xhtml#ch19list3)中的测量加法程序一样，我们将从读取货币值的函数`get_money`开始，具体见[清单
    19-4](ch19.xhtml#ch19list4)。
- en: '*get_money.s*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*get_money.s*'
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 19-4: A function to read dollars and cents from the keyboard*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 19-4：一个从键盘读取美元和分的函数*'
- en: Our money values are specified to the nearest cent here, so we multiply dollars—the
    integer part—by 100 ❶. Then we add cents—the fractional part—to give our scaled
    `int` ❷.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的货币值指定为最接近的分，因此我们将美元—整数部分—乘以100❶。然后，我们将分—小数部分—加到一起，得到我们缩放后的`int`值❷。
- en: When storing decimal fractions, the integer and fractional parts are not separated
    into bit fields as in our previous example. For example, $1.10 would be stored
    as 110 = `0x0000006e` and $2.10 as 210 = `0x000000d2`. Because we use 32-bit signed
    integers in this program, the range of a money value is –$21,473,836.48 ≤ *money*_*amount*
    ≤ +$21,473,836.47.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储小数分数时，整数部分和小数部分不会像我们之前的例子那样分成不同的比特字段。例如，$1.10 会存储为 110 = `0x0000006e`，$2.10
    会存储为 210 = `0x000000d2`。由于我们在这个程序中使用的是32位带符号整数，因此货币值的范围是 –$21,473,836.48 ≤ *money*_*amount*
    ≤ +$21,473,836.47。
- en: Displaying dollars and cents will require a different algorithm from displaying
    lengths in sixteenths, as shown in [Listing 19-5](ch19.xhtml#ch19list5).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 显示美元和分将需要与显示长度（以分之一为单位）不同的算法，如[Listing 19-5](ch19.xhtml#ch19list5)所示。
- en: '*display_money.s*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*display_money.s*'
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 19-5: A function to display dollars and cents*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 19-5：一个显示美元和分的函数*'
- en: Shifting won’t allow us to divide by 100, so we use the signed divide instruction,
    `sdiv`, to get the dollars ❶. The remainder from this division will be the number
    of cents.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 移位操作不能让我们除以100，因此我们使用带符号除法指令`div`来获取美元❶。这次除法的余数就是分数。
- en: Our computation of the remainder will have the same sign as the integer part.
    The negative sign will show when we display the dollars, but we don’t want to
    repeat it for the cents, so we negate the value for cents before displaying it
    ❷. We check whether the number of cents is less than 10, and if so, we make the
    first digit to the right of the decimal point a 0 ❸.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对余数的计算将与整数部分具有相同的符号。负号在显示美元时会出现，但我们不希望它出现在分数部分，因此在显示分数之前，我们会取反分数的值❷。我们会检查分数是否小于10，如果是，我们会将小数点右边的第一个数字设为0❸。
- en: We see a new instruction here, `cneg:`
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在这里看到一个新指令，`cneg:` '
- en: cneg**—Conditional negate**
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: cneg**—条件取反**
- en: '`cneg w`d`, w`s`,`cond loads the negated value of the 32-bit value in `w`s
    into `w`d ifcond is true. If it’s not true, `w`s is loaded into `w`d.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`cneg w`d`, w`s`,`cond 在cond为真时，将`w`s`中的32位值取反后加载到`w`d中。如果cond不为真，则将`w`s`加载到`w`d中。'
- en: '`cneg x`d`, x`s`,`cond loads the negated value of the 64-bit value in `x`s
    into `x`d ifcond is true. If it’s not true, `x`s is loaded into `x`d.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`cneg x`d`, x`s`,`cond 在cond为真时，将`x`s`中的64位值取反后加载到`x`d中。如果cond不为真，则将`x`s`加载到`x`d中。'
- en: The possible conditions, cond, can be any of the condition flags listed in [Table
    13-1](ch13.xhtml#ch13tab1) on [page 245](ch13.xhtml#page_245) except for `al`
    and `nv`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的条件`cond`可以是[Table 13-1](ch13.xhtml#ch13tab1)中列出的任何条件标志，除了`al`和`nv`。
- en: Our `main` function for this program, shown in [Listing 19-6](ch19.xhtml#ch19list6),
    will get two dollar amounts entered from the keyboard, add them, and display their
    sum.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的`main`函数，如[Listing 19-6](ch19.xhtml#ch19list6)所示，将从键盘输入两个美元金额，将它们相加，并显示它们的总和。
- en: '*add_money.s*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*add_money.s*'
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 19-6: A program to add two dollar values*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 19-6：一个添加两个美元值的程序*'
- en: Our scaling of the integer part has converted dollars to cents, so a simple
    `add` instruction computes the sum for us ❶. Our `display_money` function will
    sort out the dollars and cents in this sum.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对整数部分的缩放已将美元转换为分，因此一个简单的`add`指令就能为我们计算总和❶。我们的`display_money`函数将整理出该总和中的美元和分。
- en: This solution works well for many numbers, but we commonly use scientific notation
    for writing very large and very small numbers. In the next sections, you’ll see
    how the scientific notation has led to another way to store fractional values.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 该方案在处理许多数字时表现良好，但我们通常使用科学记数法来表示非常大或非常小的数字。在接下来的章节中，你将看到科学记数法是如何引入另一种存储小数值的方式的。
- en: '**YOUR TURN**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**你的回合**'
- en: 19.1   Enter the program in [Listings 19-1](ch19.xhtml#ch19list1) to [19-3](ch19.xhtml#ch19list3).
    Using the `gdb` debugger, examine the numbers stored in the `w19` and `w20` registers
    in `main`. Identify the integral and fractional parts.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 19.1 输入[Listings 19-1](ch19.xhtml#ch19list1)至[19-3](ch19.xhtml#ch19list3)中的程序。使用`gdb`调试器，检查`main`中的`w19`和`w20`寄存器中存储的数字。识别整数部分和小数部分。
- en: 19.2   Enter the program in [Listings 19-4](ch19.xhtml#ch19list4) to [19-6](ch19.xhtml#ch19list6).
    Using the `gdb` debugger, examine the numbers stored in the `w19` and `w20` registers
    in `main`. Identify the integral and fractional parts.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 19.2   输入[清单19-4](ch19.xhtml#ch19list4)到[19-6](ch19.xhtml#ch19list6)中的程序。使用`gdb`调试器检查在`main`中存储在`w19`和`w20`寄存器中的数字。识别出整数部分和小数部分。
- en: 19.3   Enter the program in [Listings 19-4](ch19.xhtml#ch19list4) to [19-6](ch19.xhtml#ch19list6).
    Run the program, using $21,474,836.47 for one amount and $0.01 for the other.
    What total does the program give? Why?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 19.3   输入[清单19-4](ch19.xhtml#ch19list4)到[19-6](ch19.xhtml#ch19list6)中的程序。运行程序，使用$21,474,836.47作为一个数值，$0.01作为另一个数值。程序给出的总数是多少？为什么？
- en: 19.4   Write a program in assembly language that allows a user to enter a start
    time and the amount of time a task takes, then computes the finish time. Use a
    24-hour clock with resolution to the nearest second.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 19.4   编写一个汇编语言程序，允许用户输入开始时间和任务所需的时间，然后计算完成时间。使用24小时制时钟，并精确到秒。
- en: '**Floating-Point Numbers**'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**浮动点数**'
- en: '*Floating-point numbers* allow for a much larger range than fixed-point numbers.
    However, it’s important to understand that floating-point numbers are not *real
    numbers*. Real numbers include the continuum of all numbers from –*∞* to +*∞*.
    You already know that we have a finite number of bits to work with in a computer,
    so there is a limit on the largest values that can be represented. But the problem
    is worse than simply a limit on the magnitude.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*浮动点数*的范围比定点数要大得多。然而，重要的是要理解浮动点数并不是*实数*。实数包括从–*∞*到+*∞*的所有数字的连续体。你已经知道计算机中的位数是有限的，因此可以表示的最大值是有限制的。但问题不仅仅是数量级的限制。'
- en: As you will see in this section, floating-point numbers comprise a small subset
    of real numbers. There are significant gaps between adjacent floating-point numbers.
    These gaps can produce several types of errors, as detailed in “Floating-Point
    Arithmetic Errors” on [page 425](ch19.xhtml#ch19lev1sec5). To make matters worse,
    these errors can occur in intermediate results, where they are difficult to debug.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这一节中看到的，浮动点数只是实数的一个小子集。相邻的浮动点数之间存在显著的间隙。这些间隙可能会导致几种类型的错误，详细内容请见“浮动点算术错误”，在[第425页](ch19.xhtml#ch19lev1sec5)。更糟糕的是，这些错误可能出现在中间结果中，使得它们很难调试。
- en: '***Floating-Point Representation***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***浮动点表示法***'
- en: 'Floating-point representation is based on scientific notation. In floating-point
    representation, we have a sign and two numbers to completely specify a value:
    a *significand* and an *exponent*. A decimal floating-point number is written
    as a significand times 10 raised to an exponent. For example, consider these two
    numbers:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 浮动点表示法基于科学记数法。在浮动点表示法中，我们有一个符号和两个数字来完全指定一个值：*有效数字*和*指数*。一个十进制浮动点数被写作有效数字乘以10的指数幂。例如，考虑这两个数字：
- en: '![Image](../images/pg448_Image_300.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg448_Image_300.jpg)'
- en: 'In the floating-point representation, the number is *normalized* such that
    only one digit appears to the left of the decimal point and the exponent of 10
    is adjusted accordingly. If we agree that each number is normalized and that we
    are working in base 10, then each floating-point number is completely specified
    by three items: the significand, exponent, and sign. In the previous two examples:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在浮动点表示法中，数字是*标准化*的，即小数点左边只有一个数字，并且10的指数相应调整。如果我们同意每个数字都经过标准化，并且我们在使用基数为10的表示法，那么每个浮动点数由三项完全指定：有效数字、指数和符号。在前两个例子中：
- en: '![Image](../images/pg448_Image_301.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg448_Image_301.jpg)'
- en: The advantage of using floating-point representation is that, for a given number
    of digits, we can represent a larger range of values.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浮动点表示法的优点是，在给定的数字位数下，我们可以表示更大的数值范围。
- en: Let’s look at how floating-point numbers are stored in a computer.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看浮动点数是如何在计算机中存储的。
- en: '***IEEE 754 Floating-Point Standard***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***IEEE 754 浮动点标准***'
- en: The most commonly used standard for storing floating-point numbers is IEEE 754
    (*[https://standards.ieee.org/standard/754-2019.html](https://standards.ieee.org/standard/754-2019.html)*).
    [Figure 19-1](ch19.xhtml#ch19fig1) shows the general pattern.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 存储浮动点数的最常用标准是IEEE 754（* [https://standards.ieee.org/standard/754-2019.html](https://standards.ieee.org/standard/754-2019.html)
    *）。[图19-1](ch19.xhtml#ch19fig1)展示了其一般模式。
- en: '![Image](../images/pg448_Image_302.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg448_Image_302.jpg)'
- en: '*Figure 19-1: The general pattern for storing IEEE 754 floating-point numbers*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-1：存储IEEE 754浮动点数的一般模式*'
- en: 'The A64 architecture supports four variants of this format for storing floating-point
    numbers: two 16-bit, one 32-bit, and one 64-bit. Of these, the 16-bit half-precision,
    32-bit single-precision, and 64-bit double-precision formats follow the IEEE 754
    standard. The *BF16* format (also called *BFloat16*) is the same as the IEEE 754
    single-precision format but with a truncated significand. This reduces memory
    storage requirements while preserving the dynamic range of the 32-bit format,
    but at the expense of precision. This trade-off is useful in some machine learning
    algorithms. The A64 architecture includes instructions to operate on BF16 data,
    but we won’t use them in this book. These formats are shown in [Figure 19-2](ch19.xhtml#ch19fig2).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: A64架构支持四种变体格式来存储浮动点数：两种16位格式，一种32位格式和一种64位格式。其中，16位半精度、32位单精度和64位双精度格式遵循IEEE
    754标准。*BF16*格式（也称为*BFloat16*）与IEEE 754单精度格式相同，但具有截断的有效数字。这样可以在保持32位格式的动态范围的同时减少内存存储需求，但牺牲了精度。这个折衷在一些机器学习算法中很有用。A64架构包含操作BF16数据的指令，但我们在本书中不会使用它们。这些格式在[图19-2](ch19.xhtml#ch19fig2)中展示。
- en: '![Image](../images/pg449_Image_303.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg449_Image_303.jpg)'
- en: '*Figure 19-2: The formats for (a) half-precision, (b) BF16, (c) single-precision,
    and (d) double-precision floating point*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-2：存储（a）半精度，（b）BF16，（c）单精度和（d）双精度浮动点数的格式*'
- en: 'Values in the formats shown in [Figure 19-2](ch19.xhtml#ch19fig2) represent
    a floating-point number, *N*, stored in the normalized form:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[图19-2](ch19.xhtml#ch19fig2)中显示的格式中的值表示以标准化形式存储的浮动点数*N*：'
- en: '![Image](../images/pg449_Image_304.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg449_Image_304.jpg)'
- en: The first bit, *s*, is the sign bit, `0` for positive and `1` for negative.
    As in decimal scientific notation, the exponent is adjusted such that there is
    only one nonzero digit to the left of the binary point. In binary, though, this
    digit is always 1, giving 1.*f* as the significand. Since it’s always 1, the integer
    part (1) is not stored. It’s called the *hidden bit*. Only the fractional part
    of the significand, *f*, is stored.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个位，*s*，是符号位，`0`表示正数，`1`表示负数。与十进制科学记数法类似，指数会进行调整，以便二进制点左侧只有一个非零数字。不过，在二进制中，这个数字总是1，因此有效数字为1.*f*。由于它总是1，因此整数部分（1）不需要存储。这被称为*隐藏位*。只存储有效数字的小数部分*f*。
- en: The formats need to allow for negative exponents. Your first thought might be
    to use two’s complement. However, the IEEE standard was developed in the 1970s,
    when floating-point computations took a lot of CPU time. Many algorithms in programs
    depend upon only the comparison of two numbers, and the computer scientists of
    the day realized that a format that allowed integer comparison instructions would
    result in faster execution times. So, they decided to add an amount, called a
    *bias*, to the exponent before storing it, such that the most negative allowable
    exponent would be stored as 0\. The result, a *biased exponent*, can then be stored
    as an `unsigned int`. In [Figure 19-2](ch19.xhtml#ch19fig2), the bias is 15 for
    the half-precision IEEE format, 127 for the single-precision IEEE and BF16 formats,
    and 1,023 for the double-precision IEEE format.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些格式需要支持负指数。你可能首先想到使用二进制补码。然而，IEEE标准是在1970年代开发的，那时浮动点计算需要大量的CPU时间。许多程序中的算法仅依赖于两个数字的比较，当时的计算机科学家意识到，允许整数比较指令的格式会导致更快的执行时间。因此，他们决定在存储指数之前加上一个叫做*偏置*的数值，使得最小的可允许指数存储为0。结果是一个*带偏置的指数*，可以存储为`无符号整数`。在[图19-2](ch19.xhtml#ch19fig2)中，半精度IEEE格式的偏置为15，单精度IEEE和BF16格式的偏置为127，双精度IEEE格式的偏置为1,023。
- en: 'The hidden bit scheme presents a problem: there is no way to represent 0\.
    To address this and other issues, the IEEE 754 standard has several special cases:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏位方案存在一个问题：无法表示0。为了解决这个问题以及其他问题，IEEE 754标准包含了几个特殊情况：
- en: '**Zero value**   All the biased exponent bits and fraction bits are `0`, allowing
    for both –0 and +0\. This preserves the sign of a computation that converges to
    0.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**零值** 所有偏置指数位和分数字段都为`0`，因此可以表示–0和+0。这样可以保留收敛到0的计算的符号。'
- en: '**Denormalized**   If the value to be represented is smaller than can be represented
    with all the biased exponent bits being `0`, meaning that *e* has the most negative
    value possible, the hidden bit is no longer assumed. In this case, the amount
    of bias is reduced by 1.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**非正规化**   如果待表示的值小于所有偏置指数位均为`0`时能表示的值，这意味着*e*具有最小的负值，此时不再假定隐藏位存在。在这种情况下，偏移量减少1。'
- en: '**Infinity**   Infinity is represented by setting all the biased exponent bits
    to `1` and all the fraction bits to `0`. This allows the sign bit to designate
    both +*∞* and –*∞*, allowing us to still compare numbers that are out of range.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**无穷大**   无穷大通过将所有偏置指数位设置为`1`，所有分数字段设置为`0`来表示。这样，符号位可以同时表示+*∞*和–*∞*，使我们仍然能够比较超出范围的数字。'
- en: '**Not a number (NaN)**   If the biased exponent bits are all `1` but the fraction
    bits are not all `0`, this represents a value that is in error. This might be
    used to indicate that a floating-point variable doesn’t yet have a value. NaN
    should be treated as a program error.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**非数（NaN）**   如果偏置指数位全为`1`，但分数字段不全为`0`，则表示一个错误值。这可以用来表示一个浮点变量尚未赋值。NaN应该视为程序错误。'
- en: An example of an operation that gives infinity is dividing a nonzero value by
    0\. An example that produces NaN is an operation that has an undefined result,
    such as dividing 0 by 0.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一个导致无穷大的运算示例是将一个非零值除以0。产生NaN的示例是具有未定义结果的运算，例如将0除以0。
- en: Next, I’ll discuss the A64 hardware used to work with floating-point numbers.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将讨论用于处理浮点数的A64硬件。
- en: '**Floating-Point Hardware**'
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**浮点硬件**'
- en: '[Table 9-1](ch09.xhtml#ch9tab1) in [Chapter 9](ch09.xhtml) shows that the A64
    architecture includes a register file that has 32 128-bit registers for floating-point
    or vector computations, the *SIMD&FP* registers.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[表9-1](ch09.xhtml#ch9tab1)在[第9章](ch09.xhtml)中展示了A64架构包含一个寄存器文件，该文件有32个128位寄存器，用于浮点或向量运算，这些寄存器被称为*SIMD&FP*寄存器。'
- en: The A64 architecture includes vector instructions that can operate on multiple
    data items in an SIMD&FP register simultaneously. This is a computing method called
    *single-instruction multiple-data (SIMD)*. Data items for these instructions can
    range from 8 to 64 bits, so a register can hold 2 to 16 data items. There are
    vector instructions for both integer and floating-point operations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: A64架构包括向量指令，可以同时对SIMD&FP寄存器中的多个数据项进行操作。这是一种称为*单指令多数据（SIMD）*的计算方法。这些指令的数据项可以是8到64位，因此一个寄存器可以容纳2到16个数据项。对于整数和浮点操作都有向量指令。
- en: A vector instruction operates on each data item in a SIMD&FP register independently
    from all the other data items in the register. These instructions are useful for
    algorithms that do things like process arrays. One vector instruction can operate
    on several array elements in parallel, resulting in considerable speed gains.
    Such algorithms are common in multimedia and scientific applications.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 向量指令对SIMD&FP寄存器中的每个数据项进行独立操作，不受寄存器中其他数据项的影响。这些指令对于处理数组等任务的算法非常有用。一个向量指令可以并行处理多个数组元素，从而显著提高运算速度。此类算法在多媒体和科学应用中很常见。
- en: The A64 architecture also includes scalar floating-point instructions that operate
    on a single floating-point data item in the low-order bits of the SIMD&FP registers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: A64架构还包括标量浮点指令，这些指令操作SIMD&FP寄存器低位部分的单个浮点数据项。
- en: Programming with SIMD instructions is beyond the scope of this book; we’ll consider
    only scalar floating-point computations here. [Figure 19-3](ch19.xhtml#ch19fig3)
    shows the names of the portions of the SIMD&FP registers used for the scalar floating-point
    instructions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SIMD指令进行编程超出了本书的范围；我们这里只讨论标量浮点运算。[图19-3](ch19.xhtml#ch19fig3)展示了用于标量浮点指令的SIMD&FP寄存器部分的名称。
- en: '![Image](../images/pg450_Image_305.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg450_Image_305.jpg)'
- en: '*Figure 19-3: The A64 floating-point register names*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*图19-3：A64浮点寄存器名称*'
- en: '[Listing 19-7](ch19.xhtml#ch19list7) shows how we can use these registers to
    perform floating-point arithmetic.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单19-7](ch19.xhtml#ch19list7)展示了我们如何使用这些寄存器进行浮点算术运算。'
- en: '*add_floats.s*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*add_floats.s*'
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 19-7: A program to add two floating-point numbers*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单19-7：一个程序用于加法运算两个浮点数*'
- en: We use the `scanf` function from the C standard library to read a floating-point
    number from the keyboard ❶. This will store the number in memory in the 32-bit
    IEEE 754 format. Thus, we don’t need a special instruction to load the number
    into a floating-point register; we can simply use an `ldr` instruction ❷.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 C 标准库中的 `scanf` 函数从键盘读取浮点数 ❶。这会将数字以 32 位 IEEE 754 格式存储在内存中。因此，我们不需要特殊指令将数字加载到浮点寄存器中；我们可以直接使用
    `ldr` 指令 ❷。
- en: 'We need to use the floating-point add instruction, `fadd`, to sum the numbers
    ❸. I won’t list all the floating-point instructions for performing arithmetic,
    but here are the four basic ones:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用浮点加法指令 `fadd` 来计算数字 ❸ 的和。我不会列出所有用于执行算术运算的浮点指令，但这里列出了四个基本指令：
- en: fadd—Floating-point add (scalar)
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: fadd—浮点加法（标量）
- en: '`fadd h`d`, h`s1`, h`s2 adds the half-precision floating-point numbers in `h`s1
    and `h`s2 and stores the result in `h`d.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`fadd h`d`, h`s1`, h`s2` 将 `h`s1 和 `h`s2` 中的半精度浮点数相加，并将结果存储在 `h`d 中。'
- en: '`fadd s`d`, s`s1`, s`s2 adds the single-precision floating-point numbers in
    `s`s1 and `s`s2 and stores the result in `s`d.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`fadd s`d`, s`s1`, s`s2` 将 `s`s1 和 `s`s2` 中的单精度浮点数相加，并将结果存储在 `s`d 中。'
- en: '`fadd d`d`, d`s1`, d`s2 adds the double-precision floating-point numbers in
    `d`s1 and `d`s2 and stores the result in `d`d.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`fadd d`d`, d`s1`, d`s2` 将 `d`s1 和 `d`s2` 中的双精度浮点数相加，并将结果存储在 `d`d 中。'
- en: fsub—Floating-point subtract (scalar)
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: fsub—浮点减法（标量）
- en: '`fsub h`d`, h`s1`, h`s2 subtracts the half-precision floating-point number
    in `h`s2 from the one in `h`s1 and stores the result in `h`d.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`fsub h`d`, h`s1`, h`s2` 从 `h`s2 中减去 `h`s1 中的半精度浮点数，并将结果存储在 `h`d 中。'
- en: '`fsub s`d`, s`s1`, s`s2 subtracts the single-precision floating-point number
    in `s`s2 from the one in `s`s1 and stores the result in `s`d.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`fsub s`d`, s`s1`, s`s2` 从 `s`s1 中减去 `s`s2 中的单精度浮点数，并将结果存储在 `s`d 中。'
- en: '`fsub d`d`, d`s1`, d`s2 subtracts the double-precision floating-point number
    in `d`s2 from the one in `d`s1 and stores the result in `d`d.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`fsub d`d`, d`s1`, d`s2` 从 `d`s1 中减去 `d`s2 中的双精度浮点数，并将结果存储在 `d`d 中。'
- en: fmul—Floating-point multiply (scalar)
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: fmul—浮点乘法（标量）
- en: '`fmul h`d`, h`s1`, h`s2 multiplies the half-precision floating-point numbers
    in `h`s1 and `h`s2 and stores the result in `h`d.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmul h`d`, h`s1`, h`s2` 将 `h`s1 和 `h`s2` 中的半精度浮点数相乘，并将结果存储在 `h`d 中。'
- en: '`fmul s`d`, s`s1`, s`s2 multiplies the single-precision floating-point numbers
    in `s`s1 and `s`s2 and stores the result in `s`d.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmul s`d`, s`s1`, s`s2` 将 `s`s1 和 `s`s2` 中的单精度浮点数相乘，并将结果存储在 `s`d 中。'
- en: '`fmul d`d`, d`s1`, d`s2 multiplies the double-precision floating-point numbers
    in `d`s1 and `d`s2 and stores the result in `d`d.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmul d`d`, d`s1`, d`s2` 将 `d`s1 和 `d`s2` 中的双精度浮点数相乘，并将结果存储在 `d`d 中。'
- en: fdiv—Floating-point divide (scalar)
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: fdiv—浮点除法（标量）
- en: '`fdiv h`d`, h`s1`, h`s2 divides the half-precision floating-point number in
    `h`s1 by the one in `h`s2 and stores the result in `h`d.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`fdiv h`d`, h`s1`, h`s2` 将 `h`s1 中的半精度浮点数除以 `h`s2 中的半精度浮点数，并将结果存储在 `h`d 中。'
- en: '`fdiv s`d`, s`s1`, s`s2 divides the single-precision floating-point number
    in `s`s1 by the one in `s`s2 and stores the result in `s`d.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`fdiv s`d`, s`s1`, s`s2` 将 `s`s1 中的单精度浮点数除以 `s`s2 中的单精度浮点数，并将结果存储在 `s`d 中。'
- en: '`fdiv d`d`, d`s1`, d`s2 divides the double-precision floating-point number
    in `d`s1 by the one in `d`s2 and stores the result in `d`d.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`fdiv d`d`, d`s1`, d`s2` 将 `d`s1 中的双精度浮点数除以 `d`s2 中的双精度浮点数，并将结果存储在 `d`d 中。'
- en: 'The `printf` function requires that floating-point numbers be passed as `double`s,
    so we use the `fcvt` instruction to convert our `float` values to `double`s. The
    `fcvt` instruction converts from the floating-point format of the source register
    to the floating-point format of the destination register:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf` 函数要求浮点数以 `double` 类型传递，因此我们使用 `fcvt` 指令将 `float` 值转换为 `double` 类型。`fcvt`
    指令将源寄存器中的浮点格式转换为目标寄存器中的浮点格式：'
- en: fcvt—Floating-point convert precision (scalar)
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: fcvt—浮点精度转换（标量）
- en: '`fcvt s`d`, h`s converts half-precision in `h`s to single-precision in `s`d.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`fcvt s`d`, h`s` 将 `h`s 中的半精度浮点数转换为 `s`d 中的单精度浮点数。'
- en: '`fcvt d`d`, h`s converts half-precision in `h`s to double-precision in `d`d.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`fcvt d`d`, h`s` 将 `h`s 中的半精度浮点数转换为 `d`d 中的双精度浮点数。'
- en: '`fcvt h`d`, s`s converts single-precision in `s`s to half-precision in `h`d.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`fcvt h`d`, s`s` 将 `s`s 中的单精度浮点数转换为 `h`d 中的半精度浮点数。'
- en: '`fcvt d`d`, s`s converts single-precision in `s`s to double-precision in `d`d.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`fcvt d`d`, s`s` 将 `s`s 中的单精度浮点数转换为 `d`d 中的双精度浮点数。'
- en: '`fcvt h`d`, d`s converts double-precision in `d`s to half-precision in `h`d.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`fcvt h`d`, d`s` 将 `d`s 中的双精度浮点数转换为 `h`d 中的半精度浮点数。'
- en: '`fcvt s`d`, d`s converts double-precision in `d`s to single-precision in `s`d.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`fcvt s`d`, d`s将`d`s中的双精度转换为`s`d中的单精度。'
- en: 'Although we’re not using comparisons in this program, here’s an example of
    a floating-point compare instruction:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个程序中我们没有使用比较操作，但这里有一个浮点数比较指令的例子：
- en: fcmp—Floating-point compare (scalar)
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: fcmp—浮点数比较（标量）
- en: '`fcmp h`s1`, h`s2 compares the half-precision floating-point number in `h`s1
    with `h`s2 and sets the condition flags in the `nzcv` register accordingly.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`fcmp h`s1`, h`s2将`h`s1中的半精度浮点数与`h`s2进行比较，并相应地设置`nzcv`寄存器中的条件标志。'
- en: '`fcmp h`s`, 0.0` compares the half-precision floating-point number in `h`s
    with 0.0 and sets the condition flags in the `nzcv` register accordingly.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`fcmp h`s`, 0.0`将`h`s中的半精度浮点数与0.0进行比较，并相应地设置`nzcv`寄存器中的条件标志。'
- en: '`fcmp s`s1`, s`s2 compares the single-precision floating-point number in `s`s1
    with `s`s2 and sets the condition flags in the `nzcv` register accordingly.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`fcmp s`s1`, s`s2将`s`s1中的单精度浮点数与`s`s2进行比较，并相应地设置`nzcv`寄存器中的条件标志。'
- en: '`fcmp s`s`, 0.0` compares the single-precision floating-point number in `s`s
    with 0.0 and sets the condition flags in the `nzcv` register accordingly.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`fcmp s`s`, 0.0`将`s`s中的单精度浮点数与0.0进行比较，并相应地设置`nzcv`寄存器中的条件标志。'
- en: '`fcmp d`s1`, d`s2 compares the double-precision floating-point number in `d`s1
    with `d`s2 and sets the condition flags in the `nzcv` register accordingly.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`fcmp d`s1`, d`s2将`d`s1中的双精度浮点数与`d`s2进行比较，并相应地设置`nzcv`寄存器中的条件标志。'
- en: '`fcmp d`s`, 0.0` compares the double-precision floating-point number in `d`s
    with 0.0 and sets the condition flags in the `nzcv` register accordingly.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`fcmp d`s`, 0.0`将`d`s中的双精度浮点数与0.0进行比较，并相应地设置`nzcv`寄存器中的条件标志。'
- en: Since the `fcmp` instruction sets the condition flags in the `nzcv` register,
    we can use the conditional branch instruction described in [Chapter 13](ch13.xhtml)
    with the conditions in [Table 13-1](ch13.xhtml#ch13tab1) to control program flow
    based on floating-point values.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`fcmp`指令会设置`nzcv`寄存器中的条件标志，因此我们可以使用[第13章](ch13.xhtml)中描述的条件跳转指令，并根据[表13-1](ch13.xhtml#ch13tab1)中的条件来根据浮点值控制程序流。
- en: As mentioned earlier, floating-point computations can lead to some subtle numerical
    errors in our programs. I’ll cover these in the next section.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，浮点计算可能会导致程序中的一些微妙的数值误差。我将在下一节中介绍这些问题。
- en: '**Floating-Point Arithmetic Errors**'
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**浮点算术误差**'
- en: It’s easy to think of floating-point numbers as real numbers, but they’re not.
    Most floating-point numbers are rounded approximations of the real numbers they
    represent. When using floating-point arithmetic, you need to be aware of the effects
    of rounding on your computations. If you don’t pay close attention to the rounding
    effects, you might not notice the errors that can creep into your computations.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易将浮点数视为实数，但它们并非如此。大多数浮点数是它们所表示的实数的四舍五入近似值。在使用浮点算术时，您需要意识到四舍五入对计算的影响。如果不注意四舍五入的影响，您可能无法发现计算中可能出现的误差。
- en: 'Most of the arithmetic errors I’ll discuss here are also possible with fixed-point
    arithmetic. Probably the most common arithmetic error is *rounding error*, which
    can occur for two reasons: either the number of bits available for storage is
    limited or the fractional values cannot be precisely represented in all number
    bases.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在这里讨论的大多数算术误差也可能发生在定点算术中。可能最常见的算术误差是*四舍五入误差*，这种误差可能由两个原因引起：要么存储的比特数有限，要么小数值在所有数字基中无法精确表示。
- en: Both of these limitations also apply to fixed-point representation. As you saw
    earlier in this chapter, you can often scale fixed-point numbers to eliminate
    the problem with fractional values—but then the number of bits available for storage
    limits the range of the values.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个限制同样适用于定点表示。正如本章前面所提到的，通常可以通过缩放定点数来消除小数值的问题——但是，存储的比特数限制了值的范围。
- en: Floating-point representation reduces the range problem by using an exponent
    to specify where the integer part begins. However, the significand of a floating-point
    number is a fraction, which means that most floating-point numbers do not have
    an exact representation in binary, leading to rounding errors.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数表示通过使用指数来指定整数部分的起始位置，减少了范围问题。然而，浮点数的有效数字是一个分数，这意味着大多数浮点数在二进制中没有精确的表示，导致四舍五入误差。
- en: One of the biggest problems with floating-point arithmetic is that the CPU instructions
    can shift the significand of a number, adjusting the exponent accordingly and
    causing bits to be lost and more rounding errors. With integer arithmetic, any
    shifting of bits is explicit in the program.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数运算的一个最大问题是，CPU 指令可能会改变一个数字的有效数字，同时调整指数，从而导致位丢失和更多的舍入错误。而在整数运算中，任何位的移动在程序中都是显式的。
- en: 'When computing with integers, you need to be aware of errors in the most significant
    places of the results: carry for unsigned integers and overflow for signed integers.
    With floating-point numbers, the radix point is adjusted to maintain the integrity
    of the most significant places. Most errors in floating-point arithmetic are the
    result of rounding in the low-order places that is needed to fit the value within
    the allocated number of bits. The errors in floating-point arithmetic are more
    subtle, but they can have important effects on the accuracy of our programs.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行整数计算时，你需要注意结果中最重要位上的错误：无符号整数的进位和有符号整数的溢出。而对于浮点数，基数点会被调整以保持最重要位的完整性。浮点数运算中的大多数错误是由于需要将数值适配到分配的比特数中时，低位的舍入产生的。浮点数运算中的错误更为微妙，但它们可能对程序的准确性产生重要影响。
- en: Let’s look at the different types of errors that can arise in floating-point
    computations.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在浮点计算中可能出现的不同类型的错误。
- en: '***Rounding Error***'
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***舍入误差***'
- en: 'You saw at the beginning of this chapter that most decimal fractional values
    do not have exact equivalents in binary, leading to a rounded-off approximation
    being stored in memory. Running the `add_floats` program from [Listing 19-7](ch19.xhtml#ch19list7)
    illustrates this problem:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开始时，你已经看到大多数十进制小数在二进制中没有精确的等价表示，导致存储在内存中的是一个四舍五入的近似值。运行[清单 19-7](ch19.xhtml#ch19list7)中的`add_floats`程序可以说明这个问题：
- en: '[PRE7]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The numbers the program is using are not the ones I entered, and the `fadd`
    instruction didn’t add the program’s numbers correctly. Before you go back to
    look for the bugs in [Listing 19-7](ch19.xhtml#ch19list7), let’s bring in the
    debugger to see if we can figure out what’s happening:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用的数字并不是我输入的数字，`fadd`指令没有正确地将程序中的数字加在一起。在你返回去查找[清单 19-7](ch19.xhtml#ch19list7)中的错误之前，让我们引入调试器，看看能否弄明白发生了什么：
- en: '[PRE8]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'I set a breakpoint at the call to `printf` and then ran the program, entering
    the same numbers as earlier. Let’s look at the three values that are passed to
    `printf`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我在调用`printf`的地方设置了一个断点，然后运行程序，输入了和之前一样的数字。我们来看一下传递给`printf`的三个值：
- en: '[PRE9]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This display can be a bit confusing. For each floating-pointing register, the
    values in the first set of brackets are in hexadecimal. The first value (`f =`)
    shows the integer part of the number in hexadecimal. For example, the integer
    part of the value in `d0` is `0x7b` = 123[10], which is the integer part of the
    number I entered. The next two values (`u =` and `s =`) show the bit pattern of
    the entire number as it’s stored. We can use this bit pattern with the format
    in [Figure 19-2](ch19.xhtml#ch19fig2)(d) to figure out the floating-point number.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个显示可能有点让人困惑。对于每个浮点寄存器，第一个括号中的值是十六进制的。第一个值（`f =`）显示数字的整数部分，格式是十六进制。例如，`d0`中的整数部分是`0x7b`
    = 123[10]，即我输入的数字的整数部分。接下来的两个值（`u =`和`s =`）显示了整个数字的比特模式，它是以这种方式存储的。我们可以利用这个比特模式结合[图
    19-2](ch19.xhtml#ch19fig2)(d)中的格式来推算出浮点数的值。
- en: The values in the second set of brackets show the number in floating point (`f
    =`), as though the bits were interpreted as an unsigned integer (`u =`) and as
    a signed integer (`s =`).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组括号中的值显示的是浮点数的值（`f =`），以及这些比特被解释为无符号整数（`u =`）和有符号整数（`s =`）的值。
- en: 'Don’t worry if you’re still confused by this display. I also find it a bit
    confusing. The important part is where the display shows the floating-point number
    that is actually stored in each register: 123.40000152587891 in `d0`, 567.79998779296875
    in `d1`, and 691.19998931884766 in `d2`. The `printf` function rounded each of
    these numbers to six decimal places when I ran the program. These values reflect
    the fact that most decimal fractional values do not have an exact binary equivalence.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然对这个显示感到困惑，不要担心。我自己也觉得有点困惑。重要的部分是，显示中展示的每个寄存器中实际存储的浮点数：`d0`中的123.40000152587891，`d1`中的567.79998779296875，和`d2`中的691.19998931884766。运行程序时，`printf`函数将这些数字四舍五入到了小数点后六位。这些值反映了大多数十进制小数在二进制中没有精确等价表示的事实。
- en: '***Absorption***'
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***吸收***'
- en: '*Absorption* results from adding or subtracting two numbers of widely different
    magnitude. The value of the smaller number gets lost in the computation. Let’s
    run our `add_floats` program under `gdb` to see how this occurs:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*吸收* 发生在加减两个数量级差异较大的数字时。较小的数字的值会在计算中丢失。让我们在 `gdb` 中运行我们的 `add_floats` 程序，看看这种情况是如何发生的：'
- en: '[PRE10]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'From the `gdb` display, we see that the values in the registers are:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `gdb` 显示中，我们看到寄存器中的值是：
- en: '[PRE11]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The CPU aligns the binary points of the numbers before performing the addition.
    The pattern in [Figure 19-2](ch19.xhtml#ch19fig2)(c) shows that the `fadd` instruction
    performed the following addition:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 在执行加法之前会对数字的二进制点进行对齐。图 [19-2](ch19.xhtml#ch19fig2)(c) 中的模式显示，`fadd` 指令执行了以下加法：
- en: '![Image](../images/pg456_Image_306.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg456_Image_306.jpg)'
- en: Since the significand in single-precision floating point is 24 bits (one is
    the hidden bit), the number in `s2` is rounded to `111111111111111111111111`,
    thus losing everything to the right of the binary point. The number in `s1` was
    absorbed by the much larger number in `s0`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单精度浮点数的有效数字为 24 位（其中一个是隐藏位），`s2` 中的数字被四舍五入为 `111111111111111111111111`，因此丢失了二进制点右侧的所有位。`s1`
    中的数字被 `s0` 中的更大数字吸收。
- en: '***Cancellation***'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***消除***'
- en: '*Cancellation* can occur when subtracting two numbers that differ by a small
    amount. Since floating-point notation preserves the integrity of the high-order
    portions, the subtraction will give 0 in the high-order portion of the result.
    If either of the numbers has been rounded, its low-order portion is not exact,
    which means the result will be in error.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*消除* 发生在减去两个差距很小的数字时。由于浮点表示法保留了高位部分的完整性，减法将在结果的高位部分得到 0。如果任何一个数字已经被四舍五入，它的低位部分就不再精确，这意味着结果会出错。'
- en: 'To demonstrate, we can use our `add_floats` program to subtract by entering
    a negative number. Here’s an example using two close numbers:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们可以使用我们的 `add_floats` 程序通过输入负数来进行减法。这里有一个使用两个接近数字的示例：
- en: '[PRE12]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'From the `gdb` display, we see that the values in the registers are:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `gdb` 显示中，我们看到寄存器中的值是：
- en: '[PRE13]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The relative error in this subtraction is (0.125 – 0.1) / 0.1 = 0.25 = 25%.
    The second number has been rounded from –1,677,721.4 to –1,677,721.375, which
    led to the error in the arithmetic.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这次减法中的相对误差是 (0.125 – 0.1) / 0.1 = 0.25 = 25%。第二个数字从 –1,677,721.4 四舍五入为 –1,677,721.375，这导致了算术错误。
- en: 'Let’s look at how these numbers are treated as `float`s:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些数字如何作为 `float` 类型处理：
- en: '![Image](../images/pg457_Image_307.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg457_Image_307.jpg)'
- en: Subtraction has caused the high-order 20 bits in `s0` and `s1` to cancel, leaving
    only three bits of significance for `s2`. The rounding error in `s1` carries through
    to cause an error in `s2`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 减法导致 `s0` 和 `s1` 中的高位 20 位相消，只留下 `s2` 中的三个有效位。`s1` 中的四舍五入误差传递到 `s2` 中，导致了 `s2`
    的错误。
- en: 'Let’s use two values that will not give a rounding error:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用两个不会出现四舍五入误差的值：
- en: '[PRE14]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this case, the three numbers are stored exactly:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，三个数字被准确地存储：
- en: '![Image](../images/pg457_Image_308.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg457_Image_308.jpg)'
- en: The subtraction has still caused the high-order 20 bits of `s0` and `s1` to
    cancel and left only three bits of significance for `s3`, but `s3` is correct.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这次减法仍然导致 `s0` 和 `s1` 的高位 20 位相消，并且只留下 `s3` 的三个有效位，但 `s3` 是正确的。
- en: '*Catastrophic cancellation* occurs when at least one of the floating-point
    numbers has a rounding error that causes an error in the difference. If both numbers
    are stored exactly, we get *benign cancellation*. Both types of cancellation cause
    a loss of significance in the result.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*灾难性消除* 发生在至少有一个浮点数存在四舍五入误差时，这会导致差值中的错误。如果两个数字都被精确存储，则会发生 *良性消除*。这两种类型的消除都会导致结果中的有效位丧失。'
- en: '***Associativity***'
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结合性***'
- en: Probably the most insidious effects of floating-point errors are those that
    cause errors in intermediate results. They can show up in some sets of data but
    not in others. Errors in intermediate results can even cause floating-point addition
    not to be associative—that is, there are some values of the `float`s `x`, `y`,
    and `z` for which `(x + y) + z` is not equal to `x + (y + z)`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点错误最具隐蔽性的影响之一是那些导致中间结果出错的错误。它们可能在某些数据集上出现，但在其他数据集上没有。中间结果中的错误甚至可能导致浮点加法不满足结合律——也就是说，对于某些
    `float` 类型的值 `x`、`y` 和 `z`，`(x + y) + z` 不等于 `x + (y + z)`。
- en: Let’s write a simple C program to test for associativity, as shown in [Listing
    19-8](ch19.xhtml#ch19list8).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个简单的 C 程序来测试结合性，如 [清单 19-8](ch19.xhtml#ch19list8) 所示。
- en: '*three_floats.c*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*three_floats.c*'
- en: '[PRE15]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 19-8: A program to show that floating-point arithmetic is not associative*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 19-8：一个展示浮点运算不满足结合律的程序*'
- en: 'We’ll start with some simple numbers:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一些简单的数字开始：
- en: '[PRE16]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It appears that our program has a bug. Let’s use `gdb` to see if we can figure
    out what’s going on here. I set a breakpoint at the `sum1 += z` statement so we
    can view the contents of the five variables in this program, then I ran the program:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们的程序有一个 bug。让我们使用 `gdb` 看看是否能找出问题所在。我在 `sum1 += z` 语句处设置了一个断点，这样我们就可以查看程序中五个变量的内容，然后我运行了程序：
- en: '[PRE17]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, let’s determine the addresses of the variables:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来确定变量的地址：
- en: '[PRE18]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The variables are stored in five consecutive 32-bit words beginning with `z`
    at `0x7fffffef8c`. Let’s look at these five values, both in floating-point format
    and in hexadecimal:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 变量存储在从 `z` 开始的五个连续 32 位字中，地址为 `0x7fffffef8c`。我们来查看这五个值，分别以浮点格式和十六进制表示：
- en: '[PRE19]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We’ll work with the values in hexadecimal to determine what’s going on here.
    Using the IEEE 754 format for single-precision floating point in [Figure 19-2(c)](ch19.xhtml#ch19fig2),
    we get the following addition:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以十六进制的方式处理这些值，来弄清楚发生了什么。根据 [图 19-2(c)](ch19.xhtml#ch19fig2) 中的 IEEE 754 单精度浮点格式，我们得到以下加法：
- en: '![Image](../images/pg459_Image_309.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg459_Image_309.jpg)'
- en: 'Since the format allows only 23 bits for the significand, the CPU will round
    off the sum to give the following number (remember the ties-to-even rule discussed
    on [page 410](ch19.xhtml#page_410)):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该格式仅允许 23 位有效数字，CPU 会对和进行四舍五入，得到以下数字（记住在 [第 410 页](ch19.xhtml#page_410) 中讨论的偶数舍入规则）：
- en: '![Image](../images/pg460_Image_310.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg460_Image_310.jpg)'
- en: This is the number we saw stored in IEEE 754 format at the address of `sum1`
    (`0x7fffffef9c`) in our `gdb` display earlier.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前在 `gdb` 显示中看到存储在 `sum1` 地址（`0x7fffffef9c`）中的数字，格式为 IEEE 754。
- en: 'Now we’ll execute the current instruction, which adds `z` to `sum1`, and look
    at its new value:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们执行当前指令，它将 `z` 加到 `sum1` 上，并查看它的新值：
- en: '[PRE20]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The CPU has performed the following addition:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 执行了以下加法：
- en: '![Image](../images/pg460_Image_311.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg460_Image_311.jpg)'
- en: 'The CPU then rounds off `sum1` to give a 23-bit significand:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 接着对 `sum1` 进行四舍五入，得到一个 23 位的有效数字：
- en: '![Image](../images/pg460_Image_312.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg460_Image_312.jpg)'
- en: 'Now, we’ll go though the same steps to compute `sum2`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将按照相同的步骤计算 `sum2`：
- en: '[PRE21]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The numbers here are the result of the following addition:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的数字是以下加法的结果：
- en: '![Image](../images/pg460_Image_313.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg460_Image_313.jpg)'
- en: 'Rounding off gives:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 四舍五入后得到：
- en: '![Image](../images/pg460_Image_314.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg460_Image_314.jpg)'
- en: 'The current statement adds `x`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当前语句加上了 `x`：
- en: '[PRE22]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This performs the addition:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这执行了加法：
- en: '![Image](../images/pg461_Image_315.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg461_Image_315.jpg)'
- en: 'The CPU then rounds off `sum2` to give a 23-bit significand (again, remember
    the ties-to-even rule):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 接着对 `sum2` 进行四舍五入，得到一个 23 位的有效数字（同样，记住偶数舍入规则）：
- en: '![Image](../images/pg461_Image_316.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg461_Image_316.jpg)'
- en: 'Continuing the program to the end gives:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 继续执行程序直到结束，得到：
- en: '[PRE23]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `printf` function has rounded off the display of `sum1` and `sum2` so they
    look equal, but looking inside the program with `gdb` shows that they are not
    equal. We conclude that the bug in our program is not in our logic but in our
    use of floating-point variables.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf` 函数已经将 `sum1` 和 `sum2` 的显示结果四舍五入，使得它们看起来相等，但通过 `gdb` 查看程序内部会发现它们并不相等。我们得出结论，程序中的
    bug 不在于我们的逻辑，而是在于我们使用浮点变量的方式。'
- en: 'The difference between the two orders of adding the three `float`s is very
    small:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 两种加法顺序的差异非常小：
- en: '![Image](../images/pg461_Image_317.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg461_Image_317.jpg)'
- en: However, this small difference could become significant if this is part of a
    computation that involves multiplying by large numbers.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果这是一个涉及乘以大数的计算，这个小差异可能变得显著。
- en: The main lesson to learn from this example is that floating-point arithmetic
    is seldom precise.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中学到的主要教训是，浮点运算很少是精确的。
- en: '**YOUR TURN**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮到你了**'
- en: 19.5   Modify the C program in [Listing 19-8](ch19.xhtml#ch19list8) to use `double`s.
    Does this make floating-point addition associative?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 19.5   修改 [Listing 19-8](ch19.xhtml#ch19list8) 中的 C 程序，使用 `double` 类型。这样做能使浮点加法满足结合律吗？
- en: '**Comments About Numerical Accuracy**'
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**关于数值精度的评论**'
- en: 'Novice programmers often see floating-point numbers as real numbers and thus
    think they are more accurate than integers. It’s true that using integers carries
    its own set of problems: even adding two large integers can cause overflow. Multiplying
    integers is even more likely to produce a result that will overflow. And you need
    to take into account that integer division results in two values, the quotient
    and the remainder, instead of the one value that floating-point division gives
    us.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 初学者程序员常常将浮动点数视为实数，因此认为它们比整数更准确。确实，使用整数有其自身的问题：即便是加法运算两个大整数也可能导致溢出。乘法运算更容易产生溢出的结果。而且，整数除法会产生两个值——商和余数——而不是浮动点数除法产生的一个值。
- en: 'But floating-point numbers are not real numbers. As you’ve seen in this chapter,
    floating-point representations extend the range of numerical values but have their
    own set of potential inaccuracies. Arithmetically accurate results require a thorough
    analysis of your algorithm. Here are some ideas to consider:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 但浮动点数并不是实数。正如你在本章中所看到的，浮动点数表示扩展了数值的范围，但也有可能产生不准确的结果。要得到算术上精确的结果，必须对你的算法进行深入分析。以下是一些值得考虑的建议：
- en: Try to scale the data such that integer arithmetic can be used.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试调整数据，使得可以使用整数运算。
- en: Use `double`s instead of `float`s. This improves accuracy and may actually increase
    the speed of execution. Most C and C++ library routines take `double`s as arguments,
    so the compiler converts `float`s to `double`s when passing them as arguments,
    as in the call to `printf` in [Listing 19-7](ch19.xhtml#ch19list7).
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`double`而不是`float`。这可以提高准确性，并且可能实际提高执行速度。大多数C和C++库函数都接受`double`作为参数，因此当将`float`传递给这些函数时，编译器会将其转换为`double`，就像在[Listing
    19-7](ch19.xhtml#ch19list7)中的`printf`调用一样。
- en: Try to arrange the order of computations so that similarly sized numbers are
    added or subtracted.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试安排计算顺序，使得相似大小的数字进行加法或减法运算。
- en: Avoid complex arithmetic statements that may obscure incorrect intermediate
    results.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免复杂的算术表达式，这些表达式可能会掩盖不正确的中间结果。
- en: Choose test data that stresses your algorithm. If your program processes fractional
    values, include data that does not have an exact binary equivalent.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择能加剧你算法的问题的测试数据。如果你的程序处理小数值，包含一些没有精确二进制等效的数值。
- en: The good news is that with today’s 64-bit computers, the range of integers is
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，随着今天64位计算机的出现，整数的范围已经大大扩展。
- en: '![Image](../images/pg461_Image_317a.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg461_Image_317a.jpg)'
- en: and there are libraries available in many programming languages that allow us
    to use arbitrary-precision arithmetic in our programs. You can find a list of
    these libraries at *[https://en.wikipedia.org/wiki/List_of_arbitrary-precision_arithmetic_software](https://en.wikipedia.org/wiki/List_of_arbitrary-precision_arithmetic_software)*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言中都有可以使用任意精度算术的库。你可以在*[https://en.wikipedia.org/wiki/List_of_arbitrary-precision_arithmetic_software](https://en.wikipedia.org/wiki/List_of_arbitrary-precision_arithmetic_software)*找到这些库的列表。
- en: This section has provided an overview of the primary causes of numerical errors
    when using floating-point numbers. For a more rigorous treatment of the topic,
    David Goldberg’s paper “What Every Computer Scientist Should Know About Floating-Point
    Arithmetic” (*ACM Computing Surveys*, Vol. 23, No. 1, March 1991) and *[https://en.wikipedia.org/wiki/Floating-point_arithmetic](https://en.wikipedia.org/wiki/Floating-point_arithmetic)*
    are good starting points. For an example of a programming technique to reduce
    rounding errors, you can read about the Kahan summation algorithm at *[https://en.wikipedia.org/wiki/Kahan_summation_algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm)*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了使用浮动点数时出现数值错误的主要原因概述。欲深入了解这一主题，David Goldberg的论文《What Every Computer Scientist
    Should Know About Floating-Point Arithmetic》（《ACM Computing Surveys》，第23卷，第1期，1991年3月）和*[https://en.wikipedia.org/wiki/Floating-point_arithmetic](https://en.wikipedia.org/wiki/Floating-point_arithmetic)*是不错的起点。若想了解减少舍入误差的编程技巧，你可以阅读关于Kahan求和算法的文章，链接是*[https://en.wikipedia.org/wiki/Kahan_summation_algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm)*。
- en: '**What You’ve Learned**'
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: '**Binary representation of fractional values**   Fractional values in binary
    are equal to sums of inverse powers of two.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**二进制表示的小数值** 小数值在二进制中的表示是2的倒数幂之和。'
- en: '**Fixed point in binary**   The binary point is assumed to be in a specific
    position in the binary representation of the number.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**二进制中的定点表示** 二进制点被假定为在数值的二进制表示中的特定位置。'
- en: '**Floating-point numbers are not real numbers**   The gap between adjacent
    floating-point numbers varies according to the exponent.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**浮点数不是实数** 浮点数之间的间隔会根据指数的不同而变化。'
- en: '**Floating-point is usually less accurate than fixed-point**   Rounding errors
    are commonly obscured by floating-point format normalization and can accumulate
    through multiple computations.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**浮点通常不如定点精确** 舍入误差通常被浮点格式的标准化掩盖，并可能在多次计算中累积。'
- en: '**IEEE 754**   The most common standard for representing floating-point values
    in a computer program. The integer part is always 1\. The exponent specifies the
    number of bits included in, or excluded from, the integer part.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**IEEE 754** 计算机程序中表示浮点值的最常见标准。整数部分总是 1。指数指定包含或排除整数部分的位数。'
- en: '**SIMD and floating-point hardware**   Floating-point instructions use a separate
    register file in the CPU.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**SIMD 和浮点硬件** 浮点指令在 CPU 中使用单独的寄存器文件。'
- en: So far in this book, I have discussed programs that follow a step-by-step order
    of execution of instructions. But in some instances, an instruction cannot do
    anything meaningful with its operands—for example, when we divide by 0\. As you
    saw earlier in this chapter, this can trigger an exception to the intended order
    of program execution. We may also want to allow outside events, such as using
    the keyboard, to interrupt the ongoing program execution. After discussing input/output
    in [Chapter 20](ch20.xhtml), I’ll cover interrupts and exceptions in [Chapter
    21](ch21.xhtml).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我讨论了按步骤执行指令的程序。但在某些情况下，指令不能与其操作数执行任何有意义的操作——例如，当我们除以 0 时。如本章前面所示，这可能会触发程序执行顺序的异常。我们还可能希望允许外部事件，如使用键盘，来中断正在进行的程序执行。在讨论完输入/输出后，在[第
    20 章](ch20.xhtml)中，我将在[第 21 章](ch21.xhtml)中讲解中断和异常。
