- en: '3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TURING MACHINES AND TURING COMPLETENESS
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Spend enough time around programming languages, and two phrases inevitably
    appear: “Turing machine” and “Turing completeness.” In this chapter, we’ll explain
    what these phrases mean and why they are important. Specifically, we’ll introduce
    the halting problem and discuss Alan Turing’s fantastic solution to it. That will
    set the stage for discussing Turing machines and Turing completeness. We’ll end
    by simulating a Turing machine in Python.'
  prefs: []
  type: TYPE_NORMAL
- en: The topics of this chapter fall under the heading “theoretical computer science,”
    which is a branch of mathematics, not software engineering. As we’ll see below,
    theoretical computer science predates the availability of physical computers.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Halting Problem**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Early 20th-century mathematicians had a problem. They were several decades into
    a serious effort to put all of mathematics on a logical foundation. As part of
    this program, in 1928, David Hilbert and Wilhelm Ackermann issued their “Entscheidungsproblem”
    (German for “decision problem”). When given a statement in some formal system,
    the problem asked for an algorithm that would infallibly return “yes” or “no”
    as to the validity of that statement. In other words, the problem asked for an
    algorithm that would say whether the statement can be proven from the axioms of
    the system, which are those statements accepted as true without proof. It’s important
    to note that Hilbert and Ackermann’s challenge was for a universal algorithm,
    that is, one that will always give the correct answer for all applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 1936, a young Alan Turing, not quite 24 years old, published what became
    the foundational paper of theoretical computer science: “On Computable Numbers,
    with an Application to the Entscheidungsproblem.” In this paper, Turing demonstrated
    that there is no general solution to the Entscheidungsproblem. That is, there
    is no algorithm that can always correctly decide on the validity of a statement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, Turing addressed a specific problem: the *halting problem*. There
    are different ways to describe the halting problem, but we’ll use this definition:'
  prefs: []
  type: TYPE_NORMAL
- en: Find a program, *P*, that when given as input the source code of another program,
    *T*, and an input for that program, *I*, will always output “yes” if *T* will
    eventually stop for input *I*, or “no” if *T* will run forever for input *I*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a halting problem. We want to know if a program will eventually stop,
    or run forever for a given input. The program in question is *T* and the input
    is *I*. The program that decides, that outputs “yes” or “no,” is *P*. The definition
    above uses the word *program* for *P*, with the implicit understanding that algorithms
    can be encoded in programs. After all, that is what programming is all about:
    encoding algorithms (thought) in a form that can instruct a machine. We’ll come
    back to this equivalence between algorithm and program below.'
  prefs: []
  type: TYPE_NORMAL
- en: Turing’s paper, which is quite readable and easily found online with a search
    for the title above, showed that there is no *P*. It doesn’t exist. As the halting
    problem is a decision problem, Turing thereby established that the Entscheidungsproblem
    has no solution either.
  prefs: []
  type: TYPE_NORMAL
- en: At virtually the same time as Turing, indeed, slightly before, Alonzo Church
    arrived at the same conclusion using a formal system known as *λ*-calculus (lambda
    calculus). If you read Turing’s 1936 paper, the introduction concludes with a
    reference to Church’s “recent paper” using *λ*-calculus to show what Turing was
    about to demonstrate. In the end, Turing became Church’s student at Princeton,
    completing his PhD there in 1938.
  prefs: []
  type: TYPE_NORMAL
- en: Turing’s proof that there is no solution for the halting problem required several
    iterations. The version in his 1936 paper is somewhat buggy. The essence of the
    proof is by contradiction.
  prefs: []
  type: TYPE_NORMAL
- en: Assume we have a program, *P*, a program that accepts another program, *T*,
    and an input for it, *I*. *P* tells us whether *T* will halt on *I*. The output
    of *P*, as we stated above, is “yes” or “no.”
  prefs: []
  type: TYPE_NORMAL
- en: Now, we make a slight change to *P* so it accepts a single input and uses that
    input as both *T* and *I*. Additionally, when *P* is about to return “yes” to
    indicate that *T* does halt on input *I*, we add an infinite loop before the return.
    If we call this slightly edited program *Q*, what happens when we use *Q* as the
    argument to itself?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two cases. Suppose *Q* does halt with *Q* as input. If so, *P* would
    return “yes.” However, we added an infinite loop before the return, so *Q* doesn’t
    halt. Now suppose that *Q* doesn’t halt with *Q* as input. In that case, *P* returns
    “no” to indicate that *Q* with *Q* as input doesn’t halt. However, by issuing
    “no,” *Q* does, in fact, halt. We’re left with a contradiction: *Q* given *Q*
    as input halts if and only if *Q* given *Q* as input does not halt. This is an
    impossibility, and as *Q* is really *P* with a tiny addition to the case where
    the argument does halt, it means that *P* cannot exist either. Thus, the halting
    problem has no solution.'
  prefs: []
  type: TYPE_NORMAL
- en: Turing’s proof that the halting problem has no solution is foundational, but
    what concerns us more, practically, is what he introduced along the way. He introduced,
    in 1936, before any physical computer existed, a *model of computation*. That
    is, a straightforward machine that captures the essence of what we mean by the
    word *algorithm*—in other words, a Turing machine. Let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: '**Turing Machines**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *Turing machine* is a simple computer consisting of an infinite tape partitioned
    into squares and a read/write head that moves along the tape. A table of states,
    sometimes called the *instruction table*, specifies the operation of the machine.
    Each step involves searching the instruction table for a match between the current
    state and the symbol presently on the tape beneath the head. For each match, the
    table specifies an action, a direction to move, and a new state. There are three
    allowed actions: print a symbol on the tape, erase the symbol already on the tape,
    or do nothing. The direction is either move left, move right, or don’t move. The
    machine is initialized by loading a tape, which may be blank or already marked,
    and positioning the head over the starting position, usually the beginning of
    the tape. [Figure 3-1](ch03.xhtml#ch03fig1) presents an abstract representation
    of a Turing machine.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/03fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: A conceptual Turing machine*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the machine, we follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Search the table for a match between the current state and the symbol beneath
    the tape head.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Perform the action given for that combination: do nothing, print a symbol,
    or erase a symbol.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the tape head to the left or right one square if specified in the table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the current state to the new state read from the table and repeat from Step
    1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As simple as this machine is, it can implement any algorithm; but no one said
    anything about efficiency or ease of implementation. The *Church–Turing thesis*
    goes even further and states that the very definition of algorithm is that which
    can be implemented by a Turing machine. That is, a problem can be solved by an
    algorithm if (and only if) it can be solved by a Turing machine. Note that this
    statement is a *thesis* and not a *theorem*. A thesis is something believed, with
    good reason, to be true, but a theorem is something that has been proven to be
    true.
  prefs: []
  type: TYPE_NORMAL
- en: Section 3 of Turing’s paper lists example machines. His first example is a machine
    that fills the tape with the pattern “0 1 0 1 0 *…* ” The machine prints a 0,
    moves to the right twice to leave a blank space, prints a 1, and then moves to
    the right twice, repeating forever.
  prefs: []
  type: TYPE_NORMAL
- en: The tape is initially empty, meaning there is no input to this machine. The
    head starts at the first square and the initial state is 0\. To make a move, we
    need the instruction table that tells us what the next step is. The instructions
    for this machine are in [Table 3-1](ch03.xhtml#ch03tab1).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Turing’s First Example'
  prefs: []
  type: TYPE_NORMAL
- en: '| **State** | **Symbol** | **Print** | **Move** | **New state** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | *blank* | 0 | R | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | *blank* | *blank* | R | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | *blank* | 1 | R | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | *blank* | *blank* | R | 0 |'
  prefs: []
  type: TYPE_TB
- en: The machine starts in state 0 with a blank tape. Searching the table for this
    configuration produces a match with “0 *blank*.” For this case, the table says
    to print a 0, move to the right, and set the machine to state 1.
  prefs: []
  type: TYPE_NORMAL
- en: The next step searches for state 1 and whatever is under the tape head, which
    is a blank. There is a match for this configuration. The match says to print a
    blank, move to the right, and set the machine to state 2\. State 2 matches, prints
    a 1, moves to the right, and moves to state 3\. Lastly, state 3 matches, prints
    a blank, moves to the right, and goes back to state 0\. At this point, the process
    repeats forever as there is no halt state. We’ll explore other Turing machine
    examples below.
  prefs: []
  type: TYPE_NORMAL
- en: It isn’t immediately obvious or, for that matter, obvious in any sense of the
    word, that a Turing machine embodies the concept of an algorithm. In fact, Turing
    himself believed that the Church–Turing thesis was not amenable to mathematical
    proof. In its favor, beyond multiple approaches leading to the same situation,
    is the fact that decades of attempts to disprove the thesis have been unsuccessful.
  prefs: []
  type: TYPE_NORMAL
- en: 'In his 1936 paper, Turing makes several arguments to help convince the reader
    that a Turing machine can implement any algorithm. My favorite is his comparison
    between a human computer (someone who performs calculations and the original meaning
    of the word *computer*) and a Turing machine. Turing describes a situation where
    a human computer is working on a problem in a manner similar to the configuration
    of a Turing machine and using a tape to hold results. He then describes a situation
    where the computer interrupts the work in progress:'
  prefs: []
  type: TYPE_NORMAL
- en: It is always possible for the computer to break off from his work, to go away
    and forget all about it, and later to come back and go on with it. If he does
    this, he must leave a note of instructions (written in some standard form) explaining
    how the work is to be continued. This note is the counterpart of the “state of
    mind.” We will suppose that the computer works in such a desultory manner that
    he never does more than one step at a sitting. The note of instructions must enable
    him to carry out one step and write the next note. Thus the state of progress
    of the computation at any stage is completely determined by the note of instructions
    and the symbols on the tape.
  prefs: []
  type: TYPE_NORMAL
- en: Here, Turing is appealing to our intuition. If a human can implement any algorithm
    with pen and paper, and a human is capable of following the process a Turing machine
    follows, then we should expect a Turing machine to be able to implement any algorithm
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**Universal Turing Machine**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a Turing machine is capable of implementing any algorithm, then a Turing
    machine should be able to implement another Turing machine. In other words, it
    should be possible to construct a *universal Turing machine (UTM)* that accepts
    another Turing machine and tape as input and executes it. Turing introduces this
    idea in Sections 5 through 7 of his paper.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Turing machine includes an instruction table and an input tape, which may
    be blank. A UTM accepts two things: a Turing machine, meaning the instruction
    table, and an input tape. The input Turing machine must be encoded in some way
    and Turing developed such an encoding in Section 5 of his paper.'
  prefs: []
  type: TYPE_NORMAL
- en: A Turing machine described by an instruction table like [Table 3-1](ch03.xhtml#ch03tab1)
    can be mapped to what Turing called the *standard description (S.D.)*. The sequence
    of instructions are written one after the other using letters with a semicolon
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the instructions of [Table 3-1](ch03.xhtml#ch03tab1) are 5-tuples
    that Turing writes in *standard form* as *q*[*i*]*S*[*j*]*S*[*k*]*Rq*[*m*];, where
    *q*[*i*] is the current state, *S*[*j*] is a symbol under the read head, *S*[*k*]
    is a symbol to print, *R* means move right (there’s also *L* for left or *N* for
    stay put), and *q*[*m*] is the new state. The semicolon ends the instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the S.D. of an instruction, *q*[*i*] is written as *D* followed by
    *i A*s. Similarly, the *S*[*j*] symbol is written as *D* followed by *j C*s. The
    movement letter is written as itself: *R*, *L*, or *N*. Thus, the first instruction
    of [Table 3-1](ch03.xhtml#ch03tab1) is'
  prefs: []
  type: TYPE_NORMAL
- en: 0     *blank*     0     R     1
  prefs: []
  type: TYPE_NORMAL
- en: which Turing would write as *q*[1]*S*[0]*S*[1]*Rq*[2];, as he numbers states
    from one and uses a set of allowed symbols, *S* = {blank, 0, 1}. Here, *S*[0]
    is a blank, *S*[1] is zero, and *S*[2] is one. The S.D. of this instruction is
    therefore *DADDCRDAA*;, and the entire S.D. of the machine specified by [Table
    3-1](ch03.xhtml#ch03tab1) is
  prefs: []
  type: TYPE_NORMAL
- en: '*DADDCRDAA;DAADDRDAAA;DAAADDCCRDAAAA;DAAAADDRDA;*'
  prefs: []
  type: TYPE_NORMAL
- en: After calculating the S.D. of a machine, Turing goes further to generate what
    he calls a *description number (D.N.)*, which is a single integer that fully specifies
    the Turing machine. To calculate the D.N., begin with the S.D. and replace each
    possible letter in the S.D. with an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '*A* → 1, *C* → 2, *D* → 3, *L* → 4, *R* → 5, *N* → 6, ;→ 7'
  prefs: []
  type: TYPE_NORMAL
- en: For example, the S.D. above becomes
  prefs: []
  type: TYPE_NORMAL
- en: '31332531173113353111731113322531111731111335317'
  prefs: []
  type: TYPE_NORMAL
- en: The D.N. mapping means that every computable sequence, that is, anything computable
    by a Turing machine, has at least one D.N., and each D.N. specifies only one computable
    sequence. The net result is that the number of Turing machines is enumerable.
    Turing is writing about computable numbers, which are real numbers that can be
    computed by an algorithm, but by showing that the number of Turing machines is
    enumerable (could be counted), he shows that there are infinitely many real numbers
    that are not computable, that is, numbers for which no algorithm exists. Here
    he’s building on Georg Cantor’s famous proof that the real numbers are not countable.
    For a summary of Cantor’s proof, see *[https://mathworld.wolfram.com/CantorDiagonalMethod.html](https://mathworld.wolfram.com/CantorDiagonalMethod.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: In Section 8 of his paper, Turing uses the fact that the number of Turing machines
    is countable to contemplate a machine for checking description numbers, a machine
    that knows whether or not the Turing machine associated with the description number
    will halt or not for all possible inputs. Through an attempt to apply a mathematical
    process used by Cantor, Turing arrives at a contradiction, proving that no such
    machine exists. This is his proof that the halting problem is undecidable—that
    there exists no algorithm that will tell you if program *P* halts on input *I*
    for all possible inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap, a UTM is a Turing machine that accepts encoded Turing machines and
    input tapes as its input. The UTM then runs the supplied Turing machine on the
    provided tape to produce the output of the Turing machine. Thus, a UTM is a program
    that runs other programs. Does this sound familiar? The UTM is a general-purpose
    computing machine—a computer—and it can run programs given as inputs. The UTM
    is a stored-program computer, that is, a computer that puts programs and data
    in the same memory (its input) and executes the program. This is what every modern
    computer does: specifically, every *von Neumann architecture* computer. For those
    familiar with computers—presumably everyone reading this book—this is a no-brainer
    idea; that’s just what computers do. However, the idea wasn’t a no-brainer in
    1936\. It was foundational and groundbreaking.'
  prefs: []
  type: TYPE_NORMAL
- en: Turing machines are not the only possible models of computation. Others, like
    *finite-state machines* and *Minsky register machines*, do exist. At best, these
    other models are equivalent to Turing machines (Minsky machines) or demonstrably
    less powerful (finite-state machines). Comparing models of computation is part
    of *automata theory*. The significant result for us is that Turing machines are
    the top of the heap, and there are no models of computation that can perform actions
    beyond what a Turing machine can implement. This most likely includes quantum
    computers. We’ll encounter a Minsky register machine in [Chapter 8](ch08.xhtml#ch08)
    when we discuss FRACTRAN.
  prefs: []
  type: TYPE_NORMAL
- en: Turing machines are the best known model of computation, and perhaps the best
    model possible if the Church–Turing thesis is correct. Let’s see how equivalence
    to a Turing machine is helpful for our exploration of esolangs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Turing Completeness**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Turing machine can implement any algorithm. If a programming language can
    do the same, the language is called *Turing complete*. Specifically,
  prefs: []
  type: TYPE_NORMAL
- en: A *Turing complete* system can simulate all Turing machines, that is, can simulate
    a universal Turing machine.
  prefs: []
  type: TYPE_NORMAL
- en: If a programming language is Turing complete, it can, in theory, implement anything
    a Turing machine can, and therefore any algorithm at all. As you might expect,
    widely used programming languages are Turing complete. In the next section, we’ll
    implement a Turing machine simulator in Python, which demonstrates that Python
    is Turing complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imperative programming languages need only two things to be Turing complete:'
  prefs: []
  type: TYPE_NORMAL
- en: Some form of looping based on a conditional, like a `while` loop or a combination
    of `if` and `goto`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ability to manipulate an arbitrarily large amount of memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second requirement is, of course, not met for any real-world programming
    language *as implemented*, but it is easily met when the language is *specified*.
    For example, there is nothing in Python’s specification that says “a list may
    contain at most one million items.” In the language itself, there is no limit
    on how many items a list may contain, even if an implementation must, to be realized
    in the physical world, have such a limit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why should we care about Turing completeness? Turing completeness is particularly
    interesting when dealing with esolangs. Esolangs are all about pushing boundaries
    and thinking in novel ways. Therefore, it makes sense to ask whether an esolang
    is Turing complete. If it is, then a design goal might well have been achieved:
    the language is, in theory, capable of implementing any algorithm, regardless
    of how difficult it might be to do so in practice. Not every language we’ll explore
    in this book is Turing complete; however, not being Turing complete does not mean
    useless. By itself, HTML is not Turing complete; yet, HTML is, as the basis for
    web pages, extremely useful.'
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to demonstrate Turing completeness by providing a translator
    between the language in question and another language known to be Turing complete.
    This is often used to illustrate Turing completeness for different esolangs. For
    example, the Nopfunge esolang (*[https://esolangs.org/wiki/Nopfunge](https://esolangs.org/wiki/Nopfunge)*),
    which is based on the Befunge esolang we’ll explore in [Chapter 11](ch11.xhtml#ch11),
    shows Turing completeness by translating a Minsky machine into Nopfunge. Minsky
    machines are known to be Turing complete. Therefore, if Nopfunge can implement
    a Minsky machine, then Nopfunge can implement any Turing machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The requirements for Turing completeness are so minimal that many systems not
    originally intended to be Turing complete have been shown to be so. For example,
    each of the following is Turing complete:'
  prefs: []
  type: TYPE_NORMAL
- en: The `mov` instruction for the x86 architecture (see *[https://github.com/xoreaxeaxeax/movfuscator/](https://github.com/xoreaxeaxeax/movfuscator/)*
    for a C compiler that generates only `mov` instructions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minecraft
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Magic: The Gathering* card game'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Dwarf Fortress video game (see *[https://youtu.be/j2cMHwo3nAU/](https://youtu.be/j2cMHwo3nAU/)*
    for a video showing Space Invaders running in Dwarf Fortress)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PowerPoint (see *[http://www.andrew.cmu.edu/user/twildenh/PowerPointTM/Paper.pdf](http://www.andrew.cmu.edu/user/twildenh/PowerPointTM/Paper.pdf)*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vim text editor (see *[https://github.com/ealter/vim_turing_machine/](https://github.com/ealter/vim_turing_machine/)*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list is by no means exhaustive.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s put theory into practice and implement a basic Turing machine simulator
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '**Let’s Build a Turing Machine**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Perhaps the best way to understand how a Turing machine works is to implement
    one. In a way, Turing machines are the first esolangs. They are capable of everything,
    but are impractical for serious use. Turing machines are rather general, as they
    work with an arbitrary set of symbols, but we’ll restrict ourselves to a machine
    using only 0 and 1 as symbols, along with blank for an empty space. Likewise,
    we’ll represent the instruction table as shown in [Table 3-1](ch03.xhtml#ch03tab1),
    where each row of the table is a 5-tuple describing the state and tape condition
    followed by the action, move, and new state. For example, we’ll express [Table
    3-1](ch03.xhtml#ch03tab1) in Python with [Listing 3-1](ch03.xhtml#ch03list1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-1: Turing’s first example in Python*'
  prefs: []
  type: TYPE_NORMAL
- en: The rows of [Table 3-1](ch03.xhtml#ch03tab1) match the rows of [Listing 3-1](ch03.xhtml#ch03list1).
    The first entry in the table describes state 0 and a blank. The action is to print
    a 0, move right, transfer to state 1, and then repeat. For our machines, all actions
    are to print something, and all movements are to the right or left; there is no
    standing still. All possible combinations of state and the current symbol, the
    first two elements of every instruction, should be present in the table; otherwise,
    the program is incomplete because there are state and symbol combinations with
    no defined actions.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take our Turing machine for a spin and then dive into the code.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Simulator***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code for our Turing machine simulator is in *turing.py*. It begins with
    a small catalog of example programs in `PROGS` along with a brief description
    in `NAMES`.
  prefs: []
  type: TYPE_NORMAL
- en: Running *turing.py* without arguments gives us
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The output tells us to select an example program from the list below and then
    specify the size of the blank tape, or manually enter an initial tape configuration
    as input. The optional final argument, `-t`, enables tracing, allowing us to step
    through the program to see the effect of each instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s run Turing’s first example (Program 0).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We told the simulator to use a blank tape with 20 spaces. As conceived, Turing
    machines never run out of tape. The output shows the pattern of 0s and 1s as expected.
    We’re also told that the machine stopped in state 0 and that the tape counter
    (`tc`) was at position 20\. In other words, we ran out of tape, so the simulation
    stopped. The selected program’s instruction table is printed below the output
    showing the state and symbol matched followed by the print action, movement, and
    new state.
  prefs: []
  type: TYPE_NORMAL
- en: In *turing.py*, the `main` function parses the command line arguments to select
    the program run along with the size of the blank tape or the initial tape configuration
    entered by the user. We’ll see how to enter a tape below. The machine itself is
    contained in the class `TuringMachine`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-2](ch03.xhtml#ch03list2) shows the `TuringMachine` class with the
    `Result` method omitted to save space.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-2: The TuringMachine class*'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor ➎ accepts the program (`prog`) and the initial tape (`tape`),
    if any, or the size of the blank tape. If a tape is supplied, we add an extra
    blank as several example programs expect an ending blank. The constructor sets
    up the default state (`c`) and tape counter position (`tc`) and then saves the
    program.
  prefs: []
  type: TYPE_NORMAL
- en: The `Run` method is short and sweet as most of it implements tracing ➍. Running
    a program is performing step after step until done. `Done` returns `True` if we
    fall off the tape or hit a negative state, which we’ll interpret as a halt instruction
    ➌. All the action takes place in `Step`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Step` first locates the instruction table entry corresponding to the current
    state and the symbol under the tape head ➊. Once found, we then extract the action,
    movement, and next state ➋. We then update the current tape position with the
    action. After that, we increment or decrement the tape counter based on the move
    character (`R` or `L`). Lastly, we update the state to complete the instruction
    step.'
  prefs: []
  type: TYPE_NORMAL
- en: There are additional comments in *turing.py* explaining the code in more detail.
    Please review them. The catalog of examples is in `PROGS`. To add more examples,
    place them there and add a description in `NAMES`. Note that our machine follows
    Turing’s original paper, meaning we move the tape head along the tape. If you
    examine other Turing machine simulators, and there are many far more sophisticated
    than ours, be aware that many move the *tape* instead. Therefore, if you want
    to transfer a program for such an implementation to *turing.py*, you must change
    all `R` characters to `L` and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Examples***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We described Turing’s Program 0 above. Now let’s walk through the other examples
    using a sufficient level of detail to understand the process encoded in the instruction
    table.
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 1: Change 0s to 1s**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This example is straightforward. The instructions convert all 0s to 1s and the
    program stops when a blank or one is encountered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There is only one state, state 0, with a rule for all allowed symbols: 0, 1,
    and blank. To be specific, the first row of the table says, “if in state 0 and
    the symbol under the tape head is a 0, print a 1, move to the right, and remain
    in state 0.” This instruction will continue for as long as the symbol under the
    tape head is 0\. It replaces the 0 with a 1 and moves to the next symbol again
    and again.'
  prefs: []
  type: TYPE_NORMAL
- en: The remaining two instructions capture what to do if the symbol under the tape
    head is a one or a blank. In both cases, the matched symbol is printed again to
    leave that square unchanged. The critical point is that the next state is *–*1\.
    Our machine stops if the state is negative, so *–*1 means “halt.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Combined, these states move to the right along the tape, changing every 0 into
    a 1 until the program reads a 1 or a blank. Let’s see if our interpretation is
    correct by running the program with different input tapes. Initial tape configurations
    are passed on the command line as Python lists using 0 and 1, with 2 representing
    a blank. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In each case above, the output matches what we expect from the program. All
    consecutive 0s are now 1s and blanks, and 1s are unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 2: Unary Increment**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Binary numbers use two digits: 0 and 1\. Unary numbers are tallies, that is,
    repeated instances of 1.'
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 11 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 111 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 1111 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 11111 |'
  prefs: []
  type: TYPE_TB
- en: 'Program 2 increments the unary number already on the tape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This program is quite similar to the program to map 0s to 1s. The first instruction
    marches along the tape, keeping every 1 a 1 and moving right until it finds a
    0 or blank. The program turns the first 0 or blank into a 1 and then halts.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s run this program with tracing to see how it moves. Press ENTER at each
    prompt to continue.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tracing shows the current tape, three 1s, and a blank added at the end as well
    as the current state and tape counter. The following line prints a carat under
    the current tape position. Pressing ENTER three times moves along the 1 to the
    blank. Pressing ENTER one more time fills that blank with a 1, after which the
    program halts. The initial input was 3 (`111`), and the output tape is now 4 (`1111`).
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 3: Binary Increment**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Binary numbers use 0 and 1 as digits. The addition rules for binary are simple
    and can be expressed as
  prefs: []
  type: TYPE_NORMAL
- en: '| 0 + 0 = 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 + 1 = 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 + 0 = 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 + 1 = 10 (carry) |'
  prefs: []
  type: TYPE_TB
- en: Note that the sum of 1 and 1 produces a carry. Program 3 implements a Turing
    machine that adds one to the binary number on the input tape. Its instruction
    table is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Program 3 uses three states. It isn’t readily evident from looking at the instruction
    table alone what the states are doing. So let’s run an example with tracing to
    see the instructions in action. We’ll add one to 1011[2] = 11[10]. The command
    line is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 3-2](ch03.xhtml#ch03tab2) contains the trace, step by step. The program
    generates 1100[2] = 12[10], as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** Tracing Binary Increment for 1011'
  prefs: []
  type: TYPE_NORMAL
- en: '| `1011 , (state=0, tc=0)``^` |'
  prefs: []
  type: TYPE_TB
- en: '| `1011 , (state=0, tc=1)``^` |'
  prefs: []
  type: TYPE_TB
- en: '| `1011 , (state=0, tc=2)``^` |'
  prefs: []
  type: TYPE_TB
- en: '| `1011 , (state=0, tc=3)``^` |'
  prefs: []
  type: TYPE_TB
- en: '| `1011 , (state=0, tc=4)``^` |'
  prefs: []
  type: TYPE_TB
- en: '| `1011 , (state=1, tc=3)``^` |'
  prefs: []
  type: TYPE_TB
- en: '| `1010 , (state=1, tc=2)``^` |'
  prefs: []
  type: TYPE_TB
- en: '| `1000 , (state=1, tc=1)``^` |'
  prefs: []
  type: TYPE_TB
- en: '| `1100 , (state=2, tc=0)``^` |'
  prefs: []
  type: TYPE_TB
- en: '| `1100 , (state=2, tc=1)``^` |'
  prefs: []
  type: TYPE_TB
- en: '| `1100 , (state=2, tc=2)``^` |'
  prefs: []
  type: TYPE_TB
- en: '| `1100 , (state=2, tc=3)``^` |'
  prefs: []
  type: TYPE_TB
- en: '| `1100 , (state=2, tc=4)``^` |'
  prefs: []
  type: TYPE_TB
- en: The first five steps of [Table 3-2](ch03.xhtml#ch03tab2) move along the input,
    looking for a blank marking the end of the binary number. state 0 is sufficient
    for this part. When the program finds the blank in this state, it decrements the
    tape counter to look at the rightmost digit of the binary number, after which
    state 1 becomes active.
  prefs: []
  type: TYPE_NORMAL
- en: With state 1 active, if the symbol under the tape head is a 0, it is replaced
    by a 1, the tape head moves to the left, and state 2 becomes active. This is equivalent
    to adding 1\. If the symbol under the tape head is a 1, the program replaces it
    with 0 as 1 + 1 = 0 with a carry of 1\. The machine then remains in state 1 after
    moving left. The carry is implied by state 1 and the fact that the state moves
    left, replacing 1s with 0s. The 0 and 1 instructions of state 1 together process
    the number right to left and handle the carry by remaining in state 1 until a
    0 is found. Adding 1 to 0 does not produce a carry, so the machine would move
    to state 2 and the increment would be complete.
  prefs: []
  type: TYPE_NORMAL
- en: State 2 moves the tape head back right along the number until a terminating
    blank is found, at which point the state becomes *–*1 and the machine halts. The
    action of state 2 is only to position the tape head. If we’re not interested in
    positioning the head at the end of the number, we could transition to *–*1 from
    state 1 as soon as a 0 is updated to a 1\. Try this example with different inputs
    until you are comfortable with how it works.
  prefs: []
  type: TYPE_NORMAL
- en: '**Program 4: Unary Subtraction**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Adding 1 to a unary number was quite simple. This next example implements unary
    subtraction with the larger number first, followed by a blank, and then the smaller
    number. For example, an input of `[11111 111]` returns `[11        ]`, which is
    5 *–* 3 = 2, using blanks to overwrite any extra digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run this example with tracing. We won’t list the many steps required,
    but I suspect that you will see for yourself what the instructions are doing.
    It’s quite clever. Run the example with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: State 0 finds the blank between the first and second number and then transitions
    to state 1\. State 1 finds the blank after the second number and transitions to
    state 2\. State 2 moves left over the smaller number, changing the first 1 found
    into a 0 and then moving to state 3\. State 3 finds the blank between the two
    numbers and moves to state 7\. State 7 makes the first 1 of the larger number
    a 0 and moves back to state 0\. This state 0, 1, 2, 3, 7 cycle repeats until state
    2 no longer finds a 1 in the smaller number.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, all the 1s of the smaller number are 0s, as are the same number
    of rightmost 1s of the larger number. In essence, the subtraction is complete.
    The remainder of the program changes 0s to blanks, so the only symbols on the
    tape when the program ends are the remaining 1s of the larger unary number. States
    4, 5, and 6 accomplish this and then transition from state 6 to –1 when there
    are no more 0s.
  prefs: []
  type: TYPE_NORMAL
- en: '**Try Your Hand**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Running *turing.py* without command line arguments shows five example programs.
    There is actually a sixth, Program 5, but it was intentionally left out of the
    list as an exercise. Program 5 calculates the two’s complement of the binary number
    on the input tape. Computers store negative integers in two’s complement format
    so hardware only needs to implement addition. Subtraction of two integers is addition
    using two’s complement form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finding the two’s complement of a binary number is easy: change all 0 bits
    to 1s and all the 1s to 0s, and then add 1 to that result. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 01011011 → 10100100 + 1 → 10100101
  prefs: []
  type: TYPE_NORMAL
- en: The challenge of this section is to create the instruction table for a Turing
    machine that converts its input to two’s complement format. We have a Turing machine
    that adds 1 to a binary number. We also have a Turing machine that converts 0s
    to 1s. The required machine will flip 0s and 1s before adding 1\. Try writing
    the two’s complement instruction table yourself. When ready, take a look at the
    last entry in `PROGS` and compare it with your table. You can run Program 5 easily
    enough.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The output is what we found for the example above.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter explored Turing machines and the idea of Turing completeness. We
    began with the halting problem and then moved on to Turing machines, the mechanism
    Turing used in his famous 1936 paper where he demonstrated that the halting problem
    was undecidable. We then explored the idea of a UTM, which led directly to the
    concept of a stored-program computer.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discussed the concept of Turing completeness, something we’ll refer
    to throughout the book as we explore esolangs. The idea that many systems are
    accidentally Turing complete is simple enough. Lastly, we implemented a Turing
    machine simulator in Python and worked through several example programs.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter concludes [Part I](part01.xhtml#part01) of the book. We move on
    now to consider what I’m calling “atypical programming languages,” by which I
    mean languages meant for serious use but that are sufficiently different from
    the pack in their approach to warrant a detailed examination as a precursor to
    the esolangs that follow. We will begin with Forth, a stack-based language.
  prefs: []
  type: TYPE_NORMAL
