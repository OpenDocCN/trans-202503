- en: '3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '3'
- en: TURING MACHINES AND TURING COMPLETENESS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵机与图灵完备性
- en: '![Image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common01.jpg)'
- en: 'Spend enough time around programming languages, and two phrases inevitably
    appear: “Turing machine” and “Turing completeness.” In this chapter, we’ll explain
    what these phrases mean and why they are important. Specifically, we’ll introduce
    the halting problem and discuss Alan Turing’s fantastic solution to it. That will
    set the stage for discussing Turing machines and Turing completeness. We’ll end
    by simulating a Turing machine in Python.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程语言的领域呆得久了，两种术语不可避免地出现：“图灵机”和“图灵完备性”。在本章中，我们将解释这些术语的含义以及它们为何重要。具体来说，我们将介绍停机问题并讨论艾伦·图灵对其的精彩解决方案。那将为讨论图灵机和图灵完备性打下基础。最后，我们将在
    Python 中模拟图灵机。
- en: The topics of this chapter fall under the heading “theoretical computer science,”
    which is a branch of mathematics, not software engineering. As we’ll see below,
    theoretical computer science predates the availability of physical computers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题属于“理论计算机科学”范畴，这是数学的一个分支，而不是软件工程。正如我们下面所看到的，理论计算机科学早于物理计算机的出现。
- en: '**The Halting Problem**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**停机问题**'
- en: Early 20th-century mathematicians had a problem. They were several decades into
    a serious effort to put all of mathematics on a logical foundation. As part of
    this program, in 1928, David Hilbert and Wilhelm Ackermann issued their “Entscheidungsproblem”
    (German for “decision problem”). When given a statement in some formal system,
    the problem asked for an algorithm that would infallibly return “yes” or “no”
    as to the validity of that statement. In other words, the problem asked for an
    algorithm that would say whether the statement can be proven from the axioms of
    the system, which are those statements accepted as true without proof. It’s important
    to note that Hilbert and Ackermann’s challenge was for a universal algorithm,
    that is, one that will always give the correct answer for all applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 20世纪初的数学家们遇到了一个问题。他们已经花费数十年时间，努力将所有数学建立在逻辑基础上。作为这一计划的一部分，1928年，戴维·希尔伯特和威廉·阿克曼提出了他们的“Entscheidungsproblem”（德语意思是“决策问题”）。该问题要求给定某个形式系统中的陈述，找到一种算法，能够毫无差错地返回“yes”或“no”，用于判断该陈述的有效性。换句话说，该问题要求找到一种算法，能够判断该陈述是否可以从系统的公理中推导出来，而公理是那些被接受为真但无需证明的陈述。值得注意的是，希尔伯特和阿克曼的挑战是针对一种通用算法，即一种能够始终给出所有应用场景正确答案的算法。
- en: 'In 1936, a young Alan Turing, not quite 24 years old, published what became
    the foundational paper of theoretical computer science: “On Computable Numbers,
    with an Application to the Entscheidungsproblem.” In this paper, Turing demonstrated
    that there is no general solution to the Entscheidungsproblem. That is, there
    is no algorithm that can always correctly decide on the validity of a statement.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 1936年，年轻的艾伦·图灵，年仅24岁，发表了奠定理论计算机科学基础的论文：“可计算数及其在 Entscheidungsproblem 中的应用”。在这篇论文中，图灵证明了没有通用的解决方案来解决
    Entscheidungsproblem。也就是说，无法通过任何算法始终正确地决定一个陈述的有效性。
- en: 'To do this, Turing addressed a specific problem: the *halting problem*. There
    are different ways to describe the halting problem, but we’ll use this definition:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，图灵解决了一个特定的问题：*停机问题*。停机问题有不同的描述方式，但我们将使用这个定义：
- en: Find a program, *P*, that when given as input the source code of another program,
    *T*, and an input for that program, *I*, will always output “yes” if *T* will
    eventually stop for input *I*, or “no” if *T* will run forever for input *I*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一个程序，*P*，该程序当给定另一个程序* T *的源代码和该程序的输入* I *时，如果* T *在输入* I *时最终停止，就总是输出“yes”，如果*
    T *会永远运行下去，则输出“no”。
- en: 'This is a halting problem. We want to know if a program will eventually stop,
    or run forever for a given input. The program in question is *T* and the input
    is *I*. The program that decides, that outputs “yes” or “no,” is *P*. The definition
    above uses the word *program* for *P*, with the implicit understanding that algorithms
    can be encoded in programs. After all, that is what programming is all about:
    encoding algorithms (thought) in a form that can instruct a machine. We’ll come
    back to this equivalence between algorithm and program below.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个停机问题。我们想知道一个程序在给定输入时是否最终会停止，或者会永远运行。涉及的程序是* T *，输入是* I *。做出决定并输出“yes”或“no”的程序是*
    P *。上述定义中使用了“程序”一词来指代* P *，并隐含地理解为算法可以被编码在程序中。毕竟，编程的核心就是：将算法（思想）编码成可以指示机器执行的形式。我们将在下面回到算法和程序之间的等价性。
- en: Turing’s paper, which is quite readable and easily found online with a search
    for the title above, showed that there is no *P*. It doesn’t exist. As the halting
    problem is a decision problem, Turing thereby established that the Entscheidungsproblem
    has no solution either.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵的论文，内容相当易懂，并且可以通过搜索上述标题轻松在线找到，表明了不存在 *P*。它根本不存在。由于停机问题是一个决策问题，因此图灵进一步证明了决策问题（Entscheidungsproblem）也没有解决方案。
- en: At virtually the same time as Turing, indeed, slightly before, Alonzo Church
    arrived at the same conclusion using a formal system known as *λ*-calculus (lambda
    calculus). If you read Turing’s 1936 paper, the introduction concludes with a
    reference to Church’s “recent paper” using *λ*-calculus to show what Turing was
    about to demonstrate. In the end, Turing became Church’s student at Princeton,
    completing his PhD there in 1938.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎与图灵同时，实际上稍微早一些，阿隆佐·丘奇通过一个名为 *λ* 演算（λ-calculus）的形式系统得出了相同的结论。如果你阅读图灵的1936年论文，导言部分会提到丘奇的“最近的论文”，通过
    *λ* 演算来展示图灵即将证明的内容。最终，图灵成为丘奇在普林斯顿的学生，并于1938年在那里完成了他的博士学位。
- en: Turing’s proof that there is no solution for the halting problem required several
    iterations. The version in his 1936 paper is somewhat buggy. The essence of the
    proof is by contradiction.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵证明停机问题无解的过程经历了几次迭代。他在1936年论文中的版本有些瑕疵。证明的本质是通过反证法。
- en: Assume we have a program, *P*, a program that accepts another program, *T*,
    and an input for it, *I*. *P* tells us whether *T* will halt on *I*. The output
    of *P*, as we stated above, is “yes” or “no.”
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个程序 *P*，这个程序接受另一个程序 *T* 和它的输入 *I*。*P* 告诉我们 *T* 是否会在输入 *I* 上停机。我们之前提到，*P*
    的输出是“是”或“否”。
- en: Now, we make a slight change to *P* so it accepts a single input and uses that
    input as both *T* and *I*. Additionally, when *P* is about to return “yes” to
    indicate that *T* does halt on input *I*, we add an infinite loop before the return.
    If we call this slightly edited program *Q*, what happens when we use *Q* as the
    argument to itself?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们对 *P* 做了一个小的修改，使它接受一个单一输入，并将该输入同时作为 *T* 和 *I*。另外，当 *P* 即将返回“是”以表示 *T* 在输入
    *I* 上会停机时，我们在返回之前加入一个无限循环。如果我们将这个略微编辑过的程序称为 *Q*，那么当我们将 *Q* 作为其自身的参数时会发生什么？
- en: 'There are two cases. Suppose *Q* does halt with *Q* as input. If so, *P* would
    return “yes.” However, we added an infinite loop before the return, so *Q* doesn’t
    halt. Now suppose that *Q* doesn’t halt with *Q* as input. In that case, *P* returns
    “no” to indicate that *Q* with *Q* as input doesn’t halt. However, by issuing
    “no,” *Q* does, in fact, halt. We’re left with a contradiction: *Q* given *Q*
    as input halts if and only if *Q* given *Q* as input does not halt. This is an
    impossibility, and as *Q* is really *P* with a tiny addition to the case where
    the argument does halt, it means that *P* cannot exist either. Thus, the halting
    problem has no solution.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种情况。假设 *Q* 在以 *Q* 作为输入时会停机。如果是这样，*P* 会返回“是”。然而，我们在返回之前添加了一个无限循环，所以 *Q* 并不会停机。现在假设
    *Q* 在以 *Q* 作为输入时不会停机。在这种情况下，*P* 返回“否”以表示 *Q* 在以 *Q* 作为输入时不会停机。然而，通过返回“否”，实际上 *Q*
    会停机。我们得到了一个矛盾：*Q* 以 *Q* 作为输入时停机，当且仅当 *Q* 以 *Q* 作为输入时不停止。这是不可能的，因为 *Q* 其实是 *P*
    在原有的基础上稍作修改的版本，它说明了 *P* 也不可能存在。因此，停机问题没有解决方案。
- en: Turing’s proof that the halting problem has no solution is foundational, but
    what concerns us more, practically, is what he introduced along the way. He introduced,
    in 1936, before any physical computer existed, a *model of computation*. That
    is, a straightforward machine that captures the essence of what we mean by the
    word *algorithm*—in other words, a Turing machine. Let’s take a look.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵证明停机问题无解是基础性的，但更让我们关注的，实际上是他在此过程中引入的东西。早在1936年，在任何物理计算机出现之前，他引入了一个 *计算模型*。也就是说，一个直接的机器，捕捉了我们所称之为
    *算法* 的本质——换句话说，就是图灵机。我们来看一下。
- en: '**Turing Machines**'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**图灵机**'
- en: 'A *Turing machine* is a simple computer consisting of an infinite tape partitioned
    into squares and a read/write head that moves along the tape. A table of states,
    sometimes called the *instruction table*, specifies the operation of the machine.
    Each step involves searching the instruction table for a match between the current
    state and the symbol presently on the tape beneath the head. For each match, the
    table specifies an action, a direction to move, and a new state. There are three
    allowed actions: print a symbol on the tape, erase the symbol already on the tape,
    or do nothing. The direction is either move left, move right, or don’t move. The
    machine is initialized by loading a tape, which may be blank or already marked,
    and positioning the head over the starting position, usually the beginning of
    the tape. [Figure 3-1](ch03.xhtml#ch03fig1) presents an abstract representation
    of a Turing machine.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图灵机*是一种简单的计算机，由一条被分割成方格的无限磁带和一个沿磁带移动的读写头组成。一个状态表，有时称为*指令表*，指定机器的操作。每一步都需要在指令表中查找当前状态与头下方磁带上符号的匹配项。对于每个匹配，表中会指定一个动作、一个移动方向以及一个新状态。允许的三种动作是：在磁带上打印一个符号，擦除磁带上已有的符号，或不做任何操作。方向可以是向左移动、向右移动或不动。机器通过加载磁带来初始化，磁带可以是空白的，也可以已经标记，并将读写头定位到起始位置，通常是磁带的开头。[图3-1](ch03.xhtml#ch03fig1)展示了图灵机的抽象表示。'
- en: '![Image](Images/03fig01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig01.jpg)'
- en: '*Figure 3-1: A conceptual Turing machine*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-1：概念化的图灵机*'
- en: 'To run the machine, we follow these steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行机器，我们按照以下步骤操作：
- en: Search the table for a match between the current state and the symbol beneath
    the tape head.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表中查找当前状态与磁带头下符号的匹配项。
- en: 'Perform the action given for that combination: do nothing, print a symbol,
    or erase a symbol.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于该组合执行表中指定的操作：什么都不做，打印一个符号，或擦除一个符号。
- en: Move the tape head to the left or right one square if specified in the table.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果指令表中有规定，则将磁带头向左或向右移动一个方格。
- en: Set the current state to the new state read from the table and repeat from Step
    1.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前状态设置为从表中读取到的新状态，并从第1步开始重复。
- en: As simple as this machine is, it can implement any algorithm; but no one said
    anything about efficiency or ease of implementation. The *Church–Turing thesis*
    goes even further and states that the very definition of algorithm is that which
    can be implemented by a Turing machine. That is, a problem can be solved by an
    algorithm if (and only if) it can be solved by a Turing machine. Note that this
    statement is a *thesis* and not a *theorem*. A thesis is something believed, with
    good reason, to be true, but a theorem is something that has been proven to be
    true.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这台机器非常简单，但它可以实现任何算法；不过没人提到过效率或实现的容易性。*丘奇–图灵论题*甚至更进一步，声明算法的定义是可以被图灵机实现的东西。也就是说，一个问题可以通过算法解决，当且仅当它可以通过图灵机解决时。请注意，这个声明是一个*论题*而不是*定理*。论题是经过充分理由相信为真的东西，而定理是经过证明为真的东西。
- en: Section 3 of Turing’s paper lists example machines. His first example is a machine
    that fills the tape with the pattern “0 1 0 1 0 *…* ” The machine prints a 0,
    moves to the right twice to leave a blank space, prints a 1, and then moves to
    the right twice, repeating forever.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵论文的第3节列出了示例机器。他的第一个示例是一台将磁带填充为“0 1 0 1 0 *…* ”模式的机器。该机器打印一个0，向右移动两次留下一个空白，然后打印一个1，再向右移动两次，永远重复下去。
- en: The tape is initially empty, meaning there is no input to this machine. The
    head starts at the first square and the initial state is 0\. To make a move, we
    need the instruction table that tells us what the next step is. The instructions
    for this machine are in [Table 3-1](ch03.xhtml#ch03tab1).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这条磁带最初是空的，意味着机器没有输入。读写头从第一个方格开始，初始状态为 0。为了执行操作，我们需要一个指令表，它告诉我们下一步该做什么。该机器的指令在[表3-1](ch03.xhtml#ch03tab1)中。
- en: '**Table 3-1:** Turing’s First Example'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**表3-1：图灵的第一个示例**'
- en: '| **State** | **Symbol** | **Print** | **Move** | **New state** |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| **状态** | **符号** | **打印** | **移动** | **新状态** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 0 | *blank* | 0 | R | 1 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 0 | *空白* | 0 | 右 | 1 |'
- en: '| 1 | *blank* | *blank* | R | 2 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *空白* | *空白* | 右 | 2 |'
- en: '| 2 | *blank* | 1 | R | 3 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *空白* | 1 | 右 | 3 |'
- en: '| 3 | *blank* | *blank* | R | 0 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *空白* | *空白* | 右 | 0 |'
- en: The machine starts in state 0 with a blank tape. Searching the table for this
    configuration produces a match with “0 *blank*.” For this case, the table says
    to print a 0, move to the right, and set the machine to state 1.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 该机器在状态0下开始，磁带为空。查找表中与此配置匹配的项，结果是与“0 *空白*”匹配。在这种情况下，表中指定打印一个0，向右移动，并将机器设置为状态1。
- en: The next step searches for state 1 and whatever is under the tape head, which
    is a blank. There is a match for this configuration. The match says to print a
    blank, move to the right, and set the machine to state 2\. State 2 matches, prints
    a 1, moves to the right, and moves to state 3\. Lastly, state 3 matches, prints
    a blank, moves to the right, and goes back to state 0\. At this point, the process
    repeats forever as there is no halt state. We’ll explore other Turing machine
    examples below.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是查找状态1及纸带头下的内容，这时纸带头下是一个空白。此配置有一个匹配项。匹配项指示打印一个空白，向右移动，并将机器设置为状态2。状态2匹配，打印一个1，向右移动，并转到状态3。最后，状态3匹配，打印一个空白，向右移动，并返回到状态0。此时，过程将永远重复，因为没有停止状态。接下来我们将探索其他图灵机的例子。
- en: It isn’t immediately obvious or, for that matter, obvious in any sense of the
    word, that a Turing machine embodies the concept of an algorithm. In fact, Turing
    himself believed that the Church–Turing thesis was not amenable to mathematical
    proof. In its favor, beyond multiple approaches leading to the same situation,
    is the fact that decades of attempts to disprove the thesis have been unsuccessful.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是显而易见的，或者说，从任何意义上来说，这一点都不明显，图灵机是否体现了算法的概念。事实上，图灵本人认为教会–图灵论题并不能通过数学证明。支持这一观点的原因之一是，尽管有多种方法可以得出相同的结论，但几十年来关于反驳这一论题的尝试都未曾成功。
- en: 'In his 1936 paper, Turing makes several arguments to help convince the reader
    that a Turing machine can implement any algorithm. My favorite is his comparison
    between a human computer (someone who performs calculations and the original meaning
    of the word *computer*) and a Turing machine. Turing describes a situation where
    a human computer is working on a problem in a manner similar to the configuration
    of a Turing machine and using a tape to hold results. He then describes a situation
    where the computer interrupts the work in progress:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在他1936年的论文中，图灵提出了几个论点，以帮助说服读者图灵机能够实现任何算法。我最喜欢的一点是他将人类计算机（即进行计算的人，原本“计算机”一词的含义）与图灵机进行对比。图灵描述了一种情况，在这种情况下，人类计算机正在以类似于图灵机配置的方式工作，并使用纸带来保存计算结果。接着，他描述了计算机中断工作的情况：
- en: It is always possible for the computer to break off from his work, to go away
    and forget all about it, and later to come back and go on with it. If he does
    this, he must leave a note of instructions (written in some standard form) explaining
    how the work is to be continued. This note is the counterpart of the “state of
    mind.” We will suppose that the computer works in such a desultory manner that
    he never does more than one step at a sitting. The note of instructions must enable
    him to carry out one step and write the next note. Thus the state of progress
    of the computation at any stage is completely determined by the note of instructions
    and the symbols on the tape.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机总是可以中断工作，离开并忘记所有的事情，然后再回来继续工作。如果他这么做，他必须留下一个指示说明（用某种标准形式书写），解释工作如何继续进行。这个指示说明就是“心理状态”的对应物。我们假设计算机以一种零碎的方式工作，他每次只做一步。指示说明必须使他能够执行一步并写下下一个指示说明。因此，计算的进度在任何阶段都完全由指示说明和纸带上的符号确定。
- en: Here, Turing is appealing to our intuition. If a human can implement any algorithm
    with pen and paper, and a human is capable of following the process a Turing machine
    follows, then we should expect a Turing machine to be able to implement any algorithm
    as well.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，图灵是在诉诸我们的直觉。如果人类可以用笔和纸实现任何算法，并且人类能够遵循图灵机所遵循的过程，那么我们应该也能期望图灵机能够实现任何算法。
- en: '**Universal Turing Machine**'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通用图灵机**'
- en: If a Turing machine is capable of implementing any algorithm, then a Turing
    machine should be able to implement another Turing machine. In other words, it
    should be possible to construct a *universal Turing machine (UTM)* that accepts
    another Turing machine and tape as input and executes it. Turing introduces this
    idea in Sections 5 through 7 of his paper.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一台图灵机能够实现任何算法，那么它应该能够实现另一台图灵机。换句话说，应该可以构造一个*通用图灵机（UTM）*，它接受另一台图灵机和纸带作为输入并执行它。图灵在他的论文第5到第7节中引入了这个思想。
- en: 'A Turing machine includes an instruction table and an input tape, which may
    be blank. A UTM accepts two things: a Turing machine, meaning the instruction
    table, and an input tape. The input Turing machine must be encoded in some way
    and Turing developed such an encoding in Section 5 of his paper.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵机包括一个指令表和一个可能为空白的输入带。通用图灵机（UTM）接受两样东西：一个图灵机，即指令表，以及一个输入带。输入图灵机必须以某种方式编码，图灵在他的论文第5节中开发了这种编码方法。
- en: A Turing machine described by an instruction table like [Table 3-1](ch03.xhtml#ch03tab1)
    can be mapped to what Turing called the *standard description (S.D.)*. The sequence
    of instructions are written one after the other using letters with a semicolon
    between them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由像[表3-1](ch03.xhtml#ch03tab1)这样的指令表描述的图灵机可以映射到图灵所称的*标准描述（S.D.）*。指令序列一个接一个地写出，字母之间用分号隔开。
- en: For example, the instructions of [Table 3-1](ch03.xhtml#ch03tab1) are 5-tuples
    that Turing writes in *standard form* as *q*[*i*]*S*[*j*]*S*[*k*]*Rq*[*m*];, where
    *q*[*i*] is the current state, *S*[*j*] is a symbol under the read head, *S*[*k*]
    is a symbol to print, *R* means move right (there’s also *L* for left or *N* for
    stay put), and *q*[*m*] is the new state. The semicolon ends the instruction.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[表3-1](ch03.xhtml#ch03tab1)中的指令是5元组，图灵以*标准形式*写作*q*[*i*]*S*[*j*]*S*[*k*]*Rq*[*m*];，其中*q*[*i*]是当前状态，*S*[*j*]是读头下的符号，*S*[*k*]是要打印的符号，*R*表示右移（也有*L*表示左移或*N*表示保持不动），*q*[*m*]是新状态。分号结束指令。
- en: 'To find the S.D. of an instruction, *q*[*i*] is written as *D* followed by
    *i A*s. Similarly, the *S*[*j*] symbol is written as *D* followed by *j C*s. The
    movement letter is written as itself: *R*, *L*, or *N*. Thus, the first instruction
    of [Table 3-1](ch03.xhtml#ch03tab1) is'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到指令的标准描述（S.D.），*q*[*i*]写作*D*后跟*i*个A。类似地，*S*[*j*]符号写作*D*后跟*j*个C。运动字母本身写出：*R*、*L*或*N*。因此，[表3-1](ch03.xhtml#ch03tab1)的第一条指令是
- en: 0     *blank*     0     R     1
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 0     *空白*     0     R     1
- en: which Turing would write as *q*[1]*S*[0]*S*[1]*Rq*[2];, as he numbers states
    from one and uses a set of allowed symbols, *S* = {blank, 0, 1}. Here, *S*[0]
    is a blank, *S*[1] is zero, and *S*[2] is one. The S.D. of this instruction is
    therefore *DADDCRDAA*;, and the entire S.D. of the machine specified by [Table
    3-1](ch03.xhtml#ch03tab1) is
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵会写作*q*[1]*S*[0]*S*[1]*Rq*[2];，因为他从1开始编号状态，并使用一组允许的符号，*S* = {空白、0、1}。这里，*S*[0]是空白，*S*[1]是零，*S*[2]是一个。所以，这条指令的S.D.是*DADDCRDAA*;，而[表3-1](ch03.xhtml#ch03tab1)所指定的整个机器的S.D.是
- en: '*DADDCRDAA;DAADDRDAAA;DAAADDCCRDAAAA;DAAAADDRDA;*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*DADDCRDAA;DAADDRDAAA;DAAADDCCRDAAAA;DAAAADDRDA;*'
- en: After calculating the S.D. of a machine, Turing goes further to generate what
    he calls a *description number (D.N.)*, which is a single integer that fully specifies
    the Turing machine. To calculate the D.N., begin with the S.D. and replace each
    possible letter in the S.D. with an integer.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机器的标准描述（S.D.）之后，图灵进一步生成了他所称的*描述号（D.N.）*，这是一个完全指定图灵机的单一整数。要计算D.N.，首先从S.D.开始，并将S.D.中的每个可能的字母替换为一个整数。
- en: '*A* → 1, *C* → 2, *D* → 3, *L* → 4, *R* → 5, *N* → 6, ;→ 7'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*A* → 1, *C* → 2, *D* → 3, *L* → 4, *R* → 5, *N* → 6, ;→ 7'
- en: For example, the S.D. above becomes
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，上面的S.D.变成
- en: '31332531173113353111731113322531111731111335317'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '31332531173113353111731113322531111731111335317'
- en: The D.N. mapping means that every computable sequence, that is, anything computable
    by a Turing machine, has at least one D.N., and each D.N. specifies only one computable
    sequence. The net result is that the number of Turing machines is enumerable.
    Turing is writing about computable numbers, which are real numbers that can be
    computed by an algorithm, but by showing that the number of Turing machines is
    enumerable (could be counted), he shows that there are infinitely many real numbers
    that are not computable, that is, numbers for which no algorithm exists. Here
    he’s building on Georg Cantor’s famous proof that the real numbers are not countable.
    For a summary of Cantor’s proof, see *[https://mathworld.wolfram.com/CantorDiagonalMethod.html](https://mathworld.wolfram.com/CantorDiagonalMethod.html)*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: D.N.映射意味着每一个可计算的序列，即任何图灵机可计算的东西，都至少有一个D.N.，且每个D.N.仅指定一个可计算的序列。最终结果是，图灵机的数量是可数的。图灵在讨论可计算数，这些是可以通过算法计算的实数，但通过证明图灵机的数量是可数的（即可以被计数），他展示了有无限多的实数是不可计算的，也就是说，没有任何算法可以计算这些数。在这里，他是在建立在乔治·康托尔（Georg
    Cantor）著名的证明基础上，证明实数是不可数的。有关康托尔证明的总结，请参见*[https://mathworld.wolfram.com/CantorDiagonalMethod.html](https://mathworld.wolfram.com/CantorDiagonalMethod.html)*。
- en: In Section 8 of his paper, Turing uses the fact that the number of Turing machines
    is countable to contemplate a machine for checking description numbers, a machine
    that knows whether or not the Turing machine associated with the description number
    will halt or not for all possible inputs. Through an attempt to apply a mathematical
    process used by Cantor, Turing arrives at a contradiction, proving that no such
    machine exists. This is his proof that the halting problem is undecidable—that
    there exists no algorithm that will tell you if program *P* halts on input *I*
    for all possible inputs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在他论文的第8节中，图灵利用图灵机的数量是可数的这一事实，思考了一个检查描述编号的机器，这台机器知道与描述编号相关联的图灵机是否会在所有可能的输入下停止。通过尝试应用康托尔使用的数学过程，图灵得出了一个矛盾，证明了不存在这样的机器。这是他证明停机问题是不可判定的证明——即不存在任何算法能够告诉你程序*P*是否在输入*I*上对所有可能的输入停止。
- en: 'To recap, a UTM is a Turing machine that accepts encoded Turing machines and
    input tapes as its input. The UTM then runs the supplied Turing machine on the
    provided tape to produce the output of the Turing machine. Thus, a UTM is a program
    that runs other programs. Does this sound familiar? The UTM is a general-purpose
    computing machine—a computer—and it can run programs given as inputs. The UTM
    is a stored-program computer, that is, a computer that puts programs and data
    in the same memory (its input) and executes the program. This is what every modern
    computer does: specifically, every *von Neumann architecture* computer. For those
    familiar with computers—presumably everyone reading this book—this is a no-brainer
    idea; that’s just what computers do. However, the idea wasn’t a no-brainer in
    1936\. It was foundational and groundbreaking.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，UTM（通用图灵机）是一种接受编码图灵机和输入带作为输入的图灵机。然后，UTM会在提供的带上运行所提供的图灵机，输出图灵机的结果。因此，UTM是一个运行其他程序的程序。听起来是不是很熟悉？UTM是一个通用计算机——一台计算机——它可以运行作为输入的程序。UTM是一个存储程序计算机，也就是说，它将程序和数据存储在同一个内存（即输入）中并执行程序。这就是每台现代计算机所做的事情：具体来说，每一台*冯·诺依曼架构*计算机。对于熟悉计算机的人——假设每个阅读本书的人都熟悉——这是一个显而易见的概念；这就是计算机的作用。然而，在1936年，这个想法并不是显而易见的。它是基础性和突破性的。
- en: Turing machines are not the only possible models of computation. Others, like
    *finite-state machines* and *Minsky register machines*, do exist. At best, these
    other models are equivalent to Turing machines (Minsky machines) or demonstrably
    less powerful (finite-state machines). Comparing models of computation is part
    of *automata theory*. The significant result for us is that Turing machines are
    the top of the heap, and there are no models of computation that can perform actions
    beyond what a Turing machine can implement. This most likely includes quantum
    computers. We’ll encounter a Minsky register machine in [Chapter 8](ch08.xhtml#ch08)
    when we discuss FRACTRAN.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵机并不是唯一的计算模型。其他模型，如*有限状态机*和*敏斯基寄存器机*，确实存在。最好的情况是，这些其他模型与图灵机是等价的（敏斯基机），或者证明它们的计算能力较弱（有限状态机）。比较计算模型是*自动机理论*的一部分。对我们来说，重要的结论是图灵机处于计算模型的顶端，没有任何模型能执行图灵机无法实现的操作。这很可能包括量子计算机。我们将在[第8章](ch08.xhtml#ch08)讨论FRACTRAN时遇到敏斯基寄存器机。
- en: Turing machines are the best known model of computation, and perhaps the best
    model possible if the Church–Turing thesis is correct. Let’s see how equivalence
    to a Turing machine is helpful for our exploration of esolangs.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵机是最著名的计算模型，如果教会–图灵论题是正确的，它可能是最好的计算模型。让我们看看与图灵机的等价性对我们探索esolangs（恶搞语言）有何帮助。
- en: '**Turing Completeness**'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**图灵完备性**'
- en: A Turing machine can implement any algorithm. If a programming language can
    do the same, the language is called *Turing complete*. Specifically,
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵机可以实现任何算法。如果某种编程语言也能做到这一点，那么该语言被称为*图灵完备*。具体来说，
- en: A *Turing complete* system can simulate all Turing machines, that is, can simulate
    a universal Turing machine.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*图灵完备*的系统可以模拟所有图灵机，也就是说，它可以模拟一个通用图灵机。
- en: If a programming language is Turing complete, it can, in theory, implement anything
    a Turing machine can, and therefore any algorithm at all. As you might expect,
    widely used programming languages are Turing complete. In the next section, we’ll
    implement a Turing machine simulator in Python, which demonstrates that Python
    is Turing complete.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一种编程语言是图灵完备的，那么理论上它可以实现任何图灵机可以实现的功能，因此可以实现任何算法。正如你可能预料到的，广泛使用的编程语言都是图灵完备的。在下一节中，我们将用Python实现一个图灵机模拟器，这证明了Python是图灵完备的。
- en: 'Imperative programming languages need only two things to be Turing complete:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式编程语言只需要两个条件即可具备图灵完备性：
- en: Some form of looping based on a conditional, like a `while` loop or a combination
    of `if` and `goto`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于条件的某种形式的循环，例如 `while` 循环或 `if` 与 `goto` 的组合。
- en: The ability to manipulate an arbitrarily large amount of memory.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作任意大量内存的能力。
- en: The second requirement is, of course, not met for any real-world programming
    language *as implemented*, but it is easily met when the language is *specified*.
    For example, there is nothing in Python’s specification that says “a list may
    contain at most one million items.” In the language itself, there is no limit
    on how many items a list may contain, even if an implementation must, to be realized
    in the physical world, have such a limit.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个要求，当然，对于任何现实世界中的编程语言 *按实现* 来说是不满足的，但当语言 *被规范化* 时，它是可以轻松满足的。例如，Python 的规范中没有规定“一个列表最多只能包含一百万个项目”。在语言本身中，列表可以包含多少项没有限制，即使在实际物理实现中可能需要有此限制。
- en: 'Why should we care about Turing completeness? Turing completeness is particularly
    interesting when dealing with esolangs. Esolangs are all about pushing boundaries
    and thinking in novel ways. Therefore, it makes sense to ask whether an esolang
    is Turing complete. If it is, then a design goal might well have been achieved:
    the language is, in theory, capable of implementing any algorithm, regardless
    of how difficult it might be to do so in practice. Not every language we’ll explore
    in this book is Turing complete; however, not being Turing complete does not mean
    useless. By itself, HTML is not Turing complete; yet, HTML is, as the basis for
    web pages, extremely useful.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们应该关注图灵完备性？图灵完备性在处理“自造语言”（esolang）时尤其有趣。自造语言的核心就是挑战极限，尝试用新颖的方式思考。因此，询问某种自造语言是否图灵完备是合理的。如果它是图灵完备的，那么一个设计目标可能已经达成：该语言在理论上能够实现任何算法，无论实际操作起来有多么困难。并不是我们在本书中探讨的每一种语言都是图灵完备的；然而，非图灵完备并不意味着毫无用处。单独来看，HTML并不是图灵完备的；但作为网页的基础，HTML是极其有用的。
- en: It is also possible to demonstrate Turing completeness by providing a translator
    between the language in question and another language known to be Turing complete.
    This is often used to illustrate Turing completeness for different esolangs. For
    example, the Nopfunge esolang (*[https://esolangs.org/wiki/Nopfunge](https://esolangs.org/wiki/Nopfunge)*),
    which is based on the Befunge esolang we’ll explore in [Chapter 11](ch11.xhtml#ch11),
    shows Turing completeness by translating a Minsky machine into Nopfunge. Minsky
    machines are known to be Turing complete. Therefore, if Nopfunge can implement
    a Minsky machine, then Nopfunge can implement any Turing machine.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供一个在该语言与已知的图灵完备语言之间的翻译器，也可以证明图灵完备性。这种方法通常用来展示不同自造语言的图灵完备性。例如，Nopfunge 语言（*
    [https://esolangs.org/wiki/Nopfunge](https://esolangs.org/wiki/Nopfunge)*），它基于我们将在
    [第十一章](ch11.xhtml#ch11) 中探讨的 Befunge 语言，通过将 Minsky 机翻译成 Nopfunge 来展示图灵完备性。Minsky
    机是已知的图灵完备系统。因此，如果 Nopfunge 能实现 Minsky 机，那么 Nopfunge 也能够实现任何图灵机。
- en: 'The requirements for Turing completeness are so minimal that many systems not
    originally intended to be Turing complete have been shown to be so. For example,
    each of the following is Turing complete:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵完备的要求极其简单，许多原本并不打算具备图灵完备性的系统，后来被证明也是图灵完备的。例如，以下每个系统都是图灵完备的：
- en: The `mov` instruction for the x86 architecture (see *[https://github.com/xoreaxeaxeax/movfuscator/](https://github.com/xoreaxeaxeax/movfuscator/)*
    for a C compiler that generates only `mov` instructions)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x86架构的 `mov` 指令（请参见 *[https://github.com/xoreaxeaxeax/movfuscator/](https://github.com/xoreaxeaxeax/movfuscator/)*，它是一个仅生成
    `mov` 指令的 C 编译器）
- en: Minecraft
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Minecraft
- en: '*Magic: The Gathering* card game'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*魔法风云会* 卡牌游戏'
- en: The Dwarf Fortress video game (see *[https://youtu.be/j2cMHwo3nAU/](https://youtu.be/j2cMHwo3nAU/)*
    for a video showing Space Invaders running in Dwarf Fortress)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《侏儒堡垒》视频游戏（请参见 *[https://youtu.be/j2cMHwo3nAU/](https://youtu.be/j2cMHwo3nAU/)*，该视频展示了《太空侵略者》在《侏儒堡垒》中的运行）
- en: PowerPoint (see *[http://www.andrew.cmu.edu/user/twildenh/PowerPointTM/Paper.pdf](http://www.andrew.cmu.edu/user/twildenh/PowerPointTM/Paper.pdf)*)
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerPoint（请参见 *[http://www.andrew.cmu.edu/user/twildenh/PowerPointTM/Paper.pdf](http://www.andrew.cmu.edu/user/twildenh/PowerPointTM/Paper.pdf)*）
- en: The vim text editor (see *[https://github.com/ealter/vim_turing_machine/](https://github.com/ealter/vim_turing_machine/)*)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vim 文本编辑器（请参见 *[https://github.com/ealter/vim_turing_machine/](https://github.com/ealter/vim_turing_machine/)*）
- en: This list is by no means exhaustive.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表远非详尽无遗。
- en: Let’s put theory into practice and implement a basic Turing machine simulator
    in Python.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将理论付诸实践，并用 Python 实现一个基本的图灵机模拟器。
- en: '**Let’s Build a Turing Machine**'
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**构建一个图灵机**'
- en: Perhaps the best way to understand how a Turing machine works is to implement
    one. In a way, Turing machines are the first esolangs. They are capable of everything,
    but are impractical for serious use. Turing machines are rather general, as they
    work with an arbitrary set of symbols, but we’ll restrict ourselves to a machine
    using only 0 and 1 as symbols, along with blank for an empty space. Likewise,
    we’ll represent the instruction table as shown in [Table 3-1](ch03.xhtml#ch03tab1),
    where each row of the table is a 5-tuple describing the state and tape condition
    followed by the action, move, and new state. For example, we’ll express [Table
    3-1](ch03.xhtml#ch03tab1) in Python with [Listing 3-1](ch03.xhtml#ch03list1).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 或许理解图灵机如何工作的最佳方式是实现一个图灵机。从某种意义上来说，图灵机是最早的自定义语言（esolang）。它们可以做任何事情，但对于实际应用来说并不实用。图灵机是相当通用的，因为它们可以处理任意一组符号，但我们将限制自己只使用
    0 和 1 作为符号，同时使用空白来表示空格。同样，我们将以 [表格 3-1](ch03.xhtml#ch03tab1) 所示的方式表示指令表，其中表格的每一行是一个五元组，描述了状态和磁带条件，后面跟着动作、移动和新状态。例如，我们将使用
    Python 表示 [表格 3-1](ch03.xhtml#ch03tab1)，见 [列表 3-1](ch03.xhtml#ch03list1)。
- en: '[PRE0]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 3-1: Turing’s first example in Python*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-1：图灵的第一个示例在 Python 中*'
- en: The rows of [Table 3-1](ch03.xhtml#ch03tab1) match the rows of [Listing 3-1](ch03.xhtml#ch03list1).
    The first entry in the table describes state 0 and a blank. The action is to print
    a 0, move right, transfer to state 1, and then repeat. For our machines, all actions
    are to print something, and all movements are to the right or left; there is no
    standing still. All possible combinations of state and the current symbol, the
    first two elements of every instruction, should be present in the table; otherwise,
    the program is incomplete because there are state and symbol combinations with
    no defined actions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 3-1](ch03.xhtml#ch03tab1) 的行与 [列表 3-1](ch03.xhtml#ch03list1) 的行相匹配。表格中的第一个条目描述了状态
    0 和一个空白。动作是打印一个 0，向右移动，转到状态 1，然后重复。对于我们的机器，所有动作都是打印某些东西，所有移动都是向右或向左；没有静止不动的情况。每个指令的前两个元素——状态和当前符号——的所有可能组合应出现在表格中；否则，程序是不完整的，因为存在没有定义动作的状态和符号组合。'
- en: Let’s take our Turing machine for a spin and then dive into the code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动图灵机，然后深入研究代码。
- en: '***The Simulator***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模拟器***'
- en: The code for our Turing machine simulator is in *turing.py*. It begins with
    a small catalog of example programs in `PROGS` along with a brief description
    in `NAMES`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图灵机模拟器的代码在 *turing.py* 中。它以一个小的示例程序目录 `PROGS` 开始，并在 `NAMES` 中给出了简短的描述。
- en: Running *turing.py* without arguments gives us
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有参数的情况下运行 *turing.py* 会给出：
- en: '[PRE1]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The output tells us to select an example program from the list below and then
    specify the size of the blank tape, or manually enter an initial tape configuration
    as input. The optional final argument, `-t`, enables tracing, allowing us to step
    through the program to see the effect of each instruction.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 输出告诉我们从以下列表中选择一个示例程序，然后指定空白磁带的大小，或者手动输入初始磁带配置作为输入。可选的最后一个参数 `-t` 启用跟踪功能，允许我们逐步执行程序，查看每个指令的效果。
- en: Let’s run Turing’s first example (Program 0).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行图灵的第一个示例（程序 0）。
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We told the simulator to use a blank tape with 20 spaces. As conceived, Turing
    machines never run out of tape. The output shows the pattern of 0s and 1s as expected.
    We’re also told that the machine stopped in state 0 and that the tape counter
    (`tc`) was at position 20\. In other words, we ran out of tape, so the simulation
    stopped. The selected program’s instruction table is printed below the output
    showing the state and symbol matched followed by the print action, movement, and
    new state.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉模拟器使用一个包含 20 个空白空间的磁带。按照设想，图灵机永远不会用完磁带。输出显示了预期的 0 和 1 的模式。我们还得知，机器停止在状态
    0，且磁带计数器（`tc`）位于第 20 个位置。换句话说，我们用完了磁带，因此模拟停止。选定程序的指令表显示在输出下方，显示了匹配的状态和符号，后跟打印动作、移动和新状态。
- en: In *turing.py*, the `main` function parses the command line arguments to select
    the program run along with the size of the blank tape or the initial tape configuration
    entered by the user. We’ll see how to enter a tape below. The machine itself is
    contained in the class `TuringMachine`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *turing.py* 中，`main` 函数解析命令行参数，选择运行的程序以及用户输入的空白磁带的大小或初始磁带配置。我们将看到如何输入磁带。机器本身包含在
    `TuringMachine` 类中。
- en: '[Listing 3-2](ch03.xhtml#ch03list2) shows the `TuringMachine` class with the
    `Result` method omitted to save space.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-2](ch03.xhtml#ch03list2) 显示了 `TuringMachine` 类，省略了 `Result` 方法以节省空间。'
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 3-2: The TuringMachine class*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-2：TuringMachine 类*'
- en: The constructor ➎ accepts the program (`prog`) and the initial tape (`tape`),
    if any, or the size of the blank tape. If a tape is supplied, we add an extra
    blank as several example programs expect an ending blank. The constructor sets
    up the default state (`c`) and tape counter position (`tc`) and then saves the
    program.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数 ➎ 接受程序（`prog`）和初始磁带（`tape`），如果有的话，或者空白磁带的大小。如果提供了磁带，我们会添加一个额外的空白，因为一些示例程序期望最后有一个空白。构造函数设置默认状态（`c`）和磁带计数器位置（`tc`），然后保存程序。
- en: The `Run` method is short and sweet as most of it implements tracing ➍. Running
    a program is performing step after step until done. `Done` returns `True` if we
    fall off the tape or hit a negative state, which we’ll interpret as a halt instruction
    ➌. All the action takes place in `Step`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Run` 方法简短明了，因为它大部分实现了追踪 ➍。运行程序是一个个步骤地执行直到完成。`Done` 返回 `True` 如果我们超出磁带范围或遇到负状态，我们将其解释为停止指令
    ➌。所有操作都在 `Step` 中完成。'
- en: '`Step` first locates the instruction table entry corresponding to the current
    state and the symbol under the tape head ➊. Once found, we then extract the action,
    movement, and next state ➋. We then update the current tape position with the
    action. After that, we increment or decrement the tape counter based on the move
    character (`R` or `L`). Lastly, we update the state to complete the instruction
    step.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Step` 首先定位当前状态和磁带头下符号对应的指令表条目 ➊。找到后，我们提取动作、移动和下一个状态 ➋。然后，我们根据动作更新当前磁带位置。接下来，根据移动字符（`R`
    或 `L`），我们增加或减少磁带计数器。最后，我们更新状态以完成指令步骤。'
- en: There are additional comments in *turing.py* explaining the code in more detail.
    Please review them. The catalog of examples is in `PROGS`. To add more examples,
    place them there and add a description in `NAMES`. Note that our machine follows
    Turing’s original paper, meaning we move the tape head along the tape. If you
    examine other Turing machine simulators, and there are many far more sophisticated
    than ours, be aware that many move the *tape* instead. Therefore, if you want
    to transfer a program for such an implementation to *turing.py*, you must change
    all `R` characters to `L` and vice versa.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *turing.py* 中有更多的注释，详细解释了代码。请查看它们。示例目录在 `PROGS` 中。要添加更多示例，请将它们放在那里，并在 `NAMES`
    中添加描述。请注意，我们的机器遵循图灵的原始论文，意味着我们沿着磁带移动磁带头。如果你查看其他图灵机模拟器，其中有许多比我们的更复杂，请注意很多是移动 *磁带*
    而不是磁带头。因此，如果你想将程序转换为这种实现并应用于 *turing.py*，你必须将所有的 `R` 改为 `L`，反之亦然。
- en: '***The Examples***'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***示例***'
- en: We described Turing’s Program 0 above. Now let’s walk through the other examples
    using a sufficient level of detail to understand the process encoded in the instruction
    table.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上面描述了图灵的程序 0。现在，让我们逐步讲解其他示例，详细理解指令表中编码的过程。
- en: '**Program 1: Change 0s to 1s**'
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**程序 1：将 0 改为 1**'
- en: This example is straightforward. The instructions convert all 0s to 1s and the
    program stops when a blank or one is encountered.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例很简单。指令将所有的 0 转换为 1，当遇到空白或 1 时，程序停止。
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There is only one state, state 0, with a rule for all allowed symbols: 0, 1,
    and blank. To be specific, the first row of the table says, “if in state 0 and
    the symbol under the tape head is a 0, print a 1, move to the right, and remain
    in state 0.” This instruction will continue for as long as the symbol under the
    tape head is 0\. It replaces the 0 with a 1 and moves to the next symbol again
    and again.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个状态，状态 0，对于所有允许的符号：0、1 和空白，都有一条规则。具体来说，表格的第一行写道：“如果在状态 0 并且磁带头下的符号是 0，则打印
    1，向右移动，保持在状态 0。”这个指令会一直执行，只要磁带头下的符号是 0。它将 0 替换为 1，并不断地移动到下一个符号。
- en: The remaining two instructions capture what to do if the symbol under the tape
    head is a one or a blank. In both cases, the matched symbol is printed again to
    leave that square unchanged. The critical point is that the next state is *–*1\.
    Our machine stops if the state is negative, so *–*1 means “halt.”
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的两条指令描述了当磁带头下的符号是 1 或空白时该怎么做。在这两种情况下，匹配的符号会再次打印出来，以保持该方格不变。关键点是下一状态是 *–*1。我们的机器在状态为负数时停止，因此
    *–*1 意味着“停止”。
- en: 'Combined, these states move to the right along the tape, changing every 0 into
    a 1 until the program reads a 1 or a blank. Let’s see if our interpretation is
    correct by running the program with different input tapes. Initial tape configurations
    are passed on the command line as Python lists using 0 and 1, with 2 representing
    a blank. For example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些状态一起沿着带移动，将每个0转变为1，直到程序读取到1或空白。让我们通过不同的输入带来验证我们的解释是否正确。初始带配置作为Python列表传递，其中0和1表示二进制数字，2表示空白。例如：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In each case above, the output matches what we expect from the program. All
    consecutive 0s are now 1s and blanks, and 1s are unchanged.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上述每种情况中，输出结果都与我们预期的程序行为一致。所有连续的0现在变为1和空白，1保持不变。
- en: '**Program 2: Unary Increment**'
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**程序2：单一数字递增**'
- en: 'Binary numbers use two digits: 0 and 1\. Unary numbers are tallies, that is,
    repeated instances of 1.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数使用两个数字：0和1。单一数字是计数符号，即重复的1。
- en: '| 1 | 1 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 |'
- en: '| 2 | 11 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 11 |'
- en: '| 3 | 111 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 111 |'
- en: '| 4 | 1111 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 1111 |'
- en: '| 5 | 11111 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 11111 |'
- en: 'Program 2 increments the unary number already on the tape:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 程序2对带上的单一数字进行递增：
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This program is quite similar to the program to map 0s to 1s. The first instruction
    marches along the tape, keeping every 1 a 1 and moving right until it finds a
    0 or blank. The program turns the first 0 or blank into a 1 and then halts.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序与将0映射为1的程序非常相似。第一条指令沿着带移动，保持每个1为1，并继续向右移动，直到遇到0或空白。程序将第一个0或空白转变为1，然后停止。
- en: Let’s run this program with tracing to see how it moves. Press ENTER at each
    prompt to continue.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个程序并进行追踪，看看它是如何执行的。在每个提示符下按回车键继续。
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tracing shows the current tape, three 1s, and a blank added at the end as well
    as the current state and tape counter. The following line prints a carat under
    the current tape position. Pressing ENTER three times moves along the 1 to the
    blank. Pressing ENTER one more time fills that blank with a 1, after which the
    program halts. The initial input was 3 (`111`), and the output tape is now 4 (`1111`).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 追踪显示当前带上有三个1，末尾添加了一个空白，并且显示了当前状态和带计数器。接下来的行在当前带位置下打印了一个插入符号（^）。按三次回车键会将光标移到1上的空白处。再按一次回车，那个空白就会被填充为1，然后程序停止。初始输入是3（`111`），输出带现在是4（`1111`）。
- en: '**Program 3: Binary Increment**'
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**程序3：二进制递增**'
- en: Binary numbers use 0 and 1 as digits. The addition rules for binary are simple
    and can be expressed as
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数使用0和1作为数字。二进制加法规则非常简单，可以表示为：
- en: '| 0 + 0 = 0 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 0 + 0 = 0 |'
- en: '| 0 + 1 = 1 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 0 + 1 = 1 |'
- en: '| 1 + 0 = 1 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 1 + 0 = 1 |'
- en: '| 1 + 1 = 10 (carry) |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 1 + 1 = 10（进位） |'
- en: Note that the sum of 1 and 1 produces a carry. Program 3 implements a Turing
    machine that adds one to the binary number on the input tape. Its instruction
    table is
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，1与1相加会产生进位。程序3实现了一个图灵机，它将输入带上的二进制数加1。它的指令表如下：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Program 3 uses three states. It isn’t readily evident from looking at the instruction
    table alone what the states are doing. So let’s run an example with tracing to
    see the instructions in action. We’ll add one to 1011[2] = 11[10]. The command
    line is
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 程序3使用了三个状态。从指令表本身来看，很难直接理解这些状态的作用。所以，让我们通过一个带追踪的示例来看看指令的实际效果。我们将对1011[2] = 11[10]进行递增。命令行如下：
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[Table 3-2](ch03.xhtml#ch03tab2) contains the trace, step by step. The program
    generates 1100[2] = 12[10], as expected.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[表3-2](ch03.xhtml#ch03tab2)包含了逐步追踪。程序生成了1100[2] = 12[10]，符合预期。'
- en: '**Table 3-2:** Tracing Binary Increment for 1011'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**表3-2：** 追踪二进制递增过程（对于1011）'
- en: '| `1011 , (state=0, tc=0)``^` |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `1011 , (状态=0, tc=0)``^` |'
- en: '| `1011 , (state=0, tc=1)``^` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `1011 , (状态=0, tc=1)``^` |'
- en: '| `1011 , (state=0, tc=2)``^` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `1011 , (状态=0, tc=2)``^` |'
- en: '| `1011 , (state=0, tc=3)``^` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `1011 , (状态=0, tc=3)``^` |'
- en: '| `1011 , (state=0, tc=4)``^` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `1011 , (状态=0, tc=4)``^` |'
- en: '| `1011 , (state=1, tc=3)``^` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `1011 , (状态=1, tc=3)``^` |'
- en: '| `1010 , (state=1, tc=2)``^` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `1010 , (状态=1, tc=2)``^` |'
- en: '| `1000 , (state=1, tc=1)``^` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `1000 , (状态=1, tc=1)``^` |'
- en: '| `1100 , (state=2, tc=0)``^` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `1100 , (状态=2, tc=0)``^` |'
- en: '| `1100 , (state=2, tc=1)``^` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `1100 , (状态=2, tc=1)``^` |'
- en: '| `1100 , (state=2, tc=2)``^` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `1100 , (状态=2, tc=2)``^` |'
- en: '| `1100 , (state=2, tc=3)``^` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `1100 , (状态=2, tc=3)``^` |'
- en: '| `1100 , (state=2, tc=4)``^` |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `1100 , (状态=2, tc=4)``^` |'
- en: The first five steps of [Table 3-2](ch03.xhtml#ch03tab2) move along the input,
    looking for a blank marking the end of the binary number. state 0 is sufficient
    for this part. When the program finds the blank in this state, it decrements the
    tape counter to look at the rightmost digit of the binary number, after which
    state 1 becomes active.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-2](ch03.xhtml#ch03tab2) 的前五个步骤沿着输入移动，寻找标记二进制数结尾的空格。这部分足以由 State 0 完成。当程序在这种状态下找到空格时，它将减少磁带计数器以查看二进制数的最右边的数字，然后
    State 1 变为活动状态。'
- en: With state 1 active, if the symbol under the tape head is a 0, it is replaced
    by a 1, the tape head moves to the left, and state 2 becomes active. This is equivalent
    to adding 1\. If the symbol under the tape head is a 1, the program replaces it
    with 0 as 1 + 1 = 0 with a carry of 1\. The machine then remains in state 1 after
    moving left. The carry is implied by state 1 and the fact that the state moves
    left, replacing 1s with 0s. The 0 and 1 instructions of state 1 together process
    the number right to left and handle the carry by remaining in state 1 until a
    0 is found. Adding 1 to 0 does not produce a carry, so the machine would move
    to state 2 and the increment would be complete.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当 State 1 活跃时，如果磁带头下的符号是 0，则将其替换为 1，磁带头向左移动，并激活 State 2。这相当于加 1。如果磁带头下的符号是 1，则程序将其替换为
    0，因为 1 + 1 = 0，带有 1 的进位。然后机器在向左移动后仍停留在 State 1。进位由 State 1 隐含，状态向左移动，将 1 替换为 0。State
    1 的 0 和 1 指令一起从右向左处理数字，并通过保持在 State 1 直到找到 0 来处理进位。将 1 加到 0 不会产生进位，所以机器会转移到 State
    2，增量完成。
- en: State 2 moves the tape head back right along the number until a terminating
    blank is found, at which point the state becomes *–*1 and the machine halts. The
    action of state 2 is only to position the tape head. If we’re not interested in
    positioning the head at the end of the number, we could transition to *–*1 from
    state 1 as soon as a 0 is updated to a 1\. Try this example with different inputs
    until you are comfortable with how it works.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: State 2 将磁带头向右移动到找到终止空格为止，此时状态变为 *–*1，机器停止。State 2 的动作仅是定位磁带头。如果我们不关心在数字末尾定位头部，我们可以从
    State 1 立即将 0 更新为 1 过渡到 *–*1。尝试使用不同的输入运行此示例，直到您对其工作原理感到满意。
- en: '**Program 4: Unary Subtraction**'
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**程序 4：一元减法**'
- en: Adding 1 to a unary number was quite simple. This next example implements unary
    subtraction with the larger number first, followed by a blank, and then the smaller
    number. For example, an input of `[11111 111]` returns `[11        ]`, which is
    5 *–* 3 = 2, using blanks to overwrite any extra digits.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 给一元数加 1 是非常简单的。下一个例子实现了先减去较大数，然后是空格，然后是较小数的一元减法。例如，输入 `[11111 111]` 返回 `[11        ]`，即
    5 *–* 3 = 2，使用空格覆盖任何多余的数字。
- en: 'Let’s run this example with tracing. We won’t list the many steps required,
    but I suspect that you will see for yourself what the instructions are doing.
    It’s quite clever. Run the example with the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们带着追踪运行这个例子。我们不会列出所需的许多步骤，但我怀疑你会自己看到指令在做什么。这相当巧妙。用以下命令运行这个例子：
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: State 0 finds the blank between the first and second number and then transitions
    to state 1\. State 1 finds the blank after the second number and transitions to
    state 2\. State 2 moves left over the smaller number, changing the first 1 found
    into a 0 and then moving to state 3\. State 3 finds the blank between the two
    numbers and moves to state 7\. State 7 makes the first 1 of the larger number
    a 0 and moves back to state 0\. This state 0, 1, 2, 3, 7 cycle repeats until state
    2 no longer finds a 1 in the smaller number.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: State 0 找到第一个和第二个数字之间的空格，然后转移到 State 1。State 1 找到第二个数字后面的空格，然后转移到 State 2。State
    2 向左移动到较小的数字上，将找到的第一个 1 变为 0，然后转移到 State 3。State 3 找到两个数字之间的空格，然后转移到 State 7。State
    7 将较大数字的第一个 1 变为 0，并返回到 State 0。State 0、1、2、3、7 的循环重复，直到 State 2 在较小数字中找不到 1 为止。
- en: At this point, all the 1s of the smaller number are 0s, as are the same number
    of rightmost 1s of the larger number. In essence, the subtraction is complete.
    The remainder of the program changes 0s to blanks, so the only symbols on the
    tape when the program ends are the remaining 1s of the larger unary number. States
    4, 5, and 6 accomplish this and then transition from state 6 to –1 when there
    are no more 0s.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，较小数的所有 1 都是 0，较大数最右边相同数量的 1 也是 0。实质上，减法完成了。程序的其余部分将 0 更改为空白，因此当程序结束时，磁带上唯一的符号是较大一元数的剩余
    1。States 4、5 和 6 完成了这一点，然后在没有更多 0 时从 State 6 过渡到 –1。
- en: '**Try Your Hand**'
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**试试你的能力**'
- en: Running *turing.py* without command line arguments shows five example programs.
    There is actually a sixth, Program 5, but it was intentionally left out of the
    list as an exercise. Program 5 calculates the two’s complement of the binary number
    on the input tape. Computers store negative integers in two’s complement format
    so hardware only needs to implement addition. Subtraction of two integers is addition
    using two’s complement form.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 运行*turing.py*而不带命令行参数会显示五个示例程序。实际上还有第六个程序，即程序5，但它故意没有列出，以作为练习。程序5计算输入带上二进制数的二进制补码。计算机使用二进制补码格式存储负整数，因此硬件只需要实现加法。两个整数的减法可以通过使用二进制补码形式的加法来实现。
- en: 'Finding the two’s complement of a binary number is easy: change all 0 bits
    to 1s and all the 1s to 0s, and then add 1 to that result. For example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 找到二进制数的二进制补码很简单：将所有的0位变为1，将所有的1位变为0，然后在结果上加1。例如：
- en: 01011011 → 10100100 + 1 → 10100101
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 01011011 → 10100100 + 1 → 10100101
- en: The challenge of this section is to create the instruction table for a Turing
    machine that converts its input to two’s complement format. We have a Turing machine
    that adds 1 to a binary number. We also have a Turing machine that converts 0s
    to 1s. The required machine will flip 0s and 1s before adding 1\. Try writing
    the two’s complement instruction table yourself. When ready, take a look at the
    last entry in `PROGS` and compare it with your table. You can run Program 5 easily
    enough.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的挑战是为图灵机创建一张将输入转换为二进制补码格式的指令表。我们有一台图灵机，它将1加到二进制数字上。我们也有一台图灵机，它将0转换为1。所需的机器将在加1之前翻转0和1。尝试自己编写二进制补码的指令表。准备好后，查看`PROGS`中的最后一个条目，并将其与您的表进行比较。你可以轻松运行程序5。
- en: '[PRE11]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The output is what we found for the example above.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是我们为上述示例找到的结果。
- en: '**Summary**'
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: This chapter explored Turing machines and the idea of Turing completeness. We
    began with the halting problem and then moved on to Turing machines, the mechanism
    Turing used in his famous 1936 paper where he demonstrated that the halting problem
    was undecidable. We then explored the idea of a UTM, which led directly to the
    concept of a stored-program computer.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了图灵机以及图灵完备性的概念。我们从停机问题开始，然后转到图灵机，这是图灵在其著名的1936年论文中使用的机制，他在该论文中证明了停机问题是不可判定的。然后，我们探讨了UTM的概念，这直接引出了存储程序计算机的概念。
- en: Next, we discussed the concept of Turing completeness, something we’ll refer
    to throughout the book as we explore esolangs. The idea that many systems are
    accidentally Turing complete is simple enough. Lastly, we implemented a Turing
    machine simulator in Python and worked through several example programs.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论了图灵完备性的概念，在本书中我们会不断提到它，尤其是在探索esolangs时。许多系统不经意间具备图灵完备性，这个想法足够简单。最后，我们实现了一个Python中的图灵机模拟器，并通过几个示例程序进行了实践。
- en: This chapter concludes [Part I](part01.xhtml#part01) of the book. We move on
    now to consider what I’m calling “atypical programming languages,” by which I
    mean languages meant for serious use but that are sufficiently different from
    the pack in their approach to warrant a detailed examination as a precursor to
    the esolangs that follow. We will begin with Forth, a stack-based language.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束了[第一部分](part01.xhtml#part01)的内容。接下来我们将讨论我所称的“非典型编程语言”，即那些旨在认真使用但由于其方法与常规语言有所不同，值得进行详细探讨的语言，为后续的esolangs做铺垫。我们将从Forth开始，这是一种基于栈的语言。
