- en: '**15  LPC1114 Bootloader Glitch**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the software vulnerabilities discussed in [Chapter 4](ch04.xhtml#ch04),
    the LPC1114 and LPC1343 are vulnerable to voltage glitching attacks documented
    in Gerlinsky (2017), Nedospasov (2017), and Dewar (2018). This is a beginner’s
    glitching attack, a good first target to learn fault injection.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get started, look at [Figure 4.5](ch04.xhtml#ch4fig5) and review the
    explanation of the lock features in [Chapter 4](ch04.xhtml#ch04). When the lock
    level is CRP1, we can use the memory corruption exploit in that chapter to dump
    the chip’s memory, but in CRP2 and CRP3 the bootloader commands are so restricted
    that we can’t trigger the vulnerability. That’s where voltage glitching comes
    in.
  prefs: []
  type: TYPE_NORMAL
- en: You should also see in [Figure 4.5](ch04.xhtml#ch4fig5) that a single word of
    flash memory controls the protection mode. `0x12345678` places us in CRP1, where
    the remote code execution exploit works. `0x4321-8765` places us in CRP3, where
    both JTAG and the ISP programming mode are entirely disabled. `0x87654321` is
    just as bad, allowing ISP but *only* the Mass Erase command.
  prefs: []
  type: TYPE_NORMAL
- en: The very last line of that table is the important one, and the reason why these
    chips are such an easy target for glitching. If the 32-bit word has *any other
    value* than the ones in that table, it defaults to being totally open to both
    JTAG debugging and ISP programming. While `0x43218765` or `0x87654321` will lock
    us out, a single bit error might change those to `0x43208765` or `0x87654331`,
    either of which would provide us with full access. The purpose of our fault injection
    will be to corrupt that word, providing just such a change.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0144-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.1: LPC111x'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0145-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.2: Olimex LPC-P1114 Schematic'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hardware Modifications**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gerlinsky, Nedospasov, and Dewar each made slightly different modifications
    to the Olimex development kit in [Figure 15.2](ch15.xhtml#ch15fig2), but the general
    principle is the same.
  prefs: []
  type: TYPE_NORMAL
- en: First, we want to remove the 100nF decoupling capacitor, which is C4 in the
    schematic. The purpose of this capacitor is to prevent momentary drops in voltage
    from causing faults in the chip, and we’re removing it because our intention is
    to cause this momentary failure. Leaving it in would make glitching much more
    difficult.
  prefs: []
  type: TYPE_NORMAL
- en: The decoupling capacitor for this chip is designed to sit between the VSS and
    3.3V VDD lines, but on many other chips you’ll find multiple decoupling capacitors
    or you’ll find that the cap is on a dedicated pin at a lower voltage, the CPU
    core voltage.
  prefs: []
  type: TYPE_NORMAL
- en: The board also has two traces that might be cut, and we need to cut both of
    them. `3.3V_IO_E` connects C1 and the VDDIO pin to the 3.3V power rail, while
    `3.3V_CORE` connects the VDD pin to the 3.3V rail. We’ll cut both, then reconnect
    the two sides of the cut `3.3V_CORE` trace with a 12 Ω resistor. This lets us
    measure the power consumption of the chip, as the current consumption will cause
    a very small voltage drop across the resistor. Such a measurement is not necessary
    to perform the glitch after timing is known but can be very handy for discovering
    the timing.
  prefs: []
  type: TYPE_NORMAL
- en: Shorting `P0_3` to ground will enable the bootloader mode. We will also add
    an SMA connector to expose ground and the 3.3V power rail to our voltage glitcher.
    The glitching hardware itself is just briefly shorting those two pins together,
    and while Dewar (2018) uses a ChipWhisperer and Gerlinsky (2017) uses a microcontroller
    board, you can short them with a transistor and nearly anything that sends a short
    pulse to that transistor with predictable timing after reset.
  prefs: []
  type: TYPE_NORMAL
- en: '**How Hard to Glitch?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now have an SMA connector through which we can glitch the chip, briefly shorting
    the voltage rail to ground without a decoupling capacitor to save it. Before we
    can get to the question of timing, we need to know at least roughly how much of
    a glitch to apply. Too much of a glitch will crash or reboot the target, while
    too little of a glitch will have no effect at all, as the voltage drop will be
    attenuated by the natural capacitance and line length until nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we imagine the idle state of this pin as a flat 3.3V voltage that we’ll
    drop low, there are two basic parameters to our glitch: the *depth* and the *duration*.'
  prefs: []
  type: TYPE_NORMAL
- en: The depth of a glitch is the voltage to which we will drop the pin. It’s usually
    measured from the side of the glitcher, with the understanding that the target
    won’t fall immediately to that voltage and might not fall all the way to it. A
    “crowbar” glitcher, such as the ChipWhisperer, simply shorts the two rails together
    with a MOSFET, so its depth is effectively ground.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll generally find crowbar glitchers on more recent devices, because the
    clock rate allows them to run fast enough that the glitch won’t crash the target.
    They are also quite simple to place on the circuit board, with nothing more than
    a MOSFET transistor controlled by a GPIO pin of the attacking microcontroller.
    Common choices of MOSFET include the IRLML6246 and IRF8736.
  prefs: []
  type: TYPE_NORMAL
- en: Back in the days of TV piracy, it was more common to use a 74HC4053 multiplexer
    to jump between full voltage and the deep voltage. During development, both could
    be supplied by a bench power supply, and the glitches would be a little wider
    but not quite so deep.
  prefs: []
  type: TYPE_NORMAL
- en: Having either one dimension (duration) or two (duration and depth) to calibrate,
    we’d much rather find the right values before involving the extra dimension of
    time. This is most conveniently done by running a program from flash or from RAM
    that is intentionally designed to be an easy target.
  prefs: []
  type: TYPE_NORMAL
- en: When the settings are roughly correct, this code will start printing to the
    serial port. It’s important the three variables are all volatile so that the C
    compiler will not optimize away their differences.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0148-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, we can only train our parameters on this code because the chip we
    are attacking is also available as an unlocked part for commercial use. When glitching
    a smart card, or anything else in which an unlocked sample is not available, the
    procedure is usually to glitch some other behavior, like the readout of the device
    serial number.
  prefs: []
  type: TYPE_NORMAL
- en: '**When to Glitch?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we know how wide (in duration) and how deep (in voltage) to glitch
    to cause a fault, we still need to know when to trigger the glitch. We’ll first
    choose a trigger as the beginning of time, then choose a measure of time to count
    after that trigger, and finally search for a range of times that might be running
    a vulnerable instruction worth glitching.
  prefs: []
  type: TYPE_NORMAL
- en: This is usually measured as some number of microseconds or clock cycles after
    a particular event, such as the reset line rising high. It’s important to distinguish
    between the target’s clock signal, which will be rather tightly coupled to the
    internal CPU clock, and the attacker’s clock signal, which is rather loosely coupled
    and really just another way to measure wall clock time.
  prefs: []
  type: TYPE_NORMAL
- en: The target’s clock input pin used to be a very good way to accurately target
    specific instructions, but these days many chips like the LPC11 default to an
    internal oscillator as the bootloader’s system clock, only jumping over to an
    external crystal in the main application. Other chips use an internal phase-locked
    loop (PLL) to multiply an external clock’s frequency, providing some relation
    but at a weak resolution. In this chapter, we’ll ignore the external oscillator
    and use wall time instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have chosen a measure of time, and we have chosen the rise of the
    reset pin as zero time, we need to know when to apply a glitch to unlock the bootloader.
    On other targets, we might do this through power analysis, running our SMA connector
    to a T-junction that reaches both the glitcher and an oscilloscope. On this target
    we have something better: a dump of the boot ROM, which we made for writing our
    shellcode in [Chapter 4](ch04.xhtml#ch04).'
  prefs: []
  type: TYPE_NORMAL
- en: Recall from that chapter that the bootloader checks its lock state many times,
    but that it is always checking a copy in SRAM that is made early in the boot sequence.
    That’s why the shell-code for the software exploit simply rewrites the SRAM copy
    of the CRP level and jumps right back into the main loop of the bootloader, reusing
    its code with a privilege escalation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0149-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this glitching attack we don’t have a write primitive, of course, but we
    know that there is an instruction or two doing the copy. Maybe we flip a bit as
    it’s read from flash memory, or maybe we flip a bit as it’s written to SRAM, or
    maybe we flip an opcode bit to make it a different instruction.
  prefs: []
  type: TYPE_NORMAL
- en: On 8-bit CISC chips, we might come up with this by simply counting instructions
    and their cycle costs. As the LPC11 is a pipelined RISC chip, that becomes a little
    labor intensive, as any glitch will be impacting multiple instructions at once.
    Another option for some ARM chips is to use the Embedded Trace Macrocell (ETM),
    which allows an external debugger to trace every instruction as it’s executed.
    We might also run a modified version of the boot ROM from RAM, patched to reveal
    its timing through a GPIO pin.
  prefs: []
  type: TYPE_NORMAL
- en: Without resorting to those fancy tricks, we still have some timing clues. We
    know that the ROM can’t begin execution before the reset line goes high, and we
    know that it must be past the target instruction when it accepts our first command.
    If we’re patient, we can sweep across this entire range until the chip unlocks,
    then repeat the effect in far less time knowing the offset.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not uncommon for chips to be exploited this way, with a glitcher sitting
    on a rack or in a closet for days or weeks before the right timing emerges.
  prefs: []
  type: TYPE_NORMAL
- en: Dewar (2018) suggests that attacking from a 100MHz clock, unlocks were seen
    with roughly ten glitches between 5,100 and 5,300 cycles. One board worked best
    with ten pulses at 5,211 ticks, while another worked best with eleven pulses at
    5,181 ticks. The variance likely comes from the internal R/C oscillator of the
    target chip, or the room temperature, and it’s not at all strange for different
    targets to successfully unlock at different times.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0151-01.jpg)![Image](../images/f0152-01.jpg)![Image](../images/f0153-01.jpg)![Image](../images/f0154-01.jpg)![Image](../images/f0155-01.jpg)'
  prefs: []
  type: TYPE_IMG
