- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 12 VALIDATING FORM DATA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Not all data received through web forms will be valid; users may make mistakes
    or miss required values, or a number of other things could go wrong. In this chapter,
    we’ll explore ways to validate the received data, and we’ll design some typical
    decision logic to take appropriate action depending on the values received (and
    any that are missing).
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to recognize that HTML forms submit values only as text strings,
    regardless of the input type. One of the very reasons PHP isn’t type-sensitive
    is to make it easy to treat a string containing digits as a number without explicitly
    type-casting or including data-type conversion statements. This makes it that
    much more important to carefully write (and test) the validation rules for processing
    received form data.
  prefs: []
  type: TYPE_NORMAL
- en: '### Writing Custom Validation Logic'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 11](chapter11.xhtml), you learned to use simple built-in filters
    such as FILTER _SANITIZE_SPECIAL_CHARS in conjunction with filter_input() to sanitize
    incoming form data. However, real-world data often has its own special validation
    criteria that goes beyond these built-in filters. Once you’ve retrieved data from
    the submitted form request, you may therefore need to write custom validation
    logic to make sure the data is as it should be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s illustrate how this works with a simple example: a product details form
    asking the user to enter a product code and a price (see [Figure 12-1](#fig12-1)).
    We’ll assume that the product code must have a minimum of three characters and
    that the price must be a number (either an integer or a decimal value).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure12-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-1: A product details form in need of validation logic'
  prefs: []
  type: TYPE_NORMAL
- en: As we explored in [Chapter 11](chapter11.xhtml), we can write a simple script
    confirming receipt of the form data with a few lines of PHP. [Listing 12-1](#lis12-1)
    shows how.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-1: Confirming the received product code and price'
  prefs: []
  type: TYPE_NORMAL
- en: Here we use the filter_input() function to extract the productCode and price
    variables from the received URL-encoded form data and display them back to the
    user by using PHP short echo tags. This will work if the user has submitted values
    as expected, but it’s never a good idea to assume the data that has arrived from
    the user is all present and correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should expand the script to validate the data before confirming it to the
    user. We’ll try to validate the price and product code data in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: If the product code is missing or empty, display the error message missing product
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the product code is less than three characters in length, display the error
    message product code too few characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the price isn’t a numeric value, display the error message price was not
    a number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no validation errors occur, display the message input data was error free.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you’ll see, PHP has built-in functions to help with these sorts of validation
    checks.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Multiple Validation Errors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One common approach to managing custom validation logic with multiple potential
    errors is to use an array for the errors. Start with an empty array, then use
    a series of if...else statements to add an error message to the array each time
    a new validation error is detected. If the array is empty after all the validation,
    it means the data was found to be error free. If it isn’t empty, you can loop
    through the array to display all the error messages to the user. [Listing 12-2](#lis12-2)
    uses this approach to implement the validation logic for our product details form.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-2: Implementing custom validation logic with an array of error messages'
  prefs: []
  type: TYPE_NORMAL
- en: After extracting the product code and price from the incoming form data as before,
    we create an empty array in the $errors variable ❶. Then we use an if...elseif
    structure ❷ to validate the $productCode variable. The if branch adds the message
    'missing product code' to the $errors array if $productCode is empty. (The empty()
    function will return true if $productCode wasn’t found in the received form data
    or if it contained an empty string.) The elseif branch, which is visited only
    if $productCode isn’t empty, adds the message 'product code too few characters'
    to the array if the strlen() function finds the product code to contain fewer
    than three characters.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use a separate if statement to validate the $price variable ❸. We pass
    the variable to is_numeric(), which returns true if the received string can be
    interpreted as an integer or a float. If not, we add the message 'price was not
    a number' to the array.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we test whether the $errors array contains any errors ❹. If it does,
    we use a foreach loop to display each error to the user as an item in an HTML
    ordered list. Otherwise, if the array is empty, we display the message 'input
    data was error free'.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example has illustrated a range of typical validations. You’ll often find
    yourself checking for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Any required data that’s missing**   You can test for this with the empty()
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Too few characters for text data**   You might need to ensure that the input
    meets minimum-length rules for usernames or passwords, for example. You can test
    for this with the strlen() function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Non-numeric values**   You might want to know if the value received is neither
    a valid integer nor a decimal number. You can test for this with the is_numeric()
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: While we were able to rely on built-in PHP functions for our validation checks,
    we needed custom logic to string them together and match them to the particular
    requirements of our product details form.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for a Valid Zero Value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Because of PHP’s type insensitivity, it’s easy to write code that incorrectly
    treats a numeric value of 0 as missing or false. This happens because in PHP all
    the following (among other values) are considered false:'
  prefs: []
  type: TYPE_NORMAL
- en: The Boolean false itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The integers 0 and -0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The floats 0.0 and -0.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The empty string and the string "0"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The special NULL type (including unset variables)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To illustrate the problem, say you want to test whether the user left a form
    field blank. You’d typically use the empty() function, but if the user happened
    to enter the digit 0 in the form field, the test empty('0') will return true,
    just like the test empty('') for a truly empty form field (remember that all form
    values arrive as strings in the HTTP request, even if they are numeric characters).
    If you want the 0 to be a valid entry for the field (for example, if the field
    is to record someone’s score on a test), you’ll need to write code that distinguishes
    between a valid 0 entry and an unacceptable empty string. The solution is to use
    the triple-equal-sign identical operator (===), which tests whether its operands
    have the same value *and* data type, as discussed in [Chapter 2](chapter2.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The PHP documentation describes type comparisons at* [https://www.php.net/manual/en/types.comparisons.php](https://www.php.net/manual/en/types.comparisons.php)*,
    comparing the results of the* == *and* === *operators, as well as showing the
    results for functions such as* gettype()*,* empty()*, and* isset() *for potentially
    confusing values. I recommend you bookmark this page for reference.*'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 12-3 assumes a form has been submitted with the GET method sending a
    variable named score. The code uses an if...elseif statement to differentiate
    between no value and a 0 value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-3: Distinguishing between the number 0 and an empty or NULL value'
  prefs: []
  type: TYPE_NORMAL
- en: We first use the === operator to test whether $score holds the exact string
    '0'. If not, we use the empty() function to check whether an empty string was
    received.
  prefs: []
  type: TYPE_NORMAL
- en: If testing for a valid 0 is a task you’ll need to perform often, it would be
    useful to encapsulate the necessary logic in a function that returns false when
    given the string '0' or the result of the empty() function otherwise, as shown
    in [Listing 12-4](#lis12-4). Create a *zeroFunction.php* file containing this
    code, since we’ll make use of it later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-4: A function that tests for an empty string but does not consider
    the digit 0 as empty'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that if a numeric value of 0 is an acceptable form input, you may
    need to do more than simply compare the incoming string with the string literal
    '0'. This is because other strings may also evaluate to 0, such as '0.0', '0.00',
    and so on. To be thorough, you need to test the underlying numeric value that
    the incoming string represents. Fortunately, PHP provides the intval() function,
    which can take in a string and return the numeric integer value of its contents.
    Normal PHP type juggling will take place, and so any valid numeric characters
    at the beginning of the string will be used to determine the string’s integer
    value. As discussed in [Chapter 2](chapter2.xhtml), any non-numeric content in
    a string is ignored during type juggling.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 12-1](#tab12-1) lists examples of strings and their intval() evaluations.
    Notice that the non-numeric remainders of strings are simply ignored (such as
    ''5abc'' evaluating to 5), as are any decimal components of numeric strings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 12-1: Example intval() Calls'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function call | Return value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| intval(''0'') | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| intval(''00'') | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| intval(''0.00'') | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| intval(''0.99'') | 0 (decimal component ignored) |'
  prefs: []
  type: TYPE_TB
- en: '| intval(''0005'') | 5 (leading zeros ignored) |'
  prefs: []
  type: TYPE_TB
- en: '| intval(''5abc'') | 5 (everything from ''a'' on ignored) |'
  prefs: []
  type: TYPE_TB
- en: At the end of the day, validation should match whatever data the form owner
    specifies is acceptable. It is, of course, always a good idea to offer the user
    a confirmation screen with a chance to correct values after any validation and
    string-to-number evaluation, to make sure the form’s validation logic matches
    the user’s intent.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying and Validating Forms in a Single Postback Script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A frequently used strategy for validating web forms is to use a single script,
    known as a *postback*, both to display the form and to perform validation. Combining
    these two actions ensures that the form can be redisplayed to the user in the
    event of any validation errors, with the added validation error messages included.
    A postback also makes it easy to implement a *sticky form*, a form that’s redisplayed
    with the previously submitted values prepopulated in the appropriate fields, saving
    the user from having to enter the data again. (The term *sticky* refers to the
    values remaining, or sticking, in the form after submission.)
  prefs: []
  type: TYPE_NORMAL
- en: Using a single script to both display and validate has two drawbacks. First,
    the script can get very long, especially for complex forms with lots of validation
    logic. Second, the complexity of a script performing multiple tasks is high, making
    the code potentially harder to understand, more error-prone, and harder to update
    or maintain at a later date. In [Chapter 13](chapter13.xhtml), we’ll address these
    disadvantages as we look at strategies to separate logic from display code.
  prefs: []
  type: TYPE_NORMAL
- en: For now, though, we’ll focus on creating single scripts for sticky postback
    forms. We’ll start with a form that requires only simple validation logic, and
    then we’ll revisit the array-based approach to handling multiple validation errors
    discussed earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Simple Validation Logic'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a simple postback script for a sticky form where the user enters
    their name and receives a *Hello <name>* greeting in response. We’ll arbitrarily
    say that the submitted name must have at least three characters to be valid. Our
    postback script needs to handle three possible situations that can occur after
    the server receives a new HTTP request. The first situation is the initial form
    request (via the GET HTTP method), when an empty text box and Submit button are
    presented to the user, as in [Figure 12-2](#fig12-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure12-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-2: The first presentation of the sticky postback form'
  prefs: []
  type: TYPE_NORMAL
- en: The second situation is a form submission with invalid data (via the POST HTTP
    method). In this case, the form should be redisplayed to the user with an error
    message about the invalid submission. Since the form is sticky, the text box should
    be populated with whatever text the user submitted last, as shown in [Figure 12-3](#fig12-3).
    In this example, a single letter a was submitted.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure12-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-3: Redisplaying the sticky postback form with a message about the
    invalid data'
  prefs: []
  type: TYPE_NORMAL
- en: The third and final situation is a form submission with valid data (via the
    POST HTTP method). In this case, a confirmation message should be displayed to
    the user, as shown in [Figure 12-4](#fig12-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure12-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-4: Displaying a confirmation message after valid data is submitted'
  prefs: []
  type: TYPE_NORMAL
- en: The logic for our postback PHP script can be visualized as a flow chart with
    two decisions ([Figure 12-5](#fig12-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure12-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-5: A decision flowchart for the postback sticky form'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll write the postback script in a *public/index.php* file in four stages:
    setting default values, validating the submitted data, displaying a confirmation
    for valid data, and displaying the form.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting Default Values
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: First, we need to set default values for the two key postback variables $isSubmitted
    and $isValid. The first of these Boolean flags records whether the form has been
    submitted, as determined by whether the incoming request uses the POST method
    (indicating a form submission) or the GET method (indicating the initial request
    for the form). The second flag signals whether the data received is valid. A third
    variable will set the default value of the $firstName variable for our logic.
    [Listing 12-5](#lis12-5) shows the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-5: Setting default values'
  prefs: []
  type: TYPE_NORMAL
- en: We set the $isSubmitted Boolean flag to true or false depending on the value
    of the 'REQUEST_METHOD' key in the $_SERVER array. This superglobal array holds
    information from the web server about the current executing script, the request
    being processed, and the like. If the value is the string 'POST', then $isSubmitted
    will be true; otherwise, it will be false.
  prefs: []
  type: TYPE_NORMAL
- en: We next set the $isValid Boolean flag to true by default; we’re therefore assuming
    the received data is valid unless later logic determines otherwise. Finally, we
    set $firstName to an empty string to ensure that, whatever happens, we have a
    value for this variable that can be inserted into the form text box when the form
    is presented to the user.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Learn more about the* $_SERVER *array in the PHP documentation at* [https://www.php.net/manual/en/reserved.variables.server.php](https://www.php.net/manual/en/reserved.variables.server.php)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: Validating the Submitted Data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The second block of code in our postback script, shown in [Listing 12-6](#lis12-6),
    attempts to validate the submitted form data after the form has been successfully
    submitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-6: Validating the number of characters in $firstName'
  prefs: []
  type: TYPE_NORMAL
- en: We perform the validation inside an if statement whose body will execute only
    if the $isSubmitted Boolean flag is true. Therefore, we’ll skip this code when
    the form is requested for the first time. To validate the data, we use filter_input()
    to retrieve the value of firstName from the submitted POST variables, overwriting
    the default, empty-string value of $firstName in the process ❶. Then we use strlen()
    to check whether the received string contains less than three characters ❷. If
    so, we change the $isValid Boolean flag to false and assign an error message to
    the $errorMessage variable.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a Confirmation for Valid Data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At this point, we have values in the $isSubmitted and $isValid flags that we
    can use to decide what to present to the user. Our third block of code, shown
    in [Listing 12-7](#lis12-7), uses these flags in a single if statement for the
    situation in which the form has been submitted with valid data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-7: Responding to valid data'
  prefs: []
  type: TYPE_NORMAL
- en: If both flags are true, we display a "Hello $firstName" confirmation message
    to the user. Then we terminate the script with the die() function.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the Form
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If the if statement in [Listing 12-7](#lis12-7) fails, either the form is being
    requested for the first time ($isSubmitted is false) or the submitted data is
    invalid ($isValid is false). In either case, the result is the same: we need to
    display the form to the user. [Listing 12-8](#lis12-8) shows the necessary mix
    of HTML and PHP code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-8: Displaying the form to the user'
  prefs: []
  type: TYPE_NORMAL
- en: In the HTML head, we define a CSS error class for any error message we need
    to display, with a pink background and some padding ❶. In the page’s body, we
    declare a <form> element with the POST method ❷. Notice that we don’t include
    an action attribute setting the PHP script that will process the form; when no
    action is specified, the form submission request is sent by default to the same
    URL that displayed the form. This default is perfect for a postback form like
    this one.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In HTML 4, a form had to specify an* action *attribute, but in HTML 5, the
    attribute defaults to an empty string, which results in the form submitting to
    the same URL as led to the form’s display.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the <form> element, we use PHP’s alternative if statement syntax to
    display a <div> element with the content of the $errorMessage variable if the
    form is submitted but the data isn’t valid ❸. We style the <div> with our error
    CSS class. We then display the form text input box and set its value attribute
    to the contents of the PHP $firstName variable ❹. If the form is being displayed
    for the first time, this will be the default empty string we declared in [Listing
    12-5](#lis12-5), but if the form is being redisplayed after an invalid input,
    $firstName will hold the user’s previous submission. This mechanism is what makes
    the form sticky: the submitted value sticks in the text box when submitted and
    redisplayed, saving the user from typing values again.  #### Array-Based Validation
    Logic'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now join the two key concepts from this chapter and implement our earlier
    product details form with its array-based approach to error messages as a postback
    sticky form. [Figure 12-6](#fig12-6) shows an example of the error messages to
    be output when the submitted data is missing values or violates any validation
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure12-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-6: The sticky postback product form with errors'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even with an array-based approach to data validation, our postback script will
    follow the same basic steps as before: setting default values, validating the
    data, displaying a confirmation for valid input, and displaying the form. [Listing
    12-9](#lis12-9) tackles the first step.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-9: Setting default values'
  prefs: []
  type: TYPE_NORMAL
- en: As before, we set the $isSubmitted Boolean flag to true or false depending on
    whether $_SERVER['REQUEST_METHOD'] contains 'POST'. We then set the $productCode
    and $price variables to empty strings to ensure that we can refer to them safely
    for default values in the form inputs. Finally, we set $errors to an empty array.
    We’ll add to this array only if any validation errors are found; an empty array
    will indicate that the data is valid.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 12-10 attempts to validate the submitted form data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-10: Validating the submitted form data'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, all our validation occurs inside an if statement executed only if
    the $isSubmitted flag is true. We first retrieve the productCode and price values
    from the submitted POST variables. Then we test whether $productCode is empty
    ❶ and add an error message to the $errors array if it is. Otherwise, we test whether
    $productCode is less than three characters long ❷, again adding an error message
    to the array if not. For our last validation check, we add another error message
    if $price is empty or isn’t numeric ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Next, [Listing 12-11](#lis12-11) shows the code to confirm a valid form submission.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-11: Confirming a valid submission'
  prefs: []
  type: TYPE_NORMAL
- en: First, we test whether the $errors array is empty and set the $isValid Boolean
    flag accordingly. Then, if both the $isSubmitted and $isValid Boolean flags are
    true, we display a confirmation message to the user and terminate the script with
    the die() function. If either flag is false, we need to display the form to the
    user, with any errors if appropriate. [Listing 12-12](#lis12-12) shows the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-12: Displaying the form with any error messages'
  prefs: []
  type: TYPE_NORMAL
- en: Initially, this code is similar to our earlier sticky form template from [Listing
    12-8](#lis12-8), up to the if statement checking whether the form was submitted
    but the data isn’t valid ❶. From there, we use a PHP foreach loop ❷ to print each
    message in the $errors array as a separate list item inside the <div> styled with
    our error CSS class. Later, we make the <form> element sticky by prefilling the
    product code and price fields with the values from the $productCode ❸ and $price
    ❹ variables, which will be either the user’s previous submissions or the default
    empty strings.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the same basic structure that worked for our simpler form also
    worked for this more complex postback sticky form script, and the strategy of
    building up and displaying an array of error messages fits well into this structure.
    However, the complete PHP postback script is nearly 60 lines long and performs
    enough actions as to make the single script complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we’ll explore strategies to keep the benefits of the postback
    approach for form processing (such as displaying validation messages with the
    form and using sticky form values to save the user from retyping) while breaking
    up the tasks of form display, validation, error message display, and confirmation
    logic into simpler scripts. In the process, we’ll develop a basic web application
    architecture that can scale up to meet the requirements of complex websites, forms,
    and validation rules.  ### Summary'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered strategies for validating submitted form data, including
    using an array to flexibly handle situations where zero, one, or several validation
    errors must be addressed. We highlighted the special care that must be taken when
    a 0 is submitted as a valid entry in a form. Finally, we looked at the postback
    technique for displaying and validating forms with a single script, and we implemented
    sticky forms that conveniently prefill with the user’s previous entries. As a
    PHP programmer, you may have to understand and maintain a range of website programming
    styles, and the postback approach in this chapter is a common one you’ll likely
    come across in other programmers’ code, even if it’s not an approach you use often
    when writing your own.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Create a sticky form using the HTTP POST method that prompts for an integer
    age and redisplays the form populated with the submitted value each time.
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Improve your answer to Exercise 1 so that an error message is displayed
    if a non-numeric age is entered.
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Improve your answer to Exercise 2 so that after a valid (numeric) submission
    is received, a confirmation message displays, stating the user’s age after their
    next birthday.
  prefs: []
  type: TYPE_NORMAL
- en: 4.   Create a sticky form using the HTTP POST method that prompts for an email
    address. If the address is valid, a confirmation message is displayed; if it’s
    not valid, the form is redisplayed with an error message stating that the email
    address is invalid. Think about the requirements for a valid email address.
  prefs: []
  type: TYPE_NORMAL
