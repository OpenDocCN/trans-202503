<html><head></head><body>
<h2 class="h2" id="ch06"><span epub:type="pagebreak" id="page_49"/><strong><span class="big">6</span><br/>CARRIAGE RETURN LINE FEED INJECTION</strong></h2>&#13;
<div class="image1"><img alt="Image" src="../images/common.jpg"/></div>&#13;
<p class="noindent">Some vulnerabilities allow users to input encoded characters that have special meanings in HTML and HTTP responses. Normally, applications sanitize these characters when they are included in user input to prevent attackers from maliciously manipulating HTTP messages, but in some cases, applications either forget to sanitize input or fail to do so properly. When this happens, servers, proxies, and browsers may interpret the special characters as code and alter the original HTTP message, allowing attackers to manipulate an application’s behavior.</p>&#13;
<p class="indent">Two examples of encoded characters are <span class="literal">%0D</span> and <span class="literal">%0A</span>, which represent <span class="literal">\n</span> (a carriage return) and <span class="literal">\r</span> (a line feed). These encoded characters are commonly referred to as <em>carriage return line feeds (CRLFs)</em>. Servers and browsers rely on CRLF characters to identify sections of HTTP messages, such as headers.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_50"/>A <em>carriage return line feed injection (CRLF injection)</em> vulnerability occurs when an application doesn’t sanitize user input or does so improperly. If attackers can inject CRLF characters into HTTP messages, they can achieve the two types of attacks we’ll discuss in this chapter: HTTP request smuggling and HTTP response splitting attacks. Additionally, you can usually chain a CRLF injection with another vulnerability to demonstrate a greater impact in a bug report, as I’ll demonstrate later in the chapter. For the purpose of this book, we’ll only provide examples of how to exploit a CRLF injection to achieve HTTP request smuggling.</p>&#13;
<h3 class="h3" id="ch06lev1sec1"><strong>HTTP Request Smuggling</strong></h3>&#13;
<p class="noindent"><em>HTTP request smuggling</em> occurs when an attacker exploits a CRLF injection vulnerability to append a second HTTP request to the initial, legitimate request. Because the application does not anticipate the injected CRLF, it initially treats the two requests as a single request. The request is passed through the receiving server (typically a proxy or firewall), processed, and then sent on to another server, such as an application server that performs the actions on behalf of the site. This type of vulnerability can result in cache poisoning, firewall evasion, request hijacking, or HTTP response splitting.</p>&#13;
<p class="indent">In <em>cache poisoning</em>, an attacker can change entries in an application’s cache and serve malicious pages instead of a proper page. <em>Firewall evasion</em> occurs when a request is crafted using CRLFs to avoid security checks. In a <em>request-hijacking</em> situation, an attacker can steal <span class="literal">httponly</span> cookies and HTTP authentication information with no interaction between the attacker and client. These attacks work because servers interpret CRLF characters as indicators of where HTTP headers start, so if they see another header, they interpret it as the start of a new HTTP request.</p>&#13;
<p class="indent"><em>HTTP response splitting</em>, which we’ll focus on in the rest of this chapter, allows an attacker to split a single HTTP response by injecting new headers that browsers interpret. An attacker can exploit a split HTTP response using one of two methods depending on the nature of the vulnerability. Using the first method, an attacker uses CRLF characters to complete the initial server response and insert additional headers to generate a new HTTP response. However, sometimes an attacker can only modify a response and not inject a completely new HTTP response. For example, they can only inject a limited number of characters. This leads to the second method of exploiting response splitting, inserting new HTTP response headers, such as a <span class="literal">Location</span> header. Injecting a <span class="literal">Location</span> header would allow an attacker to chain the CRLF vulnerability with a redirect, sending a target to a malicious website, or cross-site scripting (XSS), an attack we’ll cover in <a href="ch07.xhtml#ch07">Chapter 7</a>.</p>&#13;
<h3 class="h3" id="ch06lev1sec2"><span epub:type="pagebreak" id="page_51"/><strong>v.shopify.com Response Splitting</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Medium</p>&#13;
<p class="hang"><strong>URL:</strong> <em>v.shopify.com/last_shop?&lt;YOURSITE&gt;.myshopify.com</em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://hackerone.com/reports/106427/">https://hackerone.com/reports/106427/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> December 22, 2015</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $500</p>&#13;
<p class="noindent">In December 2015, HackerOne user krankopwnz reported that Shopify wasn’t validating the shop parameter passed into the URL <em>v.shopify.com/last_shop?&lt;YOURSITE&gt;.myshopify.com</em>. Shopify sent a <span class="literal">GET</span> request to this URL in order to set a cookie that recorded the last store a user had logged in to. As a result, an attacker could include the CRLF characters <span class="literal">%0d%0a</span> (capitalization doesn’t matter to encoding) in the URL as part of the <span class="literal">last_shop</span> parameter. When these characters were submitted, Shopify would use the full <span class="literal">last_shop</span> parameter to generate new headers in the HTTP response. Here is the malicious code krankopwnz injected as part of a shop name to test whether this exploit would work:</p>&#13;
<p class="programs">%0d%0aContent-Length:%200%0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20<br/>&#13;
text/html%0d%0aContent-Length:%2019%0d%0a%0d%0a&lt;html&gt;deface&lt;/html&gt;</p>&#13;
<p class="indent">Because Shopify used the unsanitized <span class="literal">last_shop</span> parameter to set a cookie in the HTTP response, the response included content that the browser interpreted as two responses. The <span class="literal">%20</span> characters represent encoded spaces, which are decoded when the response is received.</p>&#13;
<p class="indent">The response received by the browser was decoded to:</p>&#13;
<p class="programs"><span class="ent">➊</span> Content-Length: 0<br/>&#13;
   HTTP/1.1 200 OK<br/>&#13;
   Content-Type: text/html<br/>&#13;
   Content-Length: 19<br/>&#13;
<span class="ent">➋</span> &lt;html&gt;deface&lt;/html&gt;</p>&#13;
<p class="indent">The first part of the response would appear after the original HTTP headers. The content length of the original response is declared as <span class="literal">0</span> <span class="ent">➊</span>, which tells the browser no content is in the response body. Next, a CRLF starts a new line and new headers. The text sets up the new header information to tell the browser there is a second response that is HTML and that its length is <span class="literal">19</span>. Then the header information gives the browser HTML to render at <span class="ent">➋</span>. When a malicious attacker uses the injected HTTP header, a variety of vulnerabilities are possible; these include XSS, which we will cover in <a href="ch07.xhtml#ch07">Chapter 7</a>.</p>&#13;
<h4 class="h4" id="ch06lev2sec1"><span epub:type="pagebreak" id="page_52"/><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">Be on the lookout for opportunities where a site accepts input that it uses as part of its return headers, particularly when it’s setting cookies. If you see this behavior on a site, try submitting <span class="literal">%0D%0A</span> (or just <span class="literal">%0A%20</span> in Internet Explorer) to check whether the site is properly protecting against CRLF injections. If it isn’t, test to see whether you’re able to add new headers or an entire additional HTTP response. This vulnerability is best exploited when it occurs with little user interaction, such as in a <span class="literal">GET</span> request.</p>&#13;
<h3 class="h3" id="ch06lev1sec3"><strong>Twitter HTTP Response Splitting</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> High</p>&#13;
<p class="hang"><strong>URL:</strong> <em>https://twitter.com/i/safety/report_story/</em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://hackerone.com/reports/52042/">https://hackerone.com/reports/52042/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> March 15, 2015</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $3,500</p>&#13;
<p class="noindent">When you’re looking for vulnerabilities, remember to think outside the box and submit encoded values to see how a site handles the input. In some cases, sites will protect against CRLF injection by using a blacklist. In other words, the site will check for any blacklisted characters in inputs, then respond accordingly by removing those characters or not allowing the HTTP request to be made. However, an attacker can sometimes circumvent a blacklist by using character encoding.</p>&#13;
<p class="indent">In March 2015, FileDescriptor manipulated how Twitter handled character encoding to find a vulnerability that allowed him to set a cookie through an HTTP request.</p>&#13;
<p class="indent">The HTTP request that FileDescriptor tested included a <span class="literal">reported_tweet_id</span> parameter when sent to <em>https://twitter.com/i/safety/report_story/</em> (a Twitter relic that allowed users to report inappropriate ads). When responding, Twitter would also return a cookie that included the parameter submitted with the HTTP request. During his tests, FileDescriptor noted that the CR and LF characters were blacklisted and sanitized. Twitter would replace any LFs with a space and send back an HTTP 400 (Bad Request Error) when it received any CRs, thus protecting against CRLF injections. But FileDescriptor knew of a Firefox bug that incorrectly decoded cookies and potentially could allow users to inject malicious payloads to a website. The knowledge of this bug led him to test whether a similar bug could exist on Twitter.</p>&#13;
<p class="indent">In the Firefox bug, Firefox would strip any Unicode characters in cookies outside of the ASCII character range. However, Unicode characters can consist of multiple bytes. If certain bytes in a multibyte character were stripped, the remaining bytes could result in malicious characters being rendered on a web page.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_53"/>Inspired by the Firefox bug, FileDescriptor tested whether an attacker could sneak a malicious character through Twitter’s blacklist using the same multibyte character technique. So FileDescriptor found a Unicode character whose encoding ended with <span class="literal">%0A</span> (a LF) but whose other bytes were not included in the HTTP character set. He used the Unicode character <img alt="Image" class="middle" src="../images/f0053-01.jpg"/>, which is hex encoded as U+560A (<span class="literal">56 0A</span>). But when this character is used in a URL, it is URL encoded with UTF-8 as <span class="literal">%E5%98%8A</span>. These three bytes, <span class="literal">%E3</span>, <span class="literal">%98</span>, <span class="literal">%8A</span>, circumvented Twitter’s blacklist because they are not malicious characters.</p>&#13;
<p class="indent">When FileDescriptor submitted this value, he found that Twitter wouldn’t sanitize the URL-encoded character but would still decode the UTF-8 <span class="literal">%E5%98%8A</span> value back to its Unicode value <span class="literal">56 0A</span>. Twitter would drop the <span class="literal">56</span> as an invalid character, leaving the line feed characters <span class="literal">0A</span> untouched. In addition, he found that the character <img alt="Image" class="middle" src="../images/f0053-02.jpg"/> (which is encoded to <span class="literal">56 0D</span>) could be used to insert the necessary carriage return (<span class="literal">%0D</span>) into the HTTP response as well.</p>&#13;
<p class="indent">Once he confirmed that the method worked, FileDescriptor passed the value <span class="literal">%E5%98%8A%E5%98%8DSet-Cookie:%20test</span> into Twitter’s URL parameter. Twitter would decode the characters, strip the out-of-range characters, and leave <span class="literal">%0A</span> and <span class="literal">%0D</span> in the HTTP request, resulting in the value <span class="literal">%0A%0DSet-Cookie:%20test</span>. The CRLF would split the HTTP response into two so the second response would consist of just the <span class="literal">Set-Cookie: test</span> value, which is the HTTP header used to set cookies.</p>&#13;
<p class="indent">CRLF attacks can be even more dangerous when they allow for XSS attacks. While the details of exploiting XSS aren’t important for this example, it should be noted that FileDescriptor went further with this proof of concept. He demonstrated to Twitter how this CRLF vulnerability could be exploited to execute malicious JavaScript with the following URL:</p>&#13;
<p class="programs">https://twitter.com/login?redirect_after_login=https://twitter.com:21/%E5<br/>&#13;
%98%8A%E5%98%8Dcontent-type:text/html%E5%98%8A%E5%98%8Dlocation:%E5%98%8A%E5<br/>&#13;
%98%8D%E5%98%8A%E5%98%8D%E5%98%BCsvg/onload=alert%28innerHTML%29%E5%98%BE</p>&#13;
<p class="indent">The important details are the 3-byte values peppered throughout: <span class="literal">%E5%98%8A</span>, <span class="literal">%E5%98%8D</span>, <span class="literal">%E5%98%BC</span>, and <span class="literal">%E5%98%BE</span>. After character stripping, these values are decoded to <span class="literal">%0A</span>, <span class="literal">%0D</span>, <span class="literal">%3C</span>, and <span class="literal">%3E</span>, respectively, all of which are HTML special characters. The byte <span class="literal">%3C</span> is the left angle bracket (<span class="literal">&lt;</span>), and <span class="literal">%3E</span> is the right angle bracket (<span class="literal">&gt;</span>).</p>&#13;
<p class="indent">The other characters in the URL are included in the HTTP response as written. Therefore, when the encoded byte characters are decoded with line breaks, the header looks like this:</p>&#13;
<p class="programs">https://twitter.com/login?redirect_after_login=https://twitter.com:21/<br/>&#13;
content-type:text/html<br/>&#13;
location:<br/>&#13;
&lt;svg/onload=alert(innerHTML)&gt;</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_54"/>The payload is decoded to inject the header <span class="literal">content-type text/html</span>, which tells the browser the response will contain HTML. The <span class="literal">Location</span> header uses a <span class="literal">&lt;svg&gt;</span> tag to execute the JavaScript code <span class="literal">alert(innerHTML)</span>. The alert creates an alert box that contains the contents of the web page using the DOM <span class="literal">innerHTML</span> property (the <span class="literal">innerHTML</span> property returns the HTML of a given element). In this case, the alert would include the logged-in user’s session and authentication cookies, demonstrating that an attacker could steal these values. Stealing the authentication cookie would have allowed an attacker to log into a target’s account, which explains why FileDescriptor was awarded a $3,500 bounty for finding this vulnerability.</p>&#13;
<h4 class="h4" id="ch06lev2sec2"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">If a server is somehow sanitizing the characters <span class="literal">%0D%0A</span>, think about how the website might be doing that and whether you can circumvent its efforts, such as through double encoding. You can test whether the site is mishandling extra values by passing multibyte characters and determining whether they are decoded into other characters.</p>&#13;
<h3 class="h3" id="ch06lev1sec4"><strong>Summary</strong></h3>&#13;
<p class="noindent">CRLF vulnerabilities allow attackers to manipulate HTTP responses by altering their headers. Exploiting CRLF vulnerabilities can lead to cache poisoning, firewall evasion, request hijacking, or HTTP response splitting. Because a CRLF vulnerability is caused by a site reflecting back the unsanitized user input <span class="literal">%0D%0A</span> in its headers, it’s important to monitor and review all HTTP responses when hacking. Additionally, if you do find input you can control being returned in HTTP headers, but the characters <span class="literal">%0D%0A</span> are being sanitized, try including multibyte-encoded input as FileDescriptor did to determine how the site handles decoding it.</p>&#13;
</body></html>