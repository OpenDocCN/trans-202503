["```\n(define (make-chessboard n)\n  (let loop ([v n] [l '()])\n    (if (zero? v)\n        (list->vector l)\n        (loop (sub1 v) (cons (make-vector n 0) l)))))\n```", "```\n(define (cb-set! cb r c v)\n  (vector-set! (vector-ref cb c) r v))\n\n(define (cb-ref cb r c)\n  (vector-ref (vector-ref cb c) r))\n```", "```\n(define (cb-copy cb)\n  (for/vector ([v cb]) (vector-copy v)))\n```", "```\n(define (cb-print cb)\n  (let ([n (vector-length cb)])\n    (for* ([r n]\n           [c n])\n      (when (zero? c) (newline))\n      (let ([v (cb-ref cb r c)])\n        (if (zero? v)\n            (display \" .\")\n            (display \" Q\")\n            ))))\n  (newline))\n```", "```\n(define (dfs n)\n  (let ([sols '()]\n        [cb (make-chessboard n)])\n    (let loop([r 0][c 0])\n      (when (< c n)\n     ➊ (let ([valid (not (attacked cb r c))])\n          (when valid\n         ➋ (cb-set! cb r c 1)\n         ➌ (if (= c (sub1 n))\n              (let ([copy (cb-copy cb)])\n             ➍ (set! sols (cons copy sols)))\n           ➎ (loop 0 (add1 c)))\n         ➏ (cb-set! cb r c 0))\n       ➐ (when (< (add1 r) n) (loop (add1 r) c)))))\n ➑ sols))\n```", "```\n(define (attacked cb r c)\n  (let ([n (vector-length cb)])\n    (let loop ([ac (sub1 c)])\n      (if (< ac 0) #f\n          (let ([r1 (+ r (- c ac))]\n                [r2 (+ r (- ac c))])\n            (if (or (= 1 (cb-ref cb r ac))\n                    (and (< r1 n) (= 1 (cb-ref cb r1 ac)))\n                    (and (>= r2 0) (= 1 (cb-ref cb r2 ac))))\n                #t\n                (loop (sub1 ac))))))))\n```", "```\n(define (solve n)\n  (for ([cb (dfs n)]) (cb-print cb)))\n```", "```\n> (solve 4)\n\n . Q . .\n . . . Q\n Q . . .\n . . Q .\n . . Q .\n Q . . .\n . . . Q\n . Q . .\n\n> (solve 5)\n\n . . Q . .   . . . Q .  . . . . Q   . Q . . .   . . . . Q\n . . . . Q   . Q . . .  . Q . . .   . . . . Q   . . Q . .\n . Q . . .   . . . . Q  . . . Q .   . . Q . .   Q . . . .\n . . . Q .   . . Q . .  Q . . . .   Q . . . .   . . . Q .\n Q . . . .   Q . . . .  . . Q . .   . . . Q .   . Q . . .\n\n . Q . . .   . . . Q .   . . Q . .   Q . . . .  Q . . . .\n . . . Q .   Q . . . .   Q . . . .   . . Q . .  . . . Q .\n Q . . . .   . . Q . .   . . . Q .   . . . . Q  . Q . . .\n . . Q . .   . . . . Q   . Q . . .   . Q . . .  . . . . Q\n . . . . Q   . Q . . .   . . . . Q   . . . Q .  . . Q . .\n\n> (solve 8)\n\n . . Q . . . . .\n . . . . . Q . .\n . . . Q . . . .\n . Q . . . . . .\n . . . . . . . Q\n . . . . Q . . .\n . . . . . . Q .\n Q . . . . . . .\n\n<intermediate solutions omitted>\n\n Q . . . . . . .\n . . . . . . Q .\n . . . . Q . . .\n . . . . . . . Q\n . Q . . . . . .\n . . . Q . . . .\n . . . . . Q . .\n . . Q . . . . .\n```", "```\n#lang racket\n(require data/heap)\n\n(define (comp n1 n2)\n  (let ([d1 (cdr n1)]\n        [d2 (cdr n2)])\n    (<= d1 d2)))\n\n(define queue (make-heap comp))\n```", "```\n(define (enqueue n) (heap-add! queue n))\n\n(define (dequeue)\n  (let ([n (heap-min queue)])\n    (heap-remove-min! queue)\n    n))\n\n(define (update-priority s p)\n  (let ([q (for/first ([x (in-heap queue)] #:when (equal? s (car x))) x)])\n    (heap-remove! queue q)\n    (enqueue (cons s p))))\n\n(define (peek-queue) (heap-min queue))\n\n(define (queue->list) (for/list ([n (in-heap queue)]) n))\n\n(define (in-queue? s)\n  (for/or ([x (in-heap queue)]) (equal? (car x) s)))\n```", "```\n> (enqueue '(a . 12))\n> (enqueue '(b . 8))\n> (enqueue '(c . 6))\n> (queue->list)\n'((c . 6) (b . 8) (a . 12))\n\n> (in-queue? 'b)\n#t\n\n> (in-queue? 'x)\n#f\n\n> (update-priority 'a 9)\n> (queue->list)\n'((c . 6) (b . 8) (a . 9))\n\n> (dequeue)\n'(c . 6)\n\n> (queue->list)\n'((b . 8) (a . 9))\n\n> (peek-queue)\n'(b . 8)\n```", "```\n(define edge-list\n  '((S a 12)\n    (S b 8)\n    (S c 6)\n    (a b 1)\n    (b c 9)\n    (a e 8)\n    (e d 5)\n    (b d 10)\n    (c d 13)))\n```", "```\n(define parent (make-hash))\n```", "```\n(define lengths (make-hash))\n(define dist (make-hash))\n\n(define (init-graph start-node edges)\n  (let* ([INFINITY 9999]\n         [swapped (map (λ (e) (list (second e) (first e) (third e))) edges)] \n         [all-edges (append edges swapped)]\n         [nodes (list->set (map (λ (e) (first e)) all-edges))])\n    (hash-clear! lengths)\n    (for ([e all-edges]) (hash-set! lengths (cons (first e) (second e)) (third e)))\n    (set! queue (make-heap comp))\n    (hash-clear! parent)\n    (hash-clear! dist)\n    (for ([n nodes])\n      (hash-set! parent n null)\n      (hash-set! dist n INFINITY)\n      (if (equal? n start-node)\n          (enqueue (cons start-node 0))\n          (enqueue (cons n INFINITY))))\n    (hash-set! dist start-node 0)\n    all-edges))\n```", "```\n(define (dijkstra start-node edges)\n  (let ([graph (init-graph start-node edges)])\n ➊ (define (neighbors n)\n      (filter\n       (λ (e) (and (equal? n (first e)) (in-queue? (second e))))\n       graph))\n ➋ (let loop ()\n      (let* ([u (car (dequeue))])\n        (for ([n (neighbors u)])\n       ➌ (let* ([v (second n)]\n              ➍ [t (+ (hash-ref dist u) (hash-ref lengths (cons u v)))])\n    ➎ (when (< t (hash-ref dist v))\n           ➏ (hash-set! dist v t)\n           ➐ (hash-set! parent v u)\n           ➑ (update-priority v t)))))\n   ➒ (when (> (heap-count queue) 0) (loop)))))\n```", "```\n(define (get-path n)\n  (define (loop n)\n    (if (equal? null n)\n        null\n        (let ([p (hash-ref parent n)])\n          (cons n (loop p)))))\n  (reverse (loop n)))\n```", "```\n(define (show-paths)\n  (for ([n (hash-keys parent)])\n    (printf \"  ~a: ~a\\n\" n (get-path n))))\n```", "```\n(define (solve start-node edges)\n  (dijkstra start-node edges)\n  (displayln \"Shortest path listing:\")\n  (show-paths))\n```", "```\n> (solve 'S edge-list)\nShortest path listing:\n  S: (S)\n  e: (S b a e)\n  a: (S b a)\n  d: (S b d)\n  c: (S c)\n  b: (S b)\n```", "```\n> (define edges '((v a 4) (v b 15) (v c 6) (a b 12) (b c 9) (b d 8) (a f 10) (\n     c v 6) (c g 13) (g h 6) (h w 3) (a d 3) (d e 5) (b e 2) (e w 16) (b g 4)\n     (g e 8) (e h 16) (e f 3) (f w 14)))\n```", "```\n> (solve 'v edges)\nShortest path listing:\n  d: (v a d)\n  w: (v a d e b g h w)\n  f: (v a f)\n  c: (v c)\n  v: (v)\n  a: (v a)\n  e: (v a d e)\n  g: (v a d e b g)\n  h: (v a d e b g h)\n  b: (v a d e b)\n```", "```\n#lang racket\n(require data/heap)\n\n(define (comp n1 n2)\n  (let ([d1 (cdr n1)]\n        [d2 (cdr n2)])\n    (<= d1 d2)))\n\n(define queue (make-heap comp))\n\n(define (enqueue n) (heap-add! queue n))\n\n(define (dequeue)\n  (let ([n (heap-min queue)])\n    (heap-remove-min! queue)\n    n))\n```", "```\n(define SIZE 3)\n(define empty (sqr SIZE))\n\n(define (ref puzzle r c)\n  (let ([i (+ c (* r SIZE))])\n    (vector-ref puzzle i)))\n\n(define (empty-loc puzzle)\n  (values\n   (vector-ref puzzle empty)\n   (vector-ref puzzle (add1 empty))))\n```", "```\n(define tile-homes\n  (let ([hash (make-hash)])\n    (for ([n (in-range (sqr SIZE))])\n      (hash-set! hash (add1 n) (cons (quotient n SIZE) (remainder n SIZE))))\n    hash))\n\n(define (manhattan puzzle) \n  (let ([dist 0])\n    (for* ([r SIZE] [c SIZE])\n      (when (not (= empty (ref puzzle r c)))\n        (let* ([t (hash-ref tile-homes (ref puzzle r c))]\n               [tr (car t)]\n               [tc (cdr t)])\n          (set! dist (+ dist\n                        (abs (- tr r))\n                        (abs (- tc c)))))))\n    dist))\n```", "```\n(define (move-offset i)\n  (case i\n    [(0) (values  0 -1)]\n    [(1) (values  0  1)] \n    [(2) (values -1  0)] \n    [(3) (values  1  0)]))\n\n(define (make-move puzzle i)\n  (let*-values ([(ro co) (move-offset i)]\n                [(re ce) (empty-loc puzzle)]\n                [(rt ct) (values (+ re ro) (+ ce co))]\n                [(t) (ref puzzle rt ct)])\n    (for/vector ([i (in-range (+ 2 (sqr SIZE)))])\n      (cond [(< i empty)\n             (let-values ([(r c) (quotient/remainder i SIZE)])\n               (cond [(and (= r re) (= c ce)) t]\n                     [(and (= r rt) (= c ct)) empty]\n                     [else (vector-ref puzzle i)]))]\n            [(= i empty) rt]\n            [else ct]))))\n```", "```\n(define (next-states puzzle)\n  (let-values ([(re ce) (empty-loc puzzle)])\n    (define (legal i)\n      (let*-values ([(ro co) (move-offset i)]\n                    [(rt ct) (values (+ re ro) (+ ce co))])\n        (and (>= rt 0) (>= ct 0) (< rt SIZE) (< ct SIZE))))\n    (for/list ([i (in-range 4)] #:when (legal i))\n      (make-move puzzle i))))\n```", "```\n(define (print puzzle)\n  (for* ([r SIZE] [c SIZE])\n    (when (= 0 c) (printf \"\\n\"))\n    (let ([t (ref puzzle r c)])\n      (if (= t empty)\n          (printf \"  \")\n          (printf \" ~a\" t))))\n  (printf \"\\n\"))\n```", "```\n(define closed (make-hash))\n\n(define (process-closed node-parent node node-depth score)\n  (begin\n ➊ (hash-set! closed node (list node-parent score)) \n    (for ([child (next-states node)])\n   ➋ (let* ([depth (add1 node-depth)]\n          ➌ [next-score (+ depth (manhattan child))]\n          ➍ [next (cons (list child depth node) next-score)])\n        (if (hash-has-key? closed child)\n         ➎ (let* ([prior-score (second (hash-ref closed child))])\n           ➏ (when (< next-score prior-score)\n                (hash-remove! closed child)\n                (enqueue next)))\n         ➐ (enqueue next))))))\n```", "```\n(define (a-star puzzle)\n  (let [(solved #f)]\n    (hash-clear! closed)\n ➊ (set! queue (make-heap comp))  ; open\n ➋ (enqueue (cons (list puzzle 0 null) (manhattan puzzle)))\n ➌ (let loop ()\n   ➍ (unless solved\n        (let* ([node-info (dequeue)])\n       ➎ (match node-info\n            [(cons (list node node-depth node-parent) score)\n          ➏ (if (= 0 (manhattan node))\n                 (begin\n                   (set! solved #t) \n                   (print-solution (solution-list node-parent (list node))))\n             ➐ (process-closed node-parent node node-depth score)\n                 )])\n       ➑ (if (> (heap-count queue) 0)\n              (loop)\n           ➒ (unless solved(printf \"No solution found\\n\"))))))))\n```", "```\n(define (solution-list n l)\n  (if (equal? n null)\n      l\n      (let* ([parent (first (hash-ref closed n))])\n        (solution-list parent (cons n l)))))\n\n(define (print-solution l)\n  (for ([p l]) (print p)))\n```", "```\n> (a-star #(8 1 6 5 3 7 4 9 2 2 1))\n\n 8 1 6  8 1 6  8 1 6    1 6  1   6  1 3 6  1 3 6\n 5 3 7  5 3 7    3 7  8 3 7  8 3 7  8   7    8 7\n 4   2    4 2  5 4 2  5 4 2  5 4 2  5 4 2  5 4 2\n\n 1 3 6  1 3 6  1 3 6  1 3 6  1 3 6  1 3 6  1 3 6  \n 5 8 7  5 8 7  5 8 7  5 8    5   8  5 2 8  5 2 8  \n   4 2  4   2  4 2    4 2 7  4 2 7  4   7  4 7    \n\n 1 3 6  1 3    1   3  1 2 3  1 2 3  1 2 3  1 2 3  \n 5 2    5 2 6  5 2 6  5   6    5 6  4 5 6  4 5 6  \n 4 7 8  4 7 8  4 7 8  4 7 8  4 7 8    7 8  7   8  \n\n 1 2 3\n 4 5 6\n 7 8\n```", "```\n(define (cost puzzle guard)\n  (let ([dist 0])\n    (for* ([r SIZE] [c SIZE])\n      (let ([t (ref puzzle r c)])\n        (when (guard r c t)\n          (let* ([th (hash-ref tile-homes t)]\n                 [hr (car th)]\n                 [hc (cdr th)]\n                 [d (+ (abs (- hr r)) (abs (- hc c)))])\n            (set! dist (+ dist d))))))\n    dist))\n```", "```\n(define (manhattan puzzle)\n  (cost puzzle (λ (r c t) \n                 (not (= t empty)))))\n```", "```\n(define (zone1a puzzle)\n  (cost puzzle (λ (r c t)\n                 (or (and (<= t 4) (> r 1))))))\n```", "```\n(define (zone1b puzzle)\n  (cost puzzle (λ (r c t)\n                 (<= t 4))))\n```", "```\n(define zone2-tiles (set 5 9 13))\n\n(define (zone2 puzzle)\n  (cost puzzle (λ (r c t)\n                 (and (>= r 1)\n                      (set-member? zone2-tiles t)))))\n```", "```\n(define min-r 0)\n(define min-c 0)\n\n(define (next-states puzzle)\n  (let-values ([(re ce) (empty-loc puzzle)])\n    (define (legal i)\n      (let*-values ([(ro co) (move-offset i)]\n                    [(rt ct) (values (+ re ro) (+ ce co))])\n        (and (>= rt min-r) (>= ct min-c) (< rt SIZE) (< ct SIZE))))\n    (for/list ([i (in-range 4)] #:when (legal i))\n      (make-move puzzle i))))\n```", "```\n(define (process-closed node-parent node node-depth score fscore)\n  (begin\n    (hash-set! closed node (list node-parent score)) \n    (for ([child (next-states node)])\n      (let* ([depth (add1 node-depth)]\n          ➊ [next-score (+ depth (fscore child))]\n             [next (cons (list child depth node) next-score)])\n        (if (hash-has-key? closed child)\n            (let* ([prior-score (second (hash-ref closed child))])\n              (when (< next-score prior-score)\n                (hash-remove! closed child)\n                (enqueue next)))\n            (enqueue next))))))\n```", "```\n(define (a-star puzzle fscore)\n  (let ([solution null]\n        [goal null])\n    (hash-clear! closed)\n    (set! queue (make-heap comp))  ; open\n    (enqueue (cons (list puzzle 0 null) (fscore puzzle)))\n    (let loop ()\n      (when (equal? solution null)\n        (let* ([node-info (dequeue)])\n          (match node-info\n            [(cons (list node node-depth node-parent) score)\n             (if (= 0 (fscore node))\n                 (begin\n                ➊ (set! goal node)\n                ➋ (set! solution (solution-list node-parent (list node))))\n                 (process-closed node-parent node node-depth score fscore))])\n          (if (> (heap-count queue) 0)\n              (loop)\n              (when (equal? solution null) (printf \"No solution found\\n\"))))))\n ➌ (values goal solution)))\n```", "```\n(define (solve puzzle)  \n  (set! min-r 0)\n  (set! min-c 0)\n  (let*-values ([(goal sol-z1a) (a-star puzzle zone1a)])\n    (let*-values  ([(goal sol2) (a-star goal zone1b)]\n                   [(sol-z1b) (cdr sol2)])\n      (set! min-r 1)\n      (let*-values  ([(goal sol3) (a-star goal zone2)]\n                     [(sol-z2) (cdr sol3)])\n        (set! min-c 1)\n        (let*-values  ([(goal sol4) (a-star goal manhattan)]\n                       [(sol-man) (cdr sol4)])\n          (print-solution (append sol-z1a sol-z1b sol-z2 sol-man)))))))\n```", "```\n(define (print puzzle)\n  (for* ([r SIZE] [c SIZE])\n    (when (= 0 c) (printf \"\\n\"))\n    (let ([t (ref puzzle r c)])\n      (if (= t empty)\n          (printf \"   \")\n          (printf \" ~a\" (~a t #:min-width 2 #:align 'right) ))))\n  (printf \"\\n\"))\n```", "```\n> (solve #(2 10 8 3 1 6 16 4 5 9 7 11 13 14 15 12 1 2))\n\n  2 10  8  3   2 10     3    2 10  3       2 10  3  4 \n  1  6     4   1  6  8  4    1  6  8  4    1  6  8   \n  5  9  7 11   5  9  7 11    5  9  7 11    5  9  7 11\n 13 14 15 12  13 14 15 12   13 14 15 12   13 14 15 12\n\n  2 10  3  4    2 10  3  4   2     3  4       2  3  4\n  1  6     8    1     6  8   1 10  6  8    1 10  6  8\n  5  9  7 11    5  9  7 11   5  9  7 11    5  9  7 11\n 13 14 15 12   13 14 15 12  13 14 15 12   13 14 15 12\n\n  1  2  3  4    1  2  3  4    1  2  3  4   1  2  3  4  \n    10  6  8    5 10  6  8    5 10  6  8   5     6  8  \n  5  9  7 11       9  7 11    9     7 11   9 10  7 11  \n 13 14 15 12   13 14 15 12   13 14 15 12  13 14 15 12  \n\n  1  2  3  4    1  2  3  4    1  2  3  4    1  2  3  4 \n  5  6     8    5  6  7  8    5  6  7  8    5  6  7  8\n  9 10  7 11    9 10    11    9 10 11       9 10 11 12\n 13 14 15 12   13 14 15 12   13 14 15 12   13 14 15   \n\n> (solve #(5 1 2 4 14 9 3 7 13 10 12 6 15 11 8 16 3 3))\n. . .\n\n> (solve #(10 9 5 13 8 14 15 7 1 3 11 6 4 2 12 16 3 3))\n. . .\n\n> (solve #(3 1 2 4 13 6 7 8 5 12 10 11 9 14 15 16 3 3))\n. . .\n\n> (solve #(9 6 12 3 5 13 16 8 14 1 10 7 2 15 11 4 1 2))\n. . .\n\n> (solve #(11 1 3 12 5 2 9 8 10 6 14 15 7 13 4 16 3 3))\n. . .\n```", "```\n(define (array-set! array r c v)\n  (vector-set! (vector-ref array r) c v))\n\n(define (array-ref array r c)\n  (vector-ref (vector-ref array r) c))\n```", "```\n(define (getBlk r c) ; block from row and column\n  (+ (* 3 (quotient r 3)) (quotient c 3)))\n```", "```\n> (define puzzle-str \"\n150000320\n604031097\n000200000\n000049073\n400800000\n000000001\n503008000\n002000004\n007000260\n\")\n```", "```\n(define sudoku%\n  (class object%\n\n ➊ (init [puzzle-string \"\"])\n\n    (define avail-row (make-markers))\n    (define avail-col (make-markers))\n    (define avail-blk (make-markers))\n ➋ (define count 0)\n\n ➌ (define grid\n      (for/vector ([i 9]) (make-vector 9 0)))\n\n    (super-new)\n\n ➍ (define/public (item-set! r c n)\n      (array-set! grid r c n)\n      (array-set! avail-row r n #f)\n      (array-set! avail-col c n #f)\n      (let ([b (getBlk r c)])\n        (array-set! avail-blk b n #f))\n      (set! count (+ count 1)))\n    (unless (equal? puzzle-string \"\")\n   ➎ (init-puzzle puzzle-string))\n\n    (define/public (get-grid) grid)\n\n    (define/public (item-ref r c)\n      (array-ref grid r c))\n\n ➏ (define/public (init-grid grid)\n      (for* ([r 9] [c 9])\n        (let ([n (array-ref grid r c)])\n          (when (> n 0)\n            (item-set! r c n)))))\n\n ➐ (define/private (init-puzzle p)\n      (let ([g \n             (let ([rows (string-split p)])\n               (for/vector ([row rows])\n                 (for/vector ([c 9])\n                   (string->number (substring row c (add1 c))))))])\n        (init-grid g)))\n\n; More to come shortly . . .\n\n))\n```", "```\n(define (make-markers)\n  (for/vector ([i 10])\n    (let ([v (make-vector 10 #t)])\n      (vector-set! v 0 #f)  \n      v)))\n```", "```\n    (define (avail r c)\n      (let* ([b (getBlk r c)]\n             [ar (vector-ref avail-row r)]\n             [ac (vector-ref avail-col c)]\n             [ab (vector-ref avail-blk b)])\n        (for/vector ([i 10])\n          (and (vector-ref ar i)\n               (vector-ref ac i)\n               (vector-ref ab i)))))\n```", "```\n    (define (free-numbers v)\n      (for/list ([n (in-range 1 10)] #:when (vector-ref v n)) n))\n```", "```\n    (define (set-singles)\n      (let ([found #f])\n        (for* ([r 9] [c 9])\n          (let* ([free (avail r c)]\n                 [num-free (vector-count identity free)]\n                 [n (item-ref r c)])\n            (when (and (zero? n)  (= 1 num-free))\n              (let ([first-free\n                     (let loop ([i 1])\n                       (if (vector-ref free i) i\n                           (loop (add1 i))))])\n                (item-set! r c first-free)\n                (set! found #t))\n              )))\n        found))\n```", "```\n    (define/public (set-all-singles)\n      (when (set-singles) (set-all-singles)))\n```", "```\n    (define (get-free)\n      (let ([free-list '()])\n        (for* ([r 9] [c 9])\n          (let* ([free (avail r c)]\n                 [num-free (vector-count identity free)]\n                 [n (item-ref r c)])\n            (when (zero? n)\n              (set! free-list\n                    (cons\n                     (list r c num-free (free-numbers free))\n                     free-list)))))\n        free-list))\n\n    (define/public (get-min-free)\n      (let ([min-free 10]\n            [min-info null]\n            [free-list (get-free)])\n        (let loop ([free free-list])\n          (unless (equal? free '())\n            (let* ([info (car free)]\n                   [rem (cdr free)]\n                   [num-free (third info)])\n              (when (< 0 num-free min-free)\n                (set! min-free num-free)\n                (set! min-info info))\n              (loop rem))))\n        min-info))\n```", "```\n    (define/public (print)\n      (for* ([r 9] [c 9])\n        (when (zero? c) (printf \"\\n\"))\n        (let ([n (item-ref r c)])\n          (if (zero? n)\n              (printf \" .\")\n              (printf \" ~a\" n)\n              )))\n      (printf \"\\n\"))\n\n    (define/public (solved?) (= count 81))\n\n    (define/public (clone)\n      (let ([p (new sudoku%)])\n        (send p init-grid grid)\n        p))\n```", "```\n(define (solve-sudoku puzzle)\n  (let ([solution null]\n     ➊ [puzzle (send puzzle clone)])\n ➋ (define (dfs puzzle)\n      (if (send puzzle solved?)\n          (set! solution puzzle)\n          (let ([info (send puzzle get-min-free)]) \n            (match info\n              ['() #f]\n           ➌ [(list row col num free-nums) \n               (let loop ([nums free-nums])\n                 (if (equal? nums '())\n                     #f\n                  ➍ (let ([n (car nums)]\n                        ➎ [t (cdr nums)])\n                       (let ([p (send puzzle clone)])\n                      ➏ (send p item-set! row col n)\n                         (send p set-all-singles)\n                      ➐ (unless (dfs p)(loop t))))))]))))\n ➑ (send puzzle set-all-singles)\n    (dfs puzzle)\n    (if (equal? solution null)\n        (error \"No solution found.\")\n        solution\n        )))\n```", "```\n(define (solve pstr)\n  (let* ([puzzle (new sudoku% [puzzle-string pstr])]\n         [solution (solve-sudoku puzzle)])\n    (send puzzle print)\n    (send solution print)))\n```", "```\n> (define puzzle \"\n150000320\n604031097\n000200000\n000049073\n400800000\n000000001\n503008000\n002000004\n007000260\n\")\n> (solve puzzle)\n\n 1 5 . . . . 3 2 .\n 6 . 4 . 3 1 . 9 7\n . . . 2 . . . . .\n . . . . 4 9 . 7 3\n 4 . . 8 . . . . .\n . . . . . . . . 1\n 5 . 3 . . 8 . . .\n . . 2 . . . . . 4\n . . 7 . . . 2 6 .\n\n 1 5 8 9 7 4 3 2 6\n 6 2 4 5 3 1 8 9 7\n 7 3 9 2 8 6 1 4 5\n 2 8 5 1 4 9 6 7 3\n 4 7 1 8 6 3 9 5 2\n 3 9 6 7 5 2 4 8 1\n 5 6 3 4 2 8 7 1 9\n 8 1 2 6 9 7 5 3 4\n 9 4 7 3 1 5 2 6 8\n```", "```\n(require racket/draw)\n```", "```\n(define CELL-SIZE 30)\n\n(define (draw-centered-text dc text x y)\n  (let-values ([(w h d s) (send dc get-text-extent text)])\n    (let ([x (+ x (/ (- CELL-SIZE w) 2))]\n          [y (+ y (/ (- CELL-SIZE h d) 2))])\n      (send dc draw-text text x y ))))\n```", "```\n(define (draw-puzzle p1 p2)\n  (let* ([drawing (make-bitmap (* 9 CELL-SIZE) (* 9 CELL-SIZE))]\n         [dc (new bitmap-dc% [bitmap drawing])]\n         [yellow (new brush% [color (make-object color% 240 210 0)])]\n         [gray (new brush% [color \"Gainsboro\"])])\n    (for* ([r 9][c 9])\n      (let* ([x (* c CELL-SIZE)]\n             [y (* r CELL-SIZE)]\n             [n1 (send p1 item-ref r c)]\n             [n2 (send p2 item-ref r c)]\n             [num (if (zero? n2) \"\" (number->string n2))]\n             [color (if (zero? n1) yellow gray)])\n        (send dc set-pen \"black\" 1 'solid)\n        (send dc set-brush color)\n        (send dc draw-rectangle x y CELL-SIZE CELL-SIZE)\n        (draw-centered-text dc num x y)))\n    (for* ([r 3][c 3])\n      (let* ([x (* 3 c CELL-SIZE)]\n             [y (* 3 r CELL-SIZE)])\n        (send dc set-pen \"black\" 2 'solid)\n        (send dc set-brush \"black\" 'transparent)\n        (send dc draw-rectangle x y (* 3 CELL-SIZE) (* 3 CELL-SIZE))))\n    drawing))\n```", "```\n(define (solve pstr)\n  (let* ([puzzle (new sudoku% [puzzle-string pstr])]\n         [solution (solve-sudoku puzzle)])\n    (print (draw-puzzle puzzle puzzle))\n    (newline)\n    (newline)\n    (print (draw-puzzle puzzle solution))))\n```", "```\n> (solve \"\n150000320\n604031097\n000200000\n000049073\n400800000\n000000001\n503008000\n002000004\n007000260\n\")\n```"]