- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: ANSWER KEY
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案解析
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: Chapter 2
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 2 章
- en: '**2.1  Pure or Impure?**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.1  纯粹或不纯？**'
- en: From a purely formal point of view, this function is impure since it uses something
    that wasn’t provided as an argument. Given that PI is a constant, you could possibly
    stretch things a bit and accept it; after all, nobody will be able to modify PI
    because of the const definition. The best solution would be to use Math.PI with
    no external variable, constant or not.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从纯粹的形式角度来看，这个函数是不纯的，因为它使用了未作为参数提供的内容。考虑到 PI 是一个常量，你或许可以稍微放宽要求并接受它；毕竟，由于 const
    定义，没有人能修改 PI。最好的解决方案是使用 Math.PI，而不依赖任何外部变量，无论它是否是常量。
- en: '**2.2  Prepare for Failure**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.2  为失败做准备**'
- en: 'You must use try and catch; the following is a possible solution:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须使用 try 和 catch；以下是一个可能的解决方案：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The addLogging() higher-order function takes a function as a parameter ❶ and
    returns a new function. If the original function throws an exception, catch it
    and output a proper message. Upon entry ❷, log the function’s name and the arguments
    it was called with. Then try to call the original function ❸, and if there’s no
    problem, log the returned value ❹ and return it back to the caller ❺. If an exception
    was thrown, log it ❻ and throw it again for the caller to process ❼.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: addLogging() 高阶函数接受一个函数作为参数❶并返回一个新函数。如果原函数抛出异常，则捕获它并输出适当的消息。在进入时❷，记录函数的名称和它被调用时的参数。然后尝试调用原函数❸，如果没有问题，则记录返回值❹并将其返回给调用者❺。如果抛出异常，则记录它❻并再次抛出，以便调用者处理❼。
- en: '**2.3  You Got Time?**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.3  有时间吗？**'
- en: The following function does what you need; you should note several similarities
    with the logging function in the previous question.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数可以满足你的需求；你应该注意它与前一个问题中的日志记录函数有几个相似之处。
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In Node.js ❶ you need to import the performance object; in a browser it’s directly
    available. (See *[https://nodejs.org/api/perf_hooks.html](https://nodejs.org/api/perf_hooks.html)*
    and *[https://developer.mozilla.org/en-US/docs/Web/API/Performance](https://developer.mozilla.org/en-US/docs/Web/API/Performance)*
    for more information.) The addTiming() function ❷ will get a function as a parameter
    and return a new function. You’ll use an auxiliary function ❸ to output the timing
    data. Before calling the original function ❹, store the start time; if the call
    succeeds ❺ with no problem, just output the original time and the current one
    ❻, returning the original returned value ❼. If any errors occur, output a different
    message ❽ and throw the same exception again ❾ so the timed function will behave
    exactly as the original one.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 中❶，你需要导入 performance 对象；在浏览器中，它直接可用。（有关更多信息，请参见 *[https://nodejs.org/api/perf_hooks.html](https://nodejs.org/api/perf_hooks.html)*
    和 *[https://developer.mozilla.org/en-US/docs/Web/API/Performance](https://developer.mozilla.org/en-US/docs/Web/API/Performance)*。）addTiming()
    函数❷将接受一个函数作为参数并返回一个新函数。你将使用一个辅助函数❸来输出计时数据。在调用原函数之前❹，存储开始时间；如果调用成功❺且没有问题，则输出原始时间和当前时间❻，并返回原始返回值❼。如果发生任何错误，则输出不同的消息❽并再次抛出相同的异常❾，这样计时函数将完全与原函数的行为一致。
- en: '**2.4  Parsing Problem**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.4  解析问题**'
- en: 'The problem is that .map() passes three arguments to your mapping function:
    the current element of the array, its index, and the whole array. (See *[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)*
    for more on this.) On the other hand, parseInt() receives two parameters: the
    value to parse and an optional radix (10 is the default value if nothing is passed).
    In this case, parseInt() is getting passed three arguments: it ignores the third
    extra one, but it uses the array index as the radix. For instance,"8" is parsed
    as a base 3 number, producing an error, since base 3 uses only digits 0, 1, and
    2, and "32" is parsed as a base 5 number, which is equivalent to 17.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于 .map() 将三个参数传递给你的映射函数：数组的当前元素、其索引和整个数组。（有关更多内容，请参见 *[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)*。）另一方面，parseInt()
    接收两个参数：要解析的值和一个可选的基数（如果未传递，默认值为 10）。在此案例中，parseInt() 收到三个参数：它忽略第三个多余的参数，但使用数组索引作为基数。例如，“8”会被解析为基数
    3 的数字，导致错误，因为基数 3 只使用数字 0、1 和 2，而“32”会被解析为基数 5 的数字，相当于 17。
- en: '**2.5  Deny Everything**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.5  否定一切**'
- en: 'A one-liner is enough:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一行代码就足够了：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**2.6  Every, Some ... None?**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.6  每个，某些...没有？**'
- en: 'Just an example as a tip to get you started: if you want to check whether nobody
    in a group was an adult, you could equivalently check whether everybody wasn’t
    an adult, so people.none(isAdult) could be tested as people.every(negate(isAdult))
    using the previous answer.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 仅作为一个起始提示的示例：如果你想检查一个小组中没有人是成年人，你可以等效地检查每个人都不是成年人，因此 people.none(isAdult) 可以被测试为
    people.every(negate(isAdult))，如前述回答所示。
- en: '**2.7  No Some, No Every**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.7  没有Some，没有Every**'
- en: 'A hint for some(): use findIndex() to see whether any element satisfies the
    predicate; if it doesn’t return -1, it means that at least one element fulfills
    your condition. For every(), you want to see whether findIndex() cannot find any
    element that satisfies negate(your predicate), in the same manner as in the previous
    question; if none is found, it means that every element fulfills your condition.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一些() 方法的提示：使用 findIndex() 查看是否有任何元素满足谓词条件；如果返回的不是 -1，则表示至少有一个元素符合条件。对于每个()，你想要查看
    findIndex() 是否找不到任何满足 negate(你的谓词) 条件的元素，和前一个问题类似；如果没有找到，则意味着每个元素都符合条件。
- en: '**2.8  What Does It Do?**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.8  它做了什么？**'
- en: Writing Boolean(someValue) checks whether the given argument is “truthy” or
    “falsy,” returning true or false accordingly. In this case, "James Bond" and 7
    are truthy values and 0 is falsy, so the result is [true, false, false, true].
    See *[https://developer.mozilla.org/en-US/docs/Glossary/](https://developer.mozilla.org/en-US/docs/Glossary/)*
    for the conversion rules involved.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 写作 Boolean(someValue) 会检查给定的参数是否为“真值”或“假值”，并根据结果返回 true 或 false。在此案例中，“詹姆斯·邦德”和
    7 是真值，而 0 是假值，所以结果是 [true, false, false, true]。有关转换规则，请参见 *[https://developer.mozilla.org/en-US/docs/Glossary/](https://developer.mozilla.org/en-US/docs/Glossary/)*。
- en: Chapter 3
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 章
- en: '**3.1  Chaining Calls**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**3.1  链式调用**'
- en: The add() and remove() methods should just end with return this to allow for
    chaining, and that’s it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: add() 和 remove() 方法应该以 return this 结束，以支持链式调用，仅此而已。
- en: '**3.2  Arrays, Not Objects**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**3.2  数组，而非对象**'
- en: 'The following is a possible implementation:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个可能的实现：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating a bag ❶ is just a matter of creating an empty array, and checking whether
    the array’s length is zero ❷ is a way to test whether it’s empty. To find a value
    in the bag ❸, use JavaScript’s own .includes() method. You’ll keep the array in
    order, so implementing greatest ❹ is simply a matter of checking whether the bag
    is empty (in which case, it returns undefined, or else it returns the array’s
    last element). To add a value to the bag ❺, push the value into the array and
    then sort the updated array. Finally, to see whether a value can be removed ❻,
    use JavaScript’s .find()method, and if the value is in the array, use .splice()
    to remove it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个袋子 ❶ 只需要创建一个空数组，而检查该数组的长度是否为零 ❷ 是测试它是否为空的方式。要在袋子中查找一个值 ❸，使用 JavaScript 自带的
    .includes() 方法。你将保持数组的顺序，因此实现最大值 ❹ 只需要检查袋子是否为空（如果是空的，则返回 undefined，否则返回数组的最后一个元素）。要向袋子中添加一个值
    ❺，将值推入数组中，然后对更新后的数组进行排序。最后，要检查是否可以移除一个值 ❻，使用 JavaScript 的 .find() 方法，如果该值存在于数组中，则使用
    .splice() 移除它。
- en: '**3.3  Extra Operations**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**3.3  额外操作**'
- en: Many possibilities exist, but keep in mind that you’d ask for these operations
    only if you actually required them for a specific problem. The following table
    provides a few, although this list could be extended.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可能性，但请记住，只有在你确实需要它们解决特定问题时，才会请求这些操作。下表提供了一些操作，尽管这个列表可以扩展。
- en: '| Operation | Signature | Description |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 签名 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Count all | bag → integer | Given a bag, return how many values it contains.
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 计数所有 | bag → 整数 | 给定一个袋子，返回它包含的所有值的数量。 |'
- en: '| Count value | bag × value → integer | Given a bag and a value, return how
    many times it’s in the bag. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 计数值 | bag × value → 整数 | 给定一个袋子和一个值，返回该值在袋子中出现的次数。 |'
- en: '| Add many | bag × value × integer → bag | Given a new value and a count, add
    so many copies of the value to the bag. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 添加多个 | bag × value × 整数 → bag | 给定一个新值和一个计数，将该值的多个副本添加到袋子中。 |'
- en: '| Remove all | bag × value → bag | Given a bag and a value, remove all the
    value’s instances from the bag. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 移除所有 | bag × value → bag | 给定一个袋子和一个值，移除袋子中所有该值的实例。 |'
- en: '| Find next | bag × value → value &#124; undefined | Given a bag and value,
    find the closest higher value to the value in the bag. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 查找下一个 | bag × value → value &#124; undefined | 给定一个袋子和一个值，查找袋子中大于该值的最小值。
    |'
- en: '**3.4  Wrong Operations**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**3.4  错误的操作**'
- en: If you want to return special values, you can do so as with the greatest() operation,
    where you returned undefined for an empty bag. If you throw an exception, you
    can also specify it as a new return value (exception), albeit one that’s received
    in a different way (try/catch), and that would work as well.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想返回特殊的值，可以像 greatest() 操作那样返回，在空集合时返回未定义。如果抛出异常，也可以将其作为一个新的返回值（异常），尽管它是以不同的方式接收的（try/catch），但这同样有效。
- en: '**3.5  Ready, Set ...**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**3.5  准备，开始...**'
- en: We’ll consider this in Chapter 13, so please skip ahead!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第13章讨论这个内容，请跳到后面！
- en: Chapter 4
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第四章
- en: '**4.1  How Fast Did You Say?**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.1  你说的速度是多少？**'
- en: That cannot be; for large enough *n*, *f*(*n*) becomes negative.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不可能的；对于足够大的 *n*，*f*(*n*) 会变成负数。
- en: '**4.2  Weird Bound?**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.2  奇怪的界限？**'
- en: Yes, *n* = *O*(*n*²) and (more properly, since we prefer tighter bounds) also
    *o*(*n*²), because *n*² grows faster. The lower bound orders, big and small omega,
    don’t apply.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，*n* = *O*(*n*²) 且（更准确地说，因为我们更倾向于使用更紧的界限）也 *o*(*n*²)，因为 *n*² 增长得更快。下界阶数，大和小欧米伽，不适用。
- en: '**4.3  Of Big** ***O*****s and Omegas**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.3  大** ***O*****和欧米伽**'
- en: In that case (and only in that case), *f*(*n*) = Θ(*g*(*n*)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下（仅在这种情况下），*f*(*n*) = Θ(*g*(*n*)).
- en: '**4.4  Transitivity?**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.4  传递性？**'
- en: If *f*(*n*) = *O*(*g*(*n*)) and *g*(*n*) = *O*(*h*(*n*)), then *f*(*n*) = *O*(*h*(*n*)).
    We can prove this mathematically, but intuitively, the first equality means that
    *f* and *g* grow proportionally, and the second means that *g* and *h* also grow
    proportionally, and that means that *f* and *h* also grow proportionally. If you
    consider any other order, transitivity still applies; for example, *f*(*n*) =
    Ω(*g*(*n*)) and *g*(*n*) = Ω(*h*(*n*)) implies *f*(*n*) = Ω(*h*(*n*)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *f*(*n*) = *O*(*g*(*n*)) 且 *g*(*n*) = *O*(*h*(*n*)), 那么 *f*(*n*) = *O*(*h*(*n*))。我们可以通过数学证明这一点，但直观上，第一个等式意味着
    *f* 和 *g* 成比例增长，第二个等式意味着 *g* 和 *h* 也成比例增长，这就意味着 *f* 和 *h* 也成比例增长。如果考虑其他任何阶数，传递性仍然适用；例如，*f*(*n*)
    = Ω(*g*(*n*)) 且 *g*(*n*) = Ω(*h*(*n*)) 表示 *f*(*n*) = Ω(*h*(*n*)).
- en: '**4.5  A Bit of Reflexion**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.5  一点反思**'
- en: We can also say *f*(*n*) = *O*(*f*(*n*)) and *f(n)* = Ω(*f*(*n*)), but not for
    small omega or small *o*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以说 *f*(*n*) = *O*(*f*(*n*)) 和 *f(n)* = Ω(*f*(*n*))，但对于小 omega 或小 *o* 不适用。
- en: '**4.6  Going at It Backward**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.6  倒着做**'
- en: 'If *f(n)* = *O*(*g*(*n*)), then *g*(*n*) = Ω(*f*(*n*)), and if *f*(*n*) = *o*(*g*(*n*)),
    then *g*(*n*) = ω(*f*(*n*)). Note the symmetry: big *O* implies big omega, and
    small *o* implies small omega.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *f(n)* = *O*(*g*(*n*)), 那么 *g*(*n*) = Ω(*f*(*n*)), 并且如果 *f*(*n*) = *o*(*g*(*n*)),
    那么 *g*(*n*) = ω(*f*(*n*))。注意对称性：大 *O* 表示大欧米伽，小 *o* 表示小欧米伽。
- en: '**4.7  One After the Other**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.7  接踵而至**'
- en: When *n* grows, the growth of the *O*(*n*²) part will be greater than the growth
    of the *O*(*n* log *n*) part, so that’s the order of the whole process. In general,
    the order of a sequence will be that of the greatest order.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *n* 增大时，*O*(*n*²) 部分的增长将大于 *O*(*n* log *n*) 部分的增长，因此整个过程的阶数就是这个。一般来说，一个序列的阶数将是最大阶数的阶数。
- en: '**4.8  Loop the Loop**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.8  循环中的循环**'
- en: In this case, the result is *O*(*n*³). The order of the whole “loop within a
    loop” is derived from the product of both orders.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，结果是 *O*(*n*³)。整个“循环内循环”的阶数是由两个阶数的乘积得出的。
- en: '**4.9  Almost a Power ...**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.9  几乎是一个幂...**'
- en: 'A formal proof would require applying induction, but consider how you’d frame
    it. You want to end with a single element, so 1 is a valid size. At the previous
    step, the array had two 1-sized parts, separated by a single element: the previous
    size was then 3\. Before that, the array had two 3-sized parts, separated by one
    element: its size was 7\. Going backward in this fashion, if you had an *s*-sized
    array, at the previous step, the array had to be of size (2*s +* 1). Starting
    at *s* = 1, it can be formally proved that sizes are always one less than a power
    of 2 from the fact that 2(2*^k* – 1) + 1 equals 2*^k* ^(+1) – 1.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个正式的证明需要应用数学归纳法，但请考虑你如何构建它。你希望最后得到一个单独的元素，所以 1 是一个有效的大小。在前一步，数组有两个大小为 1 的部分，之间由一个元素分隔：前一个大小是
    3。再往前，数组有两个大小为 3 的部分，之间由一个元素分隔：它的大小是 7。以这种方式倒推，如果你有一个 *s* 大小的数组，在前一步，数组的大小必须是
    (2*s + 1)。从 *s* = 1 开始，可以正式证明大小始终比 2 的幂少一个元素，因为 2(2*^k* – 1) + 1 等于 2*^k* ^(+1)
    – 1。
- en: '**4.10  It Was the Best of Times; It Was the Worst of Times**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.10  这是最好的时代；也是最坏的时代**'
- en: In that case (and in that case only), we can deduce that the running time is
    Θ(*f*(*n*)).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下（仅在这种情况下），我们可以推导出运行时间是 Θ(*f*(*n*))。
- en: Chapter 5
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第五章
- en: '**5.1  Factorial in One**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.1  一阶阶乘**'
- en: 'You can use this one-liner:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这一行代码：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**5.2  Hanoi by Hand**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.2  手工汉诺塔**'
- en: 'On odd steps, always move the smallest disk cyclically (from A to B, from B
    to C, and from C to A), and on even steps, make the only possible move that doesn’t
    involve the smallest disk. This method works for an even number of disks; for
    an odd number of disks, the smallest disk needs to do the cycle in the opposite
    direction: A to C, C to A, A to B.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在奇数步时，总是循环移动最小的盘子（从A到B，从B到C，再从C到A）；在偶数步时，进行唯一不涉及最小盘子的移动。这种方法适用于偶数个盘子的情况；对于奇数个盘子，最小盘子需要反方向循环：从A到C，从C到A，再从A到B。
- en: '**5.3  Archery Backtracking**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.3  箭术回溯**'
- en: 'The key to this problem is not to drop an option immediately after choosing
    it, but rather to try it again first. The following code is basically the same
    as the solve() function from the section “Solving the Squarest Game on the Beach
    Puzzle” on page 70, with an addition:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的关键是不要在选择一个选项后立即放弃，而是应该先尝试再次使用它。以下代码基本与第70页“解决海滩上的方块游戏”部分中的solve()函数相同，只是增加了一些内容：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The parameters were renamed to better match the current puzzle ❶, so it’s rings
    instead of dolls and hit instead of dropped. The additional code tries reusing
    the first ring ❷, and if it succeeds ❸, you’re done. If trying the same ring again
    fails ❹, drop it and continue with the search as earlier.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 参数已重新命名，以更好地与当前的难题❶匹配，因此使用rings而不是dolls，使用hit而不是dropped。额外的代码尝试重新使用第一个ring ❷，如果成功❸，就完成了。如果再次尝试相同的ring失败❹，则丢弃它并继续按照之前的方式进行搜索。
- en: 'For the second question, you can indeed reuse the original solve() algorithm,
    but you need a change, because you may hit a ring more than once, so rings must
    appear several times. For example, 40 and 39 should both be considered twice as
    an option; hitting any of those three or more times would exceed 100\. Similarly,
    23 and 24 could appear up to four times, 17 five times, and 16 six times. This
    code finds the solution:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个问题，你确实可以重用原始的solve()算法，但需要做一些修改，因为你可能会多次击中一个ring，所以ring必须出现多次。例如，40和39应该都被视为两次选择；击中其中任意一个三次或更多次都会超过100。同样，23和24最多出现四次，17出现五次，16出现六次。这个代码找到了答案：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By the way, if you don’t run the code, the answer is 16, 16, 17, 17, 17, and
    17!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，如果你不运行代码，答案是16, 16, 17, 17, 17和17！
- en: '**5.4  Counting Calls**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.4  统计调用次数**'
- en: To calculate the *n*th Fibonacci number, you need one call for that, plus *C*(*n*
    – 1) calls for the (*n* – 1)th number, plus *C*(*n* – 2) calls for the (*n* –
    2)th one, so *C*(*n*) = *C*(*n* – 1) + *C*(*n* – 2) + 1\. The solution to this
    is *C*(*n*) = 2Fibo(*n* + 1) – 1.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算第*n*个斐波那契数，你需要一次调用该数，再加上*C*(*n* – 1)次调用第(*n* – 1)个数，再加上*C*(*n* – 2)次调用第(*n*
    – 2)个数，因此*C*(*n*) = *C*(*n* – 1) + *C*(*n* – 2) + 1。这个问题的解是*C*(*n*) = 2Fibo(*n*
    + 1) – 1。
- en: '**5.5  Avoid More Work**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.5  避免更多工作**'
- en: 'Simply add a test at the beginning of the loop of the costOfFragment(...) function,
    as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在costOfFragment(...)函数的循环开始时添加一个测试，如下所示：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As soon as the width of blocks from p through r exceeds MW, you can stop the
    loop; all upcoming total widths will be even greater.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从p到r的块宽度超过MW，你可以停止循环；所有接下来的总宽度将更大。
- en: '**5.6  Reduce for Clarity**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.6  为了清晰起见减少**'
- en: 'The following is a single-line way to calculate the partial values:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一种单行计算部分值的方法：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that the accumulator in this case is an array that you initialize with
    a single 0 and that will become partial[0].
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这种情况下，累加器是一个初始化为单个0的数组，它将变为partial[0]。
- en: '**5.7  Got GOUT?**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.7  得了痛风吗？**'
- en: 'Use the solve() function from the section “Solving Cryptarithmetic Puzzles”
    on page 83 as follows. The style of the code is exactly the same as for the SEND
    + MORE = MONEY puzzle:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如下使用第83页“解决加密算术谜题”部分中的solve()函数。代码的风格与SEND + MORE = MONEY谜题中的完全相同：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The maximum sum of two 2-digit numbers is 99 + 99 = 198, so O = 1, and there
    was a carry-over from the center column to the leftmost one. At the rightmost
    column, O + O = T, so T = 2, and there’s no carry-over to the center column. Finally,
    looking at the center column, T + G = 10 + U, but as T = 1, the only way T + G
    is at least 10 is if G = 9 and then U = 0; the value of GOUT is then 9102, exactly
    as solve() discovers!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 两个两位数的最大和是99 + 99 = 198，因此O = 1，并且从中间列到最左边列有进位。在最右边的列，O + O = T，因此T = 2，并且没有进位到中间列。最后，查看中间列，T
    + G = 10 + U，但由于T = 1，T + G至少为10的唯一方式是G = 9，然后U = 0；此时GOUT的值为9102，正如solve()发现的那样！
- en: Chapter 6
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章
- en: '**6.1  Forced Reversal**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.1  强制反转**'
- en: Change the signs of all the numbers. Next, sort them in ascending order, and
    then change the signs back. For instance, to sort [22, 60, 9], first change them
    to [–22, –60, –9], then sort them, and you’ll get [–60, –22, –9]. Finally, change
    the signs again [60, 22, 9], and they’ll be in the desired descending order.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 先改变所有数字的符号。接着，将它们按升序排序，然后再将符号改回来。例如，要排序[22, 60, 9]，首先将它们变为[–22, –60, –9]，然后排序，得到[–60,
    –22, –9]。最后，再将符号改回[60, 22, 9]，它们就会按期望的降序排列。
- en: '**6.2  Only Lower**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.2  仅下限**'
- en: 'Given lower(a,b), you can implement higher(a,b) and equal(a,b) as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 给定lower(a,b)，你可以如下实现higher(a,b)和equal(a,b)：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Basically it’s just like applying math: a > b if b < a ❶, and a is equal to
    b, if and only if neither a < b nor a > b ❷.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上这就像应用数学：a > b 如果 b < a ❶，并且 a 等于 b，仅当 a < b 和 a > b 都不成立时 ❷。
- en: '**6.3  Testing a Sort Algorithm**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.3  测试排序算法**'
- en: Sort a copy of the data with some other method and use JSON.stringify(...) to
    get a version of the result as a string. Then, sort the data with your new method,
    use JSON.stringify(...) on its output, and compare both JSON strings; they should
    match.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用其他方法对数据的副本进行排序，并使用JSON.stringify(...)将结果转换为字符串版本。然后，用你的新方法对数据进行排序，使用JSON.stringify(...)对其输出进行转换，并比较两个JSON字符串；它们应该匹配。
- en: '**6.4  Missing ID**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.4  缺失的ID**'
- en: This problem has two solutions. You could sort the series of numbers, and then
    a sequential run through the ordered series would detect missing numbers whenever
    the gap between consecutive numbers is greater than one. A more specific solution
    would be to initialize an array of size 1,000,000 with false, and for every number
    in the series, set the corresponding array entry to true. You can then run through
    the array, and entries that are still false represent missing IDs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题有两种解决方案。你可以先对数字序列进行排序，然后按顺序遍历已排序的序列，当连续数字之间的差大于1时，就能检测到缺失的数字。更具体的解决方案是初始化一个大小为1,000,000的数组，并将所有值设置为false，然后对序列中的每个数字，将相应的数组项设置为true。接着，你可以遍历数组，仍为false的项表示缺失的ID。
- en: '**6.5  Unmatched One**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.5  未匹配项**'
- en: Like the previous question, this problem also has two solutions. You could sort
    the whole series, and then a quick run through the sorted numbers would find the
    number that’s used only once. The second, trickier solution is to apply the bitwise
    XOR (^) to all the numbers. If you XOR a number with itself, the result is zero,
    and if you XOR a number with zero, the result is the number. If you XOR the whole
    series, the result will be the unmatched number. However, this solution works
    only if there is a single unpaired number; if there were two or more, it would
    fail.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 像前一个问题一样，这个问题也有两个解决方案。你可以先对整个系列进行排序，然后快速浏览已排序的数字，找到只出现一次的数字。第二个、更复杂的解决方案是对所有数字应用按位异或（^）。如果你将一个数字与自己异或，结果是零，如果将一个数字与零异或，结果是该数字。如果你对整个系列进行异或，结果将是未匹配的数字。然而，这个解决方案仅适用于有且只有一个未匹配的数字；如果有两个或更多，则会失败。
- en: '**6.6  Sinking Sort**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.6  下沉排序**'
- en: 'The logic is similar to bubble sort’s; you need to change only how indices
    behave:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个逻辑类似于冒泡排序，你只需改变索引的行为：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**6.7  Bubble Swap Checking**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.7  冒泡交换检查**'
- en: 'The following logic implements the idea:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下逻辑实现了这个思路：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**6.8  Inserting Recursively**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.8  递归插入**'
- en: 'The description is enough to write the code: to sort *n* numbers, first sort
    the initial (*n* – 1) ones and then insert the *n*th number in the sorted list:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个描述足够写出代码：要排序*n*个数字，首先排序初始的(*n* – 1)个数字，然后将第*n*个数字插入已排序的列表中：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**6.9  Stable Shell?**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.9  稳定的Shell排序？**'
- en: No, Shell sort isn’t stable, because the first stages (for gaps larger than
    one) may disrupt the relative order of equal keys.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 不，Shell排序不是稳定的，因为在初期阶段（对于大于1的间隔）可能会打乱相等键的相对顺序。
- en: '**6.10  A Dutch Enhancement**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.10  荷兰增强法**'
- en: 'The following implementation works:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下实现有效：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: All the code is the same up to the point where the pivot is at arr[p] ❶. You
    then do a loop to the left of the pivot position ❷, and if you find elements equal
    to the pivot, you swap; the leftmost position equal to the pivot is always at
    pl. After this pass, you repeat the process with a similar logic ❸ but from the
    pivot position to the right. The rightmost position with a value equal to the
    pivot is pr. After these added loops, all values from pl to pr are equal to the
    pivot, so you sort the rest ❹.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的代码都与枢轴在arr[p] ❶时相同。然后，你对枢轴位置左侧进行循环 ❷，如果找到与枢轴相等的元素，则交换；最左侧与枢轴相等的位置总是pl。完成这一轮后，使用类似的逻辑
    ❸从枢轴位置向右重复该过程。最右侧与枢轴相等的位置是pr。经过这些附加的循环后，从pl到pr的所有值都等于枢轴，因此你可以对其余部分进行排序 ❹。
- en: '**6.11  Simpler Merging?**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.11  更简单的合并？**'
- en: If you made that change, merge sort wouldn’t be stable. When you have equal
    values in the first and second lists, you want to choose from the former.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做了这个修改，归并排序将不再稳定。当第一和第二个列表中有相等的值时，你希望从第一个列表中选择。
- en: '**6.12  Try Not to Be Negative**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.12  尽量避免消极**'
- en: With negative numbers, you’d get a crash when digit becomes negative. And for
    noninteger numbers, the algorithm disregards the fractional part, so numbers with
    equal integer parts may end up not sorted correctly. As an extra question, think
    of ways to solve these problems.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于负数，当数字变为负数时，算法会崩溃。对于非整数，算法会忽略小数部分，因此具有相同整数部分的数字可能无法正确排序。作为额外问题，考虑如何解决这些问题。
- en: '**6.13  Fill It Up!**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.13  填充它！**'
- en: The first option would fill all the elements of bucket with a reference to the
    same array; instead of 10 different arrays, you’d get a single one, common to
    all buckets. The second option wouldn’t do anything, because .map(...) skips undefined
    positions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项会用一个对同一数组的引用填充所有桶中的元素；你将得到一个单一的数组，而不是 10 个不同的数组，这个数组对所有桶都通用。第二个选项不会有任何效果，因为
    .map(...) 会跳过未定义的位置。
- en: '**6.14  What About Letters?**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.14  那字母呢？**'
- en: In that case, you’d require more buckets, one for each possible symbol. You
    might have to do some fancy work if you want to have accented letters (such as
    á or ü) sorted together with their nonaccented versions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你需要更多的桶，每个桶代表一个可能的符号。如果你想将带有重音符号的字母（例如 á 或 ü）与没有重音符号的字母一起排序，可能需要做一些额外的工作。
- en: Chapter 7
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第七章
- en: '**7.1  Tennis Sudden Death**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**7.1  网球加时赛**'
- en: 'The number of matches is easy to find: each match discards one player, and
    to find the champion, you must discard 110 other players, so the answer is 110,
    and for *n* players, *n* – 1\. The second best could be any of the players that
    the first defeated—even possibly in the first round. This tournament had seven
    rounds, so you may need up to seven extra matches. In general terms, the number
    of rounds is the logarithm of *n* in base 2, rounded up, so the total number of
    comparisons to learn the two minimum values of an array is *n* –1 + log[2] *n*.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 比赛的数量很容易计算：每场比赛都会淘汰一名选手，要找出冠军，你必须淘汰 110 名其他选手，因此答案是 110，对于 *n* 名选手，答案是 *n* –
    1。第二名选手可能是第一个击败的任何选手——甚至可能是第一轮就击败的。这场比赛有七轮，因此你可能需要最多七场额外的比赛。一般来说，轮数是 *n* 的以 2
    为底的对数，向上取整，因此学习一个数组的两个最小值的总比较次数是 *n* – 1 + log[2] *n*。
- en: '**7.2  Take Five**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**7.2  休息五分钟**'
- en: 'You can do it with six comparisons, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过六次比较来完成，方法如下：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To understand the code, follow what happens to the variables. After the first
    test, you know for sure that a < b ❶, and with the next test you know that c <
    d ❷. You can say that a < b && a < c < d ❸, so a cannot be the median. After ❹,
    b < e && c < d, so whichever is lowest of b and c cannot be the median either.
    At ❺, b < c < d && b < e, so neither b nor d can be the median, which is the smallest
    of c and e. Similarly, at ❻, c < b < e && c < d, so neither c nor e is the median;
    the smallest of b and d is it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解代码，跟踪变量的变化。经过第一次测试后，你可以确定 a < b ❶，在下一个测试中你知道 c < d ❷。你可以说 a < b && a < c
    < d ❸，因此 a 不能是中位数。经过 ❹，b < e && c < d，因此 b 和 c 中最小的一个也不可能是中位数。在 ❺，b < c < d &&
    b < e，因此 b 和 d 都不可能是中位数，中位数是 c 和 e 中最小的一个。同样地，在 ❻，c < b < e && c < d，因此 c 和 e
    不是中位数；中位数是 b 和 d 中最小的一个。
- en: 'Just for completeness, here’s an equivalent version of median5(...) that works
    with an array of five independent values and returns the position of the found
    median. The code is parallel to the previous code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 完整起见，这里提供了一个等效版本的 median5(...)，它适用于包含五个独立值的数组，并返回找到的中位数的位置。代码与之前的代码平行：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**7.3  Top to Bottom**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**7.3  从上到下**'
- en: There are two solutions. You could change the algorithm so instead of selecting
    minimums and going from 0 to *n* – 1, it could work by selecting maximums and
    going down from *n* – 1 to 0\. To get an efficient algorithm, you should start
    by comparing *k* to *n*/2 and going up (as originally shown in the text) or down
    (as described here) depending on that comparison, whichever takes the least work.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种解决方案。你可以修改算法，改为选择最大值并从 *n* – 1 向 0 遍历，而不是选择最小值并从 0 遍历到 *n* – 1。为了获得高效的算法，应该从将
    *k* 与 *n*/2 进行比较并向上（如文本中最初展示）或向下（如这里所描述）移动开始，选择需要最少工作量的方向。
- en: 'In the particular case in which the values are numeric, you can do a trick:
    change the sign of all numbers to the opposite, use the algorithm to find the
    value at *n* – *k*, and change its sign; can you see why that works?'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在数值为数字的特殊情况下，你可以使用一个技巧：将所有数字的符号改为相反的，使用该算法找到 *n* – *k* 位置的值，并将其符号改回；你能看出为什么这样行得通吗？
- en: '**7.4  Just Iterate**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**7.4  仅迭代**'
- en: 'Instead of recursion, you can use a loop that will exit when the code has managed
    to put the *k*th value of the array in place:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一个循环，循环将在代码成功将数组的 *k* 位置值放置到正确位置时退出，而不是递归：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Set up a loop ❶ that continues as long as left and right haven’t reached the
    same place (k). At the end, instead of recursion or returning early, just manipulate
    left and right properly ❷.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个循环 ❶，只要左边和右边没有到达相同的位置（k），就继续循环。最后，避免递归或提前返回，只需适当地操作左边和右边 ❷。
- en: '**7.5  Select Without Changing**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**7.5  选择而不改变**'
- en: 'Simply make a copy of the input array, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 只需创建输入数组的副本，如下所示：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Make a copy of the array ❶, then partition it ❷, and finally return the *k*th
    value from the copied and repartitioned array ❸.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 复制数组 ❶，然后对其进行划分 ❷，最后从复制并重新划分后的数组中返回 *k* 的值 ❸。
- en: '**7.6  The Sicilian Way**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**7.6  西西里方式**'
- en: The following algorithm does the trick. You can find a different implementation
    (changing how elements are swapped) in “An Efficient Algorithm for the Approximate
    Median Selection Problem,” by S. Battiato et al., available at *[https://web.cs.wpi.edu/~hofri/medsel.pdf](https://web.cs.wpi.edu/~hofri/medsel.pdf)*.
    We’ll highlight the only differences with previous code, but we’ve also implemented
    some methods in a new way just for variety, and we used iteration instead of recursion
    (as in question 7.4) for the same reason.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法完成了这个任务。你可以在“S. Battiato等人所著的《近似中位数选择问题的高效算法》中找到不同的实现（通过改变元素交换方式）”，该文献可以在
    *[https://web.cs.wpi.edu/~hofri/medsel.pdf](https://web.cs.wpi.edu/~hofri/medsel.pdf)*
    上找到。我们将突出与之前代码的唯一差异，但我们也用新的方式实现了一些方法，只是为了多样性，并且为了同样的原因，我们用迭代代替了递归（如在问题7.4中所示）。
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You’ll need to do lots of swapping, but the swapIfNeeded(...) function ❶ avoids
    some unnecessary calls by checking whether there’s actually any need to swap.
    Since you’ll always be finding the median of up to three values, it makes sense
    to have a specific function instead of using a generic sort ❷; medianOf3(...)
    returns the position of the median using up to three comparisons with no swapping.
    In quickselect the only part that changed are the lines in bold. You’ll find the
    medians in ever-shortening parts of the array; the rr variable marks the right
    limit of the array you’re processing ❸, while the left variable always points
    at its left limit. As long as the array has more than three elements ❹, you’ll
    do a pass of choosing medians of 3 ❺ and packing them to the left of the array,
    as shown in the repeated step algorithm; the difference is that after each pass
    ❻ you’ll shorten the array and loop again to find medians of 3\. When the set
    of medians (of medians of medians of ..., and so on) is short enough, you’ll just
    choose its last element as the next pivot.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要进行大量交换，但swapIfNeeded(...)函数 ❶ 通过检查是否真的需要交换，避免了一些不必要的调用。因为你总是会找到最多三个值的中位数，所以使用特定的函数比使用通用排序更合适
    ❷；medianOf3(...)通过最多三次比较返回中位数的位置，而不需要交换。在快速选择中，唯一变化的是加粗的几行。你将在不断缩短的数组部分中找到中位数；rr变量标记你正在处理的数组的右边界
    ❸，而left变量始终指向其左边界。只要数组中的元素超过三个 ❹，你就会进行选择3个中位数的操作 ❺，并将它们打包到数组的左边，如重复步骤算法所示；不同之处在于，每次操作后
    ❻ 你都会缩短数组，并重新循环以找到3个中位数。当中位数的集合（中位数的中位数的中位数……，依此类推）足够短时，你将选择它的最后一个元素作为下一个枢轴。
- en: Chapter 8
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章
- en: '**8.1  Good Enough Shuffling**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.1  足够好的洗牌**'
- en: 'This is the code I used when testing the functions for the book:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在为书籍测试函数时使用的代码：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The parameters for this logging are the shuffling function fn, the portion
    of the array to be shuffled (from, to), the size of the input array to use (n),
    and how many times to run the test ❶. An auxiliary function bar(...) ❷ draws a
    bar of pound characters: the maximum length is len for a val value that equals
    a maximum max value; smaller values get proportionally shorter bars. Use an object,
    result, to count how many times each permutation occurred ❸ (you could also use
    a JavaScript map). The max variable ❹ tracks the maximum number of times that
    any permutation appeared. You loop n times ❺, each time initializing an array
    to shuffle ❻. Use fn to shuffle the array, creating a string key out of the result
    ❼, and update the counts ❽ and maximum ❾ observed frequencies. The last step ❿
    returns the results in tabular form, with permutations ordered alphabetically
    for clarity.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 记录这些信息的参数包括洗牌函数fn，要洗牌的数组部分（from, to），使用的输入数组的大小（n），以及测试运行的次数❶。辅助函数bar(...)❷绘制一个由井号字符组成的条形图：最大长度为len，表示val值等于最大max值时的长度；较小的值会得到比例较短的条形。使用对象result来统计每个排列出现的次数❸（你也可以使用JavaScript的map）。max变量❹跟踪任何排列出现的最大次数。你会循环n次❺，每次初始化一个数组进行洗牌❻。使用fn来洗牌数组，基于结果创建字符串键❼，并更新出现的次数❽和最大观察频率❾。最后一步❿以表格形式返回结果，排列按字母顺序排序以便清晰查看。
- en: '**8.2  Random Three or Six**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.2  随机三或六**'
- en: 'Tossing two coins produces four combinations. You can assign numbers to those
    combinations, and if a combination numbered 1 to 3 occurs, accept it; if you get
    a 4, redo the throw:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 掷两次硬币会产生四种组合。你可以为这些组合分配数字，如果得到1到3的组合，就接受它；如果得到4，则重新掷一次：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This assigns numbers to combinations of coins using the binary system, calling
    heads a 0 and tails a 1\. Use the randomBit() function to produce bits ❶. You
    “throw” the die twice, and assign a number to the resulting combination ❷. Loop
    until you get a number from 0 to 2 ❸, and after getting it, map it to a result
    ❹.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法使用二进制系统为硬币的组合分配数字，将正面记作0，反面记作1。使用randomBit()函数生成比特❶。你“掷”骰子两次，并为结果组合分配一个数字❷。循环直到得到一个0到2之间的数字❸，然后将其映射到结果❹。
- en: 'To simulate a die, you’ll need three coin tosses, but the logic is quite similar:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟投骰子，你需要掷三次硬币，但逻辑非常相似：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Finally, simulating a 1 to 20 throw is trickier. You could use 5 bits, getting
    a result from 0 to 31 and discarding the 12 last values, but that would probably
    require several attempts; after all, a failure rate of 12 out of 32 is high. A
    better solution would be using 6 bits for a result of 0 to 63, discarding the
    last 4 (so, 0–59) and dividing the result by 3 to get a 0 to 19 result, with small
    odds (4 in 64) of needing a new attempt.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，模拟一个1到20的投掷更为复杂。你可以使用5个比特，得到一个0到31的结果，丢弃最后12个值，但这可能需要多次尝试；毕竟，32次中有12次失败率太高。一个更好的方法是使用6个比特，得到一个0到63的结果，丢弃最后4个（即0–59），然后将结果除以3，得到一个0到19的结果，这样只需要小几率（64次中4次）就能重新尝试。
- en: '**8.3  Not-So-Random Shuffling**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.3  非随机洗牌**'
- en: If this algorithm produced uniform shuffles, you’d expect each value in the
    original array to appear the same number of times at each position of the shuffled
    array. For the initial value to end at the last position, you need all randomBit()
    calls to come up true, so it’s far more likely that the initial value will end
    up not far from its starting position and only rarely appear in the last places.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个算法产生均匀的洗牌，你会期望原数组中的每个值在洗牌后的数组中每个位置出现相同的次数。为了让初始值出现在最后一个位置，你需要所有的randomBit()调用都返回true，因此初始值更可能不会离起始位置太远，而很少出现在最后的位置。
- en: '**8.4  Bad Swapping Shuffle**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.4  糟糕的交换洗牌**'
- en: 'The problem is that this code doesn’t generate every possible permutation with
    the same frequencies. You can see a hint of that by noticing that this code loops
    *n* times, choosing a random number with *n* possible values each time, so it
    has *n*¹ ways to run. However, a permutation generation algorithm should run in
    *n*! ways only. If you want to verify this by hand, try the algorithm for just
    three elements and simulate all 27 possible sequences of random numbers: from
    (0,0,0), which would shuffle ABC into CBA; (0,0,1), which shuffles ABC into BCA;
    and so on, up to (2,2,2), which produces CBA. Count how many times each possible
    permutation occurs, and you’ll see that some are more favored than others. The
    algorithm doesn’t produce an even distribution of shuffles.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，这段代码并没有以相同的频率生成所有可能的排列。你可以通过注意到这段代码循环 *n* 次，每次选择一个有 *n* 种可能值的随机数，从而看到这一点，因此它有
    *n*¹ 种运行方式。然而，排列生成算法应该仅以 *n*! 种方式运行。如果你想手动验证这一点，尝试只对三个元素执行该算法，并模拟所有 27 种可能的随机数字序列：从
    (0,0,0)，它将 ABC 洗牌为 CBA；(0,0,1)，它将 ABC 洗牌为 BCA；依此类推，一直到 (2,2,2)，它产生 CBA。计算每个可能的排列出现的次数，你会发现某些排列比其他排列更常见。该算法并没有生成均匀分布的洗牌。
- en: '**8.5  Robson’s Top?**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.5  Robson的顶端？**'
- en: 'The question is equivalent to finding out the largest factorial that can be
    calculated without losing precision. Using normal precision, this turns out to
    be 18; 19! is too long:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题等同于找出在不丢失精度的情况下能够计算的最大阶乘。使用正常精度时，这个值是 18；19! 太大了：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can test whether precision is lost by adding 1 and checking whether the
    result is changed; if you get the same result, it means that JavaScript hasn’t
    enough digits to accommodate your large number ❶.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过加 1 并检查结果是否变化来测试是否丢失了精度；如果结果没有变化，意味着 JavaScript 没有足够的位数来容纳你的大数字 ❶。
- en: 'However, you could use BigInt values, and then you’d be able to work with much
    higher values—as long as the size of a factorial doesn’t exceed the allowed memory.
    The following program will happily go past 19 until something crashes:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以使用 BigInt 值，那么你就能处理更高的值——只要阶乘的大小不超过允许的内存。以下程序将愉快地计算到 19 以上，直到某些地方崩溃：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The only difference here is that it’s using BigInt numbers: 1n is such a number.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是它使用了 BigInt 数字：1n 就是这样的一个数字。
- en: '**8.6  Sampling Testing**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.6  抽样测试**'
- en: 'The solution is quite similar to what we used for shuffling, with a special
    detail related to whether you’re doing sampling with or without repetition:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案与我们用于洗牌的方法非常相似，但有一个特别的细节，涉及到你是在进行有放回抽样还是无放回抽样：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When sampling without repetition, sample B-C-A is the same as sample C-A-B,
    so you sort the elements to get a unique key A-B-C. However, when sampling with
    repetition, the two results are different. The added parameter noReps ❶ solves
    this; when counting the sample, you sort values (or not) depending on it ❷.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行无放回抽样时，样本 B-C-A 和样本 C-A-B 是相同的，因此你需要对元素进行排序，以获得一个唯一的键 A-B-C。然而，当进行有放回抽样时，这两种结果是不同的。添加的参数
    noReps ❶ 解决了这个问题；在计数样本时，你会根据它来排序值（或不排序） ❷。
- en: '**8.7  Single-Line Repeater**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.7  单行重复器**'
- en: 'The following is a single statement but is shown here on several lines for
    clarity. You generate an array of the right size and use .map(...) to fill it
    with randomly chosen values:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个单一的语句，但为了清晰起见，这里将其分成几行展示。你生成一个合适大小的数组，并使用 .map(...) 填充随机选择的值：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The tricky part is that you need to use .fill(0) to put values in the array.
    If you don’t do this, .map(...) won’t do anything, because it skips uninitialized
    array locations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 棘手的部分是，你需要使用 .fill(0) 来填充数组中的值。如果不这样做，.map(...) 什么也不会做，因为它会跳过未初始化的数组位置。
- en: '**8.8  Sort to Sample**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.8  排序以进行抽样**'
- en: 'The following logic does the work:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下逻辑完成了这个工作：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This method of assigning random keys comes directly from the section “Shuffling
    by Sorting” on page 139 ❶. The logic that follows is a slight modification of
    the logic in “Selecting with Comparisons” on page 124 ❷, and the final code to
    leave just the original values is again from “Shuffling by Sorting” ❸.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分配随机键的方法直接来自第 139 页的“通过排序进行洗牌”部分 ❶。后续的逻辑是对第 124 页“通过比较进行选择”逻辑的轻微修改 ❷，最后的代码为了只留下原始值，再次来自“通过排序进行洗牌”
    ❸。
- en: '**8.9  Iterate, Don’t Recurse**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.9  迭代，不要递归**'
- en: 'To understand why this works, consider what the calls to other(...) will be
    and with which arguments. Applying the conversion to the factorial function produces
    the well-known equivalent:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么这样有效，考虑其他(...) 的调用是什么，以及使用哪些参数。将转换应用到阶乘函数上，产生了著名的等效形式：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Applying the conversion to Floyd’s algorithm is a bit trickier, because the
    function has two arguments (k and n), but since their difference is constant because
    they decrease in parallel, you can achieve the conversion. You’ll need to rename
    some variables to avoid confusion; for example, we’re already using i with another
    meaning in Floyd’s code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 将转换应用于Floyd算法稍微复杂一些，因为该函数有两个参数（k和n），但由于它们的差值是恒定的，因为它们是并行递减的，所以你可以实现转换。你需要重命名一些变量以避免混淆；例如，在Floyd的代码中我们已经使用了i来表示其他含义。
- en: '**8.10  No Limits?**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**8.10  没有限制？**'
- en: The check isn’t needed; initially toSelect is not greater than toConsider. If
    they ever become equal, from that point onward, all elements will be chosen, because
    the test Math.random() < toSelect / toConsider will always succeed for all random
    values less than 1, and toSelect will eventually become 0.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要检查；最初toSelect并不大于toConsider。如果它们变得相等，从此以后，所有元素都会被选中，因为测试Math.random() < toSelect
    / toConsider对于所有小于1的随机值总是成功的，且toSelect最终会变为0。
- en: Chapter 9
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章
- en: '**9.1  Searching Right**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**9.1  正确的搜索**'
- en: 'This is the code I used. The checkSearch(...) higher-order function takes a
    searching function to test and a boolean flag to indicate whether to use it with
    sorted or unsorted data. The actual files with data are called data32 and data_sorted_32:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我使用的代码。checkSearch(...)高阶函数接受一个搜索函数进行测试，并用一个布尔标志表示是使用已排序的数据还是未排序的数据。实际包含数据的文件叫做data32和data_sorted_32：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You use a sorted or unsorted set of data ❶ depending on the kind of algorithm.
    An auxiliary verify(...) function ❷ allows shorter code: the function tests whether
    the result matches what you expected ❸, throwing an error if not. For successful
    searches ❹, it displays the input and output. You try searching for every value
    in the input array ❺. You then find the minimum (m1) and maximum (m2) values of
    the array ❻ and then try all possible (invalid) searches ❼ from m1 - 3 to m2 +
    3; whenever a value isn’t included in the array ❽, you specifically try to find
    it, expecting to receive -1 as result ❾.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你根据算法的种类使用已排序或未排序的数据集 ❶。一个辅助的verify(...)函数 ❷可以让代码更简短：该函数测试结果是否与预期相符 ❸，如果不符，则抛出错误。对于成功的搜索
    ❹，它会显示输入和输出。你尝试搜索输入数组中的每个值 ❺。然后你找到数组的最小值（m1）和最大值（m2） ❻，接着尝试所有可能的（无效的）搜索 ❼，从m1
    - 3到m2 + 3；每当一个值不在数组中时 ❽，你特别尝试去找它，期望得到-1作为结果 ❾。
- en: '**9.2  JavaScript’s Own**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**9.2  JavaScript的自有方法**'
- en: The simplest solution would be array.findIndex(x => x === key).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的解决方案是array.findIndex(x => x === key)。
- en: '**9.3  Infinite Search Levels?**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**9.3  无限搜索层级？**'
- en: If levels tends to infinity, b will always become 2, and that means you split
    the search area in half at each step. You’ve rediscovered binary search! Roughly
    speaking, i takes the place of l in the iterative binary search code, and m is
    the difference between l and r.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果层数趋于无限，b将始终变为2，这意味着每一步都会将搜索区域一分为二。你重新发现了二分查找！大致来说，i取代了迭代二分查找代码中的l，m是l和r之间的差值。
- en: '**9.4  Exactly How Much?**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**9.4  到底多少？**'
- en: You can calculate the average number of tests by finding the sum of 1 × 1 +
    2 × 2 + 4 × 3 + 8 × 4 and so on, up to 2*^(n–)*¹ found in *n* questions, and dividing
    by the total number of searches, 2*^n* – 1\. We worked this out in section “Analysis
    of Algorithms in Practice” on page 55, and the sum equals (*n* + 1)2*^n* – (2*^n*^(+1)
    – 1)). Dividing, you get the average you wanted, which for large values of *n*
    is close to *n* – 1, so for any array length *k*, the answer is approximately
    log[2]*k* – 1.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过求和1 × 1 + 2 × 2 + 4 × 3 + 8 × 4等，直到2*^(n–)*¹，来计算测试的平均次数，这个测试出现在*n*个问题中，再将其除以总的搜索次数2*^n*
    – 1。我们在“实践中的算法分析”一节（第55页）中计算了这一点，结果和为(*n* + 1)2*^n* – (2*^n*^(+1) – 1))。除以后，你会得到你想要的平均值，对于大的*n*值，结果接近*n*
    – 1，因此，对于任何数组长度*k*，答案大约是log[2]*k* – 1。
- en: '**9.5  Three Tops Two?**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**9.5  三顶两个？**'
- en: 'When trying to decide in which third to keep searching, if the key is in the
    first third, you’ll be able to decide by asking a single question, and if it’s
    in the other two thirds, you’ll need to ask a second question: on average, you
    need 1 × 1/3 + 2 × 2/3 = 5/3 questions. Dividing the array by 3, you’ll have log[3]
    *n* search steps, compared to log[2] *n* steps with binary search. Given that
    log[3] *n* is approximately 0.631 log[2] *n*, the performance of ternary search
    is about 5/3 × 0.631, which equals 1.052 times that of binary search, which is
    practically the same.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当试图决定在数组的哪个三分之一继续搜索时，如果关键字位于第一个三分之一，你只需问一个问题即可决定；如果它位于其他两个三分之一，则需要问第二个问题：平均而言，你需要进行
    1 × 1/3 + 2 × 2/3 = 5/3 个问题。将数组分为三份，你将进行 log[3] *n* 次搜索步骤，而二分查找则需要 log[2] *n*
    步骤。由于 log[3] *n* 约等于 0.631 log[2] *n*，因此三分查找的性能大约是 5/3 × 0.631，即二分查找的 1.052 倍，实际上差别不大。
- en: '**9.6  Binary First**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**9.6  二分查找第一个**'
- en: 'The idea is if you find the key, instead of returning it, note the position
    and keep searching to the left:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个思路是，如果你找到了关键字，应该记下位置而不是立即返回，继续向左搜索：
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The code is the same as for binary search, with four differences. Initialize
    a result variable ❶ with the value that you’ll return at the end ❹. When you find
    the key, update this variable ❷, but instead of returning, keep searching to the
    left ❸ just in case the key occurs again.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与二分查找相同，只有四个不同之处。初始化一个结果变量 ❶，它将在最后返回 ❹。当你找到关键字时，更新此变量 ❷，但不是返回，而是继续向左搜索 ❸，以防关键字再次出现。
- en: To find the last position of key in arr ❸, write l = m + 1 to keep searching
    but to the right.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找 arr 中关键字的最后位置 ❸，将 l = m + 1，继续在右侧进行搜索。
- en: '**9.7  Count Faster**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**9.7  计数更快**'
- en: Use the solutions to the previous problem to find the first and last positions
    of the key in the array. Of course, if the first search returns -1, the count
    is 0 and you don’t have to do the second search.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面问题的解法来查找数组中关键字的第一个和最后一个位置。当然，如果第一次搜索返回 -1，则计数为 0，你就不需要进行第二次搜索。
- en: '**9.8  Rotation Finding**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**9.8  旋转查找**'
- en: 'You can use a variant of binary search for this, but it’s not exactly the same;
    there’s a careful detail to pay attention to:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用二分查找的变体来解决这个问题，但它不完全相同；这里有一个需要注意的细节：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You set up l and r as for binary search ❶. You’ll stop searching whenever you
    find that the value at l isn’t greater than the value at r ❷, and while that isn’t
    true, you’ll search in a half of the array. As in binary search ❸, m is the middle
    of the array. If the value at m is greater than the value at r ❹, the rotation
    is in the right part of the array, and the minimum must be at least at m + 1.
    Otherwise, the value at l must be greater than the value at m ❺, and here you
    must be very careful because the place of the rotation could be m itself! So,
    when the rotation is on the left, you don’t set r to m - 1, as in binary search,
    but rather to m. When you find that the value at l isn’t greater than the value
    at r ❻, l is the position you’re looking for.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你像二分查找一样设置了 l 和 r ❶。每当发现 l 处的值不大于 r 处的值时，你就会停止搜索 ❷，而在此条件不成立时，你会继续在数组的一半内搜索。和二分查找一样
    ❸，m 是数组的中间位置。如果 m 处的值大于 r 处的值 ❹，则旋转发生在数组的右侧，最小值必定至少出现在 m + 1 处。否则，l 处的值必定大于 m
    处的值 ❺，在这里你需要非常小心，因为旋转的位置可能就是 m 本身！因此，当旋转发生在左侧时，你不应像二分查找那样将 r 设置为 m - 1，而应将 r 设置为
    m。当你发现 l 处的值不大于 r 处的值时 ❻，l 就是你要找的位置。
- en: '**9.9  Special First**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**9.9  特殊的第一个**'
- en: 'No, you don’t need to. Assume that arr[0] === key:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 不，你不需要这样做。假设 arr[0] === key：
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the logic, i starts at 1 ❶; the loop exits immediately ❷ because key (arr[0])
    cannot be greater than arr[1]. The final binary search ❸ is done between 0 and
    1 and succeeds.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在逻辑中，i 从 1 开始 ❶；循环立即退出 ❷，因为关键字 (arr[0]) 不可能大于 arr[1]。最终的二分查找 ❸ 是在 0 和 1 之间进行的，并成功找到结果。
- en: Chapter 10
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章
- en: '**10.1  Iterating Through Lists**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.1  遍历列表**'
- en: 'To find the size of a list, initialize a pointer to the first element and follow
    the next pointers until you get to the end, counting each node you visit:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找列表的大小，初始化一个指针指向第一个元素，然后跟随下一个指针直到到达末尾，同时计数每个访问过的节点：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The count variable ❶ keeps a count of the elements. You’ll do a loop, starting
    at the head and advancing until reaching the end ❷, and you’ll update the count
    for each node ❸.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: count 变量 ❶ 用来记录元素的数量。你将进行一个循环，从头开始，直到遍历到末尾 ❷，并为每个节点更新 count ❸。
- en: 'Similar code is used to find whether a given value is found in a list:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似的代码来查找列表中是否存在给定的值：
- en: '[PRE34]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The logic of going down the list is the same as for count(...) ❶, and for each
    element you test whether it matches the desired value. If so, you return true
    ❷, and if you reach the end of the list without a match, you return false ❸.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历列表的逻辑与`count(...)` ❶相同，对于每个元素，你会测试它是否匹配所需的值。如果匹配，则返回true ❷，如果遍历到列表末尾都没有匹配，则返回false
    ❸。
- en: 'Adding an element is also a matter of advancing down the list until reaching
    either the end or the desired position:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个元素也是通过不断向列表下移，直到到达末尾或所需的位置：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, removing a given element also works with similar logic: go down the
    list until you reach the end of the list or the position you want to remove:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，移除指定元素的过程也遵循类似的逻辑：遍历列表直到遇到列表的末尾或你想移除的位置：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**10.2  Going the Other Way**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.2  反向操作**'
- en: 'The idea is that you go through the list, pushing each value into a stack,
    and the final list will be reversed:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个思路是，你遍历列表，将每个值推入栈中，最终列表会被反转：
- en: '[PRE37]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create the reversed list as a stack with newList as its pointer ❶, and use
    list to go element by element ❷ pushing it into the newList stack; you may want
    to draw a diagram of the pointer juggling that’s going on here ❸. At the end,
    return the reversed list ❹. A question for you: Does this algorithm also work
    for null lists?'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个以newList为指针的反转列表作为栈 ❶，使用list逐个元素地推入newList栈中 ❷；你可能需要画一个指针操作的示意图 ❸。最后，返回反转后的列表
    ❹。给你一个问题：这个算法也适用于空列表吗？
- en: '**10.3  Joining Forces**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.3  联手合作**'
- en: 'The idea is to look for the last element of the first list and link it to the
    head of the second list:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 思路是寻找第一个列表的最后一个元素，并将其连接到第二个列表的头部：
- en: '[PRE38]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: An interesting case is if the first list is empty ❶, the result of the operation
    is the second list. Otherwise, use ptr to go down the first list ❷, advancing
    while the end hasn’t been reached ❸. When reaching the end ❹, just modify its
    next pointer to point at the second list.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的情况是，如果第一个列表为空 ❶，操作的结果就是第二个列表。否则，使用ptr遍历第一个列表 ❷，在未到达末尾时一直向前 ❸。当到达末尾 ❹时，只需修改它的next指针，使其指向第二个列表。
- en: '**10.4  Unloop the Loop**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.4  解除环路**'
- en: 'You don’t need to store anything; just use two pointers. The idea is to advance
    down the list with two pointers, one a node at a time, and one at twice the speed.
    If the list doesn’t have a loop, the second will reach the end and you’re done.
    If the list has a loop, however, the two pointers will eventually meet (because
    the second moves faster than the first), and that means there’s a loop:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要存储任何东西，只需要使用两个指针。这个思路是，使用两个指针来遍历列表，一个每次移动一个节点，另一个以两倍的速度移动。如果列表没有环路，第二个指针将到达末尾，操作完成。如果列表有环路，两个指针最终会相遇（因为第二个指针的速度比第一个快），这就意味着存在环路：
- en: '[PRE39]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If the list is empty ❶, then for certain there’s no loop. Otherwise, ptr1 goes
    down the list a node at a time, and ptr2 advances two nodes at a time ❷. You’ll
    keep working unless ptr2 reaches the end or ptr2 reaches ptr1 ❸. During the iteration,
    ptr1 advances one node ❹ and ptr2 advances twice ❺ unless it reached the end.
    At the end, if ptr2 had reached ptr1, there’s a loop; otherwise, there isn’t.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表为空 ❶，那么肯定没有环路。否则，ptr1一次移动一个节点，ptr2则一次移动两个节点 ❷。你会继续操作，直到ptr2到达末尾或ptr2与ptr1相遇
    ❸。在迭代过程中，ptr1前进一个节点 ❹，ptr2则前进两个节点 ❺，除非它已经到达末尾。最终，如果ptr2与ptr1相遇，那么就说明有环；否则，没有环。
- en: '**10.5  Arrays for Stacks**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.5  栈的数组实现**'
- en: 'Given the .pop(...) and .push(...) methods, implementing a stack is straightforward:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有.pop(...)和.push(...)方法，实现一个栈是直接的：
- en: '[PRE40]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: A new stack is just an empty array ❶, and to check for an empty stack, you just
    see whether the array’s length is zero ❷. To push a new value ❸, use .push(...)
    and use .pop() ❹ to pop with a check for an empty stack. Finally, getting to the
    top of the stack is just a matter of looking at the last element of the array
    ❺.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的栈就是一个空数组 ❶，要检查栈是否为空，你只需查看数组的长度是否为零 ❷。要推入一个新值 ❸，使用.push(...)，使用.pop() ❹来弹出值，并检查栈是否为空。最后，查看栈顶元素，只需要查看数组的最后一个元素
    ❺。
- en: '**10.6  Stack Printing**'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.6  栈的打印**'
- en: 'Given the implementations of size(...) and find(...) in the first question
    for this chapter, you shouldn’t need further explanation for this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在本章第一个问题中已经实现了size(...)和find(...)方法，你应该不需要进一步的解释：
- en: '[PRE41]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**10.7  Height of a Stack**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.7  栈的高度**'
- en: 'You could implement this in *O*(*n*) time by using code similar to the code
    in the previous question, but a simpler solution is to add a height field to the
    stack definition initialized to zero and update that field appropriately when
    pushing or popping values. A stack would now be something more similar to a queue,
    in that an object is used instead of just a pointer:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用类似于上一题代码的代码在*O*(*n*)时间内实现这一点，但更简单的解决方案是向栈定义中添加一个高度字段，初始值为零，并在推入或弹出值时适当更新该字段。现在的栈更像是一个队列，因为它不仅仅是一个指针，而是使用了一个对象：
- en: '[PRE42]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**10.8  Maximum Stack**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.8  最大栈**'
- en: 'The idea is to push entries with two pieces of data: not only the value that’s
    being pushed, but also the current maximum, which depends on the value being pushed
    and the previous maximum, which was at the top of the stack before the push. To
    find the minimum, you’d push three pieces of data: the value to be pushed, the
    maximum at that time, and the minimum at the same time. This allows knowing the
    maximum or minimum at any moment, in *O*(1) time.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 该思路是推入包含两项数据的条目：不仅是正在推入的值，还有当前的最大值，这个最大值取决于正在推入的值和推入前栈顶的最大值。为了找到最小值，你需要推入三项数据：要推入的值、当时的最大值，以及当时的最小值。这使得你能够在任何时刻以*O*(1)的时间获取最大值或最小值。
- en: '**10.9  Queued Arrays**'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.9  队列数组**'
- en: This operation essentially requires the same implementation as for stacks, except
    that for entering a queue, use .unshift(...) instead of push(...), so new values
    are added at the beginning of the array instead of at the end.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作本质上需要与栈相同的实现，只不过对于进入队列的操作，使用.unshift(...)而不是push(...)，这样新值会被添加到数组的开头，而不是末尾。
- en: '**10.10  Queue Length**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.10  队列长度**'
- en: Trick question! Just apply the same logic as for question 10.9.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 哗啦！只需像处理第10.9题一样应用相同的逻辑即可。
- en: '**10.11  Queueing for Sorting**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.11  排序队列**'
- en: 'The following code does the work; it just rewrites the _radixSort(arr) function
    from the “Radix Sort” section on page 115, which sorts an input array:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码完成了这项工作；它只是重写了“基数排序”部分中第115页的_radixSort(arr)函数，该函数对输入数组进行排序：
- en: '[PRE43]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The differences in the code from that in Chapter 6 are highlighted. Instead
    of creating arrays for each bucket, set up queues ❶. For each value, after deciding
    which bucket it will go in ❷, make it enter the corresponding queue ❸. After distributing
    values into queues, go through each of them ❹ to generate an array.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 与第6章中的代码不同之处已被突出显示。不是为每个桶创建数组，而是设置队列❶。对于每个值，在决定它将进入哪个桶之后❷，将其放入相应的队列中❸。将值分配到队列中后，依次遍历每个队列❹以生成数组。
- en: '**10.12  Stacked Queues**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.12  堆叠队列**'
- en: 'As suggested, the idea is to use two stacks: say IN and OUT. Push the new value
    to the IN stack to enter the queue. Pop the OUT stack to exit the queue, but if
    it was empty, first pop all values from the IN stack, one at the time, and push
    them to OUT, before finally doing the pop. Every value that enters the queue will
    go through two pushes (first to IN and at a later time to OUT) and two pops (at
    some later time from IN and eventually from OUT), so the amortized cost of the
    operation is *O*(1). Obviously, some exit operations (those that find an empty
    OUT stack) will require more time.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如建议的那样，思路是使用两个栈：一个是IN栈，一个是OUT栈。将新值推入IN栈以进入队列。从OUT栈弹出以退出队列，但如果OUT栈为空，首先从IN栈弹出所有值，一次一个，并将它们推入OUT栈，最后再进行弹出。每个进入队列的值将经过两次推入（先推入IN，稍后推入OUT）和两次弹出（稍后从IN弹出，最终从OUT弹出），因此操作的摊销成本是*O*(1)。显然，某些退出操作（例如发现OUT栈为空的操作）将需要更多的时间。
- en: '**10.13  Palindrome Detection**'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.13  回文检测**'
- en: The idea is to split the string into separate characters and enter all the letters
    into a deque. When you’re done, repeatedly check whether the front element is
    the same as the last element, and exit them both. If you get down to zero elements
    (first is null) or just one (first equals last), the string was a palindrome.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 思路是将字符串拆分为单独的字符，并将所有字母进入一个双端队列。完成后，反复检查前面元素是否与最后一个元素相同，若相同则将它们都退出。如果剩下零个元素（第一个为空）或一个元素（第一个与最后一个相同），则该字符串是回文。
- en: '**10.14  Circular Listing**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.14  循环链表**'
- en: 'The following logic does the job:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以下逻辑完成这项工作：
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: First check for an empty circular list; if so, you don’t have to do anything
    ❶. Use ptr to go around the list ❷, printing each visited node ❸, advancing to
    the next ❹, and exiting the loop when reaching the initial node again ❺.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查循环链表是否为空；如果为空，你无需做任何事情❶。使用指针(ptr)遍历链表❷，打印每个访问的节点❸，向下一个节点移动❹，并在再次到达初始节点时退出循环❺。
- en: '**10.15  Joining Circles**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.15  连接圆环**'
- en: 'Manipulating links isn’t hard, but you have to be careful. Initially, you’ll
    have this scenario:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 操作链接并不困难，但你必须小心。最初，你会遇到这种情况：
- en: '![](../images/pg516-1.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg516-1.jpg)'
- en: 'And you’ll want to get to this situation:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望能达到这种情况：
- en: '![](../images/pg516-2.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg516-2.jpg)'
- en: 'Assuming that both circ1 and circ2 are not null, you need four lines of code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 circ1 和 circ2 都不是 null，你需要四行代码：
- en: '[PRE45]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: First, B follows N ❶. Set B so that N precedes it ❷. Similarly, J follows A
    ❸, and A precedes J ❹.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，B 跟随 N ❶。设置 B，使得 N 在它之前 ❷。类似地，J 跟随 A ❸，而 A 在 J 之前 ❹。
- en: Chapter 11
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第11章
- en: '**11.1  Sentinels for Searches**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**11.1  查找的哨兵**'
- en: 'If an ordered list includes a final +Infinity value, you can simplify the search
    because you know you’ll never get past the end:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有序列表包含一个最终的 +Infinity 值，你可以简化查找，因为你知道永远不会超出末尾：
- en: '[PRE46]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Compare this code to the code in the section “Searching for a Value*”* on page
    183; the first if is now simpler. (I agree that the speed gain may be minimal,
    but the technique is commonly used and worth knowing.)
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 将这段代码与第183页“查找一个值”部分的代码进行对比；第一个 if 语句现在更简单了。（我同意速度提升可能微乎其微，但这种技术是常用的，值得了解。）
- en: '**11.2  More Sentinels?**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**11.2  更多哨兵？**'
- en: An initial -Infinity value means that you’ll never add a new value at the beginning
    of the list, so essentially that makes the pointer to the head a constant. This
    extra sentinel makes iterative code simpler; you can check it out yourself.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的 -Infinity 值意味着你永远不会在列表的开头添加新值，因此本质上使得指向头部的指针成为常量。这个额外的哨兵使得迭代代码更简洁；你可以自己验证这一点。
- en: '**11.3  A Simpler Search?**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**11.3  更简单的查找？**'
- en: You could change the function to return either null (if the value wasn’t found)
    or a pointer to the value—which will just be the first in the list.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以修改函数，使其返回 null（如果没有找到值）或指向该值的指针——这将是列表中的第一个元素。
- en: '**11.4  Re-skipping Lists**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**11.4  重新跳过列表**'
- en: Start by deleting all pointers at levels other than the bottom one. Then, create
    level 1 by going through level 0 and choosing all elements at even positions;
    level 1 will end with about half the elements of level 0\. Redo this process to
    create level 2 based on elements at even positions in level 1; then, create level
    3 based on even positions in level 2, and so on. Stop when the topmost list has
    only one element.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 从删除除最底层外所有其他层的指针开始。然后，通过遍历第0层并选择所有偶数位置的元素来创建第1层；第1层将包含大约第0层的一半元素。重复此过程，根据第1层中偶数位置的元素创建第2层；然后，根据第2层中的偶数位置元素创建第3层，以此类推。当最顶层的列表只包含一个元素时停止。
- en: '**11.5  Skip to an Index**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**11.5  跳转到一个索引**'
- en: You want to be able to produce, say, the 229th value of a list without having
    to go one by one past the previous 228 values. To sketch the solution, you’ll
    define the “width” of a link as the number of values at the next level that are
    encompassed by the link. (In other words, how many nodes do you jump over by following
    the link?) You can create and update the widths when adding or removing values.
    All widths at the bottom level are 1\. At any level, if a link goes from node
    A to node B, the width of the link is the sum of all the widths from A (inclusive)
    to B (exclusive).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望能够得到一个列表中的第229个值，而不必逐一遍历前面228个值。为了解决这个问题，你将定义一个链接的“宽度”，即下一级中由该链接包含的值的数量。（换句话说，通过跟随链接你会跳过多少个节点？）你可以在添加或删除值时创建和更新宽度。底层所有的宽度都是1。在任何一层，如果一个链接从节点
    A 到节点 B，链接的宽度就是从 A（包含）到 B（不包含）之间所有宽度的总和。
- en: Knowing these widths makes it easy to find any given position. You start at
    the topmost level, going horizontally as long as the sum of widths doesn’t exceed
    the index you want. When this sum surpasses the index you want, you go down to
    the next level and keep going horizontally.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 知道这些宽度可以轻松找到任何给定的位置。你从最顶层开始，沿水平方向遍历，只要宽度的总和不超过你想要的索引。当这个总和超过你想要的索引时，你就下降到下一层，继续沿水平方向遍历。
- en: '![](../images/pg517.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg517.jpg)'
- en: For instance, in the diagram provided, say you want to find the 11th element
    of the list (the widths of links are in parentheses below each link). At the first
    level, the first three links cover 2 + 4 + 2 = 8 elements, so by following them
    in three steps, you’re already at the 8th element of the list. The next link is
    4, so that would go past the 11th, and you’d go down. The widths of the links
    there are all 1, so you advance a couple more times and find 40, the 11th value.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在提供的图表中，假设你要查找列表中的第11个元素（每个链接的宽度在其下方括号内标出）。在第一层，前面的三个链接覆盖了 2 + 4 + 2 = 8
    个元素，所以通过这三步操作，你已经到达了列表中的第8个元素。接下来的链接宽度是4，所以会超过第11个元素，你需要向下移动。那里的链接宽度都是1，所以你再移动几次，就找到了第11个值，即40。
- en: '**11.6  Simpler Filling**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**11.6  更简化的填充**'
- en: It would fill the array with a reference to the *same* list, instead of references
    to 100 distinct lists.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 它会用对*相同*列表的引用来填充数组，而不是对100个不同列表的引用。
- en: '**11.7  A Hashed Set**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**11.7  哈希集合**'
- en: For searches and removals, there’s no change whatsoever. For additions, the
    key is to keep searching until you either find the value (in which case you wouldn’t
    add it again) or reach an empty space. For efficiency, should you find an available
    slot during the search, make a note of it, and instead of adding the new value
    at the empty space, put it into the available slot.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 对于查找和删除操作，完全没有变化。对于添加操作，关键是继续搜索，直到你找到值（在这种情况下，你就不会再添加它）或找到一个空位。为了提高效率，如果在搜索过程中找到一个空位，记下它，而不是将新值放入空位中，而是将其放入可用的空位。
- en: '**11.8  Wrong Seating**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**11.8  错误的座位安排**'
- en: 'The key is to look at the problem in a different way. Instead of thinking that
    a person upon finding their seat occupied moves to some other random seat, imagine
    that *they* sit down and the previous occupant of the seat is the one who moves
    away. (In other words, the one who originally sat down in the wrong place.) By
    the time the 100th person enters, 98 people will be in their assigned seats, and
    the first person who entered the theater will be either in their seat or in the
    100th person’s seat—it depends on how the previous person moved with only two
    possible seats to choose: their seat or the 100th person’s seat. (If they had
    chosen any other seat, they would have had to move again when the rightful occupant
    of the seat appeared.) The answer is 50 percent.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是从不同的角度看待这个问题。不要认为当一个人发现自己的座位被占了时，他会去另一个随机座位，想象一下是*他们*坐下，而原先坐在座位上的人离开了（换句话说，最初坐错位置的人）。当第100个人进入时，98个人已经坐到了自己指定的座位，而最先进入剧院的人要么坐在自己的座位上，要么坐在第100个人的座位上——这取决于前一个人如何移动，只会选择两个座位之一：自己的座位或第100个人的座位。（如果他们选择了其他座位，当座位的
    rightful occupant 出现时，他们就必须再移动。）答案是50%。
- en: '**11.9  Progressive Resizing**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**11.9  渐进调整大小**'
- en: The idea is to work with both tables at the same time, gradually removing values
    from the old one and inserting them in the new one. After you decide you need
    to resize, create a new, larger table, and from then on, all insertions will go
    to the new table. Whenever you want to search for a value, look in both tables;
    a value in the old table may have already been moved to the new table. (The same
    applies to removals.) Every time you do an operation (add, remove, or search),
    remove some values from the old table and insert them into the new one. When every
    value has been removed from the old table, just work with the new one.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的思路是同时操作两个表，逐渐从旧表中移除值，并将它们插入新表。当你决定需要调整大小时，创建一个新的、更大的表，从此以后，所有的插入操作都会去新表中。每当你需要查找一个值时，要同时查看两个表；在旧表中的值可能已经被移动到新表中。（删除操作同样适用。）每当进行一次操作（添加、删除或查找），就从旧表中移除一些值，并将它们插入新表。当旧表中的所有值都被移除后，就只使用新表。
- en: Chapter 12
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第12章
- en: '**12.1  A Matter of Levels**'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.1  层次问题**'
- en: The height of a tree would be the highest level of its nodes.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 树的高度就是其节点的最高层级。
- en: '**12.2  Breaking the Rules**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.2  打破规则**'
- en: Symbolic links (symlinks) may point to any file or directory, so they allow
    you to break the tree structure.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 符号链接（symlinks）可以指向任何文件或目录，因此它们允许你打破树结构。
- en: '**12.3  What’s in a Name?**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.3  名字有什么含义？**'
- en: A *perfect tree* is complete and full. A *complete tree* isn’t necessarily perfect
    (the bottom need not be complete), and it may not be full either, because a node
    may have only one child—for example, a tree with just two nodes. Finally, a *full
    tree* may be neither complete nor perfect; see Chapter 13 for an example of this.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*完美的树*是完整且充满的。一个*完整的树*不一定是完美的（底部不一定完整），并且它可能也不充满，因为一个节点可能只有一个孩子——例如，一个只有两个节点的树。最后，一个*充满的树*可能既不是完整的也不是完美的；具体示例见第13章。
- en: '**12.4  A** **find()** **One-Liner**'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.4  一个** **find()** **单行代码**'
- en: 'Using the ternary operator, you can make do as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三元运算符，你可以按如下方式进行：
- en: '[PRE47]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Because of space restrictions, this appears as several lines of text, but it’s
    a single statement in any case.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 由于空间限制，这里显示为多行文本，但无论如何，它都是一个单一的语句。
- en: '**12.5  Sizing a Tree**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.5  树的大小**'
- en: 'Given the definition that an empty tree has size 0 and that, otherwise, the
    size of a tree is 1 (for the root) plus the sizes of both subtrees, you can write
    a one-liner solution for this:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，如果树为空则大小为 0，否则，树的大小是 1（根节点）加上左右子树的大小，你可以写出一个单行的解决方案：
- en: '[PRE48]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '**12.6  Tall as a Tree**'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.6  像树一样高**'
- en: 'The height of a tree is the maximum length of a path from the root to a leaf.
    So, if you know the heights of both subtrees of the root, the height of the complete
    tree will be one more than the height of the highest subtree. You can program
    this very simply using recursion:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 树的高度是从根节点到叶子节点的最长路径长度。所以，如果你知道根节点的左右子树的高度，那么完整树的高度将是最高子树高度加 1。你可以使用递归非常简单地编写这个程序：
- en: '[PRE49]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '**12.7  Copy a Tree**'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.7  复制一棵树**'
- en: 'Recursion is the best solution: a copy of an empty tree is just an empty tree,
    and a copy of a nonempty tree is built out of the tree’s root, plus copies of
    its left and right subtrees:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是最好的解决方案：空树的副本就是空树，而非空树的副本是由树的根节点以及它的左右子树的副本构成的：
- en: '[PRE50]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can also build a copy another way, which should remind you of a postorder
    traversal:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以用另一种方式构建一个副本，这应该会让你想起后序遍历：
- en: '[PRE51]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If the tree to copy is null ❶, nothing needs to be done. Otherwise, first make
    a copy of the left subtree ❷, then a copy of the right subtree ❸, and finally,
    build a tree out of the tree’s key plus the two newly created trees ❹.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要复制的树为空 ❶，则无需任何操作。否则，首先复制左子树 ❷，然后复制右子树 ❸，最后，根据树的键以及两个新建的树来构建新的树 ❹。
- en: '**12.8  Do the Math**'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.8  做数学运算**'
- en: 'You need a postorder traversal for this, because before applying any operator,
    you need to know the value of its left and right subexpressions. You can do this
    with a function, since a whole class would be overkill:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个后序遍历来完成这个任务，因为在应用任何运算符之前，你需要知道左右子表达式的值。你可以通过一个函数来实现这个操作，因为整个类可能会显得过于繁重：
- en: '[PRE52]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If the tree is empty ❶, you return 0, a reasonable value. Otherwise, if the
    root is a number ❷, just return that number, and if the root is an operator ❸
    ❹ ❺ ❻, use recursion to evaluate both sides of the expression and return the calculated
    value. You also add a “catch-all” for any unexpected input ❼.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果树为空 ❶，返回 0，这是一个合理的值。否则，如果根节点是一个数字 ❷，直接返回该数字。如果根节点是一个运算符 ❸ ❹ ❺ ❻，使用递归来计算表达式两侧的值并返回计算结果。你还需要为任何意外输入添加一个“通配符”
    ❼。
- en: 'A simple example shows this at work:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子展示了这个方法：
- en: '[PRE53]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This code returns 30, as expected. Can you figure out why I didn’t include null
    pointers?
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码返回 30，正如预期的那样。你能猜出为什么我没有包含空指针吗？
- en: '**12.9  Making It Bad**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.9  使其变坏**'
- en: You never want to have a node with two children, so the root must be either
    the minimum or the maximum of the set of keys. After that, the following key must
    also have a single child, so it must be either the minimum or the maximum of the
    remaining set of keys. If you follow this logic to the end, you have two options
    for the first key, times two options for the second key, times two options for
    the third key, and so on, up until the (*n* – 1) key, after which a single option
    is left. The number of linear trees you can produce out of *n* keys is then 2*^n*
    ^(–1).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 你永远不想有一个有两个孩子的节点，因此根节点必须是键集中的最小值或最大值。之后，接下来的键也必须只有一个孩子，因此它必须是剩余键集中的最小值或最大值。如果按照这个逻辑一直推导下去，你会得到第一个键有两个选择，第二个键也有两个选择，第三个键同样如此，直到第(*n*
    – 1)个键，之后只剩一个选择。你可以从 *n* 个键中生成的线性树的数量是 2*^n* ^(–1)。
- en: '**12.10  Rebuild the Tree**'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.10  重建树**'
- en: Given the preorder and inorder lists, it’s clear that the root of the tree must
    be the first value in the preorder. If you look for that value in the inorder
    list, all keys preceding it will come from the root’s left subtree and all keys
    after it will be from the right subtree. Separate the preorder list in two, and
    you’ll have the preorder and inorder listings for both subtrees; apply recursion,
    and you’ll build the tree.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 给定前序和中序列表，很明显，树的根节点必须是前序列表中的第一个值。如果你在中序列表中查找这个值，那么它前面的所有键将来自根节点的左子树，而它后面的所有键将来自右子树。将前序列表分成两部分，你就得到了两个子树的前序和中序遍历顺序；应用递归，你就能构建出这棵树。
- en: '**12.11  More Rebuilding?**'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.11  更多的重建？**'
- en: Working with inorder and postorder would be possible; the only difference is
    that you’d find the root at the end of the postorder listing instead of at the
    beginning of the preorder listing. However, working with preorder and postorder
    isn’t possible—and an example should suffice to show why. If I tell you that the
    preorder listing was “1, 2” and the postorder listing was “2, 1”, two possible
    binary search trees produce those listings. Can you find them?
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 使用中序和后序遍历是可能的；唯一的区别是，你会在后序列表的末尾找到根节点，而不是在前序列表的开头。然而，使用前序和后序遍历则不可能——一个例子就足以说明为什么。如果我告诉你前序遍历的顺序是“1,
    2”，而后序遍历的顺序是“2, 1”，那么有两棵可能的二叉搜索树会产生这些遍历顺序。你能找到它们吗？
- en: '**12.12  Equal Traversals**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.12  相等的遍历**'
- en: Preorder and inorder would be the same if there were no left trees, so the first
    answer is “trees with only right subtrees”; for inorder and postorder, the answer
    would similarly be “trees with only left subtrees.” Finally, for preorder and
    postorder, the answer is “trees with no more than one key.”
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有左子树，则前序和中序遍历将是相同的，因此第一个答案是“只有右子树的树”；对于中序和后序遍历，答案类似地是“只有左子树的树”。最后，对于前序和后序遍历，答案是“最多只有一个键的树”。
- en: '**12.13  Sorting by Traversing**'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.13  通过遍历进行排序**'
- en: First, add all the keys into a binary search tree, create an empty array, and
    then do an inorder traversal providing a visit function that will push the key
    value into the array. (You’ll use this technique later in question 12.26.)
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将所有的键值插入到二叉搜索树中，创建一个空数组，然后进行中序遍历，提供一个访问函数，将键值推入数组中。（你将在第12.26题中使用这个技术。）
- en: '**12.14  Generic Order**'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.14  通用顺序**'
- en: 'The following code will do. Note the two recursive calls mixed with the three
    possible visit() calls:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以实现。注意，代码中有两个递归调用和三个可能的visit()调用：
- en: '[PRE54]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '**12.15  No Recursion Traversal**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.15  无递归遍历**'
- en: Use a stack from Chapter 11. You could do specific solutions for each of the
    traversals, but let’s go with a generic solution (actually implementing the anyOrder()
    function from earlier) to highlight how a stack makes avoiding recursion easy.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第11章的栈。你可以为每种遍历方式做具体的解决方案，但我们选择一种通用的解决方案（实际上是实现之前的anyOrder()函数），来展示栈如何让避免递归变得简单。
- en: 'The idea is that you’ll push into the stack the pending operations, which can
    be of two types: visit a key (type "K") or traverse a tree (type "T"). You’ll
    push these operations, and the main code will be a loop that will pop an operation
    and do it, which may imply visiting or traversing, and the latter will cause more
    operations to be pushed in:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 其思路是将待处理的操作推入栈中，这些操作有两种类型：访问一个键（类型“K”）或遍历一棵树（类型“T”）。你将这些操作推入栈中，主代码将是一个循环，弹出一个操作并执行它，这可能意味着访问或遍历，而遍历则会导致更多的操作被推入栈中：
- en: '[PRE55]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Start by creating a stack and pushing the tree you want to traverse ❶. While
    there are pending operations ❷, you’ll pop the top one ❸, and if it doesn’t point
    to an empty tree ❹, you’ll execute whatever is needed. If the operation was a
    "K", just visit the node ❺, and if it was a "T" ❻, you’ll have to push two operations
    (traverse the left and right subtrees) and a visit (for the root). The key point
    is to make sure to push them in backward order, so the operations will be popped
    in the right sequence; study this carefully. For instance, if you are doing a
    postorder traversal, you’ll first push the root visit, then the right subtree
    traversal, and finally the left subtree traversal—and when you do those operations
    in reverse order, everything will come out right.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个栈并压入你想遍历的树 ❶。当还有待处理的操作 ❷ 时，你将弹出栈顶操作 ❸，如果它不指向空树 ❹，你将执行所需操作。如果操作是 "K"，则只访问该节点
    ❺；如果操作是 "T" ❻，你需要压入两个操作（遍历左子树和右子树）和一个访问操作（对于根节点）。关键是确保按照反向顺序压入操作，这样操作将按正确的顺序弹出；仔细研究这一点。例如，如果你正在进行后序遍历，你将首先压入根节点访问操作，然后是右子树遍历，最后是左子树遍历——当你按反向顺序执行这些操作时，一切都会正确无误。
- en: '**12.16  No Duplicates Allowed**'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.16  不允许重复**'
- en: 'Basically, you just have to check whether you have arrived at the value you
    were thinking of adding:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，你只需要检查是否到达了你想要添加的值：
- en: '[PRE56]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You add a test for equality before continuing the search ❶, and the other minor
    change is that you don’t test for “less-than-or-equal-to” ❷, because the key can
    never be equal.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续搜索之前，添加一个相等性测试 ❶，另一个小变化是你不再测试“小于或等于” ❷，因为键值永远不能相等。
- en: '**12.17  Get and Delete**'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.17  获取并删除**'
- en: 'You can manage to get the minimum and remove it at the same time, if after
    finding the minimum value in the (not empty) tree, you copy its right subtree
    to the node; see the following diagram for an example:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以同时获取最小值并将其删除，如果在（非空）树中找到最小值后，将其右子树复制到该节点；参考以下示例图：
- en: '![](../images/pg524.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg524.jpg)'
- en: 'Here’s how to implement this algorithm:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是实现这个算法的方法：
- en: '[PRE57]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Assuming that the tree isn’t empty, if you cannot go to the left, return the
    right tree and the node’s key, and you’re done ❶. Otherwise, recursively get and
    remove the minimum key from the left subtree ❷ and return the updated tree node
    and the found key ❸.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 假设树不为空，如果不能向左走，则返回右子树和节点的键，操作完成 ❶。否则，递归获取并删除左子树中的最小键 ❷，并返回更新后的树节点和找到的键 ❸。
- en: 'How do you use it? The change in remove() is small, affecting only one line:
    instead of first finding the minimum key and then removing it, make a single call
    to _removeMin():'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使用它？`remove()` 方法中的变化很小，只影响一行代码：不再先找到最小键再删除，而是直接调用 _removeMin()：
- en: '[PRE58]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '**12.18  AVL Worst**'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.18  AVL最差情况**'
- en: 'Suppose H*n* is the number of nodes in the worst possible AVL tree of height
    *n*. The first few such trees are the following:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 H*n* 是最差情况下，具有高度 *n* 的AVL树中节点的数量。前几个这样的树如下所示：
- en: '![](../images/pg525.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg525.jpg)'
- en: 'Build the next worst tree out of the previous two (plus a root), so H[*n*]
    equals H[*n–*][1] + H[*n–*][2] + 1: the sequence is 0, 1, 2, 4, 7, 12, 20, . .
    . , which is one less than the Fibonacci sequence 1, 2, 3, 5, 8, 13, 21, . . .'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 从前两个树（加上根节点）构建下一个最差树，因此 H[*n*] 等于 H[*n–*][1] + H[*n–*][2] + 1：序列为 0, 1, 2, 4,
    7, 12, 20, . . . ，比斐波那契序列 1, 2, 3, 5, 8, 13, 21, . . . 少 1。
- en: '**12.19  Singles Only**'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.19  仅限单一**'
- en: Given the structure restrictions of AVL trees, only a leaf can be a single child.
    Since every single child has one parent and there may be more (not single) nodes
    in the tree, single children cannot be more than 50 percent of all nodes.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于AVL树的结构限制，只有叶子节点可以是单个子节点。由于每个单个子节点都有一个父节点，而树中可能有更多（非单个）节点，因此单个子节点不能超过所有节点的50%。
- en: '**12.20  Why One?**'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.20  为什么是一个？**'
- en: If the subtrees have sizes *p* and *q*, the tree’s size is *p* + *q* + 1, so
    the fractions are (*p* + 1) / (*p* + *q* + 2) and (*q* + 1) / (*p* + *q* + 2),
    and adding the numerators together produces exactly (*p* + *q* + 2), which is
    the denominator.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子树的大小分别为 *p* 和 *q*，则树的大小为 *p* + *q* + 1，分数分别是 (*p* + 1) / (*p* + *q* + 2)
    和 (*q* + 1) / (*p* + *q* + 2)，将分子相加得到正好是 (*p* + *q* + 2)，即分母。
- en: '**12.21  Easier Randomizing?**'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.21  更容易随机化？**'
- en: The developer is correct in that an ordered sequence of keys would become disordered,
    but a disordered sequence of keys would also exist that would become ordered after
    hashing, so while solving the problem of ordered additions, this technique wouldn’t
    completely solve the worst-case problem.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员正确地指出，顺序排列的键会变得无序，但也会存在一种无序的键序列，在哈希之后会变得有序，因此，虽然这个技术解决了有序添加的问题，但它并不能完全解决最坏情况的问题。
- en: '**12.22  Why Not Decrement?**'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.22  为什么不减少？**'
- en: If the key you want to delete isn’t in the tree, you’d still (wrongly) decrement
    the node size.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想删除的键不在树中，你仍然（错误地）会减少节点的大小。
- en: '**12.23  Bad Splay?**'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.23  错误的伸展树？**'
- en: If you only add keys, you’ll get the same linear structure as for common binary
    search trees. However, after a few removals, the height of the tree is considerably
    lowered (and the tree becomes more “bushy”), while for common binary search trees,
    the shape would still be linear.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仅添加键，你将得到与常见的二叉搜索树相同的线性结构。然而，经过几次删除操作后，树的高度会显著降低（树变得更加“丛生”），而对于常见的二叉搜索树，形状仍然是线性的。
- en: '**12.24  What Left Subtree?**'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.24  什么左子树？**'
- en: It should be null. The minimum key in a tree has no left subtree; otherwise,
    it wouldn’t be the minimum.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该是空的。树中的最小键没有左子树；否则，它就不可能是最小的。
- en: '**12.25  Code Transformation**'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.25  代码转换**'
- en: When you splay the tree with reference to a key, you end with a tree that has
    at its root the closest value to the given key, so if the key is -Infinity (assuming
    keys are numeric; an empty string would do for alphabetic keys), you can deduce
    that _splay(tree, -Infinity) produces the same result as _splayMinimum(tree).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当你根据一个键来伸展树时，最终的树将以最接近给定键的值为根，因此，如果键是 -Infinity（假设键是数字；对于字母键，空字符串也可以），你可以推断出
    _splay(tree, -Infinity) 产生的结果与 _splayMinimum(tree) 相同。
- en: 'But you can go further. Take the _splay() code and assume keyToUp is -Infinity,
    a value that cannot be in the tree and that is smaller than all current keys.
    The highlighted parts in the code that follows can then be omitted, either because
    the result is already known or because it’s unreachable code:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以进一步处理。假设将 _splay() 代码中的 keyToUp 设置为 -Infinity，这个值不可能出现在树中，并且比当前所有的键都要小。以下代码中高亮部分可以省略，因为结果已经可以得知，或者是无法访问的代码：
- en: '[PRE59]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The keyToUp parameter isn’t needed ❶ ❻, since you are assuming its value. Tests
    for equality will always fail ❷ ❹. Since keyToUp is smaller than any key, the
    side variable will always end with "left" ❸, and the test at ❺ will always succeed,
    making some code ❼ unreachable.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: keyToUp 参数不需要 ❶ ❻，因为你已经假设了它的值。平等测试将始终失败 ❷ ❹。由于 keyToUp 小于任何键，side 变量将始终以“left”结尾
    ❸，并且 ❺ 处的测试将始终成功，使得某些代码 ❼ 无法访问。
- en: 'After these simplifications, renaming _splay to _splayMin and changing tree[side]
    to tree.left leaves the following code:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些简化后，将 _splay 重命名为 _splayMin，并将 tree[side] 改为 tree.left，留下如下代码：
- en: '[PRE60]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Transforming this code to _splayMinimum() is easy now: join the two if statements
    into one by combining their tests, and you’re done.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将这段代码转换为 _splayMinimum() 很容易：将两个 if 语句合并成一个，并完成测试。
- en: '**12.26  Full Rebalance**'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**12.26  完全重平衡**'
- en: 'The idea is to get all the keys using the technique suggested in question 12.13
    and produce a well-balanced tree, splitting the array in the middle. The key there
    will be the root for the balanced tree, the keys to its left will be used to produce
    the left subtree, and likewise for the keys to its right:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这个思路是使用第12.13题中建议的技术来获取所有的键，并生成一个平衡的树，方法是将数组从中间拆分。这里的键将成为平衡树的根，根左边的键用于生成左子树，右边的键则用于生成右子树：
- en: '[PRE61]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Start with the rebalancing code, _buildPerfect() ❶. Given an array of keys,
    if the array is empty ❷, a null tree is returned. Otherwise ❸, find the array’s
    middle point ❹ and return a node as described earlier ❺; use recursion to build
    its balanced subtrees. The restructure() function ❻ is then quite short: generate
    an ordered list of keys using inOrder() ❼ and pass it to the _buildPerfect() function
    to produce the final output ❽.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 从重平衡代码开始，_buildPerfect() ❶。给定一个键的数组，如果数组为空 ❷，则返回空树。否则 ❸，找到数组的中间点 ❹，并返回一个如前所述的节点
    ❺；使用递归构建其平衡的子树。接下来，restructure() 函数 ❻ 就非常简短：使用 inOrder() ❼ 生成一个有序的键列表，并将其传递给 _buildPerfect()
    函数，以产生最终的输出 ❽。
- en: '## Chapter 13'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '## 第13章'
- en: '**13.1  Missing Test?**'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.1  缺少测试？**'
- en: No need; addChild() already does it.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要；addChild() 已经处理了这部分。
- en: '**13.2  Traversing General Trees**'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.2  遍历一般树**'
- en: Implementation is not complex. If the tree is represented using arrays of children,
    preorder traversal for a nonempty tree entails visiting the root and then sequentially
    traversing each child. For a tree represented in a left-child, right-sibling style,
    the logic starts by visiting the root and then, starting at the first child, traversing
    it and moving to the next sibling until no more siblings are left. In both cases,
    postorder traversal first starts with the children and visits the root only after
    that.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 实现并不复杂。如果树是通过子节点数组来表示的，非空树的先序遍历需要先访问根节点，然后顺序遍历每个子节点。对于采用左孩子右兄弟表示法的树，逻辑是先访问根节点，然后从第一个子节点开始，遍历该子节点并移动到下一个兄弟节点，直到没有更多的兄弟节点。在这两种情况下，后序遍历首先访问子节点，最后访问根节点。
- en: '**13.3  Nonrecursive Visiting**'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.3 非递归访问**'
- en: 'The solution is quite similar to the breadth-first queue version:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 该解决方案与广度优先队列版本非常相似：
- en: '[PRE62]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'As in other traversals, if the tree is empty, you don’t do anything ❶. Otherwise,
    you create a stack and push the tree’s root into it ❷. Then, you do a loop. While
    the stack isn’t empty ❸, pop the stack top ❹ and visit it, and then finish with
    this tricky detail: you must push all the children in *reverse* order (the rightmost
    first, the leftmost last), so the first child is visited first ❺. Be careful using
    reverse() because it modifies the array, so build a copy using destructuring.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他遍历一样，如果树为空，你不需要做任何操作 ❶。否则，你创建一个栈，并将树的根节点压入栈中 ❷。然后，你执行一个循环。当栈不为空时 ❸，弹出栈顶元素
    ❹ 并访问它，然后完成这个棘手的细节：你必须按 *反向* 顺序推送所有子节点（最右侧的节点先推，最左侧的节点最后推），这样第一个子节点会先被访问 ❺。使用
    reverse() 时要小心，因为它会修改原数组，所以需要使用解构赋值创建一个副本。
- en: '**13.4  Tree Equality**'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.4 树的相等性**'
- en: 'You could do some recursive logic to compare trees, but a simpler solution
    exists: use JSON.stringify() to produce string versions of both trees and compare
    them.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过递归的逻辑来比较树，但有一个更简单的解决方案：使用 JSON.stringify() 生成两个树的字符串版本并进行比较。
- en: '**13.5  Measuring Trees**'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.5 测量树**'
- en: 'The code is similar to what was used for binary trees in Chapter 12:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码与第 12 章中用于二叉树的代码类似：
- en: '[PRE63]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: An empty tree has size 0 ❶; otherwise, its size is 1 (for the root itself) plus
    the sum of the sizes of all its subtrees ❷, which you can calculate using .reduce().
    Then, for height, an empty tree has height 0 ❸, a leaf has height 1 ❹, and other
    trees have height 1 (for the root) plus the tallest height of any of its subtrees
    ❺.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 空树的大小为 0 ❶；否则，它的大小为 1（根节点本身）加上所有子树大小的总和 ❷，你可以通过 .reduce() 来计算。然后，对于高度，空树的高度为
    0 ❸，叶子节点的高度为 1 ❹，其他树的高度为 1（根节点）加上任意子树的最大高度 ❺。
- en: '**13.6  Sharing More**'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.6 更多的共享**'
- en: In the implementation, since we borrowed only a single key from a sibling, we
    made do with simple code. To share half and half, you should set up an array with
    all the keys from the left sibling, plus the key of the parent, plus all the keys
    in the right sibling, and divide it. The key at the middle position will go into
    the parent, all the keys to its left to the left sibling, and all the keys to
    its right to the right sibling—and a similar procedure will apply to the pointers
    in the nodes.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现中，由于我们只从兄弟节点借用了一个键，所以代码比较简单。如果要均分，你应该设置一个数组，包含来自左兄弟的所有键、父节点的键和右兄弟的所有键，然后将其分配。中间位置的键将进入父节点，左侧的所有键进入左兄弟，右侧的所有键进入右兄弟——对于节点中的指针，也会应用类似的过程。
- en: '**13.7  Faster Node Searching**'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.7 更快的节点搜索**'
- en: 'The binary search algorithm from Chapter 9 ends, upon a search failure, with
    the left index pointing at the link you should follow; check this out. Here’s
    the code:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 第 9 章中的二分查找算法，在搜索失败时，会让左索引指向应该跟随的链接；查看此代码：
- en: '[PRE64]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The algorithm is the standard one you already saw; the difference is that if
    the search fails, it returns the left pointer. As to the effect on the B-tree
    performance, the search in the node sped up by a constant factor (if the order
    of the B-tree is *p*, instead of *p* tests, we do log *p* tests), but the general
    order of algorithms remains *O*(log *n*).
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法是你之前看到的标准算法；不同之处在于，如果搜索失败，它会返回左指针。至于对 B 树性能的影响，节点内的搜索通过一个常数因子加速（如果 B 树的阶为
    *p*，那么我们执行 log *p* 次测试，而不是 *p* 次），但算法的总体时间复杂度仍然是 *O*(log *n*)。
- en: '**13.8  Lowest Order**'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.8 最低阶**'
- en: Nodes other than the root in a B-tree of order 2 should have one key and thus
    two children, so that implies a full binary tree since all leaves must be at the
    same level. So, yes, you already knew about B-trees of order 2!
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个2阶B树中，根节点以外的节点应该有一个键值，因此有两个子节点，这意味着它是一个完全二叉树，因为所有叶子节点必须位于同一层级。所以，是的，你已经了解了2阶B树！
- en: '**13.9  Many Orders of Trees**'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.9  多种树的顺序**'
- en: By default, modules are singletons, which means that the code is imported only
    once, so all trees that you create would share the same ORDER variable. If you
    want to have different variables, instead of exporting an object with many properties
    (in module.exports), you need to export a function that, when invoked, returns
    the desired object. You can see some examples of this transformation in Iain Collins’s
    “How (Not) to Create a Singleton in Node.js” at *[https://medium.com/@iaincollins/how-not-to-create-a-singleton-in-node-js-bd7fde5361f5](https://medium.com/@iaincollins/how-not-to-create-a-singleton-in-node-js-bd7fde5361f5)*.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，模块是单例模式，这意味着代码只会被导入一次，因此你创建的所有树都会共享相同的ORDER变量。如果你想要不同的变量，而不是导出一个包含多个属性的对象（在module.exports中），你需要导出一个函数，该函数在调用时返回所需的对象。你可以在Iain
    Collins的《如何（不）在Node.js中创建单例》一文中看到一些此类转换的例子，链接为*[https://medium.com/@iaincollins/how-not-to-create-a-singleton-in-node-js-bd7fde5361f5](https://medium.com/@iaincollins/how-not-to-create-a-singleton-in-node-js-bd7fde5361f5)*。
- en: '**13.10  Safe to Delete?**'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '**13.10  可以删除吗？**'
- en: When you get to delete a node with no right child, the root was red, implying
    it would have no left child. If the root had been black (the other possibility,
    considering the invariant), its left child would have been red, and you would
    have rotated *it* right, so it wouldn’t then have an empty right child.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 当删除一个没有右子节点的节点时，根节点为红色，意味着它将没有左子节点。如果根节点是黑色的（考虑到不变性，这是另一种可能性），那么它的左子节点会是红色的，你会将*它*右旋，这样它就不会有空的右子节点了。
- en: Chapter 14
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第14章
- en: '**14.1  Is It a Heap?**'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.1  它是一个堆吗？**'
- en: 'Simply loop through all the elements except the root and check that each is
    not greater than its parent. A first implementation could be:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地遍历所有根节点之外的元素，并检查每个元素是否不大于其父节点。一个初步实现可能是：
- en: '[PRE65]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You can also use .every() to shorten the code and make it more declarative:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 .every() 来简化代码，使其更加声明式：
- en: '[PRE66]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '**14.2  Making Do with Queues**'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.2  队列的应用**'
- en: If you assign monotonically ascending values to the elements you enter in a
    priority queue, it will behave like a stack in a last-in, first-out (LIFO) way.
    Similarly, if you assign monotonically descending values to elements, the priority
    queue will emulate a common queue.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为进入优先队列的元素分配单调递增的值，优先队列将表现得像栈一样，遵循后进先出（LIFO）方式。类似地，如果为元素分配单调递减的值，优先队列将模拟一个常规队列。
- en: '**14.3  Max to Min**'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.3  最大到最小**'
- en: This is a trick question! Using Floyd’s enhanced heap-building code, you can
    transform *any* array into a min heap in linear time, so you obviously can convert
    a max heap into a min heap in this time.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 trick 问题！使用Floyd改进的堆构建代码，你可以在线性时间内将*任何*数组转换为最小堆，因此显然你可以在这个时间内将一个最大堆转换为最小堆。
- en: '**14.4  Max or Min**'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.4  最大或最小**'
- en: 'Only three code changes are needed: one in the _bubbleUp() function and two
    in the _sinkDown() function. Invert the current comparisons from heap[a] > heap[b]
    to heap[a] < heap[b] and you’re done.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要三处代码更改：在_bubbleUp()函数中进行一次更改，在_sinkDown()函数中进行两次更改。将当前比较从heap[a] > heap[b]反转为heap[a]
    < heap[b]，这样就完成了。
- en: '**14.5  Merge Away!**'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.5  合并吧！**'
- en: The needed algorithm works as follows. Create a min heap whose nodes will be
    nodes from the lists. Initialize the heap by taking the first element of each
    list. Initialize an empty output list. Repeatedly, while the heap isn’t empty,
    pick the node corresponding to the root of the heap and remove it from the heap.
    Add the selected node to the output list. If the selected node had a next node,
    add it to the heap.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的算法如下：创建一个最小堆，其节点将来自各个列表。通过取每个列表的第一个元素来初始化堆。初始化一个空的输出列表。在堆不为空时，反复执行以下步骤：选择堆根节点对应的节点，并将其从堆中移除。将选中的节点添加到输出列表。如果选中的节点有下一个节点，将其添加到堆中。
- en: 'Assuming the nodes have key and next fields, the code (based on the heap developed
    in this chapter, but inverting some comparisons to produce a min heap as in question
    14.4) could be as follows:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 假设节点具有键值和下一个字段，代码（基于本章开发的堆，但通过反转一些比较以产生一个最小堆，如问题14.4所示）可能如下所示：
- en: '[PRE67]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The add() method pushes a node into the stack (unless it’s null) and bubbles
    it up ❶. The complete logic requires setting up the heap with the first element
    of each list ❷ to then do the merging. Adding an empty initial value for the output
    list ❸ simplifies the code a bit; remember to skip this extra node when returning
    the merged list ❼. While there still are any nodes in the heap ❹ (meaning there
    still is some merging to do), remove the top element, add the next node of the
    corresponding list into the heap ❺, and add the removed element at the end of
    the list ❻; the dummy node avoided the need to test for an empty list. The final
    step just returns the list, without the extra initial node ❼.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test this code easily. The following outputs a few Fibonacci numbers
    starting at 1:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '**14.6  Searching a Heap**'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: You could write a recursive function, but because the array is basically unordered,
    given any node in the heap, you’d have to search in both its left and right subtrees,
    so you will eventually have to look through the whole tree in an *O*(*n*) procedure.
    It would be better simply to use heap.find().
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '**14.7  Removing from the Middle of a Heap**'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing a key in the heap is a bit similar to removing a key:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: After a couple of checks to see whether the removal can be done ❶ ❷, moving
    the last value of the heap to the place of the removed value ❸ restores the structure
    property. The problem is that the value now at index k may not be placed correctly,
    violating the heap property. The simplest way to ensure that this is satisfied
    is to apply _bubbleUp() ❹ first and then sinkDown() ❺. At most, only one of those
    functions will do anything, and you’ll end up with a fully compliant heap.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '**14.8  Faster Build**'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'The changes to the newHeap() function are as follows:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This starts with an empty array and copies the values (if any) into it ❶; then
    it uses _sinkDown() to build the heap ❷ that is returned.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '**14.9  Another Way of Looping**'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'You could use forEach() in the following way (only the i parameter matters
    here):'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '**14.10  Extra Looping?**'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: It would work the same way (it would just be a tad slower), because the _sinkDown()
    procedure won’t do anything for elements with no children.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '**14.11  Maximum Equality**'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: It would be *O*(*n*). Neither _sinkDown() nor _bubbleUp() would do any work,
    so they are *O*(1), and there are *n* calls to those functions.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '**14.12  Unstable Heap?**'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple array works for both versions of the heapsort code: [1, 1]. The first
    1 will end at the last place of the sorted array.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '**14.13  Trimmed Selection**'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: 'If you find a value at level *i* of a heap, you know for sure that there are
    at least (*i* – 1) values greater than it, because of the heap property. Thus,
    if you are looking for the *k* greatest values of a heap, they cannot be at levels
    (*k* + 1) or beyond. If the heap has more than *k* levels, you can discard all
    beyond the *k*th level, and the selection process will be a bit faster. A heap
    with *k* complete levels has 2*^k* – 1 nodes, so if the heap has more nodes than
    that, you can shorten it:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在堆的第 *i* 层找到一个值，你可以确定有至少 (*i* – 1) 个比它大的值，这是由于堆的性质。因此，如果你正在寻找堆中的 *k* 个最大值，它们不可能出现在
    (*k* + 1) 层或更深的层次。如果堆的层数超过 *k* 层，你可以丢弃所有超出 *k* 层的部分，选择过程会稍微快一点。具有 *k* 完整层的堆有 2*^k*
    – 1 个节点，因此如果堆的节点数超过这个值，你可以将其缩短：
- en: '[PRE72]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: You could use .slice() to shorten the heap array, but JavaScript allows you
    to modify its .length property directly ❶.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 .slice() 来缩短堆数组，但 JavaScript 允许你直接修改它的 .length 属性 ❶。
- en: '**14.14  Is It a Treap?**'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.14  它是一个 Treap 吗？**'
- en: 'You can produce an interesting recursive solution with functional aspects.
    What is a valid treap? If it’s empty, it’s obviously okay; otherwise, its children
    should be treaps too:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过具有函数式特征的递归解法来得到一个有趣的解决方案。什么是有效的 treap？如果它为空，显然是有效的；否则，它的子节点也应该是 treap：
- en: '[PRE73]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This checks a basic condition having to do with its key and priority compared
    to those of its parent ❶, but notice that the first time, for the root, a trivial
    validation is provided because obviously the root has no parent with which to
    compare! Then, this recursively checks that both children are also treaps, each
    fulfilling a specific different new condition: the left subtree should have smaller
    keys and priorities than its parent ❷, and the right subtree should have greater
    keys but lower priorities ❸.'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这检查了一个基本条件，涉及将当前节点的键值和优先级与父节点的键值和优先级进行比较 ❶，但请注意，第一次对于根节点来说，提供了一个简单的验证，因为显然根节点没有父节点可以比较！然后，递归地检查两个子节点是否也都是
    treap，每个子节点都要满足一个新的不同条件：左子树的键值和优先级应该小于父节点 ❷，右子树的键值应大于父节点，但优先级较低 ❸。
- en: '**14.15  Treap Splitting**'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.15  Treap 分裂**'
- en: 'Add the limit value to the treap with an Infinity priority: because of the
    high priority, this limit will become the new root of the treap, and because of
    the binary search tree structure, all keys smaller than the limit will be in the
    root’s left subtree and greater keys will be in its right subtree, providing the
    desired partitioning.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 将限制值添加到具有无限优先级的 treap 中：由于优先级高，这个限制值将成为 treap 的新根节点，且由于二叉搜索树结构，所有小于限制值的键会在根节点的左子树中，而较大的键则会在右子树中，从而实现所需的分区。
- en: '**14.16  Rejoining Two Treaps**'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.16  重新连接两个 Treap**'
- en: To create a single treap out of two separate ones, create a dummy node with
    any random key and priority and then assign the first treap as its left subtree,
    assign the second treap as its right subtree, and finish by deleting the root
    dummy node.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 要将两个独立的 treap 合并为一个，可以创建一个带有随机键值和优先级的虚拟节点，然后将第一个 treap 作为其左子树，第二个 treap 作为其右子树，最后删除根虚拟节点。
- en: '**14.17  Removing from a Treap**'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.17  从 Treap 中删除**'
- en: This would work the same way, but it would be just a bit slower, because it
    would do a series of if statements before going down tree[other].
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法也可以按相同的方式工作，但会稍微慢一点，因为它会在进入树的其他部分之前执行一系列的 if 语句。
- en: '**14.18  Trees as Heaps**'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '**14.18  作为堆的树**'
- en: Using a balanced binary search tree would ensure logarithmic performance for
    all three operations, as you’ve seen earlier. However, you can do better by including
    a separate attribute for the maximum seen so far. You’d update it in *O*(1) time
    after each addition by simply comparing the current maximum to the new key, and
    when removing the top, you could find the new maximum also in logarithmic time,
    so top() itself would become *O*(1).
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 使用平衡的二叉搜索树可以确保所有三种操作都具有对数性能，正如你之前所见。然而，你可以通过引入一个独立的属性来表示到目前为止的最大值来做得更好。每次添加新节点时，你只需通过比较当前最大值和新键值，就可以在
    *O*(1) 时间内更新该属性，当移除顶部元素时，你可以在对数时间内找到新的最大值，因此 top() 本身将变为 *O*(1)。
- en: Chapter 15
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第15章
- en: '**15.1  Intuitive but Worse**'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '**15.1  直观但较差**'
- en: That would be *O*(*m* log *n*), since there would be *m* insertions, each *O*(log
    *n*).
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是 *O*(*m* log *n*)，因为有 *m* 次插入操作，每次是 *O*(log *n*)。
- en: '**15.2  Sequential Cases**'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '**15.2  顺序案例**'
- en: 'When inserting keys in descending order (the highest first), you get a badly
    shaped heap, but each add() takes constant time. Can you see why? And if you insert
    them in ascending order, you can achieve a full binary tree; see both cases shown
    next for keys from 1 to 7:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg536.jpg)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
- en: '**15.3  No Recursion Needed**'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'You could just write the merge as follows; the bold lines show the changes:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The new lines are the same as in the previous case (when the first heap has
    the greatest key), except they exchange heap1 and heap2 throughout.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '**15.4  Change Needed**'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: The change() method for a skew heap requires being able to remove a key and,
    after changing it, inserting it again. Given a reference to the node with the
    key, removing it requires a link to the parent (from which you must disconnect
    it), so an up pointer to a node’s parent should be added. You could alternatively
    use bubbleUp(), but it would also need a link to the parent.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '**15.5  Just Adding**'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: 'You initially have just a single tree with eight nodes. The following table
    shows which heaps you’d have at each stage and how many merges are needed after
    adding a value; cell items in bold represent merges. For example, adding the 9th
    value requires no merges, but adding the 10th produces two heaps of size 1, so
    a merge is needed to replace them with a heap of size 2\. Similarly, adding the
    11th value requires no merges, but the 12th needs two: first to merge two heaps
    of size 1 and then to merge two heaps of size 2.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '| Values | 1 | 2 | 4 | 8 | 16 |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-490
  prefs: []
  type: TYPE_TB
- en: '| 8 | 0 | 0 | 0 | 1 | 0 |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
- en: '| 9 | 1 | 0 | 0 | 1 | 0 |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
- en: '| 10 | 0 | 1 | 0 | 1 | 0 |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
- en: '| 11 | 1 | 1 | 0 | 1 | 0 |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
- en: '| 12 | 0 | 0 | 1 | 1 | 0 |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
- en: '| 13 | 1 | 0 | 1 | 1 | 0 |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
- en: '| 14 | 0 | 1 | 1 | 1 | 0 |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
- en: '| 15 | 1 | 1 | 1 | 1 | 0 |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
- en: '| 16 | 0 | 0 | 0 | 0 | 1 |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
- en: You had an initial heap with *n* = 8 values; after adding the other eight values,
    the total number of merges (in bold) was exactly eight, so on average, each addition
    required one merge. This is not a formal proof, of course, but the result can
    be proven mathematically for all binomial heaps.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '**15.6  Faster Binomial Top**'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: You can add a variable like _heapTop in lazy binomial heaps to get the top value
    of the heap.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '**15.7  Easier Bubbling Up?**'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: The problem is you are working with an addressable heap, and if you change keys
    around, old references to nodes won’t be valid any longer and will point to different
    values.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '**15.8  Searching a Heap**'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: 'This algorithm is obviously *O*(*n*) and certainly *not* the kind of thing
    you do with heaps, but let’s do it anyway. The only problem is to notice when
    to stop traversing the circular list of siblings:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This is a depth-first traversal. The stopT parameter remembers where you started
    in the list of siblings to avoid a loop ❶. Use node to store either a null value
    (if you don’t find the key) or the found node otherwise ❷. If the tree you’re
    looking at is neither null nor the stop point for the list ❸, check whether you
    found the key you were looking for at the root ❹; if so, save it to return it
    later ❼. If the root didn’t match, search downward ❺, and if that returns a null,
    search to the right, providing the starting point as the stop value ❻. Using xxx
    || yyy is typical of JavaScript; if the value of the xxx expression isn’t “falsy,”
    it is returned; otherwise, the value of the yyy expression is returned.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '**15.9  Two in One**'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: 'In _mergeA2B(), you could write:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In add(), you could join two assignments:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In remove(), you’d do something similar:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'And that would also apply in _separate():'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Is it worth it? Four lines saved versus the possibility of misreading or misunderstanding
    the code; it’s your call!
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**16.1  Maps for Tries**'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: 'The needed changes with regard to object-based tries are as follows; I leave
    comments up to you, but the modified lines are in bold. Creating a trie requires
    the following:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Finding a key just changes the way you access links:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Make the same kind of change when adding a new key:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'And the same happens when removing a key:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '**16.2  Ever Empty?**'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: The answer is yes in case you attempt to add a key that was already in the trie.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '**16.3  Rotate Your Tries**'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: Yes, you can apply rotations to a trie. You would work with the left and right
    links only and never affect the middle links.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '**16.4  Empty Middle?**'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: True, unless you didn’t want to store any data, in which case, the middle link
    of the EOW characters would be null.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '**16.5  Four-Letter Trie?**'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: 'The longest path (the trie’s height) would be from the root to the EOW for
    ZZZZ: 104 steps. The number of characters in the keys would be 4, and the alphabet
    is 26 letters, which means the height is the following: 4 × 26 = 104.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '**16.6  How Do They Look?**'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: Both an array-based trie and an object-based trie would be a list of nodes,
    one for each letter. A radix tree would have a single node, with the ALGORITHM
    word in it. Finally, a ternary tree would be a vertical column of nodes, with
    a letter at each level.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 17
  id: totrans-539
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**17.1  Where’s the Path?**'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a next[i][j] matrix that tells you where to go if you are at i and want
    to get to j. Whenever you update dist[i][j] you’ll also update next. Here’s the
    updated algorithm:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Define the next matrix ❶ and fill it with null values as the default ❷. Mark
    that to go from a point to itself, the path obviously passes through that point
    ❸, and whenever there’s an edge between two points, mark that too ❹. Whenever
    you find a better path between two points ❺, update not only dist but next as
    well. At the end, you must return the next matrix ❻, which you’ll use in the following
    path-finding algorithm:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Create a sequence array ❶ that will have all intermediate steps. If there is
    some way of going from the first point to the last ❷, push the initial point ❸,
    and if you haven’t reached the destination ❹, advance to the next point ❺ and
    push it ❻. At the end, just return the sequence ❼ that includes all steps.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '**17.2  Stop Searching Sooner**'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure to check whether there were any changes in any pass. The main loop
    of the algorithm changes as follows:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: At the beginning of each pass, set the changes variable to false ❶, but if you
    change any distance, set it to true ❷. After going through all the edges ❸, if
    there were no changes, you don’t need to repeat the loops and can exit.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '**17.3  Just One Will Do**'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to modify the signature of the function to receive three arguments
    (graph, from, and the added to) and change the main loop to see whether the top
    of the heap is the destination to point; in that case, you stop:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '**17.4  The Wrong Way**'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is a topological sort of the original graph, but in reverse order:
    the first nodes that appear are those that were the last nodes in the previous
    graph.'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '**17.5  Joining Sets Faster**'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: 'There will be two changes. First, all the nodes in the forest will include
    a size attribute, initially set to 1:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The other change appears when merging two sets into a single set. The main
    loop of the isConnected(...) code changes as follows:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The code in bold marks the change. If you find two different roots, check which
    has the smallest size and link it to the other root. Don’t forget to update its
    size to account for the added subset.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '**17.6  Take a Shortcut**'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: The following modified findParent(...) routine creates the shortcuts as described;
    can you see how it works?
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '**17.7  A Spanning Tree for a Tree?**'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: 'The exact same graph is produced: in a tree there is only one way to get from
    any point to another, so there are no alternatives for a different spanning tree.'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: '**17.8  A Heap of Edges**'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: I’ll leave this up to you, but I chose heapsort because of its assured performance.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '## Chapter 18'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: '**18.1  Getting Here**'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: 'The front list isn’t empty, which means someone exited the queue. A possible
    sequence could be as follows: X enters, then A enters, then B enters, then X exits
    (now the back list is empty and the front list consists of A and B), followed
    by C, D, and E entering in that order.'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: '**18.2  With Apologies to Abbott and Costello, Who’s on Front?**'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: 'The following logic solves the problem:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: If the queue is empty ❶, there’s no front element; return undefined, throw an
    exception, or perform other similar actions. If the front part isn’t empty ❷,
    its top element is simply the front of the queue. But if the front part is empty
    ❸, go through the back part until its end, because that’s the front of the queue.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '**18.3  No Change Needed**'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: There are many possibilities, but the simplest is to throw an exception if the
    key isn’t found and wrap the tree search algorithm in a try...catch structure,
    so if the exception is thrown, just return the original tree.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多种可能性，但最简单的方法是在没有找到键时抛出异常，并将树搜索算法包装在try...catch结构中，这样如果抛出异常，就只需返回原始树。
- en: '**18.4  A New Minimum**'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '**18.4  一个新的最小值**'
- en: 'Remember that you apply this function to find the minimum value of a nonempty
    binary search tree:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你需要应用这个函数来查找非空二叉搜索树的最小值：
- en: '[PRE92]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: If the root has no left child, the root’s value is the minimum. Otherwise, the
    minimum value of the tree will be the minimum of the root’s left child, because
    all values in that subtree are smaller than the root’s value.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 如果根节点没有左子节点，则根节点的值就是最小值。否则，树的最小值将是根节点左子节点的最小值，因为该子树中的所有值都比根节点的值小。
