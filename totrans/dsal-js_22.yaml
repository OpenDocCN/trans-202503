- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: ANSWER KEY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**2.1  Pure or Impure?**'
  prefs: []
  type: TYPE_NORMAL
- en: From a purely formal point of view, this function is impure since it uses something
    that wasn’t provided as an argument. Given that PI is a constant, you could possibly
    stretch things a bit and accept it; after all, nobody will be able to modify PI
    because of the const definition. The best solution would be to use Math.PI with
    no external variable, constant or not.
  prefs: []
  type: TYPE_NORMAL
- en: '**2.2  Prepare for Failure**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You must use try and catch; the following is a possible solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The addLogging() higher-order function takes a function as a parameter ❶ and
    returns a new function. If the original function throws an exception, catch it
    and output a proper message. Upon entry ❷, log the function’s name and the arguments
    it was called with. Then try to call the original function ❸, and if there’s no
    problem, log the returned value ❹ and return it back to the caller ❺. If an exception
    was thrown, log it ❻ and throw it again for the caller to process ❼.
  prefs: []
  type: TYPE_NORMAL
- en: '**2.3  You Got Time?**'
  prefs: []
  type: TYPE_NORMAL
- en: The following function does what you need; you should note several similarities
    with the logging function in the previous question.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In Node.js ❶ you need to import the performance object; in a browser it’s directly
    available. (See *[https://nodejs.org/api/perf_hooks.html](https://nodejs.org/api/perf_hooks.html)*
    and *[https://developer.mozilla.org/en-US/docs/Web/API/Performance](https://developer.mozilla.org/en-US/docs/Web/API/Performance)*
    for more information.) The addTiming() function ❷ will get a function as a parameter
    and return a new function. You’ll use an auxiliary function ❸ to output the timing
    data. Before calling the original function ❹, store the start time; if the call
    succeeds ❺ with no problem, just output the original time and the current one
    ❻, returning the original returned value ❼. If any errors occur, output a different
    message ❽ and throw the same exception again ❾ so the timed function will behave
    exactly as the original one.
  prefs: []
  type: TYPE_NORMAL
- en: '**2.4  Parsing Problem**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that .map() passes three arguments to your mapping function:
    the current element of the array, its index, and the whole array. (See *[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)*
    for more on this.) On the other hand, parseInt() receives two parameters: the
    value to parse and an optional radix (10 is the default value if nothing is passed).
    In this case, parseInt() is getting passed three arguments: it ignores the third
    extra one, but it uses the array index as the radix. For instance,"8" is parsed
    as a base 3 number, producing an error, since base 3 uses only digits 0, 1, and
    2, and "32" is parsed as a base 5 number, which is equivalent to 17.'
  prefs: []
  type: TYPE_NORMAL
- en: '**2.5  Deny Everything**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A one-liner is enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**2.6  Every, Some ... None?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just an example as a tip to get you started: if you want to check whether nobody
    in a group was an adult, you could equivalently check whether everybody wasn’t
    an adult, so people.none(isAdult) could be tested as people.every(negate(isAdult))
    using the previous answer.'
  prefs: []
  type: TYPE_NORMAL
- en: '**2.7  No Some, No Every**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A hint for some(): use findIndex() to see whether any element satisfies the
    predicate; if it doesn’t return -1, it means that at least one element fulfills
    your condition. For every(), you want to see whether findIndex() cannot find any
    element that satisfies negate(your predicate), in the same manner as in the previous
    question; if none is found, it means that every element fulfills your condition.'
  prefs: []
  type: TYPE_NORMAL
- en: '**2.8  What Does It Do?**'
  prefs: []
  type: TYPE_NORMAL
- en: Writing Boolean(someValue) checks whether the given argument is “truthy” or
    “falsy,” returning true or false accordingly. In this case, "James Bond" and 7
    are truthy values and 0 is falsy, so the result is [true, false, false, true].
    See *[https://developer.mozilla.org/en-US/docs/Glossary/](https://developer.mozilla.org/en-US/docs/Glossary/)*
    for the conversion rules involved.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**3.1  Chaining Calls**'
  prefs: []
  type: TYPE_NORMAL
- en: The add() and remove() methods should just end with return this to allow for
    chaining, and that’s it.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.2  Arrays, Not Objects**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a possible implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Creating a bag ❶ is just a matter of creating an empty array, and checking whether
    the array’s length is zero ❷ is a way to test whether it’s empty. To find a value
    in the bag ❸, use JavaScript’s own .includes() method. You’ll keep the array in
    order, so implementing greatest ❹ is simply a matter of checking whether the bag
    is empty (in which case, it returns undefined, or else it returns the array’s
    last element). To add a value to the bag ❺, push the value into the array and
    then sort the updated array. Finally, to see whether a value can be removed ❻,
    use JavaScript’s .find()method, and if the value is in the array, use .splice()
    to remove it.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.3  Extra Operations**'
  prefs: []
  type: TYPE_NORMAL
- en: Many possibilities exist, but keep in mind that you’d ask for these operations
    only if you actually required them for a specific problem. The following table
    provides a few, although this list could be extended.
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Signature | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Count all | bag → integer | Given a bag, return how many values it contains.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Count value | bag × value → integer | Given a bag and a value, return how
    many times it’s in the bag. |'
  prefs: []
  type: TYPE_TB
- en: '| Add many | bag × value × integer → bag | Given a new value and a count, add
    so many copies of the value to the bag. |'
  prefs: []
  type: TYPE_TB
- en: '| Remove all | bag × value → bag | Given a bag and a value, remove all the
    value’s instances from the bag. |'
  prefs: []
  type: TYPE_TB
- en: '| Find next | bag × value → value &#124; undefined | Given a bag and value,
    find the closest higher value to the value in the bag. |'
  prefs: []
  type: TYPE_TB
- en: '**3.4  Wrong Operations**'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to return special values, you can do so as with the greatest() operation,
    where you returned undefined for an empty bag. If you throw an exception, you
    can also specify it as a new return value (exception), albeit one that’s received
    in a different way (try/catch), and that would work as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**3.5  Ready, Set ...**'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll consider this in Chapter 13, so please skip ahead!
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**4.1  How Fast Did You Say?**'
  prefs: []
  type: TYPE_NORMAL
- en: That cannot be; for large enough *n*, *f*(*n*) becomes negative.
  prefs: []
  type: TYPE_NORMAL
- en: '**4.2  Weird Bound?**'
  prefs: []
  type: TYPE_NORMAL
- en: Yes, *n* = *O*(*n*²) and (more properly, since we prefer tighter bounds) also
    *o*(*n*²), because *n*² grows faster. The lower bound orders, big and small omega,
    don’t apply.
  prefs: []
  type: TYPE_NORMAL
- en: '**4.3  Of Big** ***O*****s and Omegas**'
  prefs: []
  type: TYPE_NORMAL
- en: In that case (and only in that case), *f*(*n*) = Θ(*g*(*n*)).
  prefs: []
  type: TYPE_NORMAL
- en: '**4.4  Transitivity?**'
  prefs: []
  type: TYPE_NORMAL
- en: If *f*(*n*) = *O*(*g*(*n*)) and *g*(*n*) = *O*(*h*(*n*)), then *f*(*n*) = *O*(*h*(*n*)).
    We can prove this mathematically, but intuitively, the first equality means that
    *f* and *g* grow proportionally, and the second means that *g* and *h* also grow
    proportionally, and that means that *f* and *h* also grow proportionally. If you
    consider any other order, transitivity still applies; for example, *f*(*n*) =
    Ω(*g*(*n*)) and *g*(*n*) = Ω(*h*(*n*)) implies *f*(*n*) = Ω(*h*(*n*)).
  prefs: []
  type: TYPE_NORMAL
- en: '**4.5  A Bit of Reflexion**'
  prefs: []
  type: TYPE_NORMAL
- en: We can also say *f*(*n*) = *O*(*f*(*n*)) and *f(n)* = Ω(*f*(*n*)), but not for
    small omega or small *o*.
  prefs: []
  type: TYPE_NORMAL
- en: '**4.6  Going at It Backward**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If *f(n)* = *O*(*g*(*n*)), then *g*(*n*) = Ω(*f*(*n*)), and if *f*(*n*) = *o*(*g*(*n*)),
    then *g*(*n*) = ω(*f*(*n*)). Note the symmetry: big *O* implies big omega, and
    small *o* implies small omega.'
  prefs: []
  type: TYPE_NORMAL
- en: '**4.7  One After the Other**'
  prefs: []
  type: TYPE_NORMAL
- en: When *n* grows, the growth of the *O*(*n*²) part will be greater than the growth
    of the *O*(*n* log *n*) part, so that’s the order of the whole process. In general,
    the order of a sequence will be that of the greatest order.
  prefs: []
  type: TYPE_NORMAL
- en: '**4.8  Loop the Loop**'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the result is *O*(*n*³). The order of the whole “loop within a
    loop” is derived from the product of both orders.
  prefs: []
  type: TYPE_NORMAL
- en: '**4.9  Almost a Power ...**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A formal proof would require applying induction, but consider how you’d frame
    it. You want to end with a single element, so 1 is a valid size. At the previous
    step, the array had two 1-sized parts, separated by a single element: the previous
    size was then 3\. Before that, the array had two 3-sized parts, separated by one
    element: its size was 7\. Going backward in this fashion, if you had an *s*-sized
    array, at the previous step, the array had to be of size (2*s +* 1). Starting
    at *s* = 1, it can be formally proved that sizes are always one less than a power
    of 2 from the fact that 2(2*^k* – 1) + 1 equals 2*^k* ^(+1) – 1.'
  prefs: []
  type: TYPE_NORMAL
- en: '**4.10  It Was the Best of Times; It Was the Worst of Times**'
  prefs: []
  type: TYPE_NORMAL
- en: In that case (and in that case only), we can deduce that the running time is
    Θ(*f*(*n*)).
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**5.1  Factorial in One**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use this one-liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**5.2  Hanoi by Hand**'
  prefs: []
  type: TYPE_NORMAL
- en: 'On odd steps, always move the smallest disk cyclically (from A to B, from B
    to C, and from C to A), and on even steps, make the only possible move that doesn’t
    involve the smallest disk. This method works for an even number of disks; for
    an odd number of disks, the smallest disk needs to do the cycle in the opposite
    direction: A to C, C to A, A to B.'
  prefs: []
  type: TYPE_NORMAL
- en: '**5.3  Archery Backtracking**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key to this problem is not to drop an option immediately after choosing
    it, but rather to try it again first. The following code is basically the same
    as the solve() function from the section “Solving the Squarest Game on the Beach
    Puzzle” on page 70, with an addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The parameters were renamed to better match the current puzzle ❶, so it’s rings
    instead of dolls and hit instead of dropped. The additional code tries reusing
    the first ring ❷, and if it succeeds ❸, you’re done. If trying the same ring again
    fails ❹, drop it and continue with the search as earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the second question, you can indeed reuse the original solve() algorithm,
    but you need a change, because you may hit a ring more than once, so rings must
    appear several times. For example, 40 and 39 should both be considered twice as
    an option; hitting any of those three or more times would exceed 100\. Similarly,
    23 and 24 could appear up to four times, 17 five times, and 16 six times. This
    code finds the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: By the way, if you don’t run the code, the answer is 16, 16, 17, 17, 17, and
    17!
  prefs: []
  type: TYPE_NORMAL
- en: '**5.4  Counting Calls**'
  prefs: []
  type: TYPE_NORMAL
- en: To calculate the *n*th Fibonacci number, you need one call for that, plus *C*(*n*
    – 1) calls for the (*n* – 1)th number, plus *C*(*n* – 2) calls for the (*n* –
    2)th one, so *C*(*n*) = *C*(*n* – 1) + *C*(*n* – 2) + 1\. The solution to this
    is *C*(*n*) = 2Fibo(*n* + 1) – 1.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.5  Avoid More Work**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply add a test at the beginning of the loop of the costOfFragment(...) function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As soon as the width of blocks from p through r exceeds MW, you can stop the
    loop; all upcoming total widths will be even greater.
  prefs: []
  type: TYPE_NORMAL
- en: '**5.6  Reduce for Clarity**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a single-line way to calculate the partial values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that the accumulator in this case is an array that you initialize with
    a single 0 and that will become partial[0].
  prefs: []
  type: TYPE_NORMAL
- en: '**5.7  Got GOUT?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the solve() function from the section “Solving Cryptarithmetic Puzzles”
    on page 83 as follows. The style of the code is exactly the same as for the SEND
    + MORE = MONEY puzzle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The maximum sum of two 2-digit numbers is 99 + 99 = 198, so O = 1, and there
    was a carry-over from the center column to the leftmost one. At the rightmost
    column, O + O = T, so T = 2, and there’s no carry-over to the center column. Finally,
    looking at the center column, T + G = 10 + U, but as T = 1, the only way T + G
    is at least 10 is if G = 9 and then U = 0; the value of GOUT is then 9102, exactly
    as solve() discovers!
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**6.1  Forced Reversal**'
  prefs: []
  type: TYPE_NORMAL
- en: Change the signs of all the numbers. Next, sort them in ascending order, and
    then change the signs back. For instance, to sort [22, 60, 9], first change them
    to [–22, –60, –9], then sort them, and you’ll get [–60, –22, –9]. Finally, change
    the signs again [60, 22, 9], and they’ll be in the desired descending order.
  prefs: []
  type: TYPE_NORMAL
- en: '**6.2  Only Lower**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given lower(a,b), you can implement higher(a,b) and equal(a,b) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically it’s just like applying math: a > b if b < a ❶, and a is equal to
    b, if and only if neither a < b nor a > b ❷.'
  prefs: []
  type: TYPE_NORMAL
- en: '**6.3  Testing a Sort Algorithm**'
  prefs: []
  type: TYPE_NORMAL
- en: Sort a copy of the data with some other method and use JSON.stringify(...) to
    get a version of the result as a string. Then, sort the data with your new method,
    use JSON.stringify(...) on its output, and compare both JSON strings; they should
    match.
  prefs: []
  type: TYPE_NORMAL
- en: '**6.4  Missing ID**'
  prefs: []
  type: TYPE_NORMAL
- en: This problem has two solutions. You could sort the series of numbers, and then
    a sequential run through the ordered series would detect missing numbers whenever
    the gap between consecutive numbers is greater than one. A more specific solution
    would be to initialize an array of size 1,000,000 with false, and for every number
    in the series, set the corresponding array entry to true. You can then run through
    the array, and entries that are still false represent missing IDs.
  prefs: []
  type: TYPE_NORMAL
- en: '**6.5  Unmatched One**'
  prefs: []
  type: TYPE_NORMAL
- en: Like the previous question, this problem also has two solutions. You could sort
    the whole series, and then a quick run through the sorted numbers would find the
    number that’s used only once. The second, trickier solution is to apply the bitwise
    XOR (^) to all the numbers. If you XOR a number with itself, the result is zero,
    and if you XOR a number with zero, the result is the number. If you XOR the whole
    series, the result will be the unmatched number. However, this solution works
    only if there is a single unpaired number; if there were two or more, it would
    fail.
  prefs: []
  type: TYPE_NORMAL
- en: '**6.6  Sinking Sort**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic is similar to bubble sort’s; you need to change only how indices
    behave:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**6.7  Bubble Swap Checking**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following logic implements the idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**6.8  Inserting Recursively**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The description is enough to write the code: to sort *n* numbers, first sort
    the initial (*n* – 1) ones and then insert the *n*th number in the sorted list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**6.9  Stable Shell?**'
  prefs: []
  type: TYPE_NORMAL
- en: No, Shell sort isn’t stable, because the first stages (for gaps larger than
    one) may disrupt the relative order of equal keys.
  prefs: []
  type: TYPE_NORMAL
- en: '**6.10  A Dutch Enhancement**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following implementation works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: All the code is the same up to the point where the pivot is at arr[p] ❶. You
    then do a loop to the left of the pivot position ❷, and if you find elements equal
    to the pivot, you swap; the leftmost position equal to the pivot is always at
    pl. After this pass, you repeat the process with a similar logic ❸ but from the
    pivot position to the right. The rightmost position with a value equal to the
    pivot is pr. After these added loops, all values from pl to pr are equal to the
    pivot, so you sort the rest ❹.
  prefs: []
  type: TYPE_NORMAL
- en: '**6.11  Simpler Merging?**'
  prefs: []
  type: TYPE_NORMAL
- en: If you made that change, merge sort wouldn’t be stable. When you have equal
    values in the first and second lists, you want to choose from the former.
  prefs: []
  type: TYPE_NORMAL
- en: '**6.12  Try Not to Be Negative**'
  prefs: []
  type: TYPE_NORMAL
- en: With negative numbers, you’d get a crash when digit becomes negative. And for
    noninteger numbers, the algorithm disregards the fractional part, so numbers with
    equal integer parts may end up not sorted correctly. As an extra question, think
    of ways to solve these problems.
  prefs: []
  type: TYPE_NORMAL
- en: '**6.13  Fill It Up!**'
  prefs: []
  type: TYPE_NORMAL
- en: The first option would fill all the elements of bucket with a reference to the
    same array; instead of 10 different arrays, you’d get a single one, common to
    all buckets. The second option wouldn’t do anything, because .map(...) skips undefined
    positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**6.14  What About Letters?**'
  prefs: []
  type: TYPE_NORMAL
- en: In that case, you’d require more buckets, one for each possible symbol. You
    might have to do some fancy work if you want to have accented letters (such as
    á or ü) sorted together with their nonaccented versions.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**7.1  Tennis Sudden Death**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of matches is easy to find: each match discards one player, and
    to find the champion, you must discard 110 other players, so the answer is 110,
    and for *n* players, *n* – 1\. The second best could be any of the players that
    the first defeated—even possibly in the first round. This tournament had seven
    rounds, so you may need up to seven extra matches. In general terms, the number
    of rounds is the logarithm of *n* in base 2, rounded up, so the total number of
    comparisons to learn the two minimum values of an array is *n* –1 + log[2] *n*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**7.2  Take Five**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do it with six comparisons, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To understand the code, follow what happens to the variables. After the first
    test, you know for sure that a < b ❶, and with the next test you know that c <
    d ❷. You can say that a < b && a < c < d ❸, so a cannot be the median. After ❹,
    b < e && c < d, so whichever is lowest of b and c cannot be the median either.
    At ❺, b < c < d && b < e, so neither b nor d can be the median, which is the smallest
    of c and e. Similarly, at ❻, c < b < e && c < d, so neither c nor e is the median;
    the smallest of b and d is it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just for completeness, here’s an equivalent version of median5(...) that works
    with an array of five independent values and returns the position of the found
    median. The code is parallel to the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '**7.3  Top to Bottom**'
  prefs: []
  type: TYPE_NORMAL
- en: There are two solutions. You could change the algorithm so instead of selecting
    minimums and going from 0 to *n* – 1, it could work by selecting maximums and
    going down from *n* – 1 to 0\. To get an efficient algorithm, you should start
    by comparing *k* to *n*/2 and going up (as originally shown in the text) or down
    (as described here) depending on that comparison, whichever takes the least work.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the particular case in which the values are numeric, you can do a trick:
    change the sign of all numbers to the opposite, use the algorithm to find the
    value at *n* – *k*, and change its sign; can you see why that works?'
  prefs: []
  type: TYPE_NORMAL
- en: '**7.4  Just Iterate**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of recursion, you can use a loop that will exit when the code has managed
    to put the *k*th value of the array in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Set up a loop ❶ that continues as long as left and right haven’t reached the
    same place (k). At the end, instead of recursion or returning early, just manipulate
    left and right properly ❷.
  prefs: []
  type: TYPE_NORMAL
- en: '**7.5  Select Without Changing**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply make a copy of the input array, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Make a copy of the array ❶, then partition it ❷, and finally return the *k*th
    value from the copied and repartitioned array ❸.
  prefs: []
  type: TYPE_NORMAL
- en: '**7.6  The Sicilian Way**'
  prefs: []
  type: TYPE_NORMAL
- en: The following algorithm does the trick. You can find a different implementation
    (changing how elements are swapped) in “An Efficient Algorithm for the Approximate
    Median Selection Problem,” by S. Battiato et al., available at *[https://web.cs.wpi.edu/~hofri/medsel.pdf](https://web.cs.wpi.edu/~hofri/medsel.pdf)*.
    We’ll highlight the only differences with previous code, but we’ve also implemented
    some methods in a new way just for variety, and we used iteration instead of recursion
    (as in question 7.4) for the same reason.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You’ll need to do lots of swapping, but the swapIfNeeded(...) function ❶ avoids
    some unnecessary calls by checking whether there’s actually any need to swap.
    Since you’ll always be finding the median of up to three values, it makes sense
    to have a specific function instead of using a generic sort ❷; medianOf3(...)
    returns the position of the median using up to three comparisons with no swapping.
    In quickselect the only part that changed are the lines in bold. You’ll find the
    medians in ever-shortening parts of the array; the rr variable marks the right
    limit of the array you’re processing ❸, while the left variable always points
    at its left limit. As long as the array has more than three elements ❹, you’ll
    do a pass of choosing medians of 3 ❺ and packing them to the left of the array,
    as shown in the repeated step algorithm; the difference is that after each pass
    ❻ you’ll shorten the array and loop again to find medians of 3\. When the set
    of medians (of medians of medians of ..., and so on) is short enough, you’ll just
    choose its last element as the next pivot.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**8.1  Good Enough Shuffling**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the code I used when testing the functions for the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters for this logging are the shuffling function fn, the portion
    of the array to be shuffled (from, to), the size of the input array to use (n),
    and how many times to run the test ❶. An auxiliary function bar(...) ❷ draws a
    bar of pound characters: the maximum length is len for a val value that equals
    a maximum max value; smaller values get proportionally shorter bars. Use an object,
    result, to count how many times each permutation occurred ❸ (you could also use
    a JavaScript map). The max variable ❹ tracks the maximum number of times that
    any permutation appeared. You loop n times ❺, each time initializing an array
    to shuffle ❻. Use fn to shuffle the array, creating a string key out of the result
    ❼, and update the counts ❽ and maximum ❾ observed frequencies. The last step ❿
    returns the results in tabular form, with permutations ordered alphabetically
    for clarity.'
  prefs: []
  type: TYPE_NORMAL
- en: '**8.2  Random Three or Six**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tossing two coins produces four combinations. You can assign numbers to those
    combinations, and if a combination numbered 1 to 3 occurs, accept it; if you get
    a 4, redo the throw:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This assigns numbers to combinations of coins using the binary system, calling
    heads a 0 and tails a 1\. Use the randomBit() function to produce bits ❶. You
    “throw” the die twice, and assign a number to the resulting combination ❷. Loop
    until you get a number from 0 to 2 ❸, and after getting it, map it to a result
    ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simulate a die, you’ll need three coin tosses, but the logic is quite similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Finally, simulating a 1 to 20 throw is trickier. You could use 5 bits, getting
    a result from 0 to 31 and discarding the 12 last values, but that would probably
    require several attempts; after all, a failure rate of 12 out of 32 is high. A
    better solution would be using 6 bits for a result of 0 to 63, discarding the
    last 4 (so, 0–59) and dividing the result by 3 to get a 0 to 19 result, with small
    odds (4 in 64) of needing a new attempt.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.3  Not-So-Random Shuffling**'
  prefs: []
  type: TYPE_NORMAL
- en: If this algorithm produced uniform shuffles, you’d expect each value in the
    original array to appear the same number of times at each position of the shuffled
    array. For the initial value to end at the last position, you need all randomBit()
    calls to come up true, so it’s far more likely that the initial value will end
    up not far from its starting position and only rarely appear in the last places.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.4  Bad Swapping Shuffle**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that this code doesn’t generate every possible permutation with
    the same frequencies. You can see a hint of that by noticing that this code loops
    *n* times, choosing a random number with *n* possible values each time, so it
    has *n*¹ ways to run. However, a permutation generation algorithm should run in
    *n*! ways only. If you want to verify this by hand, try the algorithm for just
    three elements and simulate all 27 possible sequences of random numbers: from
    (0,0,0), which would shuffle ABC into CBA; (0,0,1), which shuffles ABC into BCA;
    and so on, up to (2,2,2), which produces CBA. Count how many times each possible
    permutation occurs, and you’ll see that some are more favored than others. The
    algorithm doesn’t produce an even distribution of shuffles.'
  prefs: []
  type: TYPE_NORMAL
- en: '**8.5  Robson’s Top?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The question is equivalent to finding out the largest factorial that can be
    calculated without losing precision. Using normal precision, this turns out to
    be 18; 19! is too long:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can test whether precision is lost by adding 1 and checking whether the
    result is changed; if you get the same result, it means that JavaScript hasn’t
    enough digits to accommodate your large number ❶.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you could use BigInt values, and then you’d be able to work with much
    higher values—as long as the size of a factorial doesn’t exceed the allowed memory.
    The following program will happily go past 19 until something crashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference here is that it’s using BigInt numbers: 1n is such a number.'
  prefs: []
  type: TYPE_NORMAL
- en: '**8.6  Sampling Testing**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is quite similar to what we used for shuffling, with a special
    detail related to whether you’re doing sampling with or without repetition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When sampling without repetition, sample B-C-A is the same as sample C-A-B,
    so you sort the elements to get a unique key A-B-C. However, when sampling with
    repetition, the two results are different. The added parameter noReps ❶ solves
    this; when counting the sample, you sort values (or not) depending on it ❷.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.7  Single-Line Repeater**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a single statement but is shown here on several lines for
    clarity. You generate an array of the right size and use .map(...) to fill it
    with randomly chosen values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The tricky part is that you need to use .fill(0) to put values in the array.
    If you don’t do this, .map(...) won’t do anything, because it skips uninitialized
    array locations.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.8  Sort to Sample**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following logic does the work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This method of assigning random keys comes directly from the section “Shuffling
    by Sorting” on page 139 ❶. The logic that follows is a slight modification of
    the logic in “Selecting with Comparisons” on page 124 ❷, and the final code to
    leave just the original values is again from “Shuffling by Sorting” ❸.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.9  Iterate, Don’t Recurse**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand why this works, consider what the calls to other(...) will be
    and with which arguments. Applying the conversion to the factorial function produces
    the well-known equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Applying the conversion to Floyd’s algorithm is a bit trickier, because the
    function has two arguments (k and n), but since their difference is constant because
    they decrease in parallel, you can achieve the conversion. You’ll need to rename
    some variables to avoid confusion; for example, we’re already using i with another
    meaning in Floyd’s code.
  prefs: []
  type: TYPE_NORMAL
- en: '**8.10  No Limits?**'
  prefs: []
  type: TYPE_NORMAL
- en: The check isn’t needed; initially toSelect is not greater than toConsider. If
    they ever become equal, from that point onward, all elements will be chosen, because
    the test Math.random() < toSelect / toConsider will always succeed for all random
    values less than 1, and toSelect will eventually become 0.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**9.1  Searching Right**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the code I used. The checkSearch(...) higher-order function takes a
    searching function to test and a boolean flag to indicate whether to use it with
    sorted or unsorted data. The actual files with data are called data32 and data_sorted_32:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You use a sorted or unsorted set of data ❶ depending on the kind of algorithm.
    An auxiliary verify(...) function ❷ allows shorter code: the function tests whether
    the result matches what you expected ❸, throwing an error if not. For successful
    searches ❹, it displays the input and output. You try searching for every value
    in the input array ❺. You then find the minimum (m1) and maximum (m2) values of
    the array ❻ and then try all possible (invalid) searches ❼ from m1 - 3 to m2 +
    3; whenever a value isn’t included in the array ❽, you specifically try to find
    it, expecting to receive -1 as result ❾.'
  prefs: []
  type: TYPE_NORMAL
- en: '**9.2  JavaScript’s Own**'
  prefs: []
  type: TYPE_NORMAL
- en: The simplest solution would be array.findIndex(x => x === key).
  prefs: []
  type: TYPE_NORMAL
- en: '**9.3  Infinite Search Levels?**'
  prefs: []
  type: TYPE_NORMAL
- en: If levels tends to infinity, b will always become 2, and that means you split
    the search area in half at each step. You’ve rediscovered binary search! Roughly
    speaking, i takes the place of l in the iterative binary search code, and m is
    the difference between l and r.
  prefs: []
  type: TYPE_NORMAL
- en: '**9.4  Exactly How Much?**'
  prefs: []
  type: TYPE_NORMAL
- en: You can calculate the average number of tests by finding the sum of 1 × 1 +
    2 × 2 + 4 × 3 + 8 × 4 and so on, up to 2*^(n–)*¹ found in *n* questions, and dividing
    by the total number of searches, 2*^n* – 1\. We worked this out in section “Analysis
    of Algorithms in Practice” on page 55, and the sum equals (*n* + 1)2*^n* – (2*^n*^(+1)
    – 1)). Dividing, you get the average you wanted, which for large values of *n*
    is close to *n* – 1, so for any array length *k*, the answer is approximately
    log[2]*k* – 1.
  prefs: []
  type: TYPE_NORMAL
- en: '**9.5  Three Tops Two?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When trying to decide in which third to keep searching, if the key is in the
    first third, you’ll be able to decide by asking a single question, and if it’s
    in the other two thirds, you’ll need to ask a second question: on average, you
    need 1 × 1/3 + 2 × 2/3 = 5/3 questions. Dividing the array by 3, you’ll have log[3]
    *n* search steps, compared to log[2] *n* steps with binary search. Given that
    log[3] *n* is approximately 0.631 log[2] *n*, the performance of ternary search
    is about 5/3 × 0.631, which equals 1.052 times that of binary search, which is
    practically the same.'
  prefs: []
  type: TYPE_NORMAL
- en: '**9.6  Binary First**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is if you find the key, instead of returning it, note the position
    and keep searching to the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The code is the same as for binary search, with four differences. Initialize
    a result variable ❶ with the value that you’ll return at the end ❹. When you find
    the key, update this variable ❷, but instead of returning, keep searching to the
    left ❸ just in case the key occurs again.
  prefs: []
  type: TYPE_NORMAL
- en: To find the last position of key in arr ❸, write l = m + 1 to keep searching
    but to the right.
  prefs: []
  type: TYPE_NORMAL
- en: '**9.7  Count Faster**'
  prefs: []
  type: TYPE_NORMAL
- en: Use the solutions to the previous problem to find the first and last positions
    of the key in the array. Of course, if the first search returns -1, the count
    is 0 and you don’t have to do the second search.
  prefs: []
  type: TYPE_NORMAL
- en: '**9.8  Rotation Finding**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use a variant of binary search for this, but it’s not exactly the same;
    there’s a careful detail to pay attention to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You set up l and r as for binary search ❶. You’ll stop searching whenever you
    find that the value at l isn’t greater than the value at r ❷, and while that isn’t
    true, you’ll search in a half of the array. As in binary search ❸, m is the middle
    of the array. If the value at m is greater than the value at r ❹, the rotation
    is in the right part of the array, and the minimum must be at least at m + 1.
    Otherwise, the value at l must be greater than the value at m ❺, and here you
    must be very careful because the place of the rotation could be m itself! So,
    when the rotation is on the left, you don’t set r to m - 1, as in binary search,
    but rather to m. When you find that the value at l isn’t greater than the value
    at r ❻, l is the position you’re looking for.
  prefs: []
  type: TYPE_NORMAL
- en: '**9.9  Special First**'
  prefs: []
  type: TYPE_NORMAL
- en: 'No, you don’t need to. Assume that arr[0] === key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the logic, i starts at 1 ❶; the loop exits immediately ❷ because key (arr[0])
    cannot be greater than arr[1]. The final binary search ❸ is done between 0 and
    1 and succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**10.1  Iterating Through Lists**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the size of a list, initialize a pointer to the first element and follow
    the next pointers until you get to the end, counting each node you visit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The count variable ❶ keeps a count of the elements. You’ll do a loop, starting
    at the head and advancing until reaching the end ❷, and you’ll update the count
    for each node ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar code is used to find whether a given value is found in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The logic of going down the list is the same as for count(...) ❶, and for each
    element you test whether it matches the desired value. If so, you return true
    ❷, and if you reach the end of the list without a match, you return false ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding an element is also a matter of advancing down the list until reaching
    either the end or the desired position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, removing a given element also works with similar logic: go down the
    list until you reach the end of the list or the position you want to remove:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '**10.2  Going the Other Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is that you go through the list, pushing each value into a stack,
    and the final list will be reversed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the reversed list as a stack with newList as its pointer ❶, and use
    list to go element by element ❷ pushing it into the newList stack; you may want
    to draw a diagram of the pointer juggling that’s going on here ❸. At the end,
    return the reversed list ❹. A question for you: Does this algorithm also work
    for null lists?'
  prefs: []
  type: TYPE_NORMAL
- en: '**10.3  Joining Forces**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is to look for the last element of the first list and link it to the
    head of the second list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: An interesting case is if the first list is empty ❶, the result of the operation
    is the second list. Otherwise, use ptr to go down the first list ❷, advancing
    while the end hasn’t been reached ❸. When reaching the end ❹, just modify its
    next pointer to point at the second list.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.4  Unloop the Loop**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You don’t need to store anything; just use two pointers. The idea is to advance
    down the list with two pointers, one a node at a time, and one at twice the speed.
    If the list doesn’t have a loop, the second will reach the end and you’re done.
    If the list has a loop, however, the two pointers will eventually meet (because
    the second moves faster than the first), and that means there’s a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If the list is empty ❶, then for certain there’s no loop. Otherwise, ptr1 goes
    down the list a node at a time, and ptr2 advances two nodes at a time ❷. You’ll
    keep working unless ptr2 reaches the end or ptr2 reaches ptr1 ❸. During the iteration,
    ptr1 advances one node ❹ and ptr2 advances twice ❺ unless it reached the end.
    At the end, if ptr2 had reached ptr1, there’s a loop; otherwise, there isn’t.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.5  Arrays for Stacks**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the .pop(...) and .push(...) methods, implementing a stack is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: A new stack is just an empty array ❶, and to check for an empty stack, you just
    see whether the array’s length is zero ❷. To push a new value ❸, use .push(...)
    and use .pop() ❹ to pop with a check for an empty stack. Finally, getting to the
    top of the stack is just a matter of looking at the last element of the array
    ❺.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.6  Stack Printing**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the implementations of size(...) and find(...) in the first question
    for this chapter, you shouldn’t need further explanation for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '**10.7  Height of a Stack**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You could implement this in *O*(*n*) time by using code similar to the code
    in the previous question, but a simpler solution is to add a height field to the
    stack definition initialized to zero and update that field appropriately when
    pushing or popping values. A stack would now be something more similar to a queue,
    in that an object is used instead of just a pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '**10.8  Maximum Stack**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is to push entries with two pieces of data: not only the value that’s
    being pushed, but also the current maximum, which depends on the value being pushed
    and the previous maximum, which was at the top of the stack before the push. To
    find the minimum, you’d push three pieces of data: the value to be pushed, the
    maximum at that time, and the minimum at the same time. This allows knowing the
    maximum or minimum at any moment, in *O*(1) time.'
  prefs: []
  type: TYPE_NORMAL
- en: '**10.9  Queued Arrays**'
  prefs: []
  type: TYPE_NORMAL
- en: This operation essentially requires the same implementation as for stacks, except
    that for entering a queue, use .unshift(...) instead of push(...), so new values
    are added at the beginning of the array instead of at the end.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.10  Queue Length**'
  prefs: []
  type: TYPE_NORMAL
- en: Trick question! Just apply the same logic as for question 10.9.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.11  Queueing for Sorting**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code does the work; it just rewrites the _radixSort(arr) function
    from the “Radix Sort” section on page 115, which sorts an input array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The differences in the code from that in Chapter 6 are highlighted. Instead
    of creating arrays for each bucket, set up queues ❶. For each value, after deciding
    which bucket it will go in ❷, make it enter the corresponding queue ❸. After distributing
    values into queues, go through each of them ❹ to generate an array.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.12  Stacked Queues**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As suggested, the idea is to use two stacks: say IN and OUT. Push the new value
    to the IN stack to enter the queue. Pop the OUT stack to exit the queue, but if
    it was empty, first pop all values from the IN stack, one at the time, and push
    them to OUT, before finally doing the pop. Every value that enters the queue will
    go through two pushes (first to IN and at a later time to OUT) and two pops (at
    some later time from IN and eventually from OUT), so the amortized cost of the
    operation is *O*(1). Obviously, some exit operations (those that find an empty
    OUT stack) will require more time.'
  prefs: []
  type: TYPE_NORMAL
- en: '**10.13  Palindrome Detection**'
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to split the string into separate characters and enter all the letters
    into a deque. When you’re done, repeatedly check whether the front element is
    the same as the last element, and exit them both. If you get down to zero elements
    (first is null) or just one (first equals last), the string was a palindrome.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.14  Circular Listing**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following logic does the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: First check for an empty circular list; if so, you don’t have to do anything
    ❶. Use ptr to go around the list ❷, printing each visited node ❸, advancing to
    the next ❹, and exiting the loop when reaching the initial node again ❺.
  prefs: []
  type: TYPE_NORMAL
- en: '**10.15  Joining Circles**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Manipulating links isn’t hard, but you have to be careful. Initially, you’ll
    have this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg516-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And you’ll want to get to this situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg516-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Assuming that both circ1 and circ2 are not null, you need four lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: First, B follows N ❶. Set B so that N precedes it ❷. Similarly, J follows A
    ❸, and A precedes J ❹.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**11.1  Sentinels for Searches**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If an ordered list includes a final +Infinity value, you can simplify the search
    because you know you’ll never get past the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Compare this code to the code in the section “Searching for a Value*”* on page
    183; the first if is now simpler. (I agree that the speed gain may be minimal,
    but the technique is commonly used and worth knowing.)
  prefs: []
  type: TYPE_NORMAL
- en: '**11.2  More Sentinels?**'
  prefs: []
  type: TYPE_NORMAL
- en: An initial -Infinity value means that you’ll never add a new value at the beginning
    of the list, so essentially that makes the pointer to the head a constant. This
    extra sentinel makes iterative code simpler; you can check it out yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '**11.3  A Simpler Search?**'
  prefs: []
  type: TYPE_NORMAL
- en: You could change the function to return either null (if the value wasn’t found)
    or a pointer to the value—which will just be the first in the list.
  prefs: []
  type: TYPE_NORMAL
- en: '**11.4  Re-skipping Lists**'
  prefs: []
  type: TYPE_NORMAL
- en: Start by deleting all pointers at levels other than the bottom one. Then, create
    level 1 by going through level 0 and choosing all elements at even positions;
    level 1 will end with about half the elements of level 0\. Redo this process to
    create level 2 based on elements at even positions in level 1; then, create level
    3 based on even positions in level 2, and so on. Stop when the topmost list has
    only one element.
  prefs: []
  type: TYPE_NORMAL
- en: '**11.5  Skip to an Index**'
  prefs: []
  type: TYPE_NORMAL
- en: You want to be able to produce, say, the 229th value of a list without having
    to go one by one past the previous 228 values. To sketch the solution, you’ll
    define the “width” of a link as the number of values at the next level that are
    encompassed by the link. (In other words, how many nodes do you jump over by following
    the link?) You can create and update the widths when adding or removing values.
    All widths at the bottom level are 1\. At any level, if a link goes from node
    A to node B, the width of the link is the sum of all the widths from A (inclusive)
    to B (exclusive).
  prefs: []
  type: TYPE_NORMAL
- en: Knowing these widths makes it easy to find any given position. You start at
    the topmost level, going horizontally as long as the sum of widths doesn’t exceed
    the index you want. When this sum surpasses the index you want, you go down to
    the next level and keep going horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg517.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For instance, in the diagram provided, say you want to find the 11th element
    of the list (the widths of links are in parentheses below each link). At the first
    level, the first three links cover 2 + 4 + 2 = 8 elements, so by following them
    in three steps, you’re already at the 8th element of the list. The next link is
    4, so that would go past the 11th, and you’d go down. The widths of the links
    there are all 1, so you advance a couple more times and find 40, the 11th value.
  prefs: []
  type: TYPE_NORMAL
- en: '**11.6  Simpler Filling**'
  prefs: []
  type: TYPE_NORMAL
- en: It would fill the array with a reference to the *same* list, instead of references
    to 100 distinct lists.
  prefs: []
  type: TYPE_NORMAL
- en: '**11.7  A Hashed Set**'
  prefs: []
  type: TYPE_NORMAL
- en: For searches and removals, there’s no change whatsoever. For additions, the
    key is to keep searching until you either find the value (in which case you wouldn’t
    add it again) or reach an empty space. For efficiency, should you find an available
    slot during the search, make a note of it, and instead of adding the new value
    at the empty space, put it into the available slot.
  prefs: []
  type: TYPE_NORMAL
- en: '**11.8  Wrong Seating**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key is to look at the problem in a different way. Instead of thinking that
    a person upon finding their seat occupied moves to some other random seat, imagine
    that *they* sit down and the previous occupant of the seat is the one who moves
    away. (In other words, the one who originally sat down in the wrong place.) By
    the time the 100th person enters, 98 people will be in their assigned seats, and
    the first person who entered the theater will be either in their seat or in the
    100th person’s seat—it depends on how the previous person moved with only two
    possible seats to choose: their seat or the 100th person’s seat. (If they had
    chosen any other seat, they would have had to move again when the rightful occupant
    of the seat appeared.) The answer is 50 percent.'
  prefs: []
  type: TYPE_NORMAL
- en: '**11.9  Progressive Resizing**'
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to work with both tables at the same time, gradually removing values
    from the old one and inserting them in the new one. After you decide you need
    to resize, create a new, larger table, and from then on, all insertions will go
    to the new table. Whenever you want to search for a value, look in both tables;
    a value in the old table may have already been moved to the new table. (The same
    applies to removals.) Every time you do an operation (add, remove, or search),
    remove some values from the old table and insert them into the new one. When every
    value has been removed from the old table, just work with the new one.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**12.1  A Matter of Levels**'
  prefs: []
  type: TYPE_NORMAL
- en: The height of a tree would be the highest level of its nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '**12.2  Breaking the Rules**'
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic links (symlinks) may point to any file or directory, so they allow
    you to break the tree structure.
  prefs: []
  type: TYPE_NORMAL
- en: '**12.3  What’s in a Name?**'
  prefs: []
  type: TYPE_NORMAL
- en: A *perfect tree* is complete and full. A *complete tree* isn’t necessarily perfect
    (the bottom need not be complete), and it may not be full either, because a node
    may have only one child—for example, a tree with just two nodes. Finally, a *full
    tree* may be neither complete nor perfect; see Chapter 13 for an example of this.
  prefs: []
  type: TYPE_NORMAL
- en: '**12.4  A** **find()** **One-Liner**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the ternary operator, you can make do as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Because of space restrictions, this appears as several lines of text, but it’s
    a single statement in any case.
  prefs: []
  type: TYPE_NORMAL
- en: '**12.5  Sizing a Tree**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the definition that an empty tree has size 0 and that, otherwise, the
    size of a tree is 1 (for the root) plus the sizes of both subtrees, you can write
    a one-liner solution for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '**12.6  Tall as a Tree**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The height of a tree is the maximum length of a path from the root to a leaf.
    So, if you know the heights of both subtrees of the root, the height of the complete
    tree will be one more than the height of the highest subtree. You can program
    this very simply using recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '**12.7  Copy a Tree**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recursion is the best solution: a copy of an empty tree is just an empty tree,
    and a copy of a nonempty tree is built out of the tree’s root, plus copies of
    its left and right subtrees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also build a copy another way, which should remind you of a postorder
    traversal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If the tree to copy is null ❶, nothing needs to be done. Otherwise, first make
    a copy of the left subtree ❷, then a copy of the right subtree ❸, and finally,
    build a tree out of the tree’s key plus the two newly created trees ❹.
  prefs: []
  type: TYPE_NORMAL
- en: '**12.8  Do the Math**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need a postorder traversal for this, because before applying any operator,
    you need to know the value of its left and right subexpressions. You can do this
    with a function, since a whole class would be overkill:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If the tree is empty ❶, you return 0, a reasonable value. Otherwise, if the
    root is a number ❷, just return that number, and if the root is an operator ❸
    ❹ ❺ ❻, use recursion to evaluate both sides of the expression and return the calculated
    value. You also add a “catch-all” for any unexpected input ❼.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example shows this at work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This code returns 30, as expected. Can you figure out why I didn’t include null
    pointers?
  prefs: []
  type: TYPE_NORMAL
- en: '**12.9  Making It Bad**'
  prefs: []
  type: TYPE_NORMAL
- en: You never want to have a node with two children, so the root must be either
    the minimum or the maximum of the set of keys. After that, the following key must
    also have a single child, so it must be either the minimum or the maximum of the
    remaining set of keys. If you follow this logic to the end, you have two options
    for the first key, times two options for the second key, times two options for
    the third key, and so on, up until the (*n* – 1) key, after which a single option
    is left. The number of linear trees you can produce out of *n* keys is then 2*^n*
    ^(–1).
  prefs: []
  type: TYPE_NORMAL
- en: '**12.10  Rebuild the Tree**'
  prefs: []
  type: TYPE_NORMAL
- en: Given the preorder and inorder lists, it’s clear that the root of the tree must
    be the first value in the preorder. If you look for that value in the inorder
    list, all keys preceding it will come from the root’s left subtree and all keys
    after it will be from the right subtree. Separate the preorder list in two, and
    you’ll have the preorder and inorder listings for both subtrees; apply recursion,
    and you’ll build the tree.
  prefs: []
  type: TYPE_NORMAL
- en: '**12.11  More Rebuilding?**'
  prefs: []
  type: TYPE_NORMAL
- en: Working with inorder and postorder would be possible; the only difference is
    that you’d find the root at the end of the postorder listing instead of at the
    beginning of the preorder listing. However, working with preorder and postorder
    isn’t possible—and an example should suffice to show why. If I tell you that the
    preorder listing was “1, 2” and the postorder listing was “2, 1”, two possible
    binary search trees produce those listings. Can you find them?
  prefs: []
  type: TYPE_NORMAL
- en: '**12.12  Equal Traversals**'
  prefs: []
  type: TYPE_NORMAL
- en: Preorder and inorder would be the same if there were no left trees, so the first
    answer is “trees with only right subtrees”; for inorder and postorder, the answer
    would similarly be “trees with only left subtrees.” Finally, for preorder and
    postorder, the answer is “trees with no more than one key.”
  prefs: []
  type: TYPE_NORMAL
- en: '**12.13  Sorting by Traversing**'
  prefs: []
  type: TYPE_NORMAL
- en: First, add all the keys into a binary search tree, create an empty array, and
    then do an inorder traversal providing a visit function that will push the key
    value into the array. (You’ll use this technique later in question 12.26.)
  prefs: []
  type: TYPE_NORMAL
- en: '**12.14  Generic Order**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will do. Note the two recursive calls mixed with the three
    possible visit() calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '**12.15  No Recursion Traversal**'
  prefs: []
  type: TYPE_NORMAL
- en: Use a stack from Chapter 11. You could do specific solutions for each of the
    traversals, but let’s go with a generic solution (actually implementing the anyOrder()
    function from earlier) to highlight how a stack makes avoiding recursion easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is that you’ll push into the stack the pending operations, which can
    be of two types: visit a key (type "K") or traverse a tree (type "T"). You’ll
    push these operations, and the main code will be a loop that will pop an operation
    and do it, which may imply visiting or traversing, and the latter will cause more
    operations to be pushed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Start by creating a stack and pushing the tree you want to traverse ❶. While
    there are pending operations ❷, you’ll pop the top one ❸, and if it doesn’t point
    to an empty tree ❹, you’ll execute whatever is needed. If the operation was a
    "K", just visit the node ❺, and if it was a "T" ❻, you’ll have to push two operations
    (traverse the left and right subtrees) and a visit (for the root). The key point
    is to make sure to push them in backward order, so the operations will be popped
    in the right sequence; study this carefully. For instance, if you are doing a
    postorder traversal, you’ll first push the root visit, then the right subtree
    traversal, and finally the left subtree traversal—and when you do those operations
    in reverse order, everything will come out right.
  prefs: []
  type: TYPE_NORMAL
- en: '**12.16  No Duplicates Allowed**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, you just have to check whether you have arrived at the value you
    were thinking of adding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: You add a test for equality before continuing the search ❶, and the other minor
    change is that you don’t test for “less-than-or-equal-to” ❷, because the key can
    never be equal.
  prefs: []
  type: TYPE_NORMAL
- en: '**12.17  Get and Delete**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can manage to get the minimum and remove it at the same time, if after
    finding the minimum value in the (not empty) tree, you copy its right subtree
    to the node; see the following diagram for an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg524.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here’s how to implement this algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Assuming that the tree isn’t empty, if you cannot go to the left, return the
    right tree and the node’s key, and you’re done ❶. Otherwise, recursively get and
    remove the minimum key from the left subtree ❷ and return the updated tree node
    and the found key ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do you use it? The change in remove() is small, affecting only one line:
    instead of first finding the minimum key and then removing it, make a single call
    to _removeMin():'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '**12.18  AVL Worst**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose H*n* is the number of nodes in the worst possible AVL tree of height
    *n*. The first few such trees are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg525.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Build the next worst tree out of the previous two (plus a root), so H[*n*]
    equals H[*n–*][1] + H[*n–*][2] + 1: the sequence is 0, 1, 2, 4, 7, 12, 20, . .
    . , which is one less than the Fibonacci sequence 1, 2, 3, 5, 8, 13, 21, . . .'
  prefs: []
  type: TYPE_NORMAL
- en: '**12.19  Singles Only**'
  prefs: []
  type: TYPE_NORMAL
- en: Given the structure restrictions of AVL trees, only a leaf can be a single child.
    Since every single child has one parent and there may be more (not single) nodes
    in the tree, single children cannot be more than 50 percent of all nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '**12.20  Why One?**'
  prefs: []
  type: TYPE_NORMAL
- en: If the subtrees have sizes *p* and *q*, the tree’s size is *p* + *q* + 1, so
    the fractions are (*p* + 1) / (*p* + *q* + 2) and (*q* + 1) / (*p* + *q* + 2),
    and adding the numerators together produces exactly (*p* + *q* + 2), which is
    the denominator.
  prefs: []
  type: TYPE_NORMAL
- en: '**12.21  Easier Randomizing?**'
  prefs: []
  type: TYPE_NORMAL
- en: The developer is correct in that an ordered sequence of keys would become disordered,
    but a disordered sequence of keys would also exist that would become ordered after
    hashing, so while solving the problem of ordered additions, this technique wouldn’t
    completely solve the worst-case problem.
  prefs: []
  type: TYPE_NORMAL
- en: '**12.22  Why Not Decrement?**'
  prefs: []
  type: TYPE_NORMAL
- en: If the key you want to delete isn’t in the tree, you’d still (wrongly) decrement
    the node size.
  prefs: []
  type: TYPE_NORMAL
- en: '**12.23  Bad Splay?**'
  prefs: []
  type: TYPE_NORMAL
- en: If you only add keys, you’ll get the same linear structure as for common binary
    search trees. However, after a few removals, the height of the tree is considerably
    lowered (and the tree becomes more “bushy”), while for common binary search trees,
    the shape would still be linear.
  prefs: []
  type: TYPE_NORMAL
- en: '**12.24  What Left Subtree?**'
  prefs: []
  type: TYPE_NORMAL
- en: It should be null. The minimum key in a tree has no left subtree; otherwise,
    it wouldn’t be the minimum.
  prefs: []
  type: TYPE_NORMAL
- en: '**12.25  Code Transformation**'
  prefs: []
  type: TYPE_NORMAL
- en: When you splay the tree with reference to a key, you end with a tree that has
    at its root the closest value to the given key, so if the key is -Infinity (assuming
    keys are numeric; an empty string would do for alphabetic keys), you can deduce
    that _splay(tree, -Infinity) produces the same result as _splayMinimum(tree).
  prefs: []
  type: TYPE_NORMAL
- en: 'But you can go further. Take the _splay() code and assume keyToUp is -Infinity,
    a value that cannot be in the tree and that is smaller than all current keys.
    The highlighted parts in the code that follows can then be omitted, either because
    the result is already known or because it’s unreachable code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The keyToUp parameter isn’t needed ❶ ❻, since you are assuming its value. Tests
    for equality will always fail ❷ ❹. Since keyToUp is smaller than any key, the
    side variable will always end with "left" ❸, and the test at ❺ will always succeed,
    making some code ❼ unreachable.
  prefs: []
  type: TYPE_NORMAL
- en: 'After these simplifications, renaming _splay to _splayMin and changing tree[side]
    to tree.left leaves the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Transforming this code to _splayMinimum() is easy now: join the two if statements
    into one by combining their tests, and you’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: '**12.26  Full Rebalance**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is to get all the keys using the technique suggested in question 12.13
    and produce a well-balanced tree, splitting the array in the middle. The key there
    will be the root for the balanced tree, the keys to its left will be used to produce
    the left subtree, and likewise for the keys to its right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Start with the rebalancing code, _buildPerfect() ❶. Given an array of keys,
    if the array is empty ❷, a null tree is returned. Otherwise ❸, find the array’s
    middle point ❹ and return a node as described earlier ❺; use recursion to build
    its balanced subtrees. The restructure() function ❻ is then quite short: generate
    an ordered list of keys using inOrder() ❼ and pass it to the _buildPerfect() function
    to produce the final output ❽.'
  prefs: []
  type: TYPE_NORMAL
- en: '## Chapter 13'
  prefs: []
  type: TYPE_NORMAL
- en: '**13.1  Missing Test?**'
  prefs: []
  type: TYPE_NORMAL
- en: No need; addChild() already does it.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.2  Traversing General Trees**'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation is not complex. If the tree is represented using arrays of children,
    preorder traversal for a nonempty tree entails visiting the root and then sequentially
    traversing each child. For a tree represented in a left-child, right-sibling style,
    the logic starts by visiting the root and then, starting at the first child, traversing
    it and moving to the next sibling until no more siblings are left. In both cases,
    postorder traversal first starts with the children and visits the root only after
    that.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.3  Nonrecursive Visiting**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is quite similar to the breadth-first queue version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'As in other traversals, if the tree is empty, you don’t do anything ❶. Otherwise,
    you create a stack and push the tree’s root into it ❷. Then, you do a loop. While
    the stack isn’t empty ❸, pop the stack top ❹ and visit it, and then finish with
    this tricky detail: you must push all the children in *reverse* order (the rightmost
    first, the leftmost last), so the first child is visited first ❺. Be careful using
    reverse() because it modifies the array, so build a copy using destructuring.'
  prefs: []
  type: TYPE_NORMAL
- en: '**13.4  Tree Equality**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You could do some recursive logic to compare trees, but a simpler solution
    exists: use JSON.stringify() to produce string versions of both trees and compare
    them.'
  prefs: []
  type: TYPE_NORMAL
- en: '**13.5  Measuring Trees**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is similar to what was used for binary trees in Chapter 12:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: An empty tree has size 0 ❶; otherwise, its size is 1 (for the root itself) plus
    the sum of the sizes of all its subtrees ❷, which you can calculate using .reduce().
    Then, for height, an empty tree has height 0 ❸, a leaf has height 1 ❹, and other
    trees have height 1 (for the root) plus the tallest height of any of its subtrees
    ❺.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.6  Sharing More**'
  prefs: []
  type: TYPE_NORMAL
- en: In the implementation, since we borrowed only a single key from a sibling, we
    made do with simple code. To share half and half, you should set up an array with
    all the keys from the left sibling, plus the key of the parent, plus all the keys
    in the right sibling, and divide it. The key at the middle position will go into
    the parent, all the keys to its left to the left sibling, and all the keys to
    its right to the right sibling—and a similar procedure will apply to the pointers
    in the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.7  Faster Node Searching**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The binary search algorithm from Chapter 9 ends, upon a search failure, with
    the left index pointing at the link you should follow; check this out. Here’s
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The algorithm is the standard one you already saw; the difference is that if
    the search fails, it returns the left pointer. As to the effect on the B-tree
    performance, the search in the node sped up by a constant factor (if the order
    of the B-tree is *p*, instead of *p* tests, we do log *p* tests), but the general
    order of algorithms remains *O*(log *n*).
  prefs: []
  type: TYPE_NORMAL
- en: '**13.8  Lowest Order**'
  prefs: []
  type: TYPE_NORMAL
- en: Nodes other than the root in a B-tree of order 2 should have one key and thus
    two children, so that implies a full binary tree since all leaves must be at the
    same level. So, yes, you already knew about B-trees of order 2!
  prefs: []
  type: TYPE_NORMAL
- en: '**13.9  Many Orders of Trees**'
  prefs: []
  type: TYPE_NORMAL
- en: By default, modules are singletons, which means that the code is imported only
    once, so all trees that you create would share the same ORDER variable. If you
    want to have different variables, instead of exporting an object with many properties
    (in module.exports), you need to export a function that, when invoked, returns
    the desired object. You can see some examples of this transformation in Iain Collins’s
    “How (Not) to Create a Singleton in Node.js” at *[https://medium.com/@iaincollins/how-not-to-create-a-singleton-in-node-js-bd7fde5361f5](https://medium.com/@iaincollins/how-not-to-create-a-singleton-in-node-js-bd7fde5361f5)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**13.10  Safe to Delete?**'
  prefs: []
  type: TYPE_NORMAL
- en: When you get to delete a node with no right child, the root was red, implying
    it would have no left child. If the root had been black (the other possibility,
    considering the invariant), its left child would have been red, and you would
    have rotated *it* right, so it wouldn’t then have an empty right child.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**14.1  Is It a Heap?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply loop through all the elements except the root and check that each is
    not greater than its parent. A first implementation could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use .every() to shorten the code and make it more declarative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '**14.2  Making Do with Queues**'
  prefs: []
  type: TYPE_NORMAL
- en: If you assign monotonically ascending values to the elements you enter in a
    priority queue, it will behave like a stack in a last-in, first-out (LIFO) way.
    Similarly, if you assign monotonically descending values to elements, the priority
    queue will emulate a common queue.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.3  Max to Min**'
  prefs: []
  type: TYPE_NORMAL
- en: This is a trick question! Using Floyd’s enhanced heap-building code, you can
    transform *any* array into a min heap in linear time, so you obviously can convert
    a max heap into a min heap in this time.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.4  Max or Min**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Only three code changes are needed: one in the _bubbleUp() function and two
    in the _sinkDown() function. Invert the current comparisons from heap[a] > heap[b]
    to heap[a] < heap[b] and you’re done.'
  prefs: []
  type: TYPE_NORMAL
- en: '**14.5  Merge Away!**'
  prefs: []
  type: TYPE_NORMAL
- en: The needed algorithm works as follows. Create a min heap whose nodes will be
    nodes from the lists. Initialize the heap by taking the first element of each
    list. Initialize an empty output list. Repeatedly, while the heap isn’t empty,
    pick the node corresponding to the root of the heap and remove it from the heap.
    Add the selected node to the output list. If the selected node had a next node,
    add it to the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming the nodes have key and next fields, the code (based on the heap developed
    in this chapter, but inverting some comparisons to produce a min heap as in question
    14.4) could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The add() method pushes a node into the stack (unless it’s null) and bubbles
    it up ❶. The complete logic requires setting up the heap with the first element
    of each list ❷ to then do the merging. Adding an empty initial value for the output
    list ❸ simplifies the code a bit; remember to skip this extra node when returning
    the merged list ❼. While there still are any nodes in the heap ❹ (meaning there
    still is some merging to do), remove the top element, add the next node of the
    corresponding list into the heap ❺, and add the removed element at the end of
    the list ❻; the dummy node avoided the need to test for an empty list. The final
    step just returns the list, without the extra initial node ❼.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test this code easily. The following outputs a few Fibonacci numbers
    starting at 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '**14.6  Searching a Heap**'
  prefs: []
  type: TYPE_NORMAL
- en: You could write a recursive function, but because the array is basically unordered,
    given any node in the heap, you’d have to search in both its left and right subtrees,
    so you will eventually have to look through the whole tree in an *O*(*n*) procedure.
    It would be better simply to use heap.find().
  prefs: []
  type: TYPE_NORMAL
- en: '**14.7  Removing from the Middle of a Heap**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing a key in the heap is a bit similar to removing a key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: After a couple of checks to see whether the removal can be done ❶ ❷, moving
    the last value of the heap to the place of the removed value ❸ restores the structure
    property. The problem is that the value now at index k may not be placed correctly,
    violating the heap property. The simplest way to ensure that this is satisfied
    is to apply _bubbleUp() ❹ first and then sinkDown() ❺. At most, only one of those
    functions will do anything, and you’ll end up with a fully compliant heap.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.8  Faster Build**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The changes to the newHeap() function are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This starts with an empty array and copies the values (if any) into it ❶; then
    it uses _sinkDown() to build the heap ❷ that is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.9  Another Way of Looping**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You could use forEach() in the following way (only the i parameter matters
    here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '**14.10  Extra Looping?**'
  prefs: []
  type: TYPE_NORMAL
- en: It would work the same way (it would just be a tad slower), because the _sinkDown()
    procedure won’t do anything for elements with no children.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.11  Maximum Equality**'
  prefs: []
  type: TYPE_NORMAL
- en: It would be *O*(*n*). Neither _sinkDown() nor _bubbleUp() would do any work,
    so they are *O*(1), and there are *n* calls to those functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.12  Unstable Heap?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple array works for both versions of the heapsort code: [1, 1]. The first
    1 will end at the last place of the sorted array.'
  prefs: []
  type: TYPE_NORMAL
- en: '**14.13  Trimmed Selection**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you find a value at level *i* of a heap, you know for sure that there are
    at least (*i* – 1) values greater than it, because of the heap property. Thus,
    if you are looking for the *k* greatest values of a heap, they cannot be at levels
    (*k* + 1) or beyond. If the heap has more than *k* levels, you can discard all
    beyond the *k*th level, and the selection process will be a bit faster. A heap
    with *k* complete levels has 2*^k* – 1 nodes, so if the heap has more nodes than
    that, you can shorten it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: You could use .slice() to shorten the heap array, but JavaScript allows you
    to modify its .length property directly ❶.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.14  Is It a Treap?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can produce an interesting recursive solution with functional aspects.
    What is a valid treap? If it’s empty, it’s obviously okay; otherwise, its children
    should be treaps too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This checks a basic condition having to do with its key and priority compared
    to those of its parent ❶, but notice that the first time, for the root, a trivial
    validation is provided because obviously the root has no parent with which to
    compare! Then, this recursively checks that both children are also treaps, each
    fulfilling a specific different new condition: the left subtree should have smaller
    keys and priorities than its parent ❷, and the right subtree should have greater
    keys but lower priorities ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: '**14.15  Treap Splitting**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the limit value to the treap with an Infinity priority: because of the
    high priority, this limit will become the new root of the treap, and because of
    the binary search tree structure, all keys smaller than the limit will be in the
    root’s left subtree and greater keys will be in its right subtree, providing the
    desired partitioning.'
  prefs: []
  type: TYPE_NORMAL
- en: '**14.16  Rejoining Two Treaps**'
  prefs: []
  type: TYPE_NORMAL
- en: To create a single treap out of two separate ones, create a dummy node with
    any random key and priority and then assign the first treap as its left subtree,
    assign the second treap as its right subtree, and finish by deleting the root
    dummy node.
  prefs: []
  type: TYPE_NORMAL
- en: '**14.17  Removing from a Treap**'
  prefs: []
  type: TYPE_NORMAL
- en: This would work the same way, but it would be just a bit slower, because it
    would do a series of if statements before going down tree[other].
  prefs: []
  type: TYPE_NORMAL
- en: '**14.18  Trees as Heaps**'
  prefs: []
  type: TYPE_NORMAL
- en: Using a balanced binary search tree would ensure logarithmic performance for
    all three operations, as you’ve seen earlier. However, you can do better by including
    a separate attribute for the maximum seen so far. You’d update it in *O*(1) time
    after each addition by simply comparing the current maximum to the new key, and
    when removing the top, you could find the new maximum also in logarithmic time,
    so top() itself would become *O*(1).
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**15.1  Intuitive but Worse**'
  prefs: []
  type: TYPE_NORMAL
- en: That would be *O*(*m* log *n*), since there would be *m* insertions, each *O*(log
    *n*).
  prefs: []
  type: TYPE_NORMAL
- en: '**15.2  Sequential Cases**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When inserting keys in descending order (the highest first), you get a badly
    shaped heap, but each add() takes constant time. Can you see why? And if you insert
    them in ascending order, you can achieve a full binary tree; see both cases shown
    next for keys from 1 to 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg536.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**15.3  No Recursion Needed**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You could just write the merge as follows; the bold lines show the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The new lines are the same as in the previous case (when the first heap has
    the greatest key), except they exchange heap1 and heap2 throughout.
  prefs: []
  type: TYPE_NORMAL
- en: '**15.4  Change Needed**'
  prefs: []
  type: TYPE_NORMAL
- en: The change() method for a skew heap requires being able to remove a key and,
    after changing it, inserting it again. Given a reference to the node with the
    key, removing it requires a link to the parent (from which you must disconnect
    it), so an up pointer to a node’s parent should be added. You could alternatively
    use bubbleUp(), but it would also need a link to the parent.
  prefs: []
  type: TYPE_NORMAL
- en: '**15.5  Just Adding**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You initially have just a single tree with eight nodes. The following table
    shows which heaps you’d have at each stage and how many merges are needed after
    adding a value; cell items in bold represent merges. For example, adding the 9th
    value requires no merges, but adding the 10th produces two heaps of size 1, so
    a merge is needed to replace them with a heap of size 2\. Similarly, adding the
    11th value requires no merges, but the 12th needs two: first to merge two heaps
    of size 1 and then to merge two heaps of size 2.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Values | 1 | 2 | 4 | 8 | 16 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 0 | 0 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | 1 | 0 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 0 | 1 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | 1 | 1 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | 0 | 0 | 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | 1 | 0 | 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | 0 | 1 | 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 15 | 1 | 1 | 1 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | 0 | 0 | 0 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: You had an initial heap with *n* = 8 values; after adding the other eight values,
    the total number of merges (in bold) was exactly eight, so on average, each addition
    required one merge. This is not a formal proof, of course, but the result can
    be proven mathematically for all binomial heaps.
  prefs: []
  type: TYPE_NORMAL
- en: '**15.6  Faster Binomial Top**'
  prefs: []
  type: TYPE_NORMAL
- en: You can add a variable like _heapTop in lazy binomial heaps to get the top value
    of the heap.
  prefs: []
  type: TYPE_NORMAL
- en: '**15.7  Easier Bubbling Up?**'
  prefs: []
  type: TYPE_NORMAL
- en: The problem is you are working with an addressable heap, and if you change keys
    around, old references to nodes won’t be valid any longer and will point to different
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '**15.8  Searching a Heap**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This algorithm is obviously *O*(*n*) and certainly *not* the kind of thing
    you do with heaps, but let’s do it anyway. The only problem is to notice when
    to stop traversing the circular list of siblings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This is a depth-first traversal. The stopT parameter remembers where you started
    in the list of siblings to avoid a loop ❶. Use node to store either a null value
    (if you don’t find the key) or the found node otherwise ❷. If the tree you’re
    looking at is neither null nor the stop point for the list ❸, check whether you
    found the key you were looking for at the root ❹; if so, save it to return it
    later ❼. If the root didn’t match, search downward ❺, and if that returns a null,
    search to the right, providing the starting point as the stop value ❻. Using xxx
    || yyy is typical of JavaScript; if the value of the xxx expression isn’t “falsy,”
    it is returned; otherwise, the value of the yyy expression is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '**15.9  Two in One**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In _mergeA2B(), you could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'In add(), you could join two assignments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'In remove(), you’d do something similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'And that would also apply in _separate():'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Is it worth it? Four lines saved versus the possibility of misreading or misunderstanding
    the code; it’s your call!
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**16.1  Maps for Tries**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The needed changes with regard to object-based tries are as follows; I leave
    comments up to you, but the modified lines are in bold. Creating a trie requires
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Finding a key just changes the way you access links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the same kind of change when adding a new key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'And the same happens when removing a key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '**16.2  Ever Empty?**'
  prefs: []
  type: TYPE_NORMAL
- en: The answer is yes in case you attempt to add a key that was already in the trie.
  prefs: []
  type: TYPE_NORMAL
- en: '**16.3  Rotate Your Tries**'
  prefs: []
  type: TYPE_NORMAL
- en: Yes, you can apply rotations to a trie. You would work with the left and right
    links only and never affect the middle links.
  prefs: []
  type: TYPE_NORMAL
- en: '**16.4  Empty Middle?**'
  prefs: []
  type: TYPE_NORMAL
- en: True, unless you didn’t want to store any data, in which case, the middle link
    of the EOW characters would be null.
  prefs: []
  type: TYPE_NORMAL
- en: '**16.5  Four-Letter Trie?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The longest path (the trie’s height) would be from the root to the EOW for
    ZZZZ: 104 steps. The number of characters in the keys would be 4, and the alphabet
    is 26 letters, which means the height is the following: 4 × 26 = 104.'
  prefs: []
  type: TYPE_NORMAL
- en: '**16.6  How Do They Look?**'
  prefs: []
  type: TYPE_NORMAL
- en: Both an array-based trie and an object-based trie would be a list of nodes,
    one for each letter. A radix tree would have a single node, with the ALGORITHM
    word in it. Finally, a ternary tree would be a vertical column of nodes, with
    a letter at each level.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**17.1  Where’s the Path?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a next[i][j] matrix that tells you where to go if you are at i and want
    to get to j. Whenever you update dist[i][j] you’ll also update next. Here’s the
    updated algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the next matrix ❶ and fill it with null values as the default ❷. Mark
    that to go from a point to itself, the path obviously passes through that point
    ❸, and whenever there’s an edge between two points, mark that too ❹. Whenever
    you find a better path between two points ❺, update not only dist but next as
    well. At the end, you must return the next matrix ❻, which you’ll use in the following
    path-finding algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Create a sequence array ❶ that will have all intermediate steps. If there is
    some way of going from the first point to the last ❷, push the initial point ❸,
    and if you haven’t reached the destination ❹, advance to the next point ❺ and
    push it ❻. At the end, just return the sequence ❼ that includes all steps.
  prefs: []
  type: TYPE_NORMAL
- en: '**17.2  Stop Searching Sooner**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure to check whether there were any changes in any pass. The main loop
    of the algorithm changes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning of each pass, set the changes variable to false ❶, but if you
    change any distance, set it to true ❷. After going through all the edges ❸, if
    there were no changes, you don’t need to repeat the loops and can exit.
  prefs: []
  type: TYPE_NORMAL
- en: '**17.3  Just One Will Do**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to modify the signature of the function to receive three arguments
    (graph, from, and the added to) and change the main loop to see whether the top
    of the heap is the destination to point; in that case, you stop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '**17.4  The Wrong Way**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is a topological sort of the original graph, but in reverse order:
    the first nodes that appear are those that were the last nodes in the previous
    graph.'
  prefs: []
  type: TYPE_NORMAL
- en: '**17.5  Joining Sets Faster**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There will be two changes. First, all the nodes in the forest will include
    a size attribute, initially set to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The other change appears when merging two sets into a single set. The main
    loop of the isConnected(...) code changes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The code in bold marks the change. If you find two different roots, check which
    has the smallest size and link it to the other root. Don’t forget to update its
    size to account for the added subset.
  prefs: []
  type: TYPE_NORMAL
- en: '**17.6  Take a Shortcut**'
  prefs: []
  type: TYPE_NORMAL
- en: The following modified findParent(...) routine creates the shortcuts as described;
    can you see how it works?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '**17.7  A Spanning Tree for a Tree?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The exact same graph is produced: in a tree there is only one way to get from
    any point to another, so there are no alternatives for a different spanning tree.'
  prefs: []
  type: TYPE_NORMAL
- en: '**17.8  A Heap of Edges**'
  prefs: []
  type: TYPE_NORMAL
- en: I’ll leave this up to you, but I chose heapsort because of its assured performance.
  prefs: []
  type: TYPE_NORMAL
- en: '## Chapter 18'
  prefs: []
  type: TYPE_NORMAL
- en: '**18.1  Getting Here**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The front list isn’t empty, which means someone exited the queue. A possible
    sequence could be as follows: X enters, then A enters, then B enters, then X exits
    (now the back list is empty and the front list consists of A and B), followed
    by C, D, and E entering in that order.'
  prefs: []
  type: TYPE_NORMAL
- en: '**18.2  With Apologies to Abbott and Costello, Who’s on Front?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following logic solves the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: If the queue is empty ❶, there’s no front element; return undefined, throw an
    exception, or perform other similar actions. If the front part isn’t empty ❷,
    its top element is simply the front of the queue. But if the front part is empty
    ❸, go through the back part until its end, because that’s the front of the queue.
  prefs: []
  type: TYPE_NORMAL
- en: '**18.3  No Change Needed**'
  prefs: []
  type: TYPE_NORMAL
- en: There are many possibilities, but the simplest is to throw an exception if the
    key isn’t found and wrap the tree search algorithm in a try...catch structure,
    so if the exception is thrown, just return the original tree.
  prefs: []
  type: TYPE_NORMAL
- en: '**18.4  A New Minimum**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that you apply this function to find the minimum value of a nonempty
    binary search tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: If the root has no left child, the root’s value is the minimum. Otherwise, the
    minimum value of the tree will be the minimum of the root’s left child, because
    all values in that subtree are smaller than the root’s value.
  prefs: []
  type: TYPE_NORMAL
