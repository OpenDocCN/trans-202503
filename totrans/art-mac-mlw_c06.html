<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 6: Disassembly and Decompilation</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:a248aa67-aa2c-49b1-a34e-c916914c0e30" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_125" title="125"/>6</span><br/>
<span class="ChapterTitle">Disassembly and Decompilation</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">In the previous chapter, we covered various static analysis tools useful for triaging unknown Mach-O binaries. However, if you want to comprehensively understand a novel Mac malware specimen, you’ll need a foundational understanding of assembly code, as well as an ability to leverage sophisticated binary analysis tools. </p>
<p>In this chapter, we’ll first discuss assembly language basics and then move on to the static analysis approaches of disassembly and decompilation. We’ll conclude by applying these analysis approaches with Hopper, a popular reversing tool capable of reconstructing binary code in a human-readable format. While Hopper and other advanced binary analysis tools require an elementary understanding of low-level reversing concepts, and may necessitate time-consuming analysis sessions, their abilities are invaluable. Even the most sophisticated malware specimen is no match for a skilled analyst wielding these tools.</p>
<h2 id="h1-501942c06-0001"><span epub:type="pagebreak" id="Page_126" title="126"/>Assembly Language Basics</h2>
<p class="BodyFirst">As the source code of most compiled Mach-O malware generally isn’t available, analysts must leverage tools that can understand the compiled binary’s machine-level code and translate it back into something more readable: assembly code. This process is known as <em>disassembling</em>. <em>Assembly</em> is the low-level programming language that gets translated directly into binary instructions for the computer to execute. This direct translation means that binary code within a compiled binary can later be directly converted back into assembly. For example, on 64-bit Intel systems, the binary sequence 0100 1000 1000 0011 1100 0000 0010 1010 can be represented in assembly code as <code>add rax, 42</code> (which adds 42 to the <code>RAX</code> register). </p>
<p>At its core, a <em>disassembler</em> takes as input a compiled binary, such as a malware sample, and performs this translation back into assembly code. Of course, it’s then up to us to make sense of the provided assembly code. This process of disassembling binary code and understanding the subsequent assembly code is often what malware analysts are talking about when they refer to <em>reverse engineering</em> a malicious sample. </p>
<p>In this section, we’ll cover various assembler basics by focusing on x86_64, the 64-bit version of Intel’s x86 instruction set. We’ll also stick to the standard Intel assembly syntax. Though Apple recently introduced Apple Silicon, backed by the M1 system on a chip with an ARM-based processor, the overwhelming majority of macOS malware is still compiled into x86_64 code. Moreover, all malware natively targeting the M1 architecture will be distributed in the form of universal binaries for the foreseeable future. As we discussed in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>, universal binaries contain multiple architecture-specific binaries, such as those compatible with ARM and Intel. For the purposes of reverse engineering malware, these binaries should be logically identical, so an understanding of Intel’s x86_64 instruction set should suffice. Finally, many assembly language concepts are applicable to both Intel- and ARM-based architectures. However, if you are interested in learning more about the Apple M1’s ARM instruction set architecture as it pertains to analyzing macOS malware, see my 2021 BlackHat presentation, “Arm’d and Dangerous: Analyzing arm64 Malware Targeting macOS” or my white paper on the same topic.<sup class="endnote"><a href="#c06-endnote-1" id="c06-noteref-1">1</a></sup></p>
<p>Entire books have been written on the topics of assembly language and reverse engineering. If you want to delve deeper, several excellent books on the topic of disassembly and reverse engineering include <em>Art of Assembly Language</em>, <em>Hacker Disassembling Uncovered</em>, and <em>Reversing: Secrets of Reverse Engineering.</em><sup class="endnote"><a href="#c06-endnote-2" id="c06-noteref-2">2</a></sup></p>
<p>Here, I aim to provide only the necessary basics, taking some liberties to simplify various ideas, as even a foundational understanding of such concepts is sufficient for becoming a competent malware analyst. </p>
<h3 id="h2-501942c06-0001">Registers </h3>
<p class="BodyFirst">Registers are temporary storage slots on the CPU that can be referenced by name. You can think of them as akin to variables in higher-level programming languages.</p>
<p><span epub:type="pagebreak" id="Page_127" title="127"/>The Intel x86_64 instruction set contains 16 general purpose 64-bit registers, including the registers <code>RAX</code>, <code>RCX</code>, <code>RDX</code>, <code>RBX</code>, <code>RSP</code>, <code>RBP</code>, <code>RDI</code>, <code>RSI</code>, and <code>R8</code> through <code>R15</code>. However, some of these registers are often used for specific purposes. For example, the <code>RSP</code> and <code>RBP</code> registers are used to manage the <em>stack</em>, a region of memory that facilitates function calls and the storage of temporary, or <em>local</em>, variables. You’ll often encounter assembly instructions accessing local variables via a negative offset from the <code>RBP</code> register. The instruction set also contains non-general purpose registers, such as <code>RIP</code>, which contains the address of the next instruction to execute. </p>
<p>We can reference many of the 64-bit general purpose registers by their lower 8-bit, 16-bit, or 32-bit components, which you’ll sometimes come across during binary analysis. For the registers without numbers in their names, a two-letter abbreviation usually identifies the 8- or 16-bit register component. For the 32-bit component, the <code>R</code> is replaced with an <code>E</code>. As an example, consider the 64-bit general purpose register <code>RAX</code>. Its 8-bit component is named <code>AL</code> while its 16-bit component is named <code>AX</code>. Finally, its lower 32 bits are named <code>EAX</code>. For the <code>R8</code>–<code>R15</code> registers, the <code>B</code>, <code>D</code>, and <code>W</code> suffixes denote the lower 8, 16, and 32 bits, respectively. </p>
<h3 id="h2-501942c06-0002">Assembly Instructions</h3>
<p class="BodyFirst">Assembly instructions map to specific sequences of bytes that instruct the CPU to perform an operation. All instructions contain a <em>mnemonic</em>, which is a human-readable abbreviation of the operation. For example, the <code>add</code> mnemonic maps to the binary code to perform, you guessed it, an addition operation.</p>
<p>The majority of assembly instructions also contain one or more <em>operands</em>. These operands specify either the registers, values, or memory that the instruction uses. A few mnemonics and example instructions are provided in <a href="#table6-1" id="tableanchor6-1">Table 6-1</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table6-1">Table 6-1</a>: Mnemonics and Example Instructions</p></figcaption>
<table border="1" id="table-501942c06-0001">
<thead>
<tr>
<td><b>Mnemonic </b></td>
<td><b>Example</b></td>
<td><b>Description</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>add</code></td>
<td><code>add rax, 0x100</code></td>
<td>Adds the second operand (0x100) to the first. </td>
</tr>
<tr>
<td><code>mov</code></td>
<td><code>mov rax, 0x100</code></td>
<td>Moves the second operand (0x100) into the first.</td>
</tr>
<tr>
<td><code>jmp </code></td>
<td><code>jmp 0x100000100</code></td>
<td>Jumps to (continues execution at) the address in the operand (0x100000100).</td>
</tr>
<tr>
<td><code>call</code></td>
<td><code>call</code> <code>rax</code></td>
<td>Executes the subroutine specified at the address in the operand (the <code>RAX</code> register). </td>
</tr>
</tbody>
</table>
</figure>
<h3 id="h2-501942c06-0003">Calling Conventions</h3>
<p class="BodyFirst">You can often gain a fairly comprehensive understanding of a Mach-O binary by studying the system API methods it invokes. For example, a malicious binary that makes a call to a file-writing API method, passing in both the contents of a property list and path that falls within the <em>~/Library/LaunchAgents</em> directory, is likely persisting as a launch agent. Thus, we often don’t need <span epub:type="pagebreak" id="Page_128" title="128"/>to spend hours understanding all the assembly instructions in a binary. Instead, we can focus on the instructions located near API calls in order to determine what API calls are invoked, what arguments are passed in to the API call, and what actions it takes based on the result of the API call. </p>
<p>When a program wants to invoke a method or a system API call, it first needs to prepare any arguments for the call. At the assembly level, there are specific rules about how to pass arguments to a method or API function. This is referred to as the <em>calling convention</em>. The rules of the calling convention are articulated in an application binary interface (ABI). <a href="#table6-2" id="tableanchor6-2">Table 6-2</a> shows the ABI for Intel-based 64-bit macOS systems. </p>
<figure>
<figcaption class="TableTitle"><p><a id="table6-2">Table 6-2</a>: The macOS (Intel 64-Bit) Calling Convention</p></figcaption>
<table border="1" id="table-501942c06-0002">
<thead>
<tr>
<td><b>Item </b></td>
<td><b>Register</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>1st argument </td>
<td><code>RDI</code></td>
</tr>
<tr>
<td>2nd argument </td>
<td><code>RSI</code></td>
</tr>
<tr>
<td>3rd argument</td>
<td><code>RDX</code></td>
</tr>
<tr>
<td>4th argument</td>
<td><code>RCX</code></td>
</tr>
<tr>
<td>5th argument</td>
<td><code>R8</code></td>
</tr>
<tr>
<td>6th argument</td>
<td><code>R9</code></td>
</tr>
<tr>
<td>7th+ argument(s) </td>
<td>via the stack</td>
</tr>
<tr>
<td>Return value</td>
<td><code>RAX</code></td>
</tr>
</tbody>
</table>
</figure>
<p>As these rules are consistently applied, malware analysts can use them to understand exactly how a call is being made. For example, if a method takes a single parameter, the value of this parameter will always be stored in the <code>RDI</code> register prior to the call. Once you’ve identified a call in the disassembly by locating the <code>call</code> mnemonic, looking backwards in the assembly code will reveal the values of the arguments passed to the method or API. This can often provide valuable insight into the code’s logic, like what URL a malware sample is attempting to connect to, or the path of a file it is creating to infect a system. </p>
<p>Likewise, when the <code>call</code> instruction returns, the application binary interface specifies that the return value of the invoked function will be stored in the <code>RAX</code> register. Thus, you’ll often see disassembly immediately following a <code>call</code> instruction that examines and takes an action based on the result of the value in <code>RAX</code>. For example, as you’ll see shortly, a malicious sample might not beacon out to its command and control server for tasking if a function that checks for network connectivity returns zero (false) in the <code>RAX</code> register.</p>
<h3 id="h2-501942c06-0004">The objc_msgSend Function</h3>
<p class="BodyFirst">When compiled, invocations of Objective-C methods become calls to the <code>objc_msgSend</code> function (or a close variant), which routes the original Objective-C method call to the appropriate object at runtime. As malware <span epub:type="pagebreak" id="Page_129" title="129"/>analysts, we’re not really interested in the <code>objc_msgSend</code> function itself; rather, we’d like to discover what Objective-C object and method are being invoked, as these can shed valuable insight into the sample’s capabilities. Luckily, by understanding <code>objc_msgSend</code>’s parameters, we can often reconstruct a representation of the original Objective-C code. <a href="#table6-3" id="tableanchor6-3">Table 6-3</a> summarizes <code>objc_msgSend</code>’s arguments and return value. </p>
<figure>
<figcaption class="TableTitle"><p><a id="table6-3">Table 6-3</a>: Calling Convention, in the Context of the <code>objc_msgSend</code> Function</p></figcaption>
<table border="1" id="table-501942c06-0003">
<thead>
<tr>
<td><b>Item </b></td>
<td><b>Register</b></td>
<td><b>(for) <code>objc_msgSend</code></b></td>
</tr>
</thead>
<tbody>
<tr>
<td>1st argument </td>
<td><code>RDI</code></td>
<td><code>self</code>: object that the method is being invoked upon</td>
</tr>
<tr>
<td>2nd argument </td>
<td><code>RSI</code></td>
<td><code>op</code>: name of the method</td>
</tr>
<tr>
<td>3rd+ argument(s)</td>
<td><code>RDX, RCX,</code> . . .</td>
<td>Any arguments for the method </td>
</tr>
<tr>
<td>Return value</td>
<td><code>RAX</code></td>
<td>Return value from the method </td>
</tr>
</tbody>
</table>
</figure>
<p>For example, consider the short snippet of Objective-C code in <a href="#listing6-1" id="listinganchor6-1">Listing 6-1</a>, which constructs a URL object using the <code>NSURL</code> class’s <code>URLWithString:</code> method.</p>
<pre><code>NSURL* url = [NSURL URLWithString:@"http://www.google.com"];</code></pre>
<p class="CodeListingCaption"><a id="listing6-1">Listing 6-1</a>: Initializing a URL object via Objective-C</p>
<p>When we disassemble the compiled code (<a href="#listing6-2" id="listinganchor6-2">Listing 6-2</a>), we see the <code>objc_msgSend</code> function.</p>
<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">1</span> lea  rdx, qword [http___www_google_com]      ; @"http://www.google.com"  <br/><span aria-label="annotation2" class="CodeAnnotationHang">2</span> mov  rsi, qword [0x100008028]                ; @selector(URLWithString:) <br/><span aria-label="annotation3" class="CodeAnnotationHang">3</span> mov  rdi, qword [objc_cls_ref_NSURL]         ; objc_cls_ref_NSURL <br/>call qword [<b>objc_msgSend</b>]</code></pre>
<p class="CodeListingCaption"><a id="listing6-2">Listing 6-2</a>: Initializing a URL object, disassembled</p>
<p>Consulting <a href="#table6-3">Table 6-3</a>, we see that the <code>objc_msgSend</code> function’s first parameter, named <code>self</code>, contains a pointer to the object upon which the method is being invoked. If the method is a class method, this will be a reference to the class, and in the case of an instance method, <code>self</code><b> </b>will point to an instance of the class as an object. Recall that a function’s first parameter is stored in the <code>RDI</code> register. In <a href="#listing6-2">Listing 6-2</a> you can see that the <code>self</code> parameter references the <code>NSURL</code> class (as the method, <code>URLWithString:</code>, discussed shortly, is a class method) <span aria-label="annotation3" class="CodeAnnotation">3</span>. </p>
<p>The second parameter of the <code>objc_msgSend</code> function, named <code>op</code>, is a pointer to the name of the method invoked. Apple documentation calls this value a selector, which represents the name of the method as a null-terminated string. Recall that you can find the second parameter of a function call in the <code>RSI</code> register. In this example, we can see that the parameter is set to a pointer that references the string <code>URLWithString:</code> <span aria-label="annotation2" class="CodeAnnotation">2</span>.</p>
<p>The remaining parameters passed to the <code>objc_msgSend</code> function are those required by the invoked method. Since the <code>URLWithString:</code> method <span epub:type="pagebreak" id="Page_130" title="130"/>takes a single parameter, the disassembly initializes the <code>RDX</code> register (the third parameter in this case) with a pointer to a string object containing <a class="LinkURL" href="http://www.google.com">http://www.google.com</a><em> </em><span aria-label="annotation1" class="CodeAnnotation">1</span>. Finally, <code>objc_msgSend</code> returns whatever the invoked method returns. Like any other function or method call, the return value can be found in the <code>RAX</code> register. </p>
<p>For an in-depth discussion of the <code>objc_msgSend</code> function, as well as the Objective-C runtime and its internals, consult the Phrack articles “<a class="LinkURL" href="http://www.phrack.org/issues/69/9.html">Modern Objective-C Exploitation Techniques</a>” and “<a class="LinkURL" href="http://www.phrack.org/issues/66/4.html">The Objective-C Runtime: Understanding and Abusing</a>.”<sup class="endnote"><a href="#c06-endnote-3" id="c06-noteref-3">3</a></sup> This wraps up our very brief discussion on assembly language basics. Armed with a foundational understanding of this low-level language and various Objective-C internals, we’ll now take a deeper look at disassembled binary code. </p>
<h2 id="h1-501942c06-0002">Disassembly</h2>
<p class="BodyFirst">In this section we’ll discuss various disassembly concepts and illustrate them with real-world examples taken directly from malicious code. Later in this chapter we’ll walk through the process of leveraging a fully featured disassembler to generate and explore a binary’s full disassembly.</p>
<p>It is important to remember that the goal of analyzing a malicious program is to understand its general logic and capabilities, not necessarily each and every assembly instruction. As I noted earlier, focusing on the logic around method and function calls can often provide an efficient means to gain such an understanding. As such, let’s look at a few examples of disassembled code to illustrate how you can identify such calls, their parameters, and the API response. I’ve chosen these snippets because they highlight idiosyncrasies that creep into a disassembly from the higher-level languages used to write the binary. Note that I’ve abridged them to improve readability. </p>
<h3 id="h2-501942c06-0005">Objective-C Disassembly</h3>
<p class="BodyFirst">In my experience, Objective-C remains the language of choice for malware authors who target Mac users. Yet reversing Objective-C code presents several challenges, such as the widespread use of the <code>objc_msgSend</code> function discussed earlier in this chapter. Luckily, we can still glean plenty of useful information from the disassembly. </p>
<p>Komplex is a backdoor with ties to a prolific Russian APT group.<sup class="endnote"><a href="#c06-endnote-4" id="c06-noteref-4">4</a></sup> It contains various components, including an installer and a second-stage payload. Taking a peek at the installer reveals multiple calls to the <code>objc_msgSend</code> function, indicating we’re looking at compiled Objective-C code. Our goal is to determine the Objective-C objects and methods passed to <code>objc_msgSend</code> function, as these can help us figure out the installer’s actions. </p>
<p>In the installer’s main function, we find the following code (<a href="#listing6-3" id="listinganchor6-3">Listing 6-3</a>):</p>
<pre><code>0x00000001000017De    lea        rsi, qword [_joiner]<br/>0x00000001000017e5    movabs     rdi, 0x20f74<br/><br/>0x0000000100001824    mov        qword [rbp-0x90], rdi<br/>...<br/><span epub:type="pagebreak" id="Page_131" title="131"/>0x000000010000182e    mov        qword [rbp-0x98], rsi <br/>...<br/><br/>0x0000000100001909    mov        rax, qword [objc_cls_ref_NSData] <span aria-label="annotation1" class="CodeAnnotationCode">1</span><br/>0x0000000100001910    mov        rsi, qword [0x1001a9428] ; @selector(dataWithBytes:length:)<br/>0x0000000100001917    mov        rdi, rax <span aria-label="annotation2" class="CodeAnnotationCode">2</span>  <br/>0x000000010000191a    mov        rdx, qword [rbp-0x98] <span aria-label="annotation3" class="CodeAnnotationCode">3</span><br/>0x0000000100001921    mov        rcx, qword [rbp-0x90] <br/>0x0000000100001928    call       objc_msgSend <br/>0x000000010000192d    mov        qword [rbp-0x60], rax </code></pre>
<p class="CodeListingCaption"><a id="listing6-3">Listing 6-3</a>: Initializing a <code>NSData</code> object, disassembled (Komplex)</p>
<p>First, we see two local variables (<code>rbp-0x90</code> and <code>rbp-0x98</code>) being initialized, the first with a hardcoded value of <code>0x20f74</code>, and the second with the address of a global variable named <code>_joiner</code>. </p>
<p>Moving on, we then see a reference to the <code>NSData</code> class moved into the <code>RAX</code> register <span aria-label="annotation1" class="CodeAnnotation">1</span>. Two lines later, it is moved into the <code>RDI</code> register <span aria-label="annotation2" class="CodeAnnotation">2</span>. We know that when a function is called, its first parameter is stored in the <code>RDI</code> register, and that for calls to the <code>objc_msgSend</code> function, this parameter is the class or object upon which a method is to be invoked. Therefore, we now know that the malware is invoking an <code>NSData</code> class method. But which one? </p>
<p>Well, the second parameter passed to the <code>objc_msgSend</code> function identifies the method, and we know we can find it in the <code>RSI</code> register. In the disassembly, we see the <code>RSI</code> register initialized with a pointer stored at <code>0x1001a9428</code>. Moreover, the disassembler has annotated this address to let us know the installer is invoking a method named <code>dataWithBytes:length:</code>, which belongs to the <code>NSData</code> class. </p>
<p>Next, take a look at the two parameters for this method, which get passed into the <code>objc_msgSend</code> function via the <code>RDX</code> and <code>RCX</code> registers <span aria-label="annotation3" class="CodeAnnotation">3</span>. The <code>RDX</code> register will contain the value for the <code>dataWithBytes:</code> parameter and is initialized from the local variable <code>rbp-0x98</code>. Recall that this variable contains the address of a global variable named <code>_joiner</code>. The <code>RCX</code> register holds the value for the <code>length:</code> parameter and is initialized from the local variable <code>rbp-0x90</code>, which contains <code>0x20f74</code>. </p>
<p>From this analysis, we can reconstruct the original Objective-C call as follows (<a href="#listing6-4" id="listinganchor6-4">Listing 6-4</a>): </p>
<pre><code>NSData* data = [NSData dataWithBytes:_joiner length:0x20f74]; </code></pre>
<p class="CodeListingCaption"><a id="listing6-4">Listing 6-4</a>: Reconstructed Objective-C code (Komplex)</p>
<p>The created <code>NSData</code> object is then saved into a local variable found at <code>rbp-0x60</code>. </p>
<p>Next, we find another Objective-C call (<a href="#listing6-5" id="listinganchor6-5">Listing 6-5</a>).</p>
<pre><code>0x00000001000017d2    lea       rcx, qword [cfstring__tmp_content]   ; @"/tmp/content"<br/>0x00000001000017d9    mov       edx, 0x1<br/>...<br/>0x0000000100001838    mov       dword [rbp-0x9c], edx<br/>...<br/>0x0000000100001848    mov       qword [rbp-0xb0], rcx <br/><br/><span epub:type="pagebreak" id="Page_132" title="132"/>0x0000000100001931    mov       rax, qword [rbp-0x60] ; ret value from dataWithBytes:length:. <br/>0x0000000100001935    mov       rsi, qword [0x1001a9430] ; @selector(writeToFile:atomically:) <span aria-label="annotation1" class="CodeAnnotationCode">1</span><br/>0x000000010000193c    mov       rdi, rax <br/>0x000000010000193f    mov       rdx, qword [rbp-0xb0]<br/>0x0000000100001946    mov       ecx, dword [rbp-0x9c] <span aria-label="annotation2" class="CodeAnnotationCode">2</span><br/>0x000000010000194c    call      objc_msgSend</code></pre>
<p class="CodeListingCaption"><a id="listing6-5">Listing 6-5</a>: Writing out a file, disassembled (Komplex)</p>
<p>Two more local variables are initialized here, the first with a path to a file named <em>content</em> in the <em>/tmp</em> directory and the second with the hardcoded value of <code>1</code>. Then the <code>NSData</code> object created in the previous snippet of disassembly is loaded into <code>RAX</code>, and then into <code>RDI</code>. As the <code>RDI</code> register holds the first parameter for the <code>objc_msgSend</code> function call, we now know the installer is invoking a method call on this object. </p>
<p>The method is stored in the <code>RSI</code> register and identified by the disassembler as <code>writeToFile:atomically:</code> <span aria-label="annotation1" class="CodeAnnotation">1</span>. The parameters for this method are stored in the <code>RDX</code> and <code>RCX</code> registers. The former, which corresponds to the <code>writeToFile:</code> parameter, is initialized from the local variable holding the path <em>/tmp/content</em>. The latter is a Boolean flag for the <code>atomically:</code> parameter and is initialized from the local variable that contained the value <code>1</code>. As the full 64-bit register is not needed, the compiler chose to use only the lower 32 bits, which explains the reference to <code>ECX</code> instead of <code>RCX</code> <span aria-label="annotation2" class="CodeAnnotation">2</span>. </p>
<p>From this analysis, we can again reconstruct the original Objective-C call (<a href="#listing6-6" id="listinganchor6-6">Listing 6-6</a>): </p>
<pre><code>[data writeToFile:@"/tmp/content" atomically:1] </code></pre>
<p class="CodeListingCaption"><a id="listing6-6">Listing 6-6</a>: Reconstructed Objective-C (Komplex)</p>
<p>Combined with our analysis of the previous Objective-C call, we’ve uncovered the fact that the malware is writing an embedded payload, found in the global variable named <code>joiner</code><em>, </em>to the <em>/tmp/content</em> file. We can confirm that indeed <em>joiner</em> contains an embedded (Mach-O) payload by viewing its contents, which are found at <code>0x100004120</code> (<a href="#listing6-7" id="listinganchor6-7">Listing 6-7</a>).</p>
<pre><code>_joiner:<br/>0x0000000100004120         <b>db</b>  0xcf ; '.' <br/>0x0000000100004121         <b>db</b>  0xfa ; '.'<br/>0x0000000100004122         <b>db</b>  0xed ; '.'<br/>0x0000000100004123         <b>db</b>  0xfe ; '.'<br/>0x0000000100004124         <b>db</b>  0x07 ; '.'<br/>0x0000000100004125         <b>db</b>  0x00 ; '.'<br/>0x0000000100004126        <b> db</b>  0x00 ; '.'</code></pre>
<p class="CodeListingCaption"><a id="listing6-7">Listing 6-7</a>: An embedded Mach-O binary (Komplex)</p>
<p>Taking into account Intel’s little-endian format, which specifies that the least significant byte of a word is stored at the smallest address, the first four bytes make up the value <code>0xfeedfacf</code>. This value maps to the <code>MH_MAGIC_64</code> constant, which indicates the start of a 64-bit Mach-O executable. Continued analysis of the installer’s disassembly reveals that, once the embedded <span epub:type="pagebreak" id="Page_133" title="133"/>binary payload has been written to disk, it is executed. Triaging this binary reveals it is in fact Komplex’s persistent second-stage payload.</p>
<h3 id="h2-501942c06-0006">Swift Disassembly</h3>
<p class="BodyFirst">Of course, not all malware is written in Objective-C. The Swift programming language is the trendy new kid on the block, and several macOS malware specimens have been written in it. Reversing a Swift binary is slightly more difficult than reversing one written in Objective-C due to factors such as name mangling and other programming abstractions. <em>Name mangling</em> encodes items such as method names to ensure they are unique within a compiled binary. Unfortunately, unless demangled, this greatly impacts the readability of the item’s name, complicating analysis. </p>
<p>However, modern disassemblers are now able to produce reasonably understandable disassembly listings from compiled Swift binaries with, for example, mangled names fully decoded and added as annotations. Moreover, as the Swift runtime leverages many Objective-C frameworks, our discussion of the <code>objc_msgSend</code> function is still relevant. In mid-2020, researchers discovered a new macOS backdoor, which they named Dacls and attributed to the Lazarus APT Group. Its malicious installer application was written in Swift. Here we’ll highlight several snippets of its disassembly, which show the malware initializing and then launching an Objective-C <code>NSTask</code> object to execute installation commands (<a href="#listing6-8" id="listinganchor6-8">Listing 6-8</a>). </p>
<pre><code>0x000000010001e1f1    mov        r15, rax<br/>0x000000010001e1f4    movabs     rdi, '/bin/bash' <span aria-label="annotation1" class="CodeAnnotationCode">1</span><br/>0x000000010001e1fe    movabs     rsi, 'h\x00\x00\x00\x00\x00\x00\xe9'<br/>0x000000010001e208    call       imp___stubs__$sSS10FoundationE19_bridgeToObjectiveCSo8NSString<br/>                                 CyF ; (extension in Foundation):Swift.String._bridgeToObjectiv<br/>                                 eC() -&gt; __C.NSString <span aria-label="annotation2" class="CodeAnnotationCode">2</span><br/><br/>0x000000010001e20d    mov        rbx, rax<br/>0x000000010001e210    mov        rsi, qword [0x100045ba0] ; @selector(setLaunchPath:)<br/>0x000000010001e217    mov        rdi, r15<br/>0x000000010001e21a    mov        rdx, rax<br/>0x000000010001e21d    call       objc_msgSend <span aria-label="annotation3" class="CodeAnnotationCode">3</span></code></pre>
<p class="CodeListingCaption"><a id="listing6-8">Listing 6-8</a>: Swift disassembly of an <code>NSTask</code> initialization (Dacls)</p>
<p>This chunk of Swift disassembly bridges a Swift string to an Objective-C <code>NSString</code> <span aria-label="annotation2" class="CodeAnnotation">2</span>. From the disassembly, it is apparent that this string is the path to a shell: <em>/bin/bash</em> <span aria-label="annotation1" class="CodeAnnotation">1</span>. Next, as an Objective-C string, it is passed to the <code>NSTask</code>’s <code>setLaunchPath:</code> method, which gets invoked via the <code>objc_msgSend</code> function <span aria-label="annotation3" class="CodeAnnotation">3</span>. Though the <code>NSTask</code> object (found in the <code>R15</code> register) is not visible in this snippet of disassembly, the method selector <code>setLaunchPath:</code> and its argument (stored in <code>RAX</code>, as the return of the bridging call) are. Often, knowing a method name is sufficient to ascertain the class or object type, due to the fact that this name can be unique to the class. For example, a quick Google search of, or consulting Apple’s documentation on, the <code>setLaunchPath:</code> method reveals it belongs to the <code>NSTask</code> class.</p>
<p><span epub:type="pagebreak" id="Page_134" title="134"/>Once the malware has set the <code>NSTask</code>’s launch path to <em>/bin/bash</em>, it initializes the task’s arguments (<a href="#listing6-9" id="listinganchor6-9">Listing 6-9</a>). </p>
<pre><code>0x000000010001e273    call       swift_allocObject <span aria-label="annotation1" class="CodeAnnotationCode">1</span><br/>0x000000010001e278    mov        rbx, rax<br/>...<br/>0x000000010001e286    mov        qword [rax+0x20], '-c' <span aria-label="annotation2" class="CodeAnnotationCode">2</span><br/>...<br/>0x000000010001e2a4    mov        r14, qword [rbp+var_80]  <br/>0x000000010001e2a8    mov        qword [rbx+0x38], r14<br/>...<br/>0x000000010001e2c0    mov        rsi, qword [_$sSSN_10003d0b8]  ; type metadata for Swift.<br/>                                                                  String ;<br/>0x000000010001e2c7    mov        rdi, rbx<br/>0x000000010001e2ca    call       imp___stubs__$sSa10FoundationE19_bridgeToObjectiveCSo7NSArrayC<br/>                                 yF ; (extension in Foundation):Swift.Array._bridgeToObjectiveC<br/>                                 () -&gt; __C.NSArray <span aria-label="annotation3" class="CodeAnnotationCode">3</span><br/>0x000000010001e2cf    mov        r13, rax<br/>...<br/>0x000000010001e2da    mov        rsi, qword [0x100045ba8] ; @selector(setArguments:)<br/>0x000000010001e2e1    mov        rdi, r15 <br/>0x000000010001e2e4    mov        rdx, r13<br/>0x000000010001e2e7    call       objc_msgSend <span aria-label="annotation4" class="CodeAnnotationCode">4</span></code></pre>
<p class="CodeListingCaption"><a id="listing6-9">Listing 6-9</a>: More Swift disassembly of an <code>NSTask</code> initialization (Dacls)</p>
<p>As you can see, the method creates an object containing various Swift strings <span aria-label="annotation1" class="CodeAnnotation">1</span>, then bridges this to an <code>NSArray</code> <span aria-label="annotation3" class="CodeAnnotation">3</span>. This is then passed to the <code>NSTask</code>’s <code>setArguments:</code> method, which is invoked via the <code>objc_msgSend</code> function <span aria-label="annotation4" class="CodeAnnotation">4</span>. The <code>-c</code> argument <span aria-label="annotation2" class="CodeAnnotation">2</span> instructs bash to treat the following string as a command. It isn’t easy to figure out the method’s remaining arguments from this snippet of disassembly, but by using dynamic analysis (as described in the following chapters) we can passively recover these arguments, as well as determine that they are partially hardcoded within the binary at <code>0x0000000100033f70</code> (<a href="#listing6-10" id="listinganchor6-10">Listing 6-10</a>):</p>
<pre><code>0x0000000100033f70    <b>db</b>        " ~/Library/.mina &gt; /dev/null 2&gt;&amp;1 &amp;&amp; chmod +x<br/>~/Library/.mina &gt; /dev/null 2&gt;&amp;1 &amp;&amp; ~/Library/.mina &gt; /dev/null 2&gt;&amp;1", 0</code></pre>
<p class="CodeListingCaption"><a id="listing6-10">Listing 6-10</a>: Embedded arguments (Dacls)</p>
<p>These hardcoded arguments are prefixed at runtime with the copy command (<code>cp</code>) and the name of the malware’s persistent backdoor, <code>SubMenu.nib</code>. Cumulatively the arguments instruct bash to first copy the persistent backdoor to <em>~/Library/.mina</em>, set it to be executable, and finally launch it. To trigger these actions, the malware invokes the <code>NSTask</code> <code>launch</code> method (<a href="#listing6-11" id="listinganchor6-11">Listing 6-11</a>).</p>
<pre><code>0x000000010001e300    mov        rdi, qword [rcx+rax]<br/>0x000000010001e304    mov        rsi, qword [0x100045bb0]   ; @selector(launch) <span aria-label="annotation1" class="CodeAnnotationCode">1</span><br/>0x000000010001e30b    call       objc_msgSend <span aria-label="annotation2" class="CodeAnnotationCode">2</span></code></pre>
<p class="CodeListingCaption"><a id="listing6-11">Listing 6-11</a>: Disassembly of an <code>NSTask</code> launch (Dacls)</p>
<p><span epub:type="pagebreak" id="Page_135" title="135"/>As expected, the Objective-C method call is routed through the <code>objc_msgSend</code> function <span aria-label="annotation2" class="CodeAnnotation">2</span>. Helpfully, though, the disassembler has annotated the selector: <code>NSTask</code>’s <code>launch</code> method <span aria-label="annotation1" class="CodeAnnotation">1</span>.</p>
<p>At this point, from just these snippets of disassembled Swift code, we’ve been able to extract the malicious installer’s core logic. Specifically, we determined that a persistent payload (<em>SubMenu.nib</em>) was copied to the <em>~/Library/.mina</em> directory and then launched. </p>
<h3 id="h2-501942c06-0007">C/C++ Disassembly</h3>
<p class="BodyFirst">Malware authors occasionally craft Mac malware in non-Apple programming languages such as C or C++. Let’s look at another abridged snippet of disassembly, this time from a Lazarus Group first-stage implant loader named AppleJeus, originally written in C++.<sup class="endnote"><a href="#c06-endnote-5" id="c06-noteref-5">5</a></sup> The snippet is from a function named <code>getDeviceSerial</code>, though due to C++ name mangling it shows up in the disassembler as <code>Z15getDeviceSerialPc</code>. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Mangled names usually start with <code>Z</code> (or <code>_Z</code>). Following this is the length of the function name (for example, <code>15</code> for the length of <code>getDeviceSerial</code>). The mangled name is then suffixed with argument types. For example, a <code>P</code> refers to a pointer and <code>c</code> refers to a character, meaning the <code>getDeviceSerial</code> function takes a single argument whose type is character pointer (<code>char *</code>).</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>As you peruse the rather large chunk of disassembly (<a href="#listing6-12" id="listinganchor6-12">Listing 6-12</a>), first observe that the disassembler has extracted the function declaration as an annotation, which (luckily for us) includes its original name and the number and format of its parameters. From the demangled name, <code>getDeviceSerial</code>, let’s assume that this function will retrieve the serial number of the infected system (though we’ll also validate this). Since the function takes, as its only parameter, a pointer to a string buffer (<code>char*</code>), it seems reasonable to assume the function will store the extracted serial number in this buffer so that it is available to the caller.</p>
<pre><code>__Z15getDeviceSerialPc:          // getDeviceSerial(char*) <br/><br/>0x0000000100004548    mov        r14, rdi <span aria-label="annotation1" class="CodeAnnotationCode">1</span><br/><br/>0x0000000100004559    mov        rax, qword [_kIOMasterPortDefault]<br/>0x0000000100004560    mov        r15d, dword [rax] <span aria-label="annotation2" class="CodeAnnotationCode">2</span><br/><br/>0x0000000100004563    lea        rdi, qword [IOPlatformExpertDevice] ;"IOPlatformExpertDevice"<br/>0x000000010000456a    call       IOServiceMatching <span aria-label="annotation3" class="CodeAnnotationCode">3</span><br/><br/>0x000000010000456f    mov        edi, r15d <br/>0x0000000100004572    mov        rsi, rax                   <br/>0x0000000100004575    call       IOServiceGetMatchingService <span aria-label="annotation4" class="CodeAnnotationCode">4</span><br/><br/>0x000000010000457e    mov        r15d, eax<br/>0x0000000100004581    mov        rax, qword [_kCFAllocatorDefault]<br/>0x0000000100004588    mov        rdx, qword [rax] <br/>0x000000010000458b    lea        rsi, qword [IOPlatformSerialNumber] <br/>0x0000000100004592    xor        ecx, ecx                   <br/><span epub:type="pagebreak" id="Page_136" title="136"/>0x0000000100004594    mov        edi, r15d                 <br/>0x0000000100004597    call       IORegistryEntryCreateCFProperty <span aria-label="annotation5" class="CodeAnnotationCode">5</span><br/><br/>0x000000010000459c    mov        edx, 0x20<br/>0x00000001000045a1    mov        ecx, 0x8000100<br/>0x00000001000045a6    mov        rdi, rax                   <br/>0x00000001000045a9    mov        rsi, r14                  <br/>0x00000001000045ac    call       CFStringGetCString <span aria-label="annotation6" class="CodeAnnotationCode">6</span><br/> <br/>return</code></pre>
<p class="CodeListingCaption"><a id="listing6-12">Listing 6-12</a>: Disassembly of a <code>getDeviceSerial</code> function (AppleJeus)</p>
<p>First, the function moves its single argument stored in <code>RDI</code>, the output buffer, into the <code>R14</code> register, effectively locally saving it <span aria-label="annotation1" class="CodeAnnotation">1</span>. It does so because if the <code>getDeviceSerial</code> function makes any other calls that expect arguments (which it does), the <code>RDI</code> register will be reinitialized for those other calls. As you’ll see, at the end of the <code>getDeviceSerial</code> function, this output buffer is populated with the device’s serial number. Thus, the function must save this argument into an unused register. The use of such “scratch” registers to preserve values is quite common, and their annotations often facilitate the reversing of complex functions. </p>
<p>The function moves a pointer to <code>kIOMasterPortDefault</code> into <code>RAX</code> and dereferences it into the <code>R15</code> register <span aria-label="annotation2" class="CodeAnnotation">2</span>. </p>
<p>According to Apple developer documentation, <code>kIOMasterPortDefault</code> is the default mach port used to communicate with IOKit services.<sup class="endnote"><a href="#c06-endnote-6" id="c06-noteref-6">6</a></sup> (A <em>mach port </em>is a mechanism to facilitate inter-process communications.) From this observation, it seems likely that the malware will leverage IOKit to extract the infected device’s serial number.</p>
<p>Next, we see the <code>getDeviceSerial</code> function make its first call into an Apple API: the <code>IOServiceMatching</code> function <span aria-label="annotation3" class="CodeAnnotation">3</span>. Apple <a class="LinkURL" href="https://developer.apple.com/documentation/iokit/1514687-ioservicematching?language=objc">notes</a> that this function, which takes a single parameter, will create and return a dictionary that facilitates the searching of and matching on a target IOKit service.<sup class="endnote"><a href="#c06-endnote-7" id="c06-noteref-7">7</a></sup> We know that the <code>RDI</code> register holds the first argument of a function or method call. Just prior to making the call, we see the assembly code initialize this register with the value of <code>"IOPlatformExpertDevice"</code>. In other words, it’s invoking the <code>IOServiceMatching</code> function with the string <code>"IOPlatformExpertDevice"</code>. </p>
<p>Once the matching dictionary has been created, the code invokes another IOKit API, the <code>IOServiceGetMatchingService</code> function <span aria-label="annotation4" class="CodeAnnotation">4</span>. Apple documentation states that this function will find the IOService that matches the specified search criteria.<sup class="endnote"><a href="#c06-endnote-8" id="c06-noteref-8">8</a></sup> For parameters, it expects a master port and a matching dictionary. The disassembled code moves a value from the <code>R15</code> register into the <code>EDI</code> register (the 32-bit part of the <code>RDI</code> register). A few lines earlier, the code moved <code>kIOMasterPortDefault</code> into the <code>R15</code> register. Thus, the code is simply moving <code>kIOMasterPortDefault</code> into the <code>EDI</code> register, making it the first argument for the call to <code>IOServiceGetMatchingService</code>. Likewise, notice <code>RAX</code> being moved into the <code>RSI</code> register before the call, as the <code>RSI</code> register is used as the second parameter for function calls. Because the <code>RAX</code> register holds the result of the call, the <code>RSI</code> register will contain the matching dictionary from the call to <code>IOServiceMatching</code>. After <span epub:type="pagebreak" id="Page_137" title="137"/>the call to <code>IOServiceGetMatchingService</code>, an <code>io_service_t</code> service is returned in the <code>RAX</code> register. As the matching dictionary was initialized with <code>"IOPlatformExpertDevice"</code>, a reference to the <code>IOPlatformExpertDevice</code> IOKit object will be found and returned. As you’ll see, this object can be queried for information about the system (platform), including its serial number. </p>
<p>Next, the code sets up the parameters for a call to a system function that extracts the value of an <code>IOKit</code> registry property: <code>IORegistryEntryCreateCFProperty</code> <span aria-label="annotation5" class="CodeAnnotation">5</span>. This parameter setup begins by loading <code>kCFAllocatorDefault</code> into <code>RDX</code>, the register used for the third argument. Apple’s documentation of the function specifies that this is the memory allocator to use.<sup class="endnote"><a href="#c06-endnote-9" id="c06-noteref-9">9</a></sup> Following this, the address of the string <code>"IOPlatformSerialNumber"</code> is loaded into the <code>RSI</code> register. Used for the second argument, this register is the property name of interest. Next, the 32-bit component of the <code>RCX</code> register (<code>ECX</code>), the fourth argument, is initialized to zero, as the XORing of one register with itself sets the register to zero. Finally, before making the call, the value from <code>R15D</code> (the <code>D</code> indicating the 32-bit part of the <code>R15</code> register) is moved into <code>EDI</code>, the 32-bit part of the <code>RDI</code> register. This has the effect of initializing the <code>RDI</code> parameter with the value of <code>kIOMasterPortDefault</code> previously stored in <code>R15D</code>. After the call to <code>IORegistryEntryCreateCFProperty</code>, the <code>RAX</code> register will hold the value of the required property: <code>IOPlatformSerialNumber</code>.</p>
<p>Finally, the function invokes the <code>CFStringGetCString</code> function to convert the extracted property, a <code>CFString</code> object, to a plain, null-terminated C-string <span aria-label="annotation6" class="CodeAnnotation">6</span>. Of course, the parameters must be initialized prior to this call. The <code>EDX</code> register (the 32-bit part of the <code>RDX</code>) is set to <code>0x20</code>, which specifies the output buffer size. The <code>ECX</code> register (the 32-bit part of the <code>RCX</code>) is set to <code>kCFStringEncodingUTF8</code> (<code>0x8000100</code>). The <code>RDI</code> register is set to the value of <code>RAX</code>, which contains the extracted property value of <code>IOPlatformSerialNumber</code>. Lastly, the second argument, <code>RSI</code>, is set to <code>R14</code>. Remember that the <code>R14</code> register contains the value from <code>RDI</code> passed to <code>getDeviceSerial</code>. Since Apple’s documentation for <code><a class="LinkURL" href="https://developer.apple.com/documentation/corefoundation/1542721-cfstringgetcstring?language=objc">CFStringGetCString</a></code> states that the second argument is the buffer into which to copy the string, we now know that the parameter passed to the <code>getDeviceSerial</code> function is indeed an output buffer for a serial number.<sup class="endnote"><a href="#c06-endnote-10" id="c06-noteref-10">10</a></sup><sup> </sup></p>
<p>It’s worth noting that although higher-level languages such as C++ require passing the arguments in a specified order, the only requirement at the assembly level is that the parameters are stored in the appropriate registers or stack location before a call is made. As a result, you may see instructions that initialize the arguments “out of order.” For example, here you see the second argument being set last. </p>
<p>By focusing on the API calls made by the <code>getDeviceSerial</code> function, we were able to confirm its functionality: retrieving the infected system’s serial number (<code>IOPlatformSerialNumber</code>) via <code>IOKit</code>. Moreover, using parameter analysis we were able to determine that the <code>getDeviceSerial</code> function would be invoked with a buffer for the serial number. Who needs source code, right?</p>
<h3 id="h2-501942c06-0008">Control Flow Disassembly</h3>
<p class="BodyFirst">So far, our analysis has focused on the logic contained solely within functions, not on the interactions of the functions and the code that invokes them. Understanding such interactions is important when analyzing malware, as <span epub:type="pagebreak" id="Page_138" title="138"/>malicious code will often take decisive actions based on the return value of a single function. Komplex’s payload provides an illustrative example.</p>
<p>Komplex’s persistent payload contains logic in a function named <code>__Z19connectedToInternetv</code> (which demangles to <code>connectedToInternet</code>). This aptly named function checks if an infected host is connected to the internet. If the host is offline, the malware will understandably wait until network connectivity is restored before attempting to connect to its command and control server for tasking. (This check also doubles as a basic anti-analysis mechanism, based on the assumption that most analysis systems are not connected to the internet.) </p>
<p>Let’s examine the disassembly of malware code that invokes the <code>connectedToInternet</code> function and then acts upon its response (<a href="#listing6-13" id="listinganchor6-13">Listing 6-13</a>). </p>
<pre><code>0x0000000100005b15:<br/>0x0000000100005b15    call       connectedToInternet()<br/>0x0000000100005b1a    and        al, 0x1<br/>0x0000000100005b1c    mov        byte [rbp+var_19], al<br/>0x0000000100005b1f    test       byte [rbp+var_19], 0x1 <br/><span aria-label="annotation1" class="CodeAnnotationHang">1</span> 0x0000000100005b23    jz         loc_100005b2e <br/><span aria-label="annotation2" class="CodeAnnotationHang">2</span> 0x0000000100005b29    jmp        loc_100005b40 <br/><br/><span aria-label="annotation3" class="CodeAnnotationHang">3</span> 0x0000000100005b2e:<br/>0x0000000100005b2e    mov        edi, 0x3c<br/>0x0000000100005b33    call       sleep<br/>0x0000000100005b38    mov        [rbp+var_3C], eax<br/><span aria-label="annotation4" class="CodeAnnotationHang">4</span> 0x0000000100005b3b    jmp        0x0000000100005b15<br/><br/>loc_100005b40: <br/>...</code></pre>
<p class="CodeListingCaption"><a id="listing6-13">Listing 6-13</a>: Network connectivity check and control flow (Komplex)</p>
<p>First, the malware invokes the <code>connectedToInternet</code> function. As this function takes no parameters, no register setup is required. Following the call, the malware checks the return value via a <code>test</code> and a <code>jz</code> (jump zero) instruction. The <code>test</code> instruction bitwise <code>AND</code>s two operands (discards the result) and sets the <code>zero</code> flag based on the result. Thus, if the <code>connectedToInternet</code> function returns a zero, the <code>jz</code> instruction will be taken <span aria-label="annotation1" class="CodeAnnotation">1</span>, jumping to the instructions at <code>0x0000000100005b2e</code> <span aria-label="annotation3" class="CodeAnnotation">3</span>. Here, the code invokes the system’s <code>sleep</code> function before looping back to the instructions at <code>0x0000000100005b15</code> to check for connectivity once again <span aria-label="annotation4" class="CodeAnnotation">4</span>. Once the <code>connectedToInternet</code> function returns a non-zero value, an unconditional jump is taken <span aria-label="annotation2" class="CodeAnnotation">2</span>, exiting the loop. In other words, the malware will wait until the system is connected to the internet before continuing on. </p>
<p>Now that we understand the malware’s functionality, we can reconstruct the logic with the following Objective-C code (<a href="#listing6-14" id="listinganchor6-14">Listing 6-14</a>).</p>
<pre><code>while(0x0 == connectedToInternet()) {<br/>    sleep(0x3c);<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing6-14">Listing 6-14</a>: Network connectivity check and control flow, reconstructed (Komplex)</p>
<p><span epub:type="pagebreak" id="Page_139" title="139"/>After walking through these various chunks of disassembly, we can probably all agree that reading assembly code is rather tedious. Luckily, due to recent advances in decompiler technologies, there is hope! </p>
<h2 id="h1-501942c06-0003">Decompilation</h2>
<p class="BodyFirst">You’ve seen how a disassembler can parse a file and translate the binary code back into human-readable assembly. Decompilers seek to take this translation one step further by recreating a source-code level representation of extracted binary code. This source-code representation can be both more succinct and readable than assembly, making analysis of unknown binaries a simpler task. Advanced reverse-engineering tools often contain both disassembler and decompiler capabilities. Examples of such tools include Hopper (discussed in the next section), IDA Pro, and Ghidra. </p>
<p>Recall the <code>getDeviceSerial</code> function from the Lazarus Group first-stage implant loader? While the full disassembly of this function is about 50 lines long, the decompilation is much more succinct, clocking in at roughly 15 lines (<a href="#listing6-15" id="listinganchor6-15">Listing 6-15</a>).</p>
<pre><code>int getDeviceSerial(int * arg0) {<br/>    r14 = arg0;<br/>    ...<br/>    r15 = kIOMasterPortDefault;<br/>    rax = IOServiceMatching("IOPlatformExpertDevice");<br/>    rax = IOServiceGetMatchingService(r15, rax);<br/>    if (rax != 0x0) {<br/>        rbx = CFStringGetCString(IORegistryEntryCreateCFProperty(rax, <br/>              @"IOPlatformSerialNumber", kCFAllocatorDefault, 0x0), r14, 0x20, <br/>              kCFStringEncodingUTF8) != 0x0 ? 0x1 : 0x0;<br/>        IOObjectRelease(rax);<br/>    }<br/>    rax = rbx;<br/>    return rax;<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing6-15">Listing 6-15</a>: Decompilation of the <code>getDeviceSerial</code> function (AppleJeus)</p>
<p>The decompilation is quite readable, making it relatively easy to understand the logic of this function. For example, we can see that the malware obtains a reference to the <code>IOPlatformExpertDevice</code> service and then leverages it to look up the system’s serial number.</p>
<p>Similarly, the <code>connectedToInternet</code> function discussed earlier in the chapter decompiles decently (<a href="#listing6-16" id="listinganchor6-16">Listing 6-16</a>). Notice, though, that the decompiler seems a little confused by the Objective-C syntax, with <code>@class</code> and <code>@selector</code> keywords remaining in the output. Behind the scenes, this is due to a compiler optimization that invokes an optimized version of the <code>objc_msgSend</code> function called <code>objc_msgSend_fixup</code>. Still, it should be clear that the malware determines the host’s network connectivity, or lack thereof, via a request to <a class="LinkURL" href="http://www.google.com">www.google.com</a>. </p>
<pre><code><span epub:type="pagebreak" id="Page_140" title="140"/>int connectedToInternet() <br/>{<br/>    if( (@class(NSData), &amp;@selector(dataWithContentsOfURL:), (@class(NSURL), <br/>         &amp;@selector(URLWithString:), @"http://www.google.com")) != 0x0) <br/>    {<br/>         var_1 = 0x1;<br/>    }<br/>    else {<br/>         var_1 = 0x0;<br/>    }<br/>    rax = var_1 &amp; 0x1 &amp; 0xff;<br/>    return rax;<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing6-16">Listing 6-16</a>: Decompilation of the <code>connectedToInternet</code> function (Komplex)</p>
<p>Taking into consideration the many benefits of decompilation over disassembly, you might be wondering why we bothered discussing disassembly at all. There are a few reasons why disassembly might still be useful. First, even the best decompilers occasionally struggle to analyze complex binary code, such as malware with anti-analysis logic (discussed in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>). Disassemblers that simply translate binary code are far less susceptible to errors. Thus, dropping down to the assembly level code provided by the disassembler may sometimes be your only option. Second, as we saw in the decompilation of the <code>getDeviceSerial</code> and <code>connectedToInternet</code> functions, assembly code concepts such as registers remain present in the code and are thus relevant to your analysis. While decompilation can greatly simplify the analysis of binary code, the ability to understand assembly code is (still) a foundational skill for any malware analyst. </p>
<h2 id="h1-501942c06-0004">Reverse Engineering with Hopper</h2>
<p class="BodyFirst">So far we’ve discussed the concepts of disassembly and decompilation without mentioning specific tools that provide these services. These tools can be somewhat complex and a bit daunting to the beginner malware analyst. As such, we’ll briefly walk through the use of one such tool, Hopper, for binary analysis. Reasonably priced and designed natively for macOS, Hopper boasts a powerful disassembler and decompiler that excels at analyzing Mach-O binaries.<sup class="endnote"><a href="#c06-endnote-11" id="c06-noteref-11">11</a></sup></p>
<p>If you’d rather use another disassembler or decompiler, such as IDA Pro or Ghidra, the specifics of this section may not apply. However, the concepts we’ll discuss are broadly applicable across most reverse-engineering tools. </p>
<h3 id="h2-501942c06-0009">Creating a Binary to Analyze</h3>
<p class="BodyFirst">In this brief introduction to Hopper, we’ll disassemble and decompile Apple’s standard “Hello, World!” Objective-C code, shown in <a href="#listing6-17" id="listinganchor6-17">Listing 6-17</a>.</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;<br/> <br/> int main(int argc, const char * argv[]) {<br/><span epub:type="pagebreak" id="Page_141" title="141"/>    @autoreleasepool {<br/>        NSLog(@"Hello, World!");<br/>    }<br/>    return 0;<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing6-17">Listing 6-17</a>: Apple’s “Hello, World!”</p>
<p>Though trivial, it affords us an example binary sufficient for illustrating many of Hopper’s features and capabilities. Compile the code using <code>clang</code> or Xcode to generate a 64-bit Mach-O binary (<a href="#listing6-18" id="listinganchor6-18">Listing 6-18</a>):</p>
<pre><code>% <b>clang main.m -fmodules -o helloWorld</b> <br/><br/>% <b>file helloWorld</b> <br/>helloWorld: Mach-O 64-bit executable x86_64</code></pre>
<p class="CodeListingCaption"><a id="listing6-18">Listing 6-18</a>: Compiling “Hello, World!”</p>
<h3 id="h2-501942c06-0010">Loading the Binary</h3>
<p class="BodyFirst">After opening the Hopper application, start the analysis by selecting <b>File</b><span class="MenuArrow">▶</span><b>Open</b>. Choose the Mach-O binary for analysis. In the resulting loader window, leave the defaults selected and click <b>OK</b> (<a href="#figure6-1" id="figureanchor6-1">Figure 6-1</a>).</p>
<figure>
<img alt="Hopper’s Loader window contains the following options: “Start automatic analysis after the file is loaded” (selected by default), “Parse Objective-C sections if present” (selected by default), “Parse exceptions information if present” (selected by default), “Code sections contain procedures only,” and “Branch instructions always stops procedures.” Underneath these options is a section called “Mach-O 64bits options” that only has one option: “Resolve Lazy Bindings” (selected by default)." class="keyline" src="image_fi/501942c06/f06001.png"/>
<figcaption><p><a id="figure6-1">Figure 6-1</a>: Loader window in Hopper</p></figcaption>
</figure>
<p>Hopper will automatically begin its analysis of the binary by parsing the Mach-O header, disassembling the binary code, and extracting embedded strings, function and method names, and so on. Once its analysis is complete, Hopper will automatically display the disassembled code at the binary’s entry point, extracted from the <code>LC_MAIN</code> load command in the Mach-O header. </p>
<h3 id="h2-501942c06-0011">Exploring the Interface</h3>
<p class="BodyFirst">Hopper’s interface offers several ways of exploring the data it produces. On the far right is the <em>inspector</em> view. This is where Hopper displays general <span epub:type="pagebreak" id="Page_142" title="142"/>information about the binary being analyzed, including the type of binary, its architecture and CPU, and its calling convention (<a href="#figure6-2" id="figureanchor6-2">Figure 6-2</a>).</p>
<figure>
<img alt="Hopper’s inspector view contains file information, including the Path (/Users/patrick/Projects/helloWorld/helloWorld), Loader (Mach-O), CPU (intel/x86_64), CPU Syntax Variant (Intel), and Calling Convention (System V)." class="keyline" src="image_fi/501942c06/f06002.png"/>
<figcaption><p><a id="figure6-2">Figure 6-2</a>: Basic file information in Hopper</p></figcaption>
</figure>
<p>On the far left is a segment selector that can toggle between various views related to symbols and strings in the binary. For example, the <em>Proc</em> view shows procedures (functions and methods) that Hopper has identified during its analysis (<a href="#figure6-3" id="figureanchor6-3">Figure 6-3</a>). This includes functions and methods from the original source code, as well as APIs that the code invokes. For example, in our “Hello, World!” binary, Hopper has identified the main function and the call to Apple’s <code>NSLog</code> API.</p>
<figure>
<img alt="Hopper’s Procedure view has a table with the headings “Idx,” “Name,” “Blo…,” and “Size.” There are four objects, numbered 0-3 in the Idx column: _main, NSLog, objc_autoreleasePoolPop, and objc_autoreleasePoolPush." class="keyline" src="image_fi/501942c06/f06003.png"/>
<figcaption><p><a id="figure6-3">Figure 6-3</a>: Procedure view in Hopper</p></figcaption>
</figure>
<p>The<em> Str</em> view shows the embedded strings that Hopper has extracted from the binary (<a href="#figure6-4" id="figureanchor6-4">Figure 6-4</a>). In our simple binary, the only embedded string is “Hello, World!”</p>
<figure>
<img alt="Hopper’s Str view shows the only embedded string: “Hello, World!”" class="keyline" src="image_fi/501942c06/f06004.png"/>
<figcaption><p><a id="figure6-4">Figure 6-4</a>: Embedded strings view in Hopper</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_143" title="143"/>Before diving into any disassembly, it’s wise to peruse the extracted procedure names and embedded strings, as they are often an invaluable source of information about the malware’s possible capabilities. Moreover, they can guide your analysis efforts. If a procedure name or embedded string looks interesting, click it and Hopper will show you exactly where it’s referenced in the binary. </p>
<h3 id="h2-501942c06-0012">Viewing the Disassembly</h3>
<p class="BodyFirst">By default, Hopper will automatically display the disassembly of the binary’s entry point (often the main function). <a href="#listing6-19" id="listinganchor6-19">Listing 6-19</a> shows the disassembly of the main function in its entirety. Note that the method of compilation and the compiler version can both impact the disassembly. Most commonly, addresses (of functions or instructions) may change, though the order of instructions may vary as well. </p>
<pre><code>main:<br/>0x0000000100003f20    push       rbp<br/>0x0000000100003f21    mov        rbp, rsp<br/>0x0000000100003f24    sub        rsp, 0x20<br/>0x0000000100003f28    mov        dword [rbp+var_4], 0x0<br/>0x0000000100003f2f    mov        dword [rbp+var_8], edi<br/>0x0000000100003f32    mov        qword [rbp+var_10], rsi<br/>0x0000000100003f36    call       objc_autoreleasePoolPush<br/>0x0000000100003f3b    lea        rcx, qword [cfstring_Hello__World] ; @"Hello, World!"<br/>0x0000000100003f42    mov        rdi, rcx ; argument "format" for method NSLog <span aria-label="annotation1" class="CodeAnnotationCode">1</span><br/>0x0000000100003f45    mov        qword [rbp+var_18], rax<br/>0x0000000100003f49    mov        al, 0x0<br/>0x0000000100003f4b    call       NSLog <br/>0x0000000100003f50    mov        rdi, qword [rbp+var_18] ; argument "pool" for method objc_<br/>                                                           autoreleasePoolPop<br/>0x0000000100003f54    call       objc_autoreleasePoolPop <br/>0x0000000100003f59    xor        eax, eax<br/>0x0000000100003f5b    add        rsp, 0x20<br/>0x0000000100003f5f    pop        rbp<br/>0x0000000100003f60    ret</code></pre>
<p class="CodeListingCaption"><a id="listing6-19">Listing 6-19</a>: “Hello, World!” disassembled by Hopper</p>
<p>Hopper provides helpful annotations, identifying embedded strings as well as function and method arguments. For example, consider the assembly code at address <code>0x0000000100000f42</code>, which moves the <code>RCX</code> register, a pointer to the “Hello, World!” string, into <code>RDI </code><span aria-label="annotation1" class="CodeAnnotation">1</span>. Hopper has identified this code as initializing the arguments for a call to <code>NSLog</code> a few lines later. </p>
<p>You’ll often notice that various components of the disassembly are actually pointers to data elsewhere in the binary. For example, the assembly code at <code>0x0000000100000f3b</code> loads the address of the “Hello, World!” string into the <code>RCX</code> register. Hopper is smart enough to identify the <code>cfstring_Hello__World_</code> variable as a pointer. Moreover, if you double-click any pointer, Hopper will jump to the pointer’s address. For example, clicking twice on the <code>cfstring_Hello__World_</code> variable in the disassembly takes you to the string object at <span epub:type="pagebreak" id="Page_144" title="144"/>address <code>0x0000000100001008</code>. This string object of type <code>CFConstantString</code> contains pointers, too, and double-clicking those takes you to the specified address. </p>
<p>Note that Hopper also tracks backwards cross-references. For example, it has identified that the string bytes at address <code>0x0000000100000fa2</code> are cross-referenced by the <code>cfstring_Hello__World_</code> variable. That is to say, the <code>cfstring_Hello__World_</code> variable contains a reference to the <code>0x0000000100000fa2</code> address. Cross-references like these greatly facilitate static analysis of the binary code; if you notice a string of interest, you can simply ask Hopper where in the code that string is referenced. To view such cross-references, CTRL-click the address or item and select <b>References To</b>. Alternatively, select the address or item and press <b>X</b>. For example, say we wanted to see where in the disassembly the “Hello, World!” string object is referenced. We’d first select the string object at address <code>0x0000000100001008</code>, <span class="KeyCaps">CTRL</span>-click to bring up the context menu, and click <b>References to cfstring_Hello__World</b> (<a href="#figure6-5" id="figureanchor6-5">Figure 6-5</a>).</p>
<figure>
<img alt="After control-clicking the string object, the context menu appears with four options: “Rename ‘cfstring_Hello_World_’ (at 0x1000001008)”; “References to ‘cfstring_Hello_World_’ (at 0x1000001008)”; “References from ‘cfstring_Hello_World_’ (at 0x1000001008)”; and “Define structure at 0x1000001008.”" class="keyline" src="image_fi/501942c06/f06005.png"/>
<figcaption><p><a id="figure6-5">Figure 6-5</a>: Selecting the option to view cross-references to the “Hello, World!” string.</p></figcaption>
</figure>
<p>This should bring up the Cross References window for that item (<a href="#figure6-6" id="figureanchor6-6">Figure 6-6</a>).</p>
<figure>
<img alt="The Cross References window for “References to 0x1000001008” shows two columns, Address (“0x100000f3b (_main + 0x1b)”) and Value (“lea   rcx, qword [cfstring_Hello_World_]”)." class="keyline" src="image_fi/501942c06/f06006.png"/>
<figcaption><p><a id="figure6-6">Figure 6-6</a>: Cross-references to the “Hello, World!” string</p></figcaption>
</figure>
<p>Now you can see that this string has only one cross-reference: the code at address <code>0x0000000100000f3b</code>, which falls within the main function. Double-click it to jump to that location in the code. </p>
<p><span epub:type="pagebreak" id="Page_145" title="145"/>Hopper also creates cross-references for functions, methods, and API calls, allowing you to easily determine where in the code these are invoked. For example, the Cross References window in <a href="#figure6-7" id="figureanchor6-7">Figure 6-7</a> tells us that the <code>NSLog</code> API is invoked within the main function at <code>0x0000000100000f4b</code>.</p>
<figure>
<img alt="The Cross References window for “References to 0x100000f62” shows two columns, Address (“0x100000f4b (_main + 0x2b)”) and Value (“call   imp_stubs_NSLog”)." class="keyline" src="image_fi/501942c06/f06007.png"/>
<figcaption><p><a id="figure6-7">Figure 6-7</a>: Cross-references to the <span class="LiteralInCaption"><code>NSLog</code></span> function</p></figcaption>
</figure>
<p>Cross-references greatly facilitate analysis and can efficiently lead to an understanding of the binary’s functionality or capabilities. For example, imagine you’re analyzing a suspected malware sample and want to uncover the address of its command and control server. In Hopper’s Proc view, you can locate APIs, such as Apple networking methods, which are often used by the malware to connect to its server. From the Proc view, follow cross-references to understand how these APIs are being invoked (for example, with the URL or IP address of the command and control server). </p>
<p>When bouncing around in Hopper, you’ll often want to quickly return to a previous spot of analysis. Luckily, the <span class="KeyCaps">escape</span> key will take you back to where you just were. </p>
<h3 id="h2-501942c06-0013">Changing the Display Mode </h3>
<p class="BodyFirst">So far, we’ve stayed in Hopper’s default display mode, Assembly mode. As the name suggests, this mode displays the disassembly of binary code. You can toggle the display mode using a segment control found in Hopper’s main toolbar (<a href="#figure6-8" id="figureanchor6-8">Figure 6-8</a>). </p>
<figure>
<img alt="Hopper’s display modes toolbar, from left to right: Assembly mode (this mode’s toggle button contains the words “mov” and “add”), Control Flow Graph (CFG) mode (the button for this mode contains a tree graph), Pseudo-code mode (the button contains “if(b) f(x);”), and Hexadecimal mode (this button contains the groupings “486F70,” “706572,” and “204469”)." class="keyline" src="image_fi/501942c06/f06008.png"/>
<figcaption><p><a id="figure6-8">Figure 6-8</a>: Display modes in Hopper</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_146" title="146"/>Hopper’s supported display modes include the following:</p>
<ul>
<li><b>Assembly (ASM) mode:</b> The standard disassembly mode, in which Hopper displays a binary’s assembly instructions.</li>
<li><b>Control Flow Graph (CFG) mode: </b>A mode that breaks down procedures (functions) into code blocks and illustrates the control flow between them. </li>
<li><b>Pseudocode mode: </b>Hopper’s decompiler mode, in which a source-code-like or pseudocode representation is generated. </li>
<li><b>Hexadecimal mode: </b>The raw hex bytes of the binary.</li>
</ul>
<p>Of the four display modes, the pseudocode mode is arguably the most powerful. To enter this mode, first select a procedure, and then click the third button in the Display modes segment control. This will instruct Hopper to decompile the code in the procedure in order to generate a pseudocode representation of it. For our simple “Hello, World!” program, it does a lovely job (<a href="#listing6-20" id="listinganchor6-20">Listing 6-20</a>): </p>
<pre><code>int _main(int arg0, int arg1) {<br/>    var_18 = objc_autoreleasePoolPush();<br/>    NSLog(@"Hello, World!");<br/>    objc_autoreleasePoolPop(var_18);<br/>    return 0x0;<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing6-20">Listing 6-20</a>: “Hello, World!” decompiled</p>
<p>After taking into account that <code>@autoreleasepool</code> blocks are compiled into paired <code>objc_autoreleasePoolPush</code> and <code>objc_autoreleasePoolPop</code> calls, the decompilation looks quite similar to the original source code (<a href="#listing6-21" id="listinganchor6-21">Listing 6-21</a>). </p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;<br/> <br/> int main(int argc, const char * argv[]) {<br/>    @autoreleasepool {    <br/>        NSLog(@"Hello, World!");<br/>    }<br/>    return 0;<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing6-21">Listing 6-21</a>: The original “Hello, World!” source code for comparison</p>
<p>For a more comprehensive guide to using and understanding Hopper, consult the application’s official tutorial.<sup class="endnote"><a href="#c06-endnote-12" id="c06-noteref-12">12</a></sup></p>
<h2 id="h1-501942c06-0005">Up Next</h2>
<p class="BodyFirst">Armed with a solid understanding of static analysis techniques, ranging from basic file type identification to advanced decompilation, we’re now ready to turn our attention to methods of dynamic analysis. As you’ll see, <span epub:type="pagebreak" id="Page_147" title="147"/>dynamic analysis often provides a more efficient way of understanding malware. Ultimately though, static and dynamic analysis are complementary, and you’ll probably find yourself combining them.</p>
<h2 id="h1-501942c06-0006">Endnotes</h2>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c06-noteref-1" id="c06-endnote-1">1</a></sup>	Patrick Wardle, “Arm’d and Dangerous,” <em>BlackHat 2021</em> presentation, <a class="LinkURL" href="https://www.blackhat.com/us-21/briefings/schedule/#armd-and-dangerous-23772/">https://www.blackhat.com/us-21/briefings/schedule/#armd-and-dangerous-23772/</a> and “Arm’d &amp; Dangerous: An Introduction to Analysing ARM64 Malware Targeting macOS,” <em>Objective-See</em>, October 7-8, 2011, <a class="LinkURL" href="https://vblocalhost.com/uploads/VB2021-Wardle.pdf">https://vblocalhost.com/uploads/VB2021-Wardle.pdf</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c06-noteref-2" id="c06-endnote-2">2</a></sup>	Randall Hyde, <em>Art of Assembly Language</em>, second edition (No Starch Press, 2010), <a class="LinkURL" href="https://nostarch.com/assembly2.htm">https://nostarch.com/assembly2.htm</a>; Kris Kaspersky, <em>Hacker Disassembling Uncovered</em>, second edition (A-List Publishing, 2007), <i>https://www.amazon.com/Hacker-Disassembling-Uncovered-Kris-Kaspersky/dp/1931769648/</i>; Eldad Eilam, <em>Reversing: Secrets of Reverse Engineering</em> (Wiley, 2005), <i>https://www.amazon.com/Reversing-Secrets-Engineering-Eldad-Eilam/dp/0764574817/</i>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c06-noteref-3" id="c06-endnote-3">3</a></sup>	Nemo, “Modern Objective-C Exploitation Techniques,” <em>Phrack</em> 69 (May 6, 2016), <a class="LinkURL" href="http://www.phrack.org/issues/69/9.html">http://www.phrack.org/issues/69/9.html</a>; Nemo, “The Objective-C Runtime: Understanding and Abusing,” <em>Phrack</em> 66 (November 6, 2009), <a class="LinkURL" href="http://www.phrack.org/issues/66/4.html">http://www.phrack.org/issues/66/4.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c06-noteref-4" id="c06-endnote-4">4</a></sup>	Dani Creus, Tyler Halfpop, and Robert Falcone, “Sofacy’s ‘Komplex’ OS X Trojan,” <em>Unit 42</em> (September 26, 2016), <a class="LinkURL" href="https://unit42.paloaltonetworks.com/unit42-sofacys-komplex-os-x-trojan/">https://unit42.paloaltonetworks.com/unit42-sofacys-komplex-os-x-trojan/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c06-noteref-5" id="c06-endnote-5">5</a></sup>	Patrick Wardle, “Lazarus Group Goes ‘Fileless’,” <em>Objective-See</em> (December 3, 2019), <a class="LinkURL" href="https://objective-see.com/blog/blog_0x51.html">https://objective-see.com/blog/blog_0x51.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c06-noteref-6" id="c06-endnote-6">6</a></sup>	“kIOMasterPortDefault,” <em>Apple Developer Documentation</em>, <a class="LinkURL" href="https://developer.apple.com/documentation/iokit/kiomasterportdefault/">https://developer.apple.com/documentation/iokit/kiomasterportdefault/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c06-noteref-7" id="c06-endnote-7">7</a></sup>	“IOServiceMatching,” <em>Apple Developer Documentation</em>, <a class="LinkURL" href="https://developer.apple.com/documentation/iokit/1514687-ioservicematching/">https://developer.apple.com/documentation/iokit/1514687-ioservicematching/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c06-noteref-8" id="c06-endnote-8">8</a></sup>	“IOServiceGetMatchingService,” <em>Apple Developer Documentation</em>, <a class="LinkURL" href="https://developer.apple.com/documentation/iokit/1514535-ioservicegetmatchingservice/">https://developer.apple.com/documentation/iokit/1514535-ioservicegetmatchingservice/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c06-noteref-9" id="c06-endnote-9">9</a></sup>	“IORegistryEntryCreateCFProperty,” <em>Apple Developer Documentation</em>, <a class="LinkURL" href="https://developer.apple.com/documentation/iokit/1514293-ioregistryentrycreatecfproperty/">https://developer.apple.com/documentation/iokit/1514293-ioregistryentrycreatecfproperty/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c06-noteref-10" id="c06-endnote-10">10</a></sup>	“CFStringGetCString,” <em>Apple Developer Documentation</em>, <a class="LinkURL" href="https://developer.apple.com/documentation/corefoundation/1542721-cfstringgetcstring/">https://developer.apple.com/documentation/corefoundation/1542721-cfstringgetcstring/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c06-noteref-11" id="c06-endnote-11">11</a></sup>	Hopper, <a class="LinkURL" href="https://www.hopperapp.com/">https://www.hopperapp.com/</a>. Free demo of Hopper, <a class="LinkURL" href="https://www.hopperapp.com/download.html">https://www.hopperapp.com/download.html</a><em>.</em></p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c06-noteref-12" id="c06-endnote-12">12</a></sup>	Hopper official tutorial, <a class="LinkURL" href="https://www.hopperapp.com/tutorial.html">https://www.hopperapp.com/tutorial.html</a>.</p></aside>
</section>
</body>
</html>