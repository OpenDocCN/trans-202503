["```\n❶ const newList = () => [];\n\n❷ const size = (list) => list.length;\n\n❸ const isEmpty = (list) => size(list) === 0;\n\n❹ const add = (list, position, value) => {\n  list.splice(list, position, value);\n  return list;\n};\n\n❺ const remove = (list, position) => {\n  list.splice(list, position);\n  return list;\n};\n\n❻ const at = (list, position) => list[position];\n\n❼ const find = (list, value) => list.includes(value);\n```", "```\nconst first = {\n  name: \"George\",\n  next: null,\n};\n\nconst second = {\n  name: \"John\",\n  next: null,\n};\n\nconst third = {\n  name: \"Thomas\",\n  next: null,\n};\n\nfirst.next = second;\nsecond.next = third;\n```", "```\n❶ const newList = () => null;\n\n❷ const isEmpty = (list) => list === null;\n\n❸ const size = (list) => (isEmpty(list) ? 0 : 1 + size(list.next)); \n```", "```\nconst add = (list, position, value) => {\n❶ if (isEmpty(list) || position === 0) {\n  ❷ list = {value, next: list};\n  } else {\n  ❸ list.next = add(list.next, position - 1, value);\n  }\n❹ return list;\n};\n```", "```\nconst remove = (list, position) => {\n  if (isEmpty(list)) {\n  ❶ return list;\n } else if (position === 0) {\n  ❷ return list.next;\n  } else {\n  ❸ list.next = remove(list.next, position – 1);\n    return list;\n  }\n};\n```", "```\nconst at = (list, position) => {\n❶ if (isEmpty(list)) {\n   return undefined;\n❷} else if (position === 0) {\n   return list.value;\n❸} else {\n   return at(list.next, position - 1);\n }\n};\n```", "```\nconst find = (list, value) => {\n  if (isEmpty(list)) {\n ❶ return false;\n  } else {\n  ❷ return list.value === value || find(list.next, value);\n  }\n};\n```", "```\nconst newStack = () => null;\nconst isEmpty = (stack) => stack === null;\n```", "```\nconst top = (stack) => (isEmpty(stack) ? undefined : stack.value);\n```", "```\nconst push = (stack, value) => ({value, next: stack});\n```", "```\nconst pop = (stack) => (isEmpty(stack) ? stack : stack.next);\n```", "```\n❶ const newQueue = () => ({first: null, last: null});\n\n❷ const isEmpty = () => .first === null;\n```", "```\nconst front = (queue) => (isEmpty(queue) ? undefined : queue.first.value);\n```", "```\nconst enter = (queue, value) => {\n  if (isEmpty(queue)) {\n  ❶ queue.first = queue.last = {value, next: null};\n  } else {\n  ❷ queue.last.next = {value, next: null};\n  ❸ queue.last = queue.last.next;\n  }\n  return queue;\n};\n```", "```\nconst exit = (queue) => {\n❶ if (!isEmpty(queue)) {\n  ❷ queue.first = queue.first.next;\n  ❸ if (queue.first === null) {\n      queue.last === null;\n    }\n  }\n  return queue;\n};\n```", "```\nptr.prev.next = ptr.next;\nptr.next.prev = ptr.prev;\n```", "```\nconst newDeque = () => ({first: null, last: null});\nconst isEmpty = (deque) => deque.first === null;\n```", "```\n❶ const newNode = (value, prev = null, next = null) => ({value, prev, next});\n\nconst enterFront = (deque, value) => {\n  if (deque.first === null) {\n  ❷ deque.first = deque.last = newNode(value, null, null);\n  } else {\n  ❸ const newValue = newNode(value, deque.first, null);\n    deque.first.next = newValue;\n    deque.first = newValue;\n  }\n};\n\n❹ const enterBack = (deque, value) => {\n  if (deque.last === null) {\n    deque.first = deque.last = newNode(value, null, null);\n  } else {\n    const newValue = newNode(value, null, deque.last);\n    deque.last.prev = newValue;\n    deque.last = newValue;\n  }\n};\n```", "```\nconst removeFront = (deque) => {\n❶ if (!isEmpty(deque)) {\n  ❷ deque.first = deque.first.next;\n ❸ if (deque.first === null) {\n      deque.last === null;\n    }\n  }\n};\n\n❹ const removeBack = (deque) => {\n  if (!isEmpty(deque)) {\n    deque.last = deque.last.prev;\n    if (deque.last === null) {\n      deque.first === null;\n    }\n  }\n};\n```", "```\nconst newCircularList = () => null; // current\nconst isEmpty = (circ) => circ === null;\n```", "```\nconst add = (circ, valueToAdd) => {\n  const newNode = {value: valueToAdd};\n  if (isEmpty(circ)) {\n  ❶ newNode.next = newNode;\n    newNode.prev = newNode;\n  } else {\n  ❷ newNode.next = circ;\n    newNode.prev = circ.prev;\n    circ.prev.next = newNode;\n    circ.prev = newNode;\n  }\n❸ return newNode;\n};\n```", "```\nconst remove = (circ) => {\n  if (isEmpty(circ)) {\n  ❶ return circ;\n  } else if (circ.next === circ) {\n  ❷ return newCircularList();\n  } else {\n  ❸ circ.prev.next = circ.next;\n    circ.next.prev = circ.prev;\n    return circ.next;\n  }\n};\n```", "```\n❶ const current = (circ) => (isEmpty(circ) ? undefined : circ.value);\n❷ const advance = (circ) => (isEmpty(circ) ? circ : circ.next);\n```"]