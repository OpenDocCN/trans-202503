["```\n0000\n0001\n0010\n0011\n0100\n0101\n0110\n0111\n1000\n1001\n1010\n1011\n1100\n1101\n1110\n1111\n```", "```\nstatic\n          byteVar: byte;\n```", "```\nstatic\n          w: word;\n```", "```\nstatic\n          d: dword;\n```", "```\nstatic\n     q     :qword;\n     l     :lword;\n```", "```\nstatic\n     i64          :int64;\n     i128         :int128;\n```", "```\n$9\n+ $1\n----\n```", "```\n$10\n- $1\n----\n```", "```\nprogram ConvertToHex;\n#include( \"stdlib.hhf\" )\nstatic\n    value: int32;\n\nbegin ConvertToHex;\n\n    stdout.put( \"Input a decimal value:\" );\n    stdin.get( value );\n    mov( value, eax );\n    stdout.put( \"The value \", value, \" converted to hex is $\", eax, nl );\n\nend ConvertToHex;\n```", "```\nprogram ConvertToDecimal;\n#include( \"stdlib.hhf\" )\nstatic\n    value: int32;\n\nbegin ConvertToDecimal;\n\n    stdout.put( \"Input a hexadecimal value: \" );\n    stdin.get( ebx );\n    mov( ebx, value );\n    stdout.put( \"The value $\", ebx, \" converted to decimal is \", value, nl );\n\nend ConvertToDecimal;\n```", "```\nprogram ConvertToDecimal2;\n#include( \"stdlib.hhf\" )\nbegin ConvertToDecimal2;\n\n    stdout.put( \"Input a hexadecimal value: \" );\n    stdin.get( ebx );\n    stdout.put( \"The value $\", ebx, \" converted to decimal is \" );\n    stdout.puti32( ebx );\n    stdout.newln();\n\nend ConvertToDecimal2;\n```", "```\nprogram HexIO;\n\n#include( \"stdlib.hhf\" )\n\nstatic\n    i32: int32;\n\nbegin HexIO;\n\n    stdout.put( \"Enter a hexadecimal value: \" );\n    stdin.geth32();\n    mov( eax, i32 );\n    stdout.put( \"The value you entered was $\" );\n    stdout.puth32( i32 );\n    stdout.newln();\n\nend HexIO;\n```", "```\n0 and 0 = 0\n               0 and 1 = 0\n               1 and 0 = 0\n               1 and 1 = 1\n```", "```\n0 or 0 = 0\n               0 or 1 = 1\n               1 or 0 = 1\n               1 or 1 = 1\n```", "```\n0 xor 0 = 0\n               0 xor 1 = 1\n               1 xor 0 = 1\n               1 xor 1 = 0\n```", "```\nnot 0 = 1\n               not 1 = 0\n```", "```\n%1011_0101\n                         %1110_1110\n                         ----------\n                         %1010_0100\n```", "```\nand( *`source`*, *`dest`* );\n or( *`source`*, *`dest`* );\nxor( *`source`*, *`dest`* );\n```", "```\n*`dest`* = *`dest operator source`*\n```", "```\nnot( *`dest`* );\n```", "```\n*`dest`* = not( *`dest`* )\n```", "```\nprogram LogicalOp;\n#include( \"stdlib.hhf\" )\nbegin LogicalOp;\n\n    stdout.put( \"Input left operand: \" );\n    stdin.get( eax );\n    stdout.put( \"Input right operand: \" );\n    stdin.get( ebx );\n\n    mov( eax, ecx );\n    and( ebx, ecx );\n    stdout.put( \"$\", eax, \" and $\", ebx, \" = $\", ecx, nl );\n\n    mov( eax, ecx );\n    or( ebx, ecx );\n    stdout.put( \"$\", eax, \" or $\", ebx, \" = $\", ecx, nl );\n\n    mov( eax, ecx );\n    xor( ebx, ecx );\n    stdout.put( \"$\", eax, \" xor $\", ebx, \" = $\", ecx, nl );\n\n    mov( eax, ecx );\n    not( ecx );\n    stdout.put( \"not $\", eax, \" = $\", ecx, nl );\n\n    mov( ebx, ecx );\n    not( ecx );\n    stdout.put( \"not $\", ebx, \" = $\", ecx, nl );\n\nend LogicalOp;\n```", "```\n$8000 is negative because the H.O. bit is 1.\n      $100 is positive because the H.O. bit is 0.\n      $7FFF is positive.\n      $FFFF is negative.\n      $FFF ($0FFF) is positive.\n```", "```\n    %0000_0101             5 (in binary).\n                    %1111_1010             Invert all the bits.\n                    %1111_1011             Add 1 to obtain result.\n    ```", "```\n    %1111_1011             Two's complement for −5.\n                    %0000_0100             Invert all the bits.\n                    %0000_0101             Add 1 to obtain result (+5).\n    ```", "```\n    $7FFF: +32767, the largest 16-bit positive number.\n         $8000: −32768, the smallest 16-bit negative number.\n         $4000: +16384.\n    ```", "```\n    $7FFF:          %0111_1111_1111_1111   +32,767\n                    %1000_0000_0000_0000   Invert all the bits (8000h)\n                    %1000_0000_0000_0001   Add 1 (8001h or −32,767)\n\n    4000h:          %0100_0000_0000_0000   16,384\n                    %1011_1111_1111_1111   Invert all the bits ($BFFF)\n                    %1100_0000_0000_0000   Add 1 ($C000 or −16,384)\n\n    $8000:          %1000_0000_0000_0000   −32,768\n                    %0111_1111_1111_1111   Invert all the bits ($7FFF)\n                    %1000_0000_0000_0000   Add one (8000h or −32,768)\n    ```", "```\n%  0000_0101\n                          %  1111_1011\n                          ------------\n                          %1_0000_0000\n```", "```\nneg( *`dest`* );\n```", "```\nprogram twosComplement;\n#include( \"stdlib.hhf\" )\n\nstatic\n    PosValue:   int8;\n    NegValue:   int8;\n\nbegin twosComplement;\n\n    stdout.put( \"Enter an integer between 0 and 127: \" );\n    stdin.get( PosValue );\n\n    stdout.put( nl, \"Value in hexadecimal: $\" );\n    stdout.puth8( PosValue );\n\n    mov( PosValue, al );\n    not( al );\n    stdout.put( nl, \"Invert all the bits: $\", al, nl );\n    add( 1, al );\n    stdout.put( \"Add one: $\", al, nl );\n    mov( al, NegValue );\n    stdout.put( \"Result in decimal: \", NegValue, nl );\n\n    stdout.put\n    (\n        nl,\n        \"Now do the same thing with the NEG instruction: \",\n        nl\n    );\n    mov( PosValue, al );\n    neg( al );\n    mov( al, NegValue );\n    stdout.put( \"Hex result = $\", al, nl );\n    stdout.put( \"Decimal result = \", NegValue, nl );\n\nend twosComplement;\n```", "```\nstatic\n     u8:          uns8;\n     u16:         uns16;\n     u32:         uns32;\n     u64:         uns64;\n     u128:        uns128;\n```", "```\nprogram UnsExample;\n#include( \"stdlib.hhf\" )\n\nstatic\n    UnsValue:   uns16;\n\nbegin UnsExample;\n\n    stdout.put( \"Enter an integer between 32,768 and 65,535: \" );\n    stdin.getu16();\n    mov( ax, UnsValue );\n\n    stdout.put\n    (\n        \"You entered \",\n        UnsValue,\n        \".  If you treat this as a signed integer, it is \"\n    );\n    stdout.puti16( UnsValue );\n    stdout.newln();\n\nend UnsExample;\n```", "```\nSign Extension:\n8 Bits      16 Bits       32 Bits\n\n$80         $FF80         $FFFF_FF80\n$28         $0028         $0000_0028\n$9A         $FF9A         $FFFF_FF9A\n$7F         $007F         $0000_007F\n            $1020         $0000_1020\n            $8086         $FFFF_8086\n```", "```\nZero Extension:\n8 Bits      16 Bits       32 Bits\n\n$80         $0080         $0000_0080\n$28         $0028         $0000_0028\n$9A         $009A         $0000_009A\n$7F         $007F         $0000_007F\n            $1020         $0000_1020\n            $8086         $0000_8086\n```", "```\nmovsx( *`source`*, *`dest`* );\n```", "```\nprogram signExtension;\n#include( \"stdlib.hhf\" )\n\nstatic\n    i8:     int8;\n    i16:    int16;\n    i32:    int32;\n\nbegin signExtension;\n\n    stdout.put( \"Enter a small negative number: \" );\n    stdin.get( i8 );\n\n    stdout.put( nl, \"Sign extension using CBW and CWDE:\", nl, nl );\n\n    mov( i8, al );\n    stdout.put( \"You entered \", i8, \" ($\", al, \")\", nl );\n\n    cbw();\n    mov( ax, i16 );\n    stdout.put( \"16-bit sign extension: \", i16, \" ($\", ax, \")\", nl );\n\n    cwde();\n    mov( eax, i32 );\n    stdout.put( \"32-bit sign extension: \", i32, \" ($\", eax, \")\", nl );\n\n    stdout.put( nl, \"Sign extension using MOVSX:\", nl, nl );\n\n    movsx( i8, ax );\n    mov( ax, i16 );\n    stdout.put( \"16-bit sign extension: \", i16, \" ($\", ax, \")\", nl );\n\n    movsx( i8, eax );\n    mov( eax, i32 );\n    stdout.put( \"32-bit sign extension: \", i32, \" ($\", eax, \")\", nl );\n\nend signExtension;\n```", "```\n$FF80 can be sign contracted to $80.\n          $0040 can be sign contracted to $40.\n          $FE40 cannot be sign contracted to 8 bits.\n          $0100 cannot be sign contracted to 8 bits.\n```", "```\nshl( *`count`*, *`dest`* );\n```", "```\n1234 shl 1 = 12340\n```", "```\nshr( *`count`*, *`dest`* );\n```", "```\nsar( *`count`*, *`dest`* );\n```", "```\nrol( *`count`*, *`dest`* );\nror( *`count`*, *`dest`* );\n```", "```\nrcl( *`count`*, *`dest`* );\nrcr( *`count`*, *`dest`* );\n```", "```\n0100      00010   0000001          = %0100_0001_0000_0001 or $4101\n           4          2       01\n```", "```\nprogram dateDemo;\n\n#include( \"stdlib.hhf\" )\n\nstatic\n    day:        uns8;\n    month:      uns8;\n    year:       uns8;\n\n    packedDate: word;\n\nbegin dateDemo;\n\n    stdout.put( \"Enter the current month, day, and year: \" );\n    stdin.get( month, day, year );\n\n    // Pack the data into the following bits:\n    //\n    //  15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0\n    //   m  m  m  m  d  d  d  d  d  y  y  y  y  y  y  y\n\n    mov( 0, ax );\n    mov( ax, packedDate );  // Just in case there is an error.\n    if( month > 12 ) then\n\n        stdout.put( \"Month value is too large\", nl );\n\n    elseif( month = 0 ) then\n\n        stdout.put( \"Month value must be in the range 1..12\", nl );\n\n    elseif( day > 31 ) then\n\n        stdout.put( \"Day value is too large\", nl );\n\n    elseif( day = 0 ) then\n\n        stdout.put( \"Day value must be in the range 1..31\", nl );\n\n    elseif( year > 99 ) then\n\n        stdout.put( \"Year value must be in the range 0..99\", nl );\n\n    else\n\n        mov( month, al );\n        shl( 5, ax );\n        or( day, al );\n        shl( 7, ax );\n        or( year, al );\n        mov( ax, packedDate );\n\n    endif;\n\n    // Okay, display the packed value:\n\n    stdout.put( \"Packed data = $\", packedDate, nl );\n\n    // Unpack the date:\n\n    mov( packedDate, ax );\n    and( $7f, al );         // Retrieve the year value.\n    mov( al, year );\n\n    mov( packedDate, ax );  // Retrieve the day value.\n    shr( 7, ax );\n    and( %1_1111, al );\n    mov( al, day );\n\n    mov( packedDate, ax );  // Retrieve the month value.\n    rol( 4, ax );\n    and( %1111, al );\n    mov( al, month );\n\n    stdout.put( \"The date is \", month, \"/\", day, \"/\", year, nl );\n\nend dateDemo;\n```", "```\nmov( *`Date1`*, eax );          // Assume *`Date1`* and *`Date2`* are dword variables\n     if( eax > *`Date2`* ) then      // using the Long Packed Date format.\n\n          << Do something if *`Date1`* > *`Date2`* >>\n\n     endif;\n```", "```\nlahf();\n          sahf();\n```", "```\nif *`Value1`* >= (*`Value2`*-*`error`*) and *`Value1`* <= (*`Value2`*+*`error`*) then ...\n```", "```\nif abs(*`Value1`*-*`Value2`*) <= *`error`* then ...\n```", "```\n1.mmmmmmm mmmmmmmm mmmmmmmm\n```", "```\n1.234  3.75e2  −1.0  1.1e-1  1e+4  0.1  −123.456e+789  +25e0\n```", "```\n1_234_837.25  1_000.00  789_934.99  9_999.99\n```", "```\nstatic\n\n          fltVar1:      real32;\n          fltVar1a:     real32 := 2.7;\n          pi:           real32 := 3.14159;\n          DblVar:       real64;\n          DblVar2:      real64 := 1.23456789e+10;\n          XPVar:        real80;\n          XPVar2:       real80 := −1.0e-104;\n```", "```\nstdout.putr80( r:real80; width:uns32; decpts:uns32 );\nstdout.putr64( r:real64; width:uns32; decpts:uns32 );\nstdout.putr32( r:real32; width:uns32; decpts:uns32 );\n```", "```\nstdout.putr32( pi, 10, 4 );\n```", "```\n_ _ _ _ 3.1416\n```", "```\nstdout.pute80( r:real80; width:uns32 );\nstdout.pute64( r:real64; width:uns32 );\nstdout.pute32( r:real32; width:uns32 );\n```", "```\n1.23456789e+10  −1.0e-104  1e+2\n```", "```\nstdout.put( \"XPVar2 = \", XPVar2 );\n```", "```\nstdout.put( \"XPVar2 = \", XPVar2:10 );\n```", "```\n*`Variable_Name`* : *`Width`* : *`DecPts`*\n```", "```\nstdout.put( \"Pi = \", pi:5:3 );\n```", "```\n3.142\n```", "```\nstdout.put( \"Input a double-precision floating-point value: \" );\n     stdin.get( DblVar );\n```", "```\n'A'   #65    #$41    #%0100_0001\n```", "```\n''''\n```", "```\n'A' ≠ \"A\"\n```", "```\nstatic\n     UserInput:          char;\n```", "```\nstatic\n\n     TheCharA:          char := 'A';\n     ExtendedChar:      char := #128;\n```", "```\nstdout.putc( *`charvar`* );\n```", "```\nstdout.putcSize( *`charvar`*, *`widthInt32`*, *`fillchar`* );\n```", "```\nstdout.put( \"Character c = '\", c, \"'\", nl );\n```", "```\nprogram charInputDemo;\n#include( \"stdlib.hhf\" )\nbegin charInputDemo;\n\n    stdout.put( \"Enter a character: \" );\n    stdin.getc();\n    if( al >= 'a' ) then\n\n        if( al <= 'z' ) then\n\n            and( $5f, al );\n\n        endif;\n\n    endif;\n    stdout.put\n    (\n        \"The character you entered, possibly \", nl,\n        \"converted to uppercase, was '\"\n    );\n    stdout.putc( al );\n    stdout.put( \"'\", nl );\n\nend charInputDemo;\n```", "```\nprogram charInputDemo2;\n#include( \"stdlib.hhf\" )\nstatic\n    c:char;\n\nbegin charInputDemo2;\n\n    stdout.put( \"Enter a character: \" );\n    stdin.get(c);\n    if( c >= 'a' ) then\n\n        if( c <= 'z' ) then\n\n            and( $5f, c );\n\n        endif;\n\n    endif;\n    stdout.put\n    (\n        \"The character you entered, possibly \", nl,\n        \"converted to uppercase, was '\",\n        c,\n        \"'\", nl\n    );\n\nend charInputDemo2;\n```", "```\nprogram eolnDemo;\n#include( \"stdlib.hhf\" )\nbegin eolnDemo;\n\n    stdout.put( \"Enter a short line of text: \" );\n    stdin.flushInput();\n    repeat\n\n        stdin.getc();\n        stdout.putc( al );\n        stdout.put( \"=$\", al, nl );\n\n    until( stdin.eoln() );\n\nend eolnDemo;\n```"]