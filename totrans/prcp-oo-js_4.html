<html><head></head><body><section class="chapter" title="Chapter&#xA0;4.&#xA0;Constructors and Prototypes" epub:type="chapter" id="constructors_and_prototypes"><div class="titlepage"><div><div><h2 class="title">Chapter 4. Constructors and Prototypes</h2></div></div></div><p><a id="iddle1058" class="indexterm"/><a id="iddle1197" class="indexterm"/>You might be able to get pretty far in JavaScript without understanding constructors and prototypes, but you won’t truly appreciate the language without a good grasp of them. Because JavaScript lacks classes, it turns to constructors and prototypes to bring a similar order to objects. But just because some of the patterns resemble classes doesn’t mean they behave the same way. In this chapter, you’ll explore constructors and prototypes in detail to see how JavaScript uses them to create objects.</p><div class="sect1" title="Constructors"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="constructors">Constructors</h2></div></div></div><p>A <span class="emphasis"><em>constructor</em></span> is simply a function that is used with <code class="literal">new</code> to create an object. Up to this point, you’ve seen several of the built-in JavaScript constructors, such as <code class="literal">Object</code>, <code class="literal">Array</code>, and <code class="literal">Function</code>. The advantage of constructors is <a id="iddle1044" class="indexterm"/><a id="iddle1055" class="indexterm"/><a id="iddle1157" class="indexterm"/><a id="iddle1192" class="indexterm"/><a id="iddle1198" class="indexterm"/><a id="iddle1374" class="indexterm"/>that objects created with the same constructor contain the same properties and methods. If you want to create multiple similar objects, you can create your own constructors and therefore your own reference types.</p><p>Because a constructor is just a function, you define it in the same way. The only difference is that constructor names should begin with a capital letter, to distinguish them from other functions. For example, look at the following empty <code class="literal">Person</code> function:</p><a id="pro_id00077"/><pre class="programlisting"><span class="pd_green"><code class="kd">function</code></span> <code class="nx">Person</code><code class="p">()</code> <code class="p">{</code>
    <span class="pd_green1"><code class="c1">// intentionally empty</code></span>
<code class="p">}</code></pre><p>This function is a constructor, but there is absolutely no syntactic difference between this and any other function. The clue that <code class="literal">Person</code> is a constructor is in the name—the first letter is capitalized.</p><p>After the constructor is defined, you can start creating instances, like the following two <code class="literal">Person</code> objects:</p><a id="pro_id00078"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">person1</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code></span> <code class="nx">Person</code><code class="p">();</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">person2</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code></span> <code class="nx">Person</code><code class="p">();</code></pre><p>When you have no parameters to pass into your constructor, you can even omit the parentheses:</p><a id="pro_id00079"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">person1</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code></span> <code class="nx">Person</code><code class="p">;</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">person2</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code></span> <code class="nx">Person</code><code class="p">;</code></pre><p>Even though the <code class="literal">Person</code> constructor doesn’t explicitly return anything, both <code class="literal">person1</code> and <code class="literal">person2</code> are considered instances of the new <code class="literal">Person</code> type. The <code class="literal">new</code> operator automatically creates an object of the given type and returns it. That also means you can use the <code class="literal">instanceof</code> operator to deduce an object’s type. The following code shows <code class="literal">instanceof</code> in action with the newly created objects:</p><a id="pro_id00080"/><pre class="programlisting"><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person1</code> <span class="pd_green"><code class="k">instanceof</code></span> <code class="nx">Person</code><code class="p">);</code>     <span class="pd_green1"><code class="c1">// true</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person2</code> <span class="pd_green"><code class="k">instanceof</code></span> <code class="nx">Person</code><code class="p">);</code>     <span class="pd_green1"><code class="c1">// true</code></span></pre><p>Because <code class="literal">person1</code> and <code class="literal">person2</code> were created with the <code class="literal">Person</code> constructor, <code class="literal">instanceof</code> returns <code class="literal">true</code> when it checks whether these objects are instances of the <code class="literal">Person</code> type.</p><p>You can also check the type of an instance using the <code class="literal">constructor</code> property. Every object instance is automatically created with a <code class="literal">constructor</code> property that contains a reference to the constructor function that created it. For <span class="emphasis"><em>generic</em></span> objects (those created via an object literal or the <code class="literal">Object</code> constructor), <code class="literal">constructor</code> is set to <code class="literal">Object</code>; for objects created with a custom <a id="iddle1054" class="indexterm"/><a id="iddle1063" class="indexterm"/><a id="iddle1201" class="indexterm"/><a id="iddle1361" class="indexterm"/>constructor, <code class="literal">constructor</code> points back to that constructor function instead. For example, <code class="literal">Person</code> is the <code class="literal">constructor</code> property for <code class="literal">person1</code> and <code class="literal">person2</code>:</p><a id="pro_id00081"/><pre class="programlisting"><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person1</code><code class="p">.</code><code class="nx">constructor</code> <span class="pd_ash"><code class="o">===</code></span> <code class="nx">Person</code><code class="p">);</code>     <span class="pd_green1"><code class="c1">// true</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person2</code><code class="p">.</code><code class="nx">constructor</code> <span class="pd_ash"><code class="o">===</code></span> <code class="nx">Person</code><code class="p">);</code>     <span class="pd_green1"><code class="c1">// true</code></span></pre><p>The <code class="literal">console.log</code> function outputs <code class="literal">true</code> in both cases, because both objects were created with the <code class="literal">Person</code> constructor.</p><p>Even though this relationship exists between an instance and its constructor, you are still advised to use <code class="literal">instanceof</code> to check the type of an instance. This is because the <code class="literal">constructor</code> property can be overwritten and therefore may not be completely accurate.</p><p>Of course, an empty constructor function isn’t very useful. The whole point of a constructor is to make it easy to create more objects with the same properties and methods. To do that, simply add any properties you want to <code class="literal">this</code> inside of the constructor, as in the following example:</p><a id="pro_id00082"/><pre class="programlisting">  <span class="pd_green"><code class="kd">function</code></span> <code class="nx">Person</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
<code class="err">❶</code>     <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">name</code><code class="p">;</code>
<code class="err">❷</code>     <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">sayName</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
          <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
      <code class="p">};</code>
  <code class="p">}</code></pre><p>This version of the <code class="literal">Person</code> constructor accepts a single named parameter, <code class="literal">name</code>, and assigns it to the <code class="literal">name</code> property of the <code class="literal">this</code> object ❶. The constructor also adds a <code class="literal">sayName()</code> method to the object ❷. The <code class="literal">this</code> object is automatically created by <code class="literal">new</code> when you call the constructor, and it is an instance of the constructor’s type. (In this case, <code class="literal">this</code> is an instance of <code class="literal">Person</code>.) There’s no need to return a value from the function because the <code class="literal">new</code> operator produces the return value.</p><p>Now you can use the <code class="literal">Person</code> constructor to create objects with an initialized <code class="literal">name</code> property:</p><a id="pro_id00083"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">person1</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code></span> <code class="nx">Person</code><code class="p">(</code><span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">);</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">person2</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code></span> <code class="nx">Person</code><code class="p">(</code><span class="pd_red"><code class="s2">"Greg"</code></span><code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person1</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>            <span class="pd_green1"><code class="c1">// "Nicholas"</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person2</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>            <span class="pd_green1"><code class="c1">// "Greg"</code></span>

<code class="nx">person1</code><code class="p">.</code><code class="nx">sayName</code><code class="p">();</code>                    <span class="pd_green1"><code class="c1">// outputs "Nicholas"</code></span>
<code class="nx">person2</code><code class="p">.</code><code class="nx">sayName</code><code class="p">();</code>                    <span class="pd_green1"><code class="c1">// outputs "Greg"</code></span></pre><p>Each object has its own <code class="literal">name</code> property, so <code class="literal">sayName()</code> should return different values depending on the object on which you use it.</p><div class="note" title="Note"><h3 class="title"><a id="ch04note01"/>Note</h3><p><a id="iddle1060" class="indexterm"/><a id="iddle1086" class="indexterm"/><a id="iddle1199" class="indexterm"/><a id="iddle1214" class="indexterm"/><span class="emphasis"><em>You can also explicitly call return inside of a constructor. If the returned value is an object, it will be returned instead of the newly created object instance. If the returned value is a primitive, the newly created object is used and the returned value is ignored.</em></span></p></div><p>Constructors allow you to initialize an instance of a type in a consistent way, performing all of the property setup that is necessary before the object can be used. For example, you could also use <code class="literal">Object.defineProperty()</code> inside of a constructor to help initialize the instance:</p><a id="pro_id00084"/><pre class="programlisting"><span class="pd_green"><code class="kd">function</code></span> <code class="nx">Person</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>

    <span class="pd_green"><code class="nb">Object</code></span><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><span class="pd_green"><code class="k">this</code></span><code class="p">,</code> <span class="pd_red"><code class="s2">"name"</code></span><code class="p">,</code> <code class="p">{</code>
        <code class="nx">get</code><code class="o">:</code> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
            <span class="pd_green"><code class="k">return</code></span> <code class="nx">name</code><code class="p">;</code>
        <code class="p">},</code>
        <code class="nx">set</code><code class="o">:</code> <span class="pd_green"><code class="kd">function</code></span><code class="p">(</code><code class="nx">newName</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">newName</code><code class="p">;</code>
        <code class="p">},</code>
        <code class="nx">enumerable</code><code class="o">:</code> <span class="pd_green"><code class="kc">true</code></span><code class="p">,</code>
        <code class="nx">configurable</code><code class="o">:</code> <span class="pd_green"><code class="kc">true</code></span>
    <code class="p">});</code>

    <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">sayName</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
    <code class="p">};</code>
<code class="p">}</code></pre><p>In this version of the <code class="literal">Person</code> constructor, the <code class="literal">name</code> property is an accessor property that uses the <code class="literal">name</code> parameter for storing the actual name. This is possible because named parameters act like local variables.</p><p>Make sure to always call constructors with <code class="literal">new</code>; otherwise, you risk changing the global object instead of the newly created object. Consider what happens in the following code:</p><a id="pro_id00085"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">person1</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">Person</code><code class="p">(</code><span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">);</code>            <span class="pd_green1"><code class="c1">// note: missing "new"</code></span>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person1</code> <span class="pd_green"><code class="k">instanceof</code></span> <code class="nx">Person</code><code class="p">);</code>      <span class="pd_green1"><code class="c1">// false</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">typeof</code></span> <code class="nx">person1</code><code class="p">);</code>                 <span class="pd_green1"><code class="c1">// "undefined"</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>                           <span class="pd_green1"><code class="c1">// "Nicholas"</code></span></pre><p>When <code class="literal">Person</code> is called as a function without <code class="literal">new</code>, the value of <code class="literal">this</code> inside of the constructor is equal to the global <code class="literal">this</code> object. The variable <code class="literal">person1</code> doesn’t contain a value because the <code class="literal">Person</code> constructor relies on <code class="literal">new</code> to supply a return value. Without <code class="literal">new</code>, <code class="literal">Person</code> is just a function without a <code class="literal">return</code> statement. The assignment to <code class="literal">this.name</code> actually creates a global <a id="iddle1102" class="indexterm"/><a id="iddle1139" class="indexterm"/><a id="iddle1152" class="indexterm"/><a id="iddle1296" class="indexterm"/><a id="iddle1300" class="indexterm"/>variable called <code class="literal">name</code>, which is where the name passed to <code class="literal">Person</code> is stored. <a class="xref" href="ch06.html" title="Chapter 6. Object Patterns">Chapter 6</a> describes a solution to both this problem and more complex object composition patterns.</p><div class="note" title="Note"><h3 class="title"><a id="ch04note02"/>Note</h3><p><span class="emphasis"><em>An error occurs if you call the Person constructor in strict mode without using new. This is because strict mode doesn’t assign this to the global object. Instead, this remains undefined, and an error occurs whenever you attempt to create a property on undefined.</em></span></p></div><p>Constructors allow you to configure object instances with the same properties, but constructors alone don’t eliminate code redundancy. In the example code thus far, each instance has had its own <code class="literal">sayName()</code> method even though <code class="literal">sayName()</code> doesn’t change. That means if you have 100 instances of an object, then there are 100 copies of a function that do the exact same thing, just with different data.</p><p>It would be much more efficient if all of the instances shared one method, and then that method could use <code class="literal">this.name</code> to retrieve the appropriate data. This is where prototypes come in.</p></div><div class="sect1" title="Prototypes"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="prototypes">Prototypes</h2></div></div></div><p>You can think of a <span class="emphasis"><em>prototype</em></span> as a recipe for an object. Almost every function (with the exception of some built-in functions) has a <code class="literal">prototype</code> property that is used during the creation of new instances. That prototype is shared among all of the object instances, and those instances can access properties of the prototype. For example, the <code class="literal">hasOwnProperty()</code> method is defined on the generic <code class="literal">Object</code> prototype, but it can be accessed from any object as if it were an own property, as shown in this example:</p><a id="pro_id00086"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">book</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">title</code><code class="o">:</code> <span class="pd_red"><code class="s2">"The Principles of Object-Oriented JavaScript"</code></span>
<code class="p">};</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_red"><code class="s2">"title"</code></span> <span class="pd_green"><code class="k">in</code></span> <code class="nx">book</code><code class="p">);</code>                                    <span class="pd_green1"><code class="c1">// true</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">book</code><code class="p">.</code><code class="nx">hasOwnProperty</code><code class="p">(</code><span class="pd_red"><code class="s2">"title"</code></span><code class="p">));</code>                       <span class="pd_green1"><code class="c1">// true</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_red"><code class="s2">"hasOwnProperty"</code></span> <span class="pd_green"><code class="k">in</code></span> <code class="nx">book</code><code class="p">);</code>                           <span class="pd_green1"><code class="c1">// true</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">book</code><code class="p">.</code><code class="nx">hasOwnProperty</code><code class="p">(</code><span class="pd_red"><code class="s2">"hasOwnProperty"</code></span><code class="p">));</code>              <span class="pd_green1"><code class="c1">// false</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="nb">Object</code></span><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">hasOwnProperty</code><code class="p">(</code><span class="pd_red"><code class="s2">"hasOwnProperty"</code></span><code class="p">));</code>  <span class="pd_green1"><code class="c1">// true</code></span></pre><p>Even though there is no definition for <code class="literal">hasOwnProperty()</code> on <code class="literal">book</code>, that method can still be accessed as <code class="literal">book.hasOwnProperty()</code> because the definition does exist on <code class="literal">Object.prototype</code>. Remember that the <code class="literal">in</code> operator returns <code class="literal">true</code> for both prototype properties <span class="emphasis"><em>and</em></span> own properties.</p><div class="sidebar"><a id="identifying_a_prototype_property"/><div class="sidebar-title">Identifying a Prototype Property</div><p><a id="iddle1278" class="indexterm"/><a id="iddle1294" class="indexterm"/><a id="iddle1298" class="indexterm"/><a id="iddle1303" class="indexterm"/>You can determine whether a property is on the prototype by using a function such as:</p><a id="pro_id00087"/><pre class="programlisting"><span class="pd_green"><code class="kd">function</code></span> <code class="nx">hasPrototypeProperty</code><code class="p">(</code><code class="nx">object</code><code class="p">,</code> <code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <span class="pd_green"><code class="k">return</code></span> <code class="nx">name</code> <span class="pd_green"><code class="k">in</code></span> <code class="nx">object</code> <span class="pd_ash"><code class="o">&amp;&amp;</code></span> <code class="o">!</code><code class="nx">object</code><code class="p">.</code><code class="nx">hasOwnProperty</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>
<code class="p">}</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">hasPrototypeProperty</code><code class="p">(</code><code class="nx">book</code><code class="p">,</code> <span class="pd_red"><code class="s2">"title"</code></span><code class="p">));</code>            <span class="pd_green1"><code class="c1">// false</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">hasPrototypeProperty</code><code class="p">(</code><code class="nx">book</code><code class="p">,</code> <span class="pd_red"><code class="s2">"hasOwnProperty"</code></span><code class="p">));</code>   <span class="pd_green1"><code class="c1">// true</code></span></pre><p>If the property is <code class="literal">in</code> an object but <code class="literal">hasOwnProperty()</code> returns <code class="literal">false</code>, then the property is on the prototype.</p></div><div class="sect2" title="The [[Prototype]] Property"><div class="titlepage"><div><div><h3 class="title" id="left_square_bracketleft_square_bracketpr">The [[Prototype]] Property</h3></div></div></div><p>An instance keeps track of its prototype through an internal property called <code class="literal">[[Prototype]]</code>. This property is a pointer back to the prototype object that the instance is using. When you create a new object using <code class="literal">new</code>, the constructor’s <code class="literal">prototype</code> property is assigned to the <code class="literal">[[Prototype]]</code> property of that new object. <a class="xref" href="ch04.html#left_square_bracketleft_square_br" title="Figure 4-1. The [[Prototype]] properties for person1 and person2 point to the same prototype.">Figure 4-1</a> shows how the <code class="literal">[[Prototype]]</code> property lets multiple instances of an object type refer to the same prototype, which can reduce code duplication.</p><div class="figure"><a id="left_square_bracketleft_square_br"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00006"/><img src="figs/web/oojs04_01.png" alt="The [[Prototype]] properties for person1 and person2 point to the same prototype."/></div></div><div class="figure-title">Figure 4-1. The <code class="literal">[[Prototype]]</code> properties for <code class="literal">person1</code> and <code class="literal">person2</code> point to the same prototype.</div></div><p><a id="iddle1134" class="indexterm"/><a id="iddle1168" class="indexterm"/><a id="iddle1218" class="indexterm"/><a id="iddle1229" class="indexterm"/><a id="iddle1253" class="indexterm"/><a id="iddle1288" class="indexterm"/><a id="iddle1295" class="indexterm"/>You can read the value of the <code class="literal">[[Prototype]]</code> property by using the <code class="literal">Object.getPrototypeOf()</code> method on an object. For example, the following code checks the <code class="literal">[[Prototype]]</code> of a generic, empty object.</p><a id="pro_id00088"/><pre class="programlisting"><code class="err">❶</code> <span class="pd_green"><code class="kd">var</code></span> <code class="nx">object</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">{};</code>
  <span class="pd_green"><code class="kd">var</code></span> <code class="nx">prototype</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="nb">Object</code></span><code class="p">.</code><code class="nx">getPrototypeOf</code><code class="p">(</code><code class="nx">object</code><code class="p">);</code>

  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">prototype</code> <span class="pd_ash"><code class="o">===</code></span> <span class="pd_green"><code class="nb">Object</code></span><code class="p">.</code><code class="nx">prototype</code><code class="p">);</code>          <span class="pd_green1"><code class="c1">// true</code></span></pre><p>For any generic object like this one ❶, <code class="literal">[[Prototype]]</code> is always a reference to <code class="literal">Object.prototype</code>.</p><div class="note" title="Note"><h3 class="title"><a id="ch04note03"/>Note</h3><p><span class="emphasis"><em>Some JavaScript engines also support a property called __proto__ on all objects. This property allows you to both read from and write to the [[Prototype]] property. Firefox, Safari, Chrome, and Node.js all support this property, and __proto__ is on the path for standardization in ECMAScript 6.</em></span></p></div><p>You can also test to see if one object is a prototype for another by using the <code class="literal">isPrototypeOf()</code> method, which is included on all objects:</p><a id="pro_id00089"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">object</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">{};</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="nb">Object</code></span><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">isPrototypeOf</code><code class="p">(</code><code class="nx">object</code><code class="p">));</code>    <span class="pd_green1"><code class="c1">// true</code></span></pre><p>Because <code class="literal">object</code> is just a generic object, its prototype should be <code class="literal">Object.prototype</code>, meaning <code class="literal">isPrototypeOf()</code> should return <code class="literal">true</code>.</p><p>When a property is read on an object, the JavaScript engine first looks for an own property with that name. If the engine finds a correctly named own property, it returns that value. If no own property with that name exists on the target object, JavaScript searches the <code class="literal">[[Prototype]]</code> object instead. If a prototype property with that name exists, the value of that property is returned. If the search concludes without finding a property with the correct name, <code class="literal">undefined</code> is returned.</p><p>Consider the following, in which an object is first created without any own properties:</p><a id="pro_id00090"/><pre class="programlisting">  <span class="pd_green"><code class="kd">var</code></span> <code class="nx">object</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">{};</code>

<code class="err">❶</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">object</code><code class="p">.</code><code class="nx">toString</code><code class="p">());</code>    <span class="pd_green1"><code class="c1">// "[object Object]"</code></span>

  <code class="nx">object</code><code class="p">.</code><code class="nx">toString</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
      <span class="pd_green"><code class="k">return</code></span> <span class="pd_red"><code class="s2">"[object Custom]"</code></span><code class="p">;</code>
  <code class="p">};</code>

<code class="err">❷</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">object</code><code class="p">.</code><code class="nx">toString</code><code class="p">());</code>    <span class="pd_green1"><code class="c1">// "[object Custom]"</code></span>

  <span class="pd_green1"><code class="c1">// delete own property</code></span>
  <span class="pd_green"><code class="k">delete</code></span> <code class="nx">object</code><code class="p">.</code><code class="nx">toString</code><code class="p">;</code>

<code class="err">❸</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">object</code><code class="p">.</code><code class="nx">toString</code><code class="p">());</code>    <span class="pd_green1"><code class="c1">// "[object Object]"</code></span>

  <span class="pd_green1"><code class="c1">// no effect - delete only works on own properties</code></span>
  <span class="pd_green"><code class="k">delete</code></span> <code class="nx">object</code><code class="p">.</code><code class="nx">toString</code><code class="p">;</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">object</code><code class="p">.</code><code class="nx">toString</code><code class="p">());</code>    <span class="pd_green1"><code class="c1">// "[object Object]"</code></span></pre><p>In this example, the <code class="literal">toString()</code> method comes from the prototype and returns <code class="literal">"[object Object]"</code> ❶ by default. If you then define an own property called <code class="literal">toString()</code>, that own property is used whenever <code class="literal">toString()</code> is called on the object again ❷. The own property <span class="emphasis"><em>shadows</em></span> the prototype property, so the prototype property of the same name is no longer used. The prototype property is used again only if the own property is deleted from the object ❸. (Keep in mind that you can’t delete a prototype property from an instance because the <code class="literal">delete</code> operator acts only on own properties.) <a class="xref" href="ch04.html#object_with_no_own_properties_left_paren" title="Figure 4-2. An object with no own properties (top) has only the methods of its prototype. Adding a toString() property to the object (middle) replaces the prototype property until you delete it (bottom).">Figure 4-2</a> shows what is happening in this example.</p><p>This example also highlights an important concept: You cannot assign a value to a prototype property from an instance. As you can see in the middle section of <a class="xref" href="ch04.html#object_with_no_own_properties_left_paren" title="Figure 4-2. An object with no own properties (top) has only the methods of its prototype. Adding a toString() property to the object (middle) replaces the prototype property until you delete it (bottom).">Figure 4-2</a>, assigning a value to <code class="literal">toString</code> creates a new own property on the instance, leaving the property on the prototype untouched.</p><div class="figure"><a id="object_with_no_own_properties_left_paren"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00007"/><img src="figs/web/oojs04_02.png.jpg" alt="An object with no own properties (top) has only the methods of its prototype. Adding a toString() property to the object (middle) replaces the prototype property until you delete it (bottom)."/></div></div><div class="figure-title">Figure 4-2. An object with no own properties (top) has only the methods of its prototype. Adding a <code class="literal">toString()</code> property to the object (middle) replaces the prototype property until you delete it (bottom).</div></div></div><div class="sect2" title="Using Prototypes with Constructors"><div class="titlepage"><div><div><h3 class="title" id="using_prototypes_with_constructors">Using Prototypes with Constructors</h3></div></div></div><p>The shared nature of prototypes makes them ideal for defining methods once for all objects of a given type. Because methods tend to do the same thing for all instances, there’s no reason each instance needs its own set of methods.</p><p>It’s much more efficient to put the methods on the prototype and then use <code class="literal">this</code> to access the current instance. For example, consider the following new <code class="literal">Person</code> constructor:</p><a id="pro_id00091"/><pre class="programlisting">  <span class="pd_green"><code class="kd">function</code></span> <code class="nx">Person</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
      <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">name</code><code class="p">;</code>
  <code class="p">}</code>

<code class="err">❶</code> <code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">sayName</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
  <code class="p">};</code>

  <span class="pd_green"><code class="kd">var</code></span> <code class="nx">person1</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code></span> <code class="nx">Person</code><code class="p">(</code><span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">);</code>
  <span class="pd_green"><code class="kd">var</code></span> <code class="nx">person2</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code></span> <code class="nx">Person</code><code class="p">(</code><span class="pd_red"><code class="s2">"Greg"</code></span><code class="p">);</code>

  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person1</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>          <span class="pd_green1"><code class="c1">// "Nicholas"</code></span>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person2</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>          <span class="pd_green1"><code class="c1">// "Greg"</code></span>

  <code class="nx">person1</code><code class="p">.</code><code class="nx">sayName</code><code class="p">();</code>                  <span class="pd_green1"><code class="c1">// outputs "Nicholas"</code></span>
  <code class="nx">person2</code><code class="p">.</code><code class="nx">sayName</code><code class="p">();</code>                  <span class="pd_green1"><code class="c1">// outputs "Greg"</code></span></pre><p><a id="iddle1062" class="indexterm"/><a id="iddle1076" class="indexterm"/><a id="iddle1187" class="indexterm"/><a id="iddle1306" class="indexterm"/><a id="iddle1318" class="indexterm"/>In this version of the <code class="literal">Person</code> constructor, <code class="literal">sayName()</code> is defined on the prototype ❶ instead of in the constructor. The object instances work exactly the same as the example from earlier in this chapter, even though <code class="literal">sayName()</code> is now a prototype property instead of an own property. Because <code class="literal">person1</code> and <code class="literal">person2</code> are each base references for their calls to <code class="literal">sayName()</code>, the <code class="literal">this</code> value is assigned to <code class="literal">person1</code> and <code class="literal">person2</code>, respectively.</p><p>You can also store other types of data on the prototype, but be careful when using reference values. Because these values are shared across instances, you might not expect one instance to be able to change values that another instance will access. This example shows what can happen when you don’t watch where your reference values are pointing:</p><a id="pro_id00092"/><pre class="programlisting">  <span class="pd_green"><code class="kd">function</code></span> <code class="nx">Person</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
      <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">name</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">sayName</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
<code class="p">};</code>
<code class="err">❶</code> <code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">favorites</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">[];</code>

  <span class="pd_green"><code class="kd">var</code></span> <code class="nx">person1</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code></span> <code class="nx">Person</code><code class="p">(</code><span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">);</code>
  <span class="pd_green"><code class="kd">var</code></span> <code class="nx">person2</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code></span> <code class="nx">Person</code><code class="p">(</code><span class="pd_red"><code class="s2">"Greg"</code></span><code class="p">);</code>

  <code class="nx">person1</code><code class="p">.</code><code class="nx">favorites</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><span class="pd_red"><code class="s2">"pizza"</code></span><code class="p">);</code>
  <code class="nx">person2</code><code class="p">.</code><code class="nx">favorites</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><span class="pd_red"><code class="s2">"quinoa"</code></span><code class="p">);</code>

  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person1</code><code class="p">.</code><code class="nx">favorites</code><code class="p">);</code>     <span class="pd_green1"><code class="c1">// "pizza,quinoa"</code></span>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person2</code><code class="p">.</code><code class="nx">favorites</code><code class="p">);</code>     <span class="pd_green1"><code class="c1">// "pizza,quinoa"</code></span></pre><p>The <code class="literal">favorites</code> property ❶ is defined on the prototype, which means <code class="literal">person1.favorites</code> and <code class="literal">person2.favorites</code> point to the <span class="emphasis"><em>same array</em></span>. Any values you add to either person’s <code class="literal">favorites</code> will be elements in that array on the prototype. That may not be the behavior that you actually want, so it’s important to be very careful about what you define on the prototype.</p><p>Even though you can add properties to the prototype one by one, many developers use a more succinct pattern that involves replacing the prototype with an object literal:</p><a id="pro_id00093"/><pre class="programlisting">  <span class="pd_green"><code class="kd">function</code></span> <code class="nx">Person</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
      <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">name</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">{</code>
<code class="err">❶</code>     <code class="nx">sayName</code><code class="o">:</code> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
          <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
      <code class="p">},</code>

<code class="err">❷</code>     <code class="nx">toString</code><code class="o">:</code> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
          <span class="pd_green"><code class="k">return</code></span> <span class="pd_red"><code class="s2">"[Person "</code></span> <span class="pd_ash"><code class="o">+</code></span> <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code> <code class="o">+</code> <span class="pd_red"><code class="s2">"]"</code></span><code class="p">;</code>
      <code class="p">}</code>
  <code class="p">};</code></pre><p>This code defines two methods on the prototype, <code class="literal">sayName()</code> ❶ and <code class="literal">toString()</code> ❷. This pattern has become quite popular because it eliminates the need to type <code class="literal">Person.prototype</code> multiple times. There is, however, one side effect to be aware of:</p><a id="pro_id00094"/><pre class="programlisting">  <span class="pd_green"><code class="kd">var</code></span> <code class="nx">person1</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code></span> <code class="nx">Person</code><code class="p">(</code><span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">);</code>

  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person1</code> <span class="pd_green"><code class="k">instanceof</code></span> <code class="nx">Person</code><code class="p">);</code>        <span class="pd_green1"><code class="c1">// true</code></span>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person1</code><code class="p">.</code><code class="nx">constructor</code> <span class="pd_ash"><code class="o">===</code></span> <code class="nx">Person</code><code class="p">);</code>   <span class="pd_green1"><code class="c1">// false</code></span>
<code class="err">❶</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person1</code><code class="p">.</code><code class="nx">constructor</code> <span class="pd_ash"><code class="o">===</code></span> <span class="pd_green"><code class="nb">Object</code></span><code class="p">);</code>   <span class="pd_green1"><code class="c1">// true</code></span></pre><p><a id="iddle1056" class="indexterm"/><a id="iddle1304" class="indexterm"/>Using the object literal notation to overwrite the prototype changed the <code class="literal">constructor</code> property so that it now points to <code class="literal">Object</code> ❶ instead of <code class="literal">Person</code>. This happened because the <code class="literal">constructor</code> property exists on the prototype, not on the object instance. When a function is created, its <code class="literal">prototype</code> property is created with a <code class="literal">constructor</code> property equal to the function. This pattern completely overwrites the prototype object, which means that <code class="literal">constructor</code> will come from the newly created (generic) object that was assigned to <code class="literal">Person.prototype</code>. To avoid this, restore the <code class="literal">constructor</code> property to a proper value when overwriting the prototype:</p><a id="pro_id00095"/><pre class="programlisting">  <span class="pd_green"><code class="kd">function</code></span> <code class="nx">Person</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
      <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">name</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">{</code>
<code class="err">❶</code>     <code class="nx">constructor</code><code class="o">:</code> <code class="nx">Person</code><code class="p">,</code>

      <code class="nx">sayName</code><code class="o">:</code> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
          <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
      <code class="p">},</code>

      <code class="nx">toString</code><code class="o">:</code> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
          <span class="pd_green"><code class="k">return</code></span> <span class="pd_red"><code class="s2">"[Person "</code></span> <code class="o">+</code> <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code> <code class="o">+</code> <span class="pd_red"><code class="s2">"]"</code></span><code class="p">;</code>
      <code class="p">}</code>
  <code class="p">};</code>

  <span class="pd_green"><code class="kd">var</code></span> <code class="nx">person1</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code></span> <code class="nx">Person</code><code class="p">(</code><span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">);</code>
  <span class="pd_green"><code class="kd">var</code></span> <code class="nx">person2</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code></span> <code class="nx">Person</code><code class="p">(</code><span class="pd_red"><code class="s2">"Greg"</code></span><code class="p">);</code>

  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person1</code> <span class="pd_green"><code class="k">instanceof</code></span> <code class="nx">Person</code><code class="p">);</code>         <span class="pd_green1"><code class="c1">// true</code></span>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person1</code><code class="p">.</code><code class="nx">constructor</code> <span class="pd_ash"><code class="o">===</code></span> <code class="nx">Person</code><code class="p">);</code>    <span class="pd_green1"><code class="c1">// true</code></span>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person1</code><code class="p">.</code><code class="nx">constructor</code> <span class="pd_ash"><code class="o">===</code></span> <span class="pd_green"><code class="nb">Object</code></span><code class="p">);</code>    <span class="pd_green1"><code class="c1">// false</code></span>

  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person2</code> <span class="pd_green"><code class="k">instanceof</code></span> <code class="nx">Person</code><code class="p">);</code>         <span class="pd_green1"><code class="c1">// true</code></span>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person2</code><code class="p">.</code><code class="nx">constructor</code> <span class="pd_ash"><code class="o">===</code></span> <code class="nx">Person</code><code class="p">);</code>    <span class="pd_green1"><code class="c1">// true</code></span>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person2</code><code class="p">.</code><code class="nx">constructor</code> <span class="pd_ash"><code class="o">===</code></span> <span class="pd_green"><code class="nb">Object</code></span><code class="p">);</code>    <span class="pd_green1"><code class="c1">// false</code></span></pre><p>In this example, the <code class="literal">constructor</code> property is specifically assigned on the prototype ❶. It’s good practice to make this the first property on the prototype so you don’t forget to include it.</p><p>Perhaps the most interesting aspect of the relationships among constructors, prototypes, and instances is that there is no direct link between the instance and the constructor. There is, however, a direct link between the instance and the prototype and between the prototype and the constructor. <a class="xref" href="ch04.html#instance_and_its_constructor_are_linked" title="Figure 4-3. An instance and its constructor are linked via the prototype.">Figure 4-3</a> illustrates this relationship.</p><div class="figure"><a id="instance_and_its_constructor_are_linked"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00008"/><img src="figs/web/oojs04_03.png.jpg" alt="An instance and its constructor are linked via the prototype."/></div></div><div class="figure-title">Figure 4-3. An instance and its constructor are linked via the prototype.</div></div><p><a id="iddle1158" class="indexterm"/><a id="iddle1299" class="indexterm"/><a id="iddle1302" class="indexterm"/>This nature of this relationship means that any disruption between the instance and the prototype will also create a disruption between the instance and the constructor.</p></div><div class="sect2" title="Changing Prototypes"><div class="titlepage"><div><div><h3 class="title" id="changing_prototypes">Changing Prototypes</h3></div></div></div><p>Because all instances of a particular type reference a shared prototype, you can augment all of those objects together at any time. Remember, the <code class="literal">[[Prototype]]</code> property just contains a pointer to the prototype, and any changes to the prototype are immediately available on any instance referencing it. That means you can literally add new members to a prototype at any point and have those changes reflected on existing instances, as in this example:</p><a id="pro_id00096"/><pre class="programlisting">  <span class="pd_green"><code class="kd">function</code></span> <code class="nx">Person</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
      <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">name</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">{</code>
      <code class="nx">constructor</code><code class="o">:</code> <code class="nx">Person</code><code class="p">,</code>

<code class="err">❶</code>     <code class="nx">sayName</code><code class="o">:</code> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
          <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
      <code class="p">},</code>

<code class="err">❷</code>     <code class="nx">toString</code><code class="o">:</code> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
          <span class="pd_green"><code class="k">return</code></span> <span class="pd_red"><code class="s2">"[Person "</code></span> <code class="o">+</code> <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code> <code class="o">+</code> <span class="pd_red"><code class="s2">"]"</code></span><code class="p">;</code>
      <code class="p">}</code>
  <code class="p">};</code>
<code class="err">❸</code> <span class="pd_green"><code class="kd">var</code></span> <code class="nx">person1</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code></span> <code class="nx">Person</code><code class="p">(</code><span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">);</code>
  <span class="pd_green"><code class="kd">var</code></span> <code class="nx">person2</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code></span> <code class="nx">Person</code><code class="p">(</code><span class="pd_red"><code class="s2">"Greg"</code></span><code class="p">);</code>

  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_red"><code class="s2">"sayHi"</code></span> <span class="pd_green"><code class="k">in</code></span> <code class="nx">person1</code><code class="p">);</code>         <span class="pd_green1"><code class="c1">// false</code></span>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_red"><code class="s2">"sayHi"</code></span> <span class="pd_green"><code class="k">in</code></span> <code class="nx">person2</code><code class="p">);</code>         <span class="pd_green1"><code class="c1">// false</code></span>

  <span class="pd_green1"><code class="c1">// add a new method</code></span>
<code class="err">❹</code> <code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">sayHi</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="err">"</code><code class="nx">H</code><span class="pd_red"><code class="nx">i</code><code class="err">"</code><code class="p">);</code></span>
  <code class="p">};</code>

<code class="err">❺</code> <code class="nx">person1</code><code class="p">.</code><code class="nx">sayHi</code><code class="p">();</code>                         <span class="pd_green1"><code class="c1">// outputs "Hi"</code></span>
  <code class="nx">person2</code><code class="p">.</code><code class="nx">sayHi</code><code class="p">();</code>                         <span class="pd_green1"><code class="c1">// outputs "Hi"</code></span></pre><p><a id="iddle1116" class="indexterm"/><a id="iddle1118" class="indexterm"/><a id="iddle1216" class="indexterm"/><a id="iddle1247" class="indexterm"/><a id="iddle1327" class="indexterm"/><a id="iddle1330" class="indexterm"/>In this code, the <code class="literal">Person</code> type starts out with only two methods, <code class="literal">sayName()</code> ❶ and <code class="literal">toString()</code> ❷. Two instances of <code class="literal">Person</code> are created ❸, and then the <code class="literal">sayHi()</code> ❹ method is added to the prototype. After that point, both instances can now access <code class="literal">sayHi()</code> ❺. The search for a named property happens each time that property is accessed, so the experience is seamless.</p><p>The ability to modify the prototype at any time has some interesting repercussions for sealed and frozen objects. When you use <code class="literal">Object.seal()</code> or <code class="literal">Object.freeze()</code> on an object, you are acting <span class="emphasis"><em>solely</em></span> on the object instance and the own properties. You can’t add new own properties or change existing own properties on frozen objects, but you can certainly still add properties on the prototype and continue extending those objects, as demonstrated in the following listing.</p><a id="pro_id00097"/><pre class="programlisting">  <span class="pd_green"><code class="kd">var</code></span> <code class="nx">person1</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code></span> <code class="nx">Person</code><code class="p">(</code><span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">);</code>
  <span class="pd_green"><code class="kd">var</code></span> <code class="nx">person2</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code></span> <code class="nx">Person</code><code class="p">(</code><span class="pd_red"><code class="s2">"Greg"</code></span><code class="p">);</code>

<code class="err">❶</code> <span class="pd_green"><code class="nb">Object</code></span><code class="p">.</code><code class="nx">freeze</code><code class="p">(</code><code class="nx">person1</code><code class="p">);</code>

<code class="err">❷</code> <code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">sayHi</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_red"><code class="s2">"Hi"</code></span><code class="p">);</code>
  <code class="p">};</code>

<code class="nx">person1</code><code class="p">.</code><code class="nx">sayHi</code><code class="p">();</code>                            <span class="pd_green1"><code class="c1">// outputs "Hi"</code></span>
<code class="nx">person2</code><code class="p">.</code><code class="nx">sayHi</code><code class="p">();</code>                            <span class="pd_green1"><code class="c1">// outputs "Hi"</code></span></pre><p>In this example, there are two instances of <code class="literal">Person</code>. The first (<code class="literal">person1</code>) is frozen ❶, while the second is a normal object. When you add <code class="literal">sayHi()</code> to the prototype ❷, both <code class="literal">person1</code> and <code class="literal">person2</code> attain a new method, seemingly contradicting <code class="literal">person1</code>’s frozen status. The <code class="literal">[[Prototype]]</code> property is considered an own property of the instance, and while the property itself is frozen, the value (an object) is not.</p><div class="note" title="Note"><h3 class="title"><a id="ch04note04"/>Note</h3><p><a id="iddle1024" class="indexterm"/><a id="iddle1039" class="indexterm"/><a id="iddle1045" class="indexterm"/><a id="iddle1184" class="indexterm"/><a id="iddle1301" class="indexterm"/><a id="iddle1345" class="indexterm"/><span class="emphasis"><em>In practice, you probably won’t use prototypes this way very often when developing in JavaScript. However, it’s important to understand the relationships that exist between objects and their prototype, and strange examples like this help to illuminate the concepts.</em></span></p></div></div><div class="sect2" title="Built-in Object Prototypes"><div class="titlepage"><div><div><h3 class="title" id="built-in_object_prototypes">Built-in Object Prototypes</h3></div></div></div><p>At this point, you might wonder if prototypes also allow you to modify the built-in objects that come standard in the JavaScript engine. The answer is yes. All built-in objects have constructors, and therefore, they have prototypes that you can change. For instance, adding a new method for use on all arrays is as simple as modifying <code class="literal">Array.prototype</code>.</p><a id="pro_id00098"/><pre class="programlisting"><span class="pd_green"><code class="nb">Array</code></span><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">sum</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
    <span class="pd_green"><code class="k">return</code></span> <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">reduce</code><code class="p">(</code><span class="pd_green"><code class="kd">function</code></span><code class="p">(</code><code class="nx">previous</code><code class="p">,</code> <code class="nx">current</code><code class="p">)</code> <code class="p">{</code>
        <span class="pd_green"><code class="k">return</code></span> <code class="nx">previous</code> <span class="pd_ash"><code class="o">+</code></span> <code class="nx">current</code><code class="p">;</code>
    <code class="p">});</code>
<code class="p">};</code>

<span class="pd_green"><code class="kd">var</code></span> <code class="nx">numbers</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">[</code> <span class="pd_ash"><code class="mi">1</code></span><code class="p">,</code> <span class="pd_ash"><code class="mi">2</code></span><code class="p">,</code> <span class="pd_ash"><code class="mi">3</code></span><code class="p">,</code> <span class="pd_ash"><code class="mi">4</code></span><code class="p">,</code> <span class="pd_ash"><code class="mi">5</code></span><code class="p">,</code> <span class="pd_ash"><code class="mi">6</code></span> <code class="p">];</code>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">result</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">numbers</code><code class="p">.</code><code class="nx">sum</code><code class="p">();</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">result</code><code class="p">);</code>                <span class="pd_green1"><code class="c1">// 21</code></span></pre><p>This example creates a method called <code class="literal">sum()</code> on <code class="literal">Array.prototype</code> that simply adds up all of the items in the array and returns the result. The <code class="literal">numbers</code> array automatically has access to that method through the prototype. Inside of <code class="literal">sum()</code>, <code class="literal">this</code> refers to <code class="literal">numbers</code>, which is an instance of <code class="literal">Array</code>, so the method is free to use other array methods such as <code class="literal">reduce()</code>.</p><p>You may recall that strings, numbers, and Booleans all have built-in primitive wrapper types that are used to access primitive values as if they were objects. If you modify the primitive wrapper type prototype as in this example, you can actually add more functionality to those primitive values:</p><a id="pro_id00099"/><pre class="programlisting"><span class="pd_green"><code class="nb">String</code></span><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">capitalize</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
    <span class="pd_green"><code class="k">return</code></span> <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">charAt</code><code class="p">(</code><span class="pd_ash"><code class="mi">0</code></span><code class="p">).</code><code class="nx">toUpperCase</code><code class="p">()</code> <span class="pd_ash"><code class="o">+</code></span> <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">substring</code><code class="p">(</code><span class="pd_ash"><code class="mi">1</code></span><code class="p">);</code>
<code class="p">};</code>

<span class="pd_green"><code class="kd">var</code></span> <code class="nx">message</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_red"><code class="s2">"hello world!"</code></span><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">.</code><code class="nx">capitalize</code><code class="p">());</code>  <span class="pd_green1"><code class="c1">// "Hello world!"</code></span></pre><p>This code creates a new method called <code class="literal">capitalize()</code> for strings. The <code class="literal">String</code> type is the primitive wrapper for strings, and modifying its prototype means that all strings automatically get those changes.</p><div class="note" title="Note"><h3 class="title"><a id="ch04note05"/>Note</h3><p><span class="emphasis"><em>While it may be fun and interesting to modify built-in objects to experiment with functionality, it’s not a good idea to do so in a production environment. Developers expect built-in objects to behave a certain way and have certain methods. Deliberately altering built-in objects violates those expectations and makes other developers unsure how the objects should work.</em></span></p></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id00005">Summary</h2></div></div></div><p>Constructors are just normal functions that are called with the <code class="literal">new</code> operator. You can define your own constructors anytime you want to create multiple objects with the same properties. You can identify objects created from constructors using <code class="literal">instanceof</code> or by accessing their <code class="literal">constructor</code> property directly.</p><p>Every function has a <code class="literal">prototype</code> property that defines any properties shared by objects created with a particular constructor. Shared methods and primitive value properties are typically defined on prototypes, while all other properties are defined within the constructor. The <code class="literal">constructor</code> property is actually defined on the prototype because it is shared among object instances.</p><p>The prototype of an object is stored internally in the <code class="literal">[[Prototype]]</code> property. This property is a reference, not a copy. If you change the prototype at any point in time, those changes will occur on all instances because of the way JavaScript looks up properties. When you try to access a property on an object, that object is searched for any own property with the name you specify. If an own property is not found, the prototype is searched. This searching mechanism means the prototype can continue to change, and object instances referencing that prototype will reflect those changes immediately.</p><p>Built-in objects also have prototypes that can be modified. While it’s not recommended to do this in production, it can be helpful for experimentation and proofs of concept for new functionality.</p></div></section></body></html>