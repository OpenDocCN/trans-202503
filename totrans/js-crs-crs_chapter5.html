<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>JavaScript Crash Course</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:26ab05bf-a247-42ca-b08d-ede069333d2b" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch5" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="CHAPTER" id="ch5">
<span class="CN"><span aria-label=" Page 73. " epub:type="pagebreak" id="pg_73" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">FUNCTIONS</samp></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" src="../images/opener.png"/>
</figure>
<p class="INTROTNI2">As you learned in <span class="chapterintro_Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, a <i>function</i> is a self-contained block of code for performing a certain task. We’ve already used some of JavaScript’s built-in functions, such as <span class="SANS_TheSansMonoCd_W5Regular_11">alert</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">console.log</span>, but you can also create your own custom functions to perform the tasks particular to your application. Then you can <i>call</i> these functions to run the associated code. Packaging code into functions in this way makes your programming more effective, as you don’t have to repeat the code every time you want to use it.</p>
<p class="TX">In this chapter, you’ll learn different techniques for writing your own functions. You’ll see how to provide input to functions and receive output from them. You’ll also see how functions can be treated as ordinary values, <span aria-label=" Page 74. " epub:type="pagebreak" id="pg_74" role="doc-pagebreak"/>just like a number or a string. In particular, we’ll explore how functions can serve as input or output for other, higher-order functions.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="h1-26"/><samp class="SANS_Futura_Std_Bold_B_11">Declaring and Calling Functions</samp></h3>
<p class="TNI1">Before you can use a custom function, you have to establish what the function is called and what it does. One way is to use a <i>function declaration</i>, a block of code that defines a function. To illustrate, we’ll declare a simple function called <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> that takes in someone’s name and logs a custom greeting for that person to the console. Open the JavaScript console in Chrome and enter the following:</p>

<pre><code><b>function sayHello(name) {</b>
<b>  console.log(`Hello, ${name}!`);</b>
<b>}</b>
</code></pre>
<p class="TX">A function declaration has four parts. First, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">function</span> keyword to tell JavaScript we’re creating a function. Next, we give the function a name—in this case, <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span>. After that, we provide a comma-separated list of the function’s parameters, surrounded by parentheses. <i>Parameters</i> are pieces of information that the function needs to do its job. In this case, our function has one parameter, <span class="SANS_TheSansMonoCd_W5Regular_11">name</span>, indicating that the function needs to be supplied with someone’s name in order to create a greeting. (If a function has no parameters, we simply write an empty set of parentheses.) Finally, we write the function’s body, surrounded by braces. This is the code that should be executed when the function is called. In our example, the body consists of a call to <span class="SANS_TheSansMonoCd_W5Regular_11">console.log</span> to print out a greeting, with the value of the <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> parameter inserted via a template literal.</p>
<p class="TX">Now that we’ve declared our <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> function, we can call it whenever we want to greet someone. Each time we call the function, we’ll need to provide a value for the <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> parameter. That value is called an <i>argument</i>, and it’s specified in parentheses when the function is called. By passing the function different arguments, we can create different custom greetings. For example:</p>

<pre><code><b>sayHello("Nick");</b>
Hello, Nick!
undefined
<b>sayHello("Mei");</b>
Hello, Mei!
undefined
</code></pre>
<p class="TX">The first time we call our <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> function, we pass <span class="SANS_TheSansMonoCd_W5Regular_11">"Nick"</span> as an argument in the parentheses after the function name. As a result, the message <span class="SANS_TheSansMonoCd_W5Regular_11">Hello, Nick!</span> is logged to the console. The second time we call the function, we pass <span class="SANS_TheSansMonoCd_W5Regular_11">"Mei"</span> as an argument, so the message <span class="SANS_TheSansMonoCd_W5Regular_11">Hello, Mei!</span> is logged. In each case, the value of the argument is bound to the function’s <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> parameter, and the function body runs with the <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> parameter set to that value. <span aria-label=" Page 75. " epub:type="pagebreak" id="pg_75" role="doc-pagebreak"/>Essentially, you can think of <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> as a variable within the function that takes on the value of the corresponding argument (such as <span class="SANS_TheSansMonoCd_W5Regular_11">"Nick"</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">"Mei"</span>) when the function is called.</p>
<p class="TX">The distinction between parameters and arguments is subtle but important. Parameters are generic names for a function’s inputs, whereas arguments are the actual input values passed to the function when you call it. Each function has only one set of parameters, but every time you call the function it can have a new set of arguments. In this way, parameters make your functions highly customizable. The <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> function, for example, has one parameter, <span class="SANS_TheSansMonoCd_W5Regular_11">name</span>, but it can be called with a different argument each time. We’ve seen it called with <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello("Nick")</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello("Mei")</span>, but the possibilities are endless: <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello("Kitty")</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello("Dolly")</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello("world")</span>, and so on.</p>
<p class="TX">Notice that each call to <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> outputs <span class="SANS_TheSansMonoCd_W5Regular_11">undefined</span> as well as the custom greeting. This extra line of output is the function’s return value. <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> returns <span class="SANS_TheSansMonoCd_W5Regular_11">undefined</span> because we didn’t explicitly give it a return value; we’ll look at how to do that next.</p>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="H2" id="sec2"><span id="h2-38"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Return Values</samp></h4>
<p class="TNI1">A <i>return value</i> is a value that a function produces for use elsewhere in your code. In many cases, you’ll want a function to take in some inputs using parameters, process those inputs in some way, and output the result. That output is the return value. For example, let’s declare a function that takes in two numbers and returns their sum:</p>

<pre><code><b>function add(x, y) {</b>
<b>  return x + y;</b>
<b>}</b>
</code></pre>
<p class="TX">This <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> function has two parameters, <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>. The function body consists of the <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> keyword followed by the expression <span class="SANS_TheSansMonoCd_W5Regular_11">x + y</span>. When the function is called, JavaScript will evaluate this expression, adding <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> together, and return the result, as shown here:</p>

<pre><code><b>add(1, 2);</b>
3
</code></pre>
<p class="BodyContinued">We call <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> with the arguments <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">2</span>, which become the values for parameters <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>, respectively. (The arguments are matched with the parameters in the order in which they’re given.) The function sums the two arguments and returns the resulting value, <span class="SANS_TheSansMonoCd_W5Regular_11">3</span>.</p>
<p class="TX">When we call a function in the Chrome console, its return value is automatically printed out—but it’s important to distinguish between a function explicitly logging text to the console, as we saw <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> do earlier, and a function returning a value, as <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> is doing here. When a function logs a value using <span class="SANS_TheSansMonoCd_W5Regular_11">console.log</span>, the only place that value exists is in the log; we can’t make further use of it later. By contrast, when a function returns a value, we can then use that value later in our code. The fact that the return value <span aria-label=" Page 76. " epub:type="pagebreak" id="pg_76" role="doc-pagebreak"/>is also displayed in the console is largely irrelevant. It helps us see what the function is doing, but logging to the console isn’t the <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> function’s main purpose, unlike the <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> function.</p>
<p class="TX">One way to make use of a function’s return value is to call the function as part of an assignment expression, so the return value will be stored in a variable. Then we can work with that variable later in the code. For example:</p>

<pre><code><b>let sum </b><b>= add(500, 500);</b>
undefined
<b>`I walked ${sum} miles`;</b>
'I walked 1000 miles'
</code></pre>
<p class="BodyContinued">Here we declare the variable <span class="SANS_TheSansMonoCd_W5Regular_11">sum</span> and initialize it to the return value of the <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> function, which we call with the arguments <span class="SANS_TheSansMonoCd_W5Regular_11">500</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">500</span>. The console shows <span class="SANS_TheSansMonoCd_W5Regular_11">undefined</span> even though <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> has a return value because, as discussed in <span class="bodycontinued_Xref"><a href="chapter2.xhtml">Chapter 2</a></span>, declaring a variable always prints <span class="SANS_TheSansMonoCd_W5Regular_11">undefined</span>. We then use the function’s return value by incorporating <span class="SANS_TheSansMonoCd_W5Regular_11">sum</span> into a template literal to create the string <span class="SANS_TheSansMonoCd_W5Regular_11">"I walked 1000 miles"</span>.</p>
<p class="TX">Notice that it wouldn’t be possible to do something similar with our <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> function as it’s currently written. For example, we can’t use it to generate the greeting <span class="SANS_TheSansMonoCd_W5Regular_11">"Hello, Nick!"</span> and then write some code to incorporate that greeting into a longer string. The <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> function returns <span class="SANS_TheSansMonoCd_W5Regular_11">undefined</span>, because we didn’t use the <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> keyword to explicitly give it a return value. It merely logs the greeting to the console, and there’s no way to access the greeting once it’s been logged.</p>
<p class="TX">It’s not necessary to store a function’s return value in a variable to use it. A function call that returns a value can be used anywhere a value can be used, just as you can use variables and literal values interchangeably. For instance, the previous example could be rewritten like so:</p>

<pre><code><b>`I walked ${add(500, 500)} miles`;</b>
'I walked 1000 miles'
</code></pre>
<p class="BodyContinued">Here, instead of calling <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> separately and storing the result in a variable, we call the function from within the template literal. Its return value is inserted directly into the resulting string, producing the same message as before. It’s often more readable to store the return value in a variable, but both approaches are equally valid.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<aside aria-label="box-15" class="box" id="sec3">
<h4 class="BH" id="box-15"><samp class="SANS_Dogma_OT_Bold_B_11">TRY IT YOURSELF</samp></h4>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">  5-1.</samp><samp class="SANS_Futura_Std_Book_11">  Rewrite the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> <samp class="SANS_Futura_Std_Book_11">function so it returns the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">`Hello, ${name}!`</span> <samp class="SANS_Futura_Std_Book_11">greeting instead of logging it. Then write some code to use the returned greeting. For example, apply the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">toUpperCase</span> <samp class="SANS_Futura_Std_Book_11">string method to convert the greeting to all caps.</samp></p>
</aside>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="H2" id="sec4"><span id="h2-39"/><span aria-label=" Page 77. " epub:type="pagebreak" id="pg_77" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parameter Types</samp></h4>
<p class="TNI1">The data types of function parameters in JavaScript are not fixed. This is because JavaScript is a <i>dynamically typed</i> programming language, in which the types of variables and parameters can change while the program is running, as opposed to a <i>statically typed</i> language, in which the types of variables and parameters are determined before the program is run.</p>
<p class="TX">To illustrate, so far we’ve been using the <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> function to add numbers together, but there’s nothing stopping us from using it to concatenate two strings:</p>

<pre><code><b>add("Hello, ", "world!");</b>
'Hello, world!'
</code></pre>
<p class="BodyContinued">Here we pass the function two strings as arguments, so the <span class="SANS_TheSansMonoCd_W5Regular_11">+</span> operator in the function body is interpreted to mean string concatenation rather than numerical addition. The function therefore combines the strings and returns the result.</p>
<p class="TX">By extension, we could also pass arguments of other types, or even mix data types within the same function call:</p>

<pre><code><b>add(true, false);</b>
1
<b>add(1, '1');</b>
'11'
</code></pre>
<p class="BodyContinued">In these cases, JavaScript’s rules around type coercion, discussed in <span class="bodycontinued_Xref"><a href="chapter2.xhtml">Chapter 2</a></span>, come into play. When we try to add two Booleans with <span class="SANS_TheSansMonoCd_W5Regular_11">add(true, false)</span>, JavaScript converts the Booleans to the numbers <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> before the addition, producing the number <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>. When we try to add a number and a string with <span class="SANS_TheSansMonoCd_W5Regular_11">add(1, "1")</span>, JavaScript converts both of the operands to strings and concatenates them, producing the string <span class="SANS_TheSansMonoCd_W5Regular_11">"11"</span>.</p>
<p class="TX">Dynamic typing brings a lot of flexibility to JavaScript, but if you aren’t careful, it can also open the way for some confusing bugs. It’s essential to have a good idea of the types you’re using, to make sure you’re not passing a string to a function that expects a number, for example.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h4 class="H2" id="sec5"><span id="h2-40"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Side Effects</samp></h4>
<p class="TNI1">A <i>side effect</i> is anything a function does that makes a difference outside of the function itself, apart from returning a value. Side effects can be intended or unintended, and include updating the value of a variable declared outside the function, modifying an array or object declared outside the function, or outputting a string to the console.</p>
<p class="TX">Some functions, like our <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> function, have no side effects and are called only for their return value. Other functions, like <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span>, have no return value and are called only for their side effects. It’s also possible to write functions that return a value <i>and</i> have side effects. For example, <span aria-label=" Page 78. " epub:type="pagebreak" id="pg_78" role="doc-pagebreak"/>we can redefine <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> to log some information to the console and update a variable, in addition to returning the sum of its arguments:</p>

<pre><code><b>let addCalls = 0;</b>

<b>function add(x, y) {</b>
<b>  addCalls++;</b>
<b>  console.log(`x was ${x} and y was ${y}`);</b>
<b>  return x + y;</b>
<b>}</b>
</code></pre>
<p class="BodyContinued">Here we declare the variable <span class="SANS_TheSansMonoCd_W5Regular_11">addCalls</span>, which we’ll use to keep track of how often the <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> function is called. Then we write our updated <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> function declaration. The function now increments <span class="SANS_TheSansMonoCd_W5Regular_11">addCalls</span> and logs the values of its parameters to the console, before returning the sum of the parameters, as before.</p>
<p class="TX">Let’s try calling the revised function:</p>

<pre><code><b>let sum = add(Math.PI, Math.E);</b>
x was 3.141592653589793 and y was 2.718281828459045
<b>addCalls;</b>
1
<b>sum;</b>
5.859874482048838
</code></pre>
<p class="BodyContinued">The function call has the side effect of logging the two values to the console before adding them together. It also has the side effect of updating the <span class="SANS_TheSansMonoCd_W5Regular_11">addCalls</span> variable, changing its value from <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>. Additionally, the function has the (non–side effect) result of returning the sum of its arguments, which we’ve stored in the <span class="SANS_TheSansMonoCd_W5Regular_11">sum</span> variable.</p>
<p class="TX">If we made further calls to <span class="SANS_TheSansMonoCd_W5Regular_11">add</span>, the variable <span class="SANS_TheSansMonoCd_W5Regular_11">addCalls</span> would keep incrementing each time, giving us a running count of the number of times the function is called. You don’t typically need to keep track of the number of times a function is called like this, although you could use such a mechanism to restrict how often a program is allowed to call some function that requires a lot of processing power (a technique known as <i>rate limiting</i>). You could achieve this by periodically resetting the counter—perhaps every minute—and skipping the function call if the counter goes over some threshold.</p>
</section>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h3 class="H1" id="sec6"><span id="h1-27"/><samp class="SANS_Futura_Std_Bold_B_11">Passing a Function as an Argument</samp></h3>
<p class="TNI1">In JavaScript, functions are <i>first-class citizens</i>, which means they can be used like any other value, such as a number or a string. For example, you can store a function in a variable or pass a function as an argument to another function. The latter is especially common, as there are many functions that delegate work to other functions. When a function is passed as an argument, it’s often referred to as a <i>callback</i> because the function it’s passed to is said to “call it back” by executing it.</p>
<p class="TX"><span aria-label=" Page 79. " epub:type="pagebreak" id="pg_79" role="doc-pagebreak"/>We’ll illustrate this with JavaScript’s built-in <span class="SANS_TheSansMonoCd_W5Regular_11">setTimeout</span> function, which allows you to delay the calling of another function. It takes two arguments: a function to call, and a time in milliseconds (ms) to wait before calling that function. Here’s how it works:</p>

<pre><code><b>function sayHi() {</b>
<b>  console.log("Hi!");</b>
<b>}</b>
<b>setTimeout(sayHi, 2000);</b>
1
Hi!
</code></pre>
<p class="TX">First we create a simple function with no arguments, <span class="SANS_TheSansMonoCd_W5Regular_11">sayHi</span>, which just calls <span class="SANS_TheSansMonoCd_W5Regular_11">console.log</span>. We then call <span class="SANS_TheSansMonoCd_W5Regular_11">setTimeout</span>, passing the <span class="SANS_TheSansMonoCd_W5Regular_11">sayHi</span> function and the number <span class="SANS_TheSansMonoCd_W5Regular_11">2000</span> (indicating 2,000 ms, or 2 seconds) as arguments. Once you press <small>ENTER</small>, <span class="SANS_TheSansMonoCd_W5Regular_11">setTimeout</span> should immediately return a <i>timeout ID</i>—in this case, <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>—which is a unique identifier you could use to cancel the delayed function call if desired. Then, after two seconds, the <span class="SANS_TheSansMonoCd_W5Regular_11">sayHi</span> function is called, and the string <span class="SANS_TheSansMonoCd_W5Regular_11">"Hi!"</span> is logged to the console.</p>
<blockquote>
<p class="NOTE"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></p>
</blockquote>
<p class="NOTE-TXT"><i>To cancel a function call delayed with setTimeout, call the clearTimeout function, passing the timeout ID as an argument.</i></p>
<p class="TX">Notice that when we pass a function as an argument, we write its name without parentheses: in this case, <span class="SANS_TheSansMonoCd_W5Regular_11">sayHi</span> rather than <span class="SANS_TheSansMonoCd_W5Regular_11">sayHi()</span>. A function name without parentheses simply <i>refers</i> to the function, while a function name with parentheses actually <i>calls</i> the function. We can see this distinction in the JavaScript console:</p>

<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">❶</span> <b>sayHi;</b>
<span class="TheSansMonoCd_W5Regular_Italic_I_11">f sayHi() {</span>
  <span class="TheSansMonoCd_W5Regular_Italic_I_11">console.log("Hi!");</span>
<span class="TheSansMonoCd_W5Regular_Italic_I_11">}</span>

<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> <b>sayHi();</b>
Hi!
undefined
</code></pre>
<p class="TX">Executing just plain <span class="SANS_TheSansMonoCd_W5Regular_11">sayHi;</span> without parentheses <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> prints the function’s definition but doesn’t call it. However, executing <span class="SANS_TheSansMonoCd_W5Regular_11">sayHi();</span> with parentheses <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> calls the <span class="SANS_TheSansMonoCd_W5Regular_11">sayHi</span> function, printing the string <span class="SANS_TheSansMonoCd_W5Regular_11">"Hi!"</span> and returning <span class="SANS_TheSansMonoCd_W5Regular_11">undefined</span>.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="H1" id="sec7"><span id="h1-28"/><samp class="SANS_Futura_Std_Bold_B_11">Other Function Syntaxes</samp></h3>
<p class="TNI1">So far in this chapter we’ve focused on creating functions using function declarations, but JavaScript also supports other ways to create functions. Function declarations follow a straightforward format and use a similar syntax to how functions are defined in many other languages, like C<span class="symbol">++</span> <span aria-label=" Page 80. " epub:type="pagebreak" id="pg_80" role="doc-pagebreak"/>and Python. They’re perfectly fine when you’re writing functions that you intend to call directly, like the <span class="SANS_TheSansMonoCd_W5Regular_11">sayHello</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> functions that we’ve discussed. However, once you start treating functions as values by passing them as arguments and the like, the other styles of creating functions become more useful. We’ll turn to those now, starting with function expressions.</p>
<section aria-labelledby="sec8" epub:type="division">
<h4 class="H2" id="sec8"><span id="h2-41"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Function Expressions</samp></h4>
<p class="TNI1">A <i>function expression</i>, also known as a <i>function literal</i>, is a code literal whose value is a function, just as <span class="SANS_TheSansMonoCd_W5Regular_11">123</span> is a literal whose value is the number 123. Whereas a function declaration creates a function and binds it to a name, a function expression is an expression that evaluates to (returns) a function, for you to do with what you will.</p>
<p class="TX">Syntactically, a function expression looks very similar to a function declaration, with two main differences. First, a function expression doesn’t have to include a name, although you can include one if you want. Function expressions without names are also called <i>anonymous functions</i>. Second, a function expression can’t be written at the start of a line of code, or JavaScript will think it’s a function declaration; there has to be some code before the <span class="SANS_TheSansMonoCd_W5Regular_11">function</span> keyword. This is why function expressions are often used in contexts where functions need to be treated as values.</p>
<p class="TX">For example, you can define a function expression and assign it as the value of a variable, all in one statement, as shown here:</p>

<pre><code><b>let addExpression = function (x, y) {</b>
<b>  return x + y;</b>
<b>};</b>
</code></pre>
<p class="BodyContinued">The <span class="SANS_TheSansMonoCd_W5Regular_11">function</span> keyword appears on the right side of an assignment statement, rather than at the start of a line, so JavaScript treats this as a function expression. In this case, we’re assigning the function expression to the <span class="SANS_TheSansMonoCd_W5Regular_11">addExpression</span> variable. The function itself is anonymous, since we don’t provide a name after the <span class="SANS_TheSansMonoCd_W5Regular_11">function</span> keyword (you’ll see an example where we do this in the <span class="bodycontinued_Xref">“Named Function Expressions”</span> box on the following page). It has two parameters, <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>, specified in parentheses, just like our original <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> function. The body returns the sum of the parameters and is enclosed in braces, much like the body of a function declaration, but notice that we need to put a semicolon after the closing brace to signify the end of the statement assigning the function to a variable.</p>
<p class="TX">Although the function itself is technically anonymous, it’s now bound to the <span class="SANS_TheSansMonoCd_W5Regular_11">addExpression</span> variable. We can therefore call the function by putting a pair of parentheses containing the necessary arguments after the variable name, just like calling any named function:</p>

<pre><code><b>addExpression(1, 2);</b>
3
</code></pre>
<p class="BodyContinued"><span aria-label=" Page 81. " epub:type="pagebreak" id="pg_81" role="doc-pagebreak"/>Entering <span class="SANS_TheSansMonoCd_W5Regular_11">addExpression(1, 2)</span> calls the function, returning the sum of the two arguments.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<aside aria-label="box-16" class="box" id="sec9">
<h4 class="BH" id="box-16"><samp class="SANS_Dogma_OT_Bold_B_11">NAMED FUNCTION EXPRESSIONS</samp></h4>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">You can optionally include a name in a function expression after the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">function</span> <samp class="SANS_Futura_Std_Book_11">keyword. For instance:</samp></p>

<pre><code><b>let addExpressionNamed</b> <b>=</b> <b>function add(x, y) {</b>
  <b>return x</b> <b>+</b> <b>y;</b>
<b>};</b>
</code></pre>
<p class="BoxBodyContinued"><samp class="SANS_Futura_Std_Book_11">Here we give the function expression a name,</samp> add<samp class="SANS_Futura_Std_Book_11">, although notice that we’re still assigning the function to a separately named variable,</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">addExpressionNamed</span><samp class="SANS_Futura_Std_Book_11">. In fact, the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> <samp class="SANS_Futura_Std_Book_11">name isn’t in scope outside of the function body itself. This means that we can’t call the function by name, for example, with</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">add(1, 2)</span><samp class="SANS_Futura_Std_Book_11">. We have to call it using the variable name the function was assigned to:</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">addExpressionNamed(1, 2)</span><samp class="SANS_Futura_Std_Book_11">.</samp></p>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Naming function expressions isn’t as common as leaving them anonymous, but this syntax can be useful for debugging purposes, to help distinguish one function expression from another. You can see this if you use</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">console.log</span> <samp class="SANS_Futura_Std_Book_11">to log the values of</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">addExpression</span> <samp class="SANS_Futura_Std_Book_11">and</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">addExpressionNamed</span><samp class="SANS_Futura_Std_Book_11">. The former will just show the anonymous function expression, while the latter will include the</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> <samp class="SANS_Futura_Std_Book_11">name in the output, which is useful if you don’t know which function you’re logging to the console.</samp></p>
</aside>
<p class="TX">In many respects, function expressions and function declarations are interchangeable, so choosing between the two approaches is often just a matter of style. For example, defining our function for adding two numbers as a function expression and assigning it to a variable is largely equivalent to defining it using a function declaration, as we did originally. When it comes to passing functions as arguments, however, function expressions offer certain advantages. Earlier, for example, we declared the <span class="SANS_TheSansMonoCd_W5Regular_11">sayHi</span> function, then passed its name to <span class="SANS_TheSansMonoCd_W5Regular_11">setTimeout</span> as an argument. A more common way to do this is to write an equivalent function expression directly in the <span class="SANS_TheSansMonoCd_W5Regular_11">setTimeout</span> function’s arguments list, without first assigning it to a variable:</p>

<pre><code><b>setTimeout(function () {</b>
<b>  console.log("Hi!");</b>
<b>},</b> <b>2000);</b>
2
Hi!
</code></pre>
<p class="TX">Previously we called <span class="SANS_TheSansMonoCd_W5Regular_11">setTimeout(sayHi, 2000)</span>, passing the name of a function as the first argument, but this time we’re passing a function expression instead. The function expression defines an anonymous function for logging <span class="SANS_TheSansMonoCd_W5Regular_11">"Hi!"</span> to the console (the equivalent of the <span class="SANS_TheSansMonoCd_W5Regular_11">sayHi</span> function we declared <span aria-label=" Page 82. " epub:type="pagebreak" id="pg_82" role="doc-pagebreak"/>earlier). Notice that the <span class="SANS_TheSansMonoCd_W5Regular_11">function</span> keyword isn’t the first thing in the line of code, a requirement for function expressions, and that the closing brace is followed by a comma, since the function expression is part of a list of arguments.</p>
<p class="TX">As before, calling <span class="SANS_TheSansMonoCd_W5Regular_11">setTimeout</span> returns a timeout ID, this time <span class="SANS_TheSansMonoCd_W5Regular_11">2</span>. Then, when our anonymous function is called two seconds later, <span class="SANS_TheSansMonoCd_W5Regular_11">Hi!</span> appears in the console. Using a function expression in this case is more concise, since we don’t have to separately define the delayed function before passing it to <span class="SANS_TheSansMonoCd_W5Regular_11">setTimeout</span>.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="H2" id="sec10"><span id="h2-42"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Arrow Functions</samp></h4>
<p class="TNI1">JavaScript has yet another syntax for defining functions, called <i>arrow function expressions</i>, or <i>arrow functions</i> for short. An arrow function is a more compact version of a function expression, and in most cases the choice between the two is purely stylistic. You can use an arrow function anywhere a normal function expression would work, and save yourself a bit of typing in the process. For example, here’s how to make a function that adds two numbers using arrow function syntax:</p>

<pre><code><b>let addArrow = (x, y) =&gt; {</b>
<b>  return x + y;</b>
<b>};</b>
</code></pre>
<p class="TX">An arrow function doesn’t use the <span class="SANS_TheSansMonoCd_W5Regular_11">function</span> keyword. Instead, it begins with the arguments list—in this case, <span class="SANS_TheSansMonoCd_W5Regular_11">(x, y)</span>—followed by an arrow (<span class="SANS_TheSansMonoCd_W5Regular_11">=&gt;</span>) and the function body. Here we’re assigning the arrow function to the <span class="SANS_TheSansMonoCd_W5Regular_11">addArrow</span> variable, which lets us call it just like other functions:</p>

<pre><code><b>addArrow(2, 2);</b>
4
</code></pre>
<p class="TX">We defined <span class="SANS_TheSansMonoCd_W5Regular_11">addArrow</span> using <i>block body</i> syntax, where the body is placed between braces and each statement within the body is written on its own indented line. If the body consists of just a single statement, however, there’s an even simpler syntax, called <i>concise body</i>:</p>

<pre><code><b>let addArrowConcise = (x, y) =&gt; x + y;</b></code></pre>
<p class="BodyContinued">Here the body is written on the same line as the rest of the statement, and it isn’t surrounded by braces. Also, the <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> keyword is implied, meaning the expression in the body (in this case, <span class="SANS_TheSansMonoCd_W5Regular_11">x + y</span>) is automatically understood to be the function’s return value. This concise body syntax is great for writing simple functions, but if your function body involves multiple statements, you’ll have to use the block body syntax (and include the <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> keyword if the function has an explicit return value).</p>
<p class="TX">If the arrow function has exactly one parameter, you can further simplify the syntax by omitting the parentheses around the parameter name:</p>

<pre><code><span aria-label=" Page 83. " epub:type="pagebreak" id="pg_83" role="doc-pagebreak"/><b>let squared = x =&gt; x * x;</b>
<b>squared(3);</b>
9
</code></pre>
<p class="BodyContinued">This arrow function takes in a number, <span class="SANS_TheSansMonoCd_W5Regular_11">x</span>, and returns its square (<span class="SANS_TheSansMonoCd_W5Regular_11">x * x</span>). Since <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> is the function’s only parameter, we don’t need to put it in parentheses. This works for both block body and concise body syntax.</p>
<p class="TX">Like function expressions, arrow functions provide an efficient way to define functions that are passed as arguments. To illustrate, we’ll consider JavaScript’s built-in <span class="SANS_TheSansMonoCd_W5Regular_11">setInterval</span> function. Like <span class="SANS_TheSansMonoCd_W5Regular_11">setTimeout</span>, it takes another function and a time in milliseconds as arguments, but unlike <span class="SANS_TheSansMonoCd_W5Regular_11">setTimeout</span>, it repeatedly calls the provided function, waiting the specified amount of time between each call. Here, for example, we pass <span class="SANS_TheSansMonoCd_W5Regular_11">setInterval</span> an arrow function that logs the string <span class="SANS_TheSansMonoCd_W5Regular_11">"Beep"</span> to the console:</p>

<pre><code><b>setInterval(() =&gt; {</b>
<b>  console.log("Beep");</b>
<b>}, 1000);</b>
3
Beep
</code></pre>
<p class="TX">Our arrow function takes no arguments, so it begins with an empty set of parentheses for the parameter list. The closing brace at the end of the body is followed by a comma to separate the arrow function from the next argument to <span class="SANS_TheSansMonoCd_W5Regular_11">setInterval</span>, which specifies a one-second pause (1,000 ms) between repetitions.</p>
<p class="TX">When we execute this code, it first returns an interval ID for canceling the repetition—in this case, <span class="SANS_TheSansMonoCd_W5Regular_11">3</span>. Then, after a one-second delay, the first <span class="SANS_TheSansMonoCd_W5Regular_11">"Beep"</span> is logged. After that, a number should appear on the left of the console output and increment every second to show how many times <span class="SANS_TheSansMonoCd_W5Regular_11">console.log("Beep")</span> has been called. Chrome uses this trick to keep the console from filling up with duplicate lines of output. When you’re ready for the code to stop <span class="SANS_TheSansMonoCd_W5Regular_11">Beep</span>-ing, refresh the browser page, or call the <span class="SANS_TheSansMonoCd_W5Regular_11">clearInterval</span> function, passing the interval ID. In our example, that would be <span class="SANS_TheSansMonoCd_W5Regular_11">clearInterval(3)</span>.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<aside aria-label="box-17" class="box" id="sec11">
<h4 class="BH" id="box-17"><samp class="SANS_Dogma_OT_Bold_B_11">TRY IT YOURSELF</samp></h4>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">  5-2.</samp><samp class="SANS_Futura_Std_Book_11">  You’ve now seen three different ways of creating functions: function declarations, function expressions, and arrow functions. Write each of the following in all three styles:</samp></p>
<ul class="ul">
<li class="BoxListBulletSub"><samp class="SANS_Futura_Std_Book_11">A function that takes a number from</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> <samp class="SANS_Futura_Std_Book_11">to</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">5</span> <samp class="SANS_Futura_Std_Book_11">and returns the English word for that number. For example,</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> <samp class="SANS_Futura_Std_Book_11">should return</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">"one"</span><samp class="SANS_Futura_Std_Book_11">. Hint: use an array to define the mapping from numbers to strings.</samp></li>
<li class="BoxListBulletSub"><span aria-label=" Page 84. " epub:type="pagebreak" id="pg_84" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Book_11">A function with no parameters that prints how many times it’s been called. Hint: define a variable outside of the function to keep track of the number of calls, like we did in the “Side Effects” section on page 77.</samp></li>
<li class="BoxListBulletSub"><samp class="SANS_Futura_Std_Book_11">A function that prints the current date and time. Hint: you can get the current date and time with</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">new Date()</span><samp class="SANS_Futura_Std_Book_11">.</samp></li>
</ul>
</aside>
</section>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h3 class="H1" id="sec12"><span id="h1-29"/><samp class="SANS_Futura_Std_Bold_B_11">Rest Parameters</samp></h3>
<p class="TNI1">Sometimes you want your function to accept a variable number of arguments. For example, say you want to make a function that takes someone’s name and their favorite colors, and prints them out in a sentence. You don’t know ahead of time how many favorite colors the user will enter, so you want to make your function flexible enough to handle however many colors are passed in. In JavaScript, you can do this with a <i>rest parameter</i>, a special type of parameter that collects a variable number of arguments into an array.</p>
<p class="TX">Rest parameters work with any style of function definition. Here we use one to create an arrow function that lists the user’s favorite colors:</p>

<pre><code><b>let myColors = (name, …favoriteColors) =&gt; {</b>
<b>  let colorString </b><b>= favoriteColors.join(", ");</b>
<b>  console.log(`My name is ${name} and my favorite colors are ${colorString}.`);</b>
<b>};</b>
<b>myColors("Nick", "blue", "green", "orange");</b>
My name is Nick and my favorite colors are blue, green, orange.
</code></pre>
<p class="TX">A rest parameter looks like an ordinary parameter preceded by three periods, and it always has to be the last parameter listed in the function definition. When the function is called, any regular parameters, listed first, are matched to the first provided arguments, in order. Then, the rest parameter bundles the remaining arguments into an array. In our example, <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> is a regular parameter, and <span class="SANS_TheSansMonoCd_W5Regular_11">favoriteColors</span> is the rest parameter. When we call the function, the argument <span class="SANS_TheSansMonoCd_W5Regular_11">"Nick"</span> is assigned to the <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> parameter. The remaining arguments, <span class="SANS_TheSansMonoCd_W5Regular_11">"blue"</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">"green"</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">"orange"</span>, are gathered into a single array and assigned to the <span class="SANS_TheSansMonoCd_W5Regular_11">favoriteColors</span> parameter. Because <span class="SANS_TheSansMonoCd_W5Regular_11">favoriteColors</span> is an array, we can use the <span class="SANS_TheSansMonoCd_W5Regular_11">join</span> method to convert it into a string, separating each color by a comma and a space. Then we incorporate the color string into a larger string using a template literal and use <span class="SANS_TheSansMonoCd_W5Regular_11">console .log</span> to print it.</p>
<p class="TX">Since <span class="SANS_TheSansMonoCd_W5Regular_11">favoriteColors</span> is a rest parameter, we can use the function with as few or as many colors as we want:</p>

<pre><code><b>myColors("Boring", "gray");</b>
My name is Boring and my favorite colors are gray.
<b>myColors("Indecisive", "red", "orange", "yellow", "green", "blue", "indigo", "violet");</b>
My name is Indecisive and my favorite colors are red, orange, yellow, green, blue, indigo, violet.
</code></pre>
<p class="BodyContinued"><span aria-label=" Page 85. " epub:type="pagebreak" id="pg_85" role="doc-pagebreak"/>No matter how many arguments we provide, the function still works.</p>
<p class="TX">Here’s another example of using a rest parameter, this time to sum all the numbers provided as arguments:</p>

<pre><code><b>function sum(…numbers) {</b>
<b>  let total = 0;</b>
<b>  for (let number of numbers) {</b>
<b>    total += number;</b>
<b>  }</b>
<b>  return total;</b>
<b>}</b>
<b>sum(1, 2, 3, 4, 5);</b>
15
<b>sum(6, 7, 8, 9, 10, 11, 12, 13);</b>
76
</code></pre>
<p class="BodyContinued">This time we’ve used a function declaration instead of an arrow function, and the function’s only parameter is the rest parameter. Because there are no other parameters, all the arguments are collected into an array and assigned to the <span class="SANS_TheSansMonoCd_W5Regular_11">numbers</span> rest parameter. Then we use a <span class="SANS_TheSansMonoCd_W5Regular_11">for…of</span> loop to add the numbers together.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h3 class="H1" id="sec13"><span id="h1-30"/><samp class="SANS_Futura_Std_Bold_B_11">Higher-Order Functions</samp></h3>
<p class="TNI1">A <i>higher-order function</i> is a function that takes another function as an argument, or that outputs another function as its return value. You’ve already seen two higher-order functions in this chapter: <span class="SANS_TheSansMonoCd_W5Regular_11">setTimeout</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">setInterval</span>, which both take a callback function to execute later as an argument. JavaScript has many other built-in higher-order functions as well. We’ll consider some here, and discuss how to write your own higher-order functions.</p>
<section aria-labelledby="sec14" epub:type="division">
<h4 class="H2" id="sec14"><span id="h2-43"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Array Methods That Take Callbacks</samp></h4>
<p class="TNI1">There are a number of built-in methods for working with arrays that take a callback function. Remember, a method is a type of function that operates on an object, such as an array. In most cases, the callback passed to these higher-order array methods is called once for each item in the array. Let’s take a look at a few examples.</p>
<p class="HeadC"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Finding an Array Element</samp></p>
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">find</span> array method finds the first element in an array that matches some criterion. You specify the criterion with a callback function that returns a Boolean <span class="SANS_TheSansMonoCd_W5Regular_11">true</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">false</span> value. For example, if we wanted to find the first item in our shopping list with more than six characters, we could do the following:</p>

<pre><code><b>let shoppingList </b><b>= ["Milk", "Sugar", "Bananas", "Ice Cream"];</b>
<b>shoppingList.find(item =&gt; item.length &gt; 6);</b>
'Bananas'
</code></pre>
<p class="TX"><span aria-label=" Page 86. " epub:type="pagebreak" id="pg_86" role="doc-pagebreak"/>The callback function we pass to <span class="SANS_TheSansMonoCd_W5Regular_11">find</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">item =&gt; item.length &gt; 6</span>. This callback takes advantage of two useful syntactic features of arrow functions. First, because our function has only one parameter, <span class="SANS_TheSansMonoCd_W5Regular_11">item</span>, we can leave off the parentheses around the parameter list. Second, because the function body involves only one statement, <span class="SANS_TheSansMonoCd_W5Regular_11">item.length &gt; 6</span>, we can use concise body syntax, leaving off the <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> keyword and the braces around the body. These features let us define the logic for finding the element as compactly as possible, making arrow functions ideal for writing simple callbacks.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">find</span> method runs the callback for each element in the array in turn. The callback takes in the element and returns <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">false</span> based on whether the element has more than six characters. If the callback returns <span class="SANS_TheSansMonoCd_W5Regular_11">true</span> for a given element, the <span class="SANS_TheSansMonoCd_W5Regular_11">find</span> method returns that element and halts the search. In this case, the method returns <span class="SANS_TheSansMonoCd_W5Regular_11">"Bananas"</span> rather than <span class="SANS_TheSansMonoCd_W5Regular_11">"Ice Cream"</span> since <span class="SANS_TheSansMonoCd_W5Regular_11">"Bananas"</span> comes earlier in the array.</p>
<p class="TX">If no item is found that meets the criterion, the <span class="SANS_TheSansMonoCd_W5Regular_11">find</span> method returns <span class="SANS_TheSansMonoCd_W5Regular_11">undefined</span>:</p>

<pre><code><b>shoppingList.find(item =&gt; item[0] === </b><b>"</b><b>A</b><b>"</b><b>);</b>
undefined
</code></pre>
<p class="BodyContinued">This time we pass <span class="SANS_TheSansMonoCd_W5Regular_11">find</span> a callback that checks if an element starts with the letter <i>A</i>. None of the shopping list items do, so the method returns <span class="SANS_TheSansMonoCd_W5Regular_11">undefined</span>.</p>
<p class="HeadC"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Filtering the Elements of an Array</samp></p>
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">filter</span> method returns a new array containing all the elements from the original array that satisfy some criterion. As with the <span class="SANS_TheSansMonoCd_W5Regular_11">find</span> method, the criterion is specified using a callback. To illustrate, we’ll update our original <span class="SANS_TheSansMonoCd_W5Regular_11">find</span> example by changing the method name to <span class="SANS_TheSansMonoCd_W5Regular_11">filter</span>. This will give us a list of <i>all</i> items with more than six characters, rather than just the first item that passes this test:</p>

<pre><code><b>let shoppingList </b><b>= ["Milk", "Sugar", "Bananas", "Ice Cream"];</b>
<b>shoppingList.filter(item =&gt; item.length &gt; 6);</b>
<span class="code_MenuArrow"></span><var>(2) ['Bananas', 'Ice Cream']</var>
</code></pre>
<p class="BodyContinued">This filters out the array elements whose character lengths are too short, while leaving both <span class="SANS_TheSansMonoCd_W5Regular_11">"Bananas"</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">"Ice Cream"</span> in the resulting array.</p>
<p class="HeadC"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Transforming Each Element of an Array</samp></p>
<p class="TNI1">Sometimes you’ll want to transform each element in an array and store the results in a new array. For instance, you might have an array of numbers that all need to be operated on in the same way. You could do this using a <span class="SANS_TheSansMonoCd_W5Regular_11">for…of</span> loop, as we discussed in <a href="chapter4.xhtml">Chapter 4</a>, but a more concise technique is to use the <span class="SANS_TheSansMonoCd_W5Regular_11">map</span> array method. It applies the same callback to each element of an array and returns a new array containing the results. Here, for example, we use <span class="SANS_TheSansMonoCd_W5Regular_11">map</span> to take in an array of numbers and produce an array of those numbers’ cubes:</p>

<pre><code><span aria-label=" Page 87. " epub:type="pagebreak" id="pg_87" role="doc-pagebreak"/><b>let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];</b>
<b>let cubes = numbers.map(x =&gt; x * x * x);</b>
<b>cubes;</b>
<span class="code_MenuArrow"></span><var>(10) [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]</var>
</code></pre>
<p class="TX">Our callback function, <span class="SANS_TheSansMonoCd_W5Regular_11">x =&gt; x * x * x</span>, takes an array element and cubes it. The <span class="SANS_TheSansMonoCd_W5Regular_11">map</span> method applies this callback to each element in the <span class="SANS_TheSansMonoCd_W5Regular_11">numbers</span> array, returning a new array of the first 10 perfect cubes while leaving the original array unchanged. Compare the concise syntax of passing <span class="SANS_TheSansMonoCd_W5Regular_11">map</span> an arrow function with the equivalent code using a <span class="SANS_TheSansMonoCd_W5Regular_11">for…of</span> loop:</p>

<pre><code><b>let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];</b>
<b>let cubes = [];</b>
<b>for (let x of numbers) {</b>
<b>  cubes.push(x * x * x);</b>
<b>}</b>
<b>cubes;</b>
<span class="code_MenuArrow"></span><var>(10) [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]</var>
</code></pre>
<p class="TX">The result is the same, but with <span class="SANS_TheSansMonoCd_W5Regular_11">map</span> we’re able to declare and populate the <span class="SANS_TheSansMonoCd_W5Regular_11">cubes</span> array in a single line of code, instead of first declaring <span class="SANS_TheSansMonoCd_W5Regular_11">cubes</span> as an empty array and then filling it up within the body of the <span class="SANS_TheSansMonoCd_W5Regular_11">for…of</span> loop.</p>
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">map</span> method is also useful if you have an array of similar objects and you want to extract the same piece of information from each one. For example, say you have an array of objects that represent items in a store, each with a <span class="SANS_TheSansMonoCd_W5Regular_11">name</span> and a <span class="SANS_TheSansMonoCd_W5Regular_11">price</span> property, and you want to get an array of just the prices. You can pass <span class="SANS_TheSansMonoCd_W5Regular_11">map</span> a callback function accessing each object’s <span class="SANS_TheSansMonoCd_W5Regular_11">price</span> property, like so:</p>

<pre><code><b>let stockList = [</b>
<b>  {name: "Cheese", price: 3},</b>
<b>  {name: "Bread", price: 1},</b>
<b>  {name: "Butter", price: 2}</b>
<b>];</b>
<b>let prices = stockList.map(item =&gt; item.price);</b>
<b>prices;</b>
<span class="code_MenuArrow"></span><var>(3) [3, 1, 2]</var>
</code></pre>
<p class="BodyContinued">Here, the callback function is <span class="SANS_TheSansMonoCd_W5Regular_11">item =&gt; item.price</span>, which takes an <span class="SANS_TheSansMonoCd_W5Regular_11">item</span> and returns the value of that item’s <span class="SANS_TheSansMonoCd_W5Regular_11">price</span> property. The <span class="SANS_TheSansMonoCd_W5Regular_11">map</span> function applies the callback to each object in the original array in turn, and creates a new array with all the prices.</p>
<p class="TX">In general, it’s preferable to use <span class="SANS_TheSansMonoCd_W5Regular_11">map</span> rather than the equivalent loop whenever possible, both for the <span class="SANS_TheSansMonoCd_W5Regular_11">map</span> method’s conciseness and for the code’s <i>self-documenting</i> nature (the method name <span class="SANS_TheSansMonoCd_W5Regular_11">map</span> implies that you’re making a new array that copies and modifies elements from another array, without the need for further comment). A loop would be more appropriate when your needs are more custom, for example, if the number of elements in the output array doesn’t match the number in the original array.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h4 class="H2" id="sec15"><span id="h2-44"/><span aria-label=" Page 88. " epub:type="pagebreak" id="pg_88" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Custom Functions That Take Callbacks</samp></h4>
<p class="TNI1">To create your own higher-order function that takes a callback as an argument, simply include a name for the callback in the function’s list of parameters, just as you’d name any other parameter. Then, when you want to call the callback within the function body, add parentheses after the parameter name, just like calling any other function. Let’s illustrate this by declaring a <span class="SANS_TheSansMonoCd_W5Regular_11">doubler</span> function that takes in a callback and calls it twice:</p>

<pre><code><b>function doubler(callback) {</b>
<b>  callback();</b>
<b>  callback();</b>
<b>} </b>
<b>doubler(() =&gt; console.log("Hi there!"));</b>
Hi there!
Hi there!
</code></pre>
<p class="TX">When we define the <span class="SANS_TheSansMonoCd_W5Regular_11">doubler</span> function, we give it a <span class="SANS_TheSansMonoCd_W5Regular_11">callback</span> parameter. Then, in the function body, we write <span class="SANS_TheSansMonoCd_W5Regular_11">callback()</span> twice to make two calls to the function passed to this parameter. When we call <span class="SANS_TheSansMonoCd_W5Regular_11">doubler</span>, we pass it a function that logs <span class="SANS_TheSansMonoCd_W5Regular_11">"Hi there!"</span> to the console, so this message gets logged twice. Notice that this callback function doesn’t require any arguments, so we’ve written an empty set of parentheses before the arrow symbol.</p>
<p class="TX">As we’ve discussed, JavaScript has no conception of set data types for function parameters, so there’s nothing stopping us from trying to pass a value that isn’t a function as an argument to <span class="SANS_TheSansMonoCd_W5Regular_11">doubler</span>. If we do, though, we’ll get an error when JavaScript tries to call the non-function:</p>

<pre><code><b>doubler("hello");</b>
<span class="code_MenuArrow"></span>Uncaught TypeError: callback is not a function
<b>    </b>at doubler (&lt;anonymous&gt;:2:5)
<b>    </b>at &lt;anonymous&gt;:1:1
</code></pre>
<p class="BodyContinued">Here we pass <span class="SANS_TheSansMonoCd_W5Regular_11">doubler</span> a string instead of a function, so we get a <span class="SANS_TheSansMonoCd_W5Regular_11">TypeError</span>.</p>
<p class="TX">The callback we passed to <span class="SANS_TheSansMonoCd_W5Regular_11">doubler</span> didn’t require any arguments, but you can also set up a higher-order function so its callback takes arguments. Here, for example, we create a function that calls another function some number of times, passing the current number of times into the callback:</p>

<pre><code><b>function callMultipleTimes(times, callback) {</b>
<b>  for (let i </b><b>= 0; i &lt; times; i++) {</b>
<b>    callback(i);</b>
<b>  }</b>
<b>}</b>
</code></pre>
<p class="TX">We declare the <span class="SANS_TheSansMonoCd_W5Regular_11">callMultipleTimes</span> function to have two parameters: a function to call (<span class="SANS_TheSansMonoCd_W5Regular_11">callback</span>) and a number of times to call it (<span class="SANS_TheSansMonoCd_W5Regular_11">times</span>). (Note that unlike <span class="SANS_TheSansMonoCd_W5Regular_11">setTimeout</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">setInterval</span>, where the callback is the first parameter, our function here follows the more common JavaScript convention of having the callback be the last parameter.) The function body consists of <span aria-label=" Page 89. " epub:type="pagebreak" id="pg_89" role="doc-pagebreak"/>a <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop in which we call <span class="SANS_TheSansMonoCd_W5Regular_11">callback(i)</span>, passing the looping variable <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> as an argument to the callback.</p>
<p class="TX">Because the callback function is passed a single argument, we know that the callback function we pass to <span class="SANS_TheSansMonoCd_W5Regular_11">callMultipleTimes</span> should have a single parameter. For example:</p>

<pre><code><b>callMultipleTimes(3, time =&gt; console.log(`This was time: ${time}`));</b>
This was time: 0
This was time: 1
This was time: 2
</code></pre>
<p class="BodyContinued">Here we pass an arrow function as a callback. It has a single <span class="SANS_TheSansMonoCd_W5Regular_11">time</span> parameter. The function incorporates <span class="SANS_TheSansMonoCd_W5Regular_11">time</span> into a message that gets logged to the console. Each time this callback is executed, <span class="SANS_TheSansMonoCd_W5Regular_11">time</span> takes on the current value of looping variable <span class="SANS_TheSansMonoCd_W5Regular_11">i</span>, inserting the numbers <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">2</span> into the logged message, respectively.</p>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h4 class="H2" id="sec16"><span id="h2-45"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Functions That Return Functions</samp></h4>
<p class="TNI1">So far we’ve focused on higher-order functions that take in functions as arguments, but a higher-order function can also output a function as its return value. For example, say you want to create various functions that add a suffix to the end of a string, such as adding <span class="SANS_TheSansMonoCd_W5Regular_11">"!!!"</span> at the end to make the string seem more exciting, or <span class="SANS_TheSansMonoCd_W5Regular_11">"???"</span> to make it seem more puzzling. Rather than manually defining a separate function for adding each possible suffix, or making a function with <span class="SANS_TheSansMonoCd_W5Regular_11">text</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">suffix</span> parameters and having to supply the suffix every time you call it, you can define a higher-order function that takes in a suffix and returns a function that will append that suffix to a string:</p>

<pre><code><b>function makeAppender(suffix) {</b>
<span aria-label="annotation1" class="CodeAnnotationCode">❶</span><b> return function (text) {</b>
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span><b> return text + suffix;</b>
<b>  };</b>
<b>}</b>
</code></pre>
<p class="TX">There are two <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> keywords here. The first <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> is used by the higher-order <span class="SANS_TheSansMonoCd_W5Regular_11">makeAppender</span> function to return an anonymous function. It’s followed by the <span class="SANS_TheSansMonoCd_W5Regular_11">function</span> keyword, indicating that we’re defining a function to be returned. The second <span class="SANS_TheSansMonoCd_W5Regular_11">return</span> keyword <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> is inside the anonymous function itself. When <i>that</i> function is called, it returns the value of the anonymous function’s <span class="SANS_TheSansMonoCd_W5Regular_11">text</span> parameter concatenated with the <span class="SANS_TheSansMonoCd_W5Regular_11">makeAppender</span> function’s <span class="SANS_TheSansMonoCd_W5Regular_11">suffix</span> parameter.</p>
<p class="TX">To be able to call the inner function, we first have to get access to it by calling the outer function:</p>

<pre><code><b>let exciting = makeAppender("!!!");</b>
<b>exciting("Hello");</b>
'Hello!!!'
</code></pre>
<p class="BodyContinued"><span aria-label=" Page 90. " epub:type="pagebreak" id="pg_90" role="doc-pagebreak"/>Calling <span class="SANS_TheSansMonoCd_W5Regular_11">makeAppender("!!!")</span> returns a new function, which we assign to the <span class="SANS_TheSansMonoCd_W5Regular_11">exciting</span> variable. This variable now contains the function expression that was returned from <span class="SANS_TheSansMonoCd_W5Regular_11">makeAppender</span>, which takes a string as an argument. When we call <span class="SANS_TheSansMonoCd_W5Regular_11">exciting("Hello")</span>, we get the string <span class="SANS_TheSansMonoCd_W5Regular_11">"Hello!!!"</span>, the result of concatenating the <span class="SANS_TheSansMonoCd_W5Regular_11">"Hello"</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">"!!!"</span> strings together.</p>
<p class="TX">The benefit of our higher-order <span class="SANS_TheSansMonoCd_W5Regular_11">makeAppender</span> function is that we can use it to generate additional functions for appending other suffixes besides <span class="SANS_TheSansMonoCd_W5Regular_11">"!!!"</span>. For example:</p>

<pre><code><b>let puzzling =</b><b> makeAppender("???");</b>
<b>puzzling("Hello");</b>
'Hello???'
<b>let winking = makeAppender(" ;-)");</b>
<b>winking("Hello");</b>
'Hello ;-)'
</code></pre>
<p class="BodyContinued">Here <span class="SANS_TheSansMonoCd_W5Regular_11">makeAppender</span> returns two more functions, which we assign as values to the <span class="SANS_TheSansMonoCd_W5Regular_11">puzzling</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">winking</span> variables. We had to define only a single higher-order function, but we now have three different suffix-appending functions to choose from, and we can reuse them as much as we like:</p>

<pre><code><b>winking("Goodbye");</b>
'Goodbye ;-)'
<b>puzzling("Goodbye");</b>
'Goodbye???'
<b>exciting("Goodbye");</b>
'Goodbye!!!'
</code></pre>
<p class="TX">Notice that each function we returned from <span class="SANS_TheSansMonoCd_W5Regular_11">makeAppender</span> remembers the value of <span class="SANS_TheSansMonoCd_W5Regular_11">suffix</span> that we passed in, which is how it can keep appending the same suffix. Each of these functions was defined within the scope of <span class="SANS_TheSansMonoCd_W5Regular_11">makeAppender</span>, so even though the call to <span class="SANS_TheSansMonoCd_W5Regular_11">makeAppender</span> has completed, the inner function it returned is able to hold onto other values from that same scope, including <span class="SANS_TheSansMonoCd_W5Regular_11">suffix</span>.</p>
<p class="TX">We discussed scope in <a href="chapter4.xhtml">Chapter 4</a>, noting, for example, how variables defined within a <span class="SANS_TheSansMonoCd_W5Regular_11">while</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop can’t be accessed outside of the loop. Similarly, variables defined inside a function have scope only within that function, so they typically disappear once the function call ends. Scope gets more interesting with nested functions, however, as in the example at hand. You might expect the scope of the outer <span class="SANS_TheSansMonoCd_W5Regular_11">makeAppender</span> function to “disappear” after we call it, but the inner function retains access to the variables and arguments from that scope, as long as we keep a reference to the inner function (which we do through the variables <span class="SANS_TheSansMonoCd_W5Regular_11">exciting</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">puzzling</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">winking</span>). Functions that hold onto variables and parameters from their enclosing scopes are known as <i>closures</i> because they “close over” their environments. (Imagine that the inner function has a dome over it that preserves all the variables in its scope.)</p>
</section>
<section aria-labelledby="sec17" epub:type="division">
<aside aria-label="box-18" class="box" id="sec17">
<h4 class="BH" id="box-18"><span aria-label=" Page 91. " epub:type="pagebreak" id="pg_91" role="doc-pagebreak"/><samp class="SANS_Dogma_OT_Bold_B_11">TRY IT YOURSELF</samp></h4>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Bold_B_11">  5-3.</samp><samp class="SANS_Futura_Std_Book_11">  Write a function called</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">makeWrapper</span> <samp class="SANS_Futura_Std_Book_11">that takes a prefix and a suffix, and returns a new function that adds the prefix and suffix to a provided string. For example, you could enter</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">let bracketWrapper = makeWrapper("[", "]");</span> <samp class="SANS_Futura_Std_Book_11">and then call</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">bracketWrapper("Bracket me!");</span> <samp class="SANS_Futura_Std_Book_11">to get the string</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">"[Bracket me!]"</span><samp class="SANS_Futura_Std_Book_11">. Likewise, you could enter</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">let bracesWrapper = makeWrapper("{", "}");</span> <samp class="SANS_Futura_Std_Book_11">and then call</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">bracesWrapper("Brace Me!");</span> <samp class="SANS_Futura_Std_Book_11">to get the string</samp> <span class="SANS_TheSansMonoCd_W5Regular_11">"{Brace me!}"</span><samp class="SANS_Futura_Std_Book_11">.</samp></p>
</aside>
</section>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h3 class="H1" id="sec18"><span id="h1-31"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>
<p class="TNI1">In this chapter, you learned how to make your code more readable and concise by creating and working with your own custom functions. You saw the three main styles of defining functions—function declarations, function expressions, and arrow functions—and experimented with block body and concise body syntax. You learned how to provide input to a function by passing values to its parameters as arguments, and you learned how to take advantage of a function’s work, either through its return value, its side effects, or both. You also saw how functions can be assigned as values to variables, and how they can be passed to or returned from higher-order functions.</p>
</section>
</section>
</body>
</html>