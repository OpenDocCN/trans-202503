<html><head></head><body>
		<section>&#13;
			<header>&#13;
				<h1 class="chapter"><span class="ChapterNumber"><span epub:type="pagebreak" id="Page_241" title="241"/>14</span><br/><span class="ChapterTitle">Motors and Movement</span></h1>&#13;
			</header>&#13;
			<p class="ChapterIntro">In this chapter you will</p>&#13;
			<ul>&#13;
				<li>Use a servo to create an analog thermometer</li>&#13;
				<li>Learn how to control the speed and direction of DC electric motors</li>&#13;
				<li>Learn how to control small stepper motors</li>&#13;
				<li>Use an Arduino motor shield</li>&#13;
				<li>Begin work on a motorized robot vehicle</li>&#13;
				<li>Use simple microswitches for collision avoidance</li>&#13;
				<li>Use infrared and ultrasonic distance sensors for collision avoidance</li>&#13;
			</ul>&#13;
			<h2 id="h1-500587c14-0001">Making Small Motions with Servos</h2>&#13;
			<p class="BodyFirst">A <em>servo</em> (short for <em>servomechanism</em>) is an electric motor with a built-in sensor. It can be commanded to rotate to a specific angular position. By attaching the shaft of the servo to other machines, like wheels, gears, and levers, you can precisely control items in the external world. For example, you might use a servo to control the steering of a remote control car by connecting the servo to a <em>horn</em>, a small arm or bar that the servo rotates. An example of a horn is one of the hands on an analog clock. <a href="#figure14-1" id="figureanchor14-1">Figure 14-1</a> shows a servo and three types of horns.</p>&#13;
			<span epub:type="pagebreak" id="Page_242" title="242"/>&#13;
			<figure>&#13;
				<img alt="f14001" src="image_fi/500587c14/f14001.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-1">Figure 14-1</a>: A servo and various horns</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h3 id="h2-500587c14-0001">Selecting a Servo</h3>&#13;
			<p class="BodyFirst">When you’re selecting a servo, consider several parameters:</p>&#13;
			<ol class="none">&#13;
				<li><span class="RunInHead">Speed</span>  The time it takes for the servo to rotate, usually measured in seconds per angular degree, revolutions per minute (RPM), or seconds per 60 degrees.</li>&#13;
				<li><span class="RunInHead">Rotational range</span>  The angular range through which the servo can rotate—for example, 180 degrees (half of a full rotation) or 360 degrees (one complete rotation).</li>&#13;
				<li><span class="RunInHead">Current</span>  How much current the servo draws. When using a servo with an Arduino, you may need to use an external power supply for the servo.</li>&#13;
				<li><span class="RunInHead">Torque</span>  The amount of force the servo can exert when rotating. The greater the torque, the heavier the item the servo can control. The torque produced is generally proportional to the amount of current used.</li>&#13;
			</ol>&#13;
			<p>&#13;
				The servo shown in <a href="#figure14-1">Figure 14-1</a> is a generic SG90-type servo. It is inexpensive and can rotate up to 180 degrees, as shown in <a href="#figure14-2" id="figureanchor14-2">Figure 14-2</a>.</p>&#13;
				<span epub:type="pagebreak" id="Page_243" title="243"/>&#13;
				<figure>&#13;
				<img alt="f14002" src="image_fi/500587c14/f14002.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-2">Figure 14-2</a>: Example servo rotation range</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h3 id="h2-500587c14-0002">Connecting a Servo</h3>&#13;
			<p class="BodyFirst">It’s easy to connect a servo to an Arduino because it needs only three wires. If you’re using the SG90, the darkest wire connects to GND, the center wire connects to 5 V, and the lightest wire (the <em>pulse</em> or<em> data </em>wire) connects to a digital pin. If you’re using a different servo, check its data sheet for the correct wiring.</p>&#13;
			<h3 id="h2-500587c14-0003">Putting a Servo to Work</h3>&#13;
			<p class="BodyFirst">Now let’s put our servo to work. In this sketch, the servo will turn through its rotational range. Connect the servo to your Arduino as described, with the pulse wire connected to digital pin 4, and then enter and upload the sketch in <a href="#listing14-1" id="listinganchor14-1">Listing 14-1</a>.</p>&#13;
			<pre><code>// Listing 14-1&#13;
#include &lt;Servo.h&gt;&#13;
Servo myservo; &#13;
void setup()&#13;
{ myservo.attach(4); &#13;
}&#13;
void loop()&#13;
{ myservo.write(180); delay(1000); myservo.write(90); delay(1000); myservo.write(0); delay(1000);&#13;
}</code></pre>&#13;
			<p class="CodeListingCaption"><a id="listing14-1">Listing 14-1</a>: Servo demonstration sketch</p>&#13;
			<p><span epub:type="pagebreak" id="Page_244" title="244"/>In this sketch, we use the Servo library, which needs to be installed. Follow the instructions outlined in Chapter 7. In the Library Manager, find and then install the “Servo by Michael Margolis, Arduino” library. Create an instance of the servo with the following:</p>&#13;
			<pre><code>#include &lt;Servo.h&gt;&#13;
Servo myservo;</code></pre>&#13;
			<p>&#13;
				Then, in <code>void setup()</code>, we tell the Arduino which digital pin the servo control is using:</p>&#13;
			<pre><code>myservo.attach(4); // control pin on digital 4</code></pre>&#13;
			<p>Now we simply move the servo with the following:</p>&#13;
			<pre><code>myservo.write(<em>x</em>);</code></pre>&#13;
			<p>&#13;
				Here, <var>x</var> is an integer between 0 and 180 representing the angular position to which the servo will be moved. When running the sketch in <a href="#listing14-1">Listing 14-1</a>, the servo will rotate across its maximum range, stopping at the extremes (0 degrees and 180 degrees) and at the midpoint (90 degrees). When looking at your servo, note that the 180-degree position is on the left and 0 degrees is on the right.</p>&#13;
			<p>In addition to pushing or pulling objects, servos can be used to communicate data in a similar way as an analog gauge. For example, you could use a servo as an analog thermometer, as you’ll see in Project 37.</p>&#13;
			<h2 class="HeadProject" id="h1-500587c14-0002"><span>Project #37: Building an Analog Thermometer</span></h2>&#13;
			<p class="BodyFirst">Using our servo and the TMP36 temperature sensor from earlier chapters, we’ll build an analog thermometer. We’ll measure the temperature and then convert this measurement to an angle between 0 and 180 degrees to indicate a temperature between 0 and 30 degrees Celsius. The servo will rotate to the angle that matches the current temperature.</p>&#13;
			<h3 id="h2-500587c14-0004">The Hardware</h3>&#13;
			<p class="BodyFirst">The required hardware is minimal:</p>&#13;
			<ul>&#13;
				<li>One TMP36 temperature sensor</li>&#13;
				<li>One breadboard</li>&#13;
				<li>One small servo</li>&#13;
				<li>Various connecting wires</li>&#13;
				<li>Arduino and USB cable</li>&#13;
			</ul>&#13;
			<h3 id="h2-500587c14-0005"><span epub:type="pagebreak" id="Page_245" title="245"/>The Schematic</h3>&#13;
			<p class="BodyFirst">The circuit is also very simple, as shown in <a href="#figure14-3" id="figureanchor14-3">Figure 14-3</a>.</p>&#13;
			<figure>&#13;
				<img alt="f14003" src="image_fi/500587c14/f14003.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-3">Figure 14-3</a>: Schematic for Project 37</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h3 id="h2-500587c14-0006">The Sketch</h3>&#13;
			<p class="BodyFirst">The sketch will determine the temperature using the same method used in Project 8 in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>. Then it will convert the temperature into an angular rotation value for the servo.</p>&#13;
			<p>Enter and upload the following sketch:</p>&#13;
			<pre><code>// Project 37 - Building an Analog Thermometer&#13;
float voltage = 0;&#13;
float sensor = 0;&#13;
float currentC = 0;&#13;
int      angle = 0;&#13;
#include &lt;Servo.h&gt; &#13;
Servo myservo;&#13;
void setup() &#13;
{<span epub:type="pagebreak" id="Page_246" title="246"/>  myservo.attach(4);&#13;
}<span aria-label="annotation1" class="CodeAnnotationHang">1</span> int calculateservo(float temperature) &#13;
{ float resulta; int resultb; resulta = -6 * temperature; resulta = resulta + 180; resultb = int(resulta);                return resultb;&#13;
}&#13;
void loop() &#13;
{ // read current temperature sensor = analogRead(0);        voltage = (sensor*5000)/1024;  voltage = voltage-500;         currentC = voltage/10;         // display current temperature on servo <span aria-label="annotation1" class="CodeAnnotationHang">1</span>  angle = calculateservo(currentC);  // convert temperature to a servo position if (angle&gt;=0 &amp;&amp; angle &lt;=30) { myservo.write(angle); // set servo to temperature delay(1000);  }&#13;
}</code></pre>&#13;
			<p>&#13;
				Most of this sketch should be clear to you at this point, but the function <code>calculateservo()</code> at <span aria-label="annotation1" class="CodeAnnotation">1</span> is new. This function converts the temperature into the matching angle for the servo to use according to the following formula:</p>&#13;
			<p class="equation">angle = (–6 × temperature) + 180</p>&#13;
			<p>&#13;
				You might find it useful to make a <em>backing sheet</em> to show the range of temperatures that the servo will display, with a small arrow to create a realistic effect. An example is shown in <a href="#figure14-4" id="figureanchor14-4">Figure 14-4</a>. You can download a printable version of the backing sheet from the book’s website: <a class="LinkURL" href="https://nostarch.com/arduino-workshop-2nd-edition/">https://nostarch.com/arduino-workshop-2nd-edition/</a>.</p>&#13;
			<figure>&#13;
				<img alt="f14004" src="image_fi/500587c14/f14004.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-4">Figure 14-4</a>: A backing sheet indicates the temperature on our thermometer.</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h2 id="h1-500587c14-0003"><span epub:type="pagebreak" id="Page_247" title="247"/>Using Electric Motors</h2>&#13;
			<p class="BodyFirst">The next step in our motor-controlling journey is to work with small electric motors. Small motors are used for many applications, from small fans to toy cars to model railroads.</p>&#13;
			<h3 id="h2-500587c14-0007">Selecting a Motor</h3>&#13;
			<p class="BodyFirst">As with servos, you need to consider several parameters when you’re choosing an electric motor:</p>&#13;
			<ol class="none">&#13;
				<li><span class="RunInHead">The operating voltage</span>  The voltage at which the motor is designed to operate. This can vary, from 3 V to more than 12 V.</li>&#13;
				<li><span class="RunInHead">The current without a load</span>  The amount of current the motor uses at its operating voltage while spinning freely, without anything connected to the motor’s shaft.</li>&#13;
				<li><span class="RunInHead">The stall current</span>  The amount of current used by the motor when it is trying to turn but cannot because of the load on the motor.</li>&#13;
				<li><span class="RunInHead">The speed at the operating voltage</span>  The motor’s speed in RPM.</li>&#13;
			</ol>&#13;
			<p>&#13;
				Our example will use a small, inexpensive electric motor with a speed of 8,540 RPM when running on 3 V, similar to the one shown in <a href="#figure14-5" id="figureanchor14-5">Figure 14-5</a>.</p>&#13;
			<figure>&#13;
				<img alt="f14005" src="image_fi/500587c14/f14005.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-5">Figure 14-5</a>: Our small electric motor</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>&#13;
				To control our motor we’ll use a transistor, introduced in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>. Because our motor uses up to 0.7 A of current (more than can be passed by the BC548 transistor), we’ll use a transistor called a Darlington for this project.</p>&#13;
			<h3 id="h2-500587c14-0008">The TIP120 Darlington Transistor</h3>&#13;
			<p class="BodyFirst">A <em>Darlington transistor</em> is nothing more than two transistors connected together. It can handle high currents and voltages. The TIP120 Darlington can pass up to 5 A of current at 60 V, which is more than enough to control our small motor. The TIP120 uses a similar schematic symbol as the BC548, as shown in <a href="#figure14-6" id="figureanchor14-6">Figure 14-6</a>, but the TIP120 transistor is physically larger than the BC548.</p>&#13;
			<figure>&#13;
				<img alt="f14006" src="image_fi/500587c14/f14006.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-6">Figure 14-6</a>: TIP120 schematic symbol</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p><span epub:type="pagebreak" id="Page_248" title="248"/>The TIP120 uses the TO-220 housing style, as shown in <a href="#figure14-7" id="figureanchor14-7">Figure 14-7</a>.</p>&#13;
			<figure>&#13;
				<img alt="f14007" src="image_fi/500587c14/f14007.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-7">Figure 14-7</a>: The TIP120</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>When you’re looking at the TIP120 from the labeled side, the pins from left to right are base (B), collector (C), and emitter (E). The metal heat sink tab is also connected to the collector.</p>&#13;
			<h2 class="HeadProject" id="h1-500587c14-0004"><span>Project #38: Controlling the Motor</span></h2>&#13;
			<p class="BodyFirst">In this project, we’ll control the motor by adjusting the speed.</p>&#13;
			<h3 id="h2-500587c14-0009">The Hardware</h3>&#13;
			<p class="BodyFirst">The following hardware is required:</p>&#13;
			<ul>&#13;
				<li>One small 3 V electric motor</li>&#13;
				<li>One 1 kΩ resistor (R1)</li>&#13;
				<li>One breadboard</li>&#13;
				<li>One 1N4004 diode</li>&#13;
				<li>One TIP120 Darlington transistor</li>&#13;
				<li>A separate 3 V power source</li>&#13;
				<li>Various connecting wires</li>&#13;
				<li>Arduino and USB cable</li>&#13;
			</ul>&#13;
			<p>&#13;
				You must use a separate power source for motors, because the Arduino cannot supply enough current for the motor in all possible situations. If the motor becomes stuck, then it will draw up to its <em>stall current</em>, which could be more than 1 A. That’s more than the Arduino can supply, and if it attempts to supply that much current the Arduino could be permanently damaged.</p>&#13;
			<p>&#13;
				A separate battery holder is a simple solution. For a 3 V supply, a two-cell AA battery holder with flying leads will suffice, such as the one shown in <a href="#figure14-8" id="figureanchor14-8">Figure 14-8</a>.</p>&#13;
				<span epub:type="pagebreak" id="Page_249" title="249"/>&#13;
				<figure>&#13;
				<img alt="f14008" src="image_fi/500587c14/f14008.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-8">Figure 14-8</a>: A two-cell AA battery holder</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h3 id="h2-500587c14-0010">The Schematic</h3>&#13;
			<p class="BodyFirst">Assemble the circuit as shown in the schematic in <a href="#figure14-9" id="figureanchor14-9">Figure 14-9</a>.</p>&#13;
			<figure>&#13;
				<img alt="f14009" src="image_fi/500587c14/f14009.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-9">Figure 14-9</a>: Schematic for Project 38</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h3 id="h2-500587c14-0011"><span epub:type="pagebreak" id="Page_250" title="250"/>The Sketch</h3>&#13;
			<p class="BodyFirst">In this project, we’ll adjust the speed of the motor from stopped (zero) to the maximum and then reduce it back to zero. Enter and upload the following sketch:</p>&#13;
			<pre><code>// Project 38 - Controlling the Motor&#13;
void setup() &#13;
{ pinMode(5, OUTPUT);&#13;
}&#13;
void loop() &#13;
{<span aria-label="annotation1" class="CodeAnnotationHang">1</span>   for (int a=0; a&lt;256; a++)  { analogWrite(5, a);<span aria-label="annotation2" class="CodeAnnotationHang">2</span>     delay(100);  }<span aria-label="annotation3" class="CodeAnnotationHang">3</span>   delay(5000);<span aria-label="annotation4" class="CodeAnnotationHang">4</span>   for (int a=255; a&gt;=0; a--) { analogWrite(5,a); delay(100); } delay(5000);&#13;
}</code></pre>&#13;
			<p>&#13;
				We control the speed of the motor using pulse-width modulation (as demonstrated in Project 3 in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>). Recall that we can do this only with digital pins 3, 5, 6, 9, 10, and 11. Using this method, current is applied to the motor in short bursts: the longer the burst, the faster the speed, as the motor is on more than it is off during a set period of time. So at <span aria-label="annotation1" class="CodeAnnotation">1</span>, the motor speed starts at zero and increases slowly; you can control the acceleration by changing the <code>delay</code> value at <span aria-label="annotation2" class="CodeAnnotation">2</span>. At <span aria-label="annotation3" class="CodeAnnotation">3</span>, the motor is running as fast as possible and holds that speed for 5 seconds. Then, from <span aria-label="annotation4" class="CodeAnnotation">4</span>, the process reverses, and the motor slows to a stop.</p>&#13;
			<aside epub:type="sidebar">&#13;
				<div class="top hr">&#13;
					<hr/>&#13;
				</div>&#13;
				<section class="note">&#13;
					<h2><span class="NoteHead">NOTE</span></h2>&#13;
					<p>	When it starts moving, you may hear a whine from the motor, which sounds like the sound of an electric train or a tram when it moves away from a station. This is normal and nothing to worry about.</p>&#13;
					<div class="bottom hr">&#13;
						<hr/>&#13;
					</div>&#13;
				</section>&#13;
			</aside>&#13;
			<p>&#13;
				The diode is used in the same way it was with the relay control circuit described in Figure 3-19 on <span class="xref" itemid="xref_target_page 42">page 42</span> to protect the circuit. When the current is switched off from the motor, stray current exists for a brief time inside the motor’s coil and has to go somewhere. The diode allows the stray current to loop around through the coil until it dissipates as a tiny amount of heat.</p>&#13;
			<h2 id="h1-500587c14-0005"><span epub:type="pagebreak" id="Page_251" title="251"/>Using Small Stepper Motors</h2>&#13;
			<p class="BodyFirst">Stepper motors are different from regular DC motors, in that they divide a full rotation of the motor into a fixed number of steps. They do this by using two coil windings that are independently controlled. So instead of controlling a rotation with varying voltage as with a regular DC motor, you instead turn on or off the coils in a stepper motor in a certain pattern to rotate the shaft in either direction a set number of times. This control makes steppers ideal for jobs that need precise motor positioning. They are quite commonly found in devices from computer printers to advanced manufacturing devices.</p>&#13;
			<p>&#13;
				We will demonstrate stepper motor operation using the model 28BYJ-48, as shown in <a href="#figure14-10" id="figureanchor14-10">Figure 14-10</a>. This type of stepper motor can be controlled to rotate to one of 4,096 positions; that is, one full rotation is divided into 4,096 steps.</p>&#13;
			<figure>&#13;
				<img alt="f14010" src="image_fi/500587c14/f14010.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-10">Figure 14-10</a>: A stepper motor and controller board</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>&#13;
				The board next to the motor is used as an interface between your Arduino and the stepper motor, making connection easy and fast. It is usually supplied along with the stepper motor. A close-up is shown in <a href="#figure14-11" id="figureanchor14-11">Figure 14-11</a>.</p>&#13;
			<figure>&#13;
				<img alt="f14011" src="image_fi/500587c14/f14011.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-11">Figure 14-11</a>: The stepper motor controller board</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p><span epub:type="pagebreak" id="Page_252" title="252"/>Now to connect your stepper motor to the Arduino. Make the connections as shown in <a href="#table14-1" id="tableanchor14-1">Table 14-1</a>.</p>&#13;
			<figure>&#13;
				<figcaption class="TableTitle">&#13;
					<p><a id="table14-1">Table 14-1</a>: Connections Between the Stepper Motor Controller Board and the Arduino</p>&#13;
				</figcaption>&#13;
				<table border="1" id="table-500587c14-0001">&#13;
					<thead>&#13;
						<tr>&#13;
							<td><b>Control board pin label</b></td>&#13;
							<td><b>Arduino pin</b></td>&#13;
						</tr>&#13;
					</thead>&#13;
					<tbody>&#13;
						<tr>&#13;
							<td>IN1</td>&#13;
							<td>D8</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td>IN2</td>&#13;
							<td>D9</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td>IN3</td>&#13;
							<td>D10</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td>IN4</td>&#13;
							<td>D11</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td>5–12 V+</td>&#13;
							<td>5 V</td>&#13;
						</tr>&#13;
						<tr>&#13;
							<td>5–12 V−</td>&#13;
							<td>GND</td>&#13;
						</tr>&#13;
					</tbody>&#13;
				</table>&#13;
			</figure>&#13;
			<p>&#13;
				You can briefly run the stepper motor using power from your Arduino if nothing else is drawing power from the Arduino. However, this is not recommended. Instead, use an external 5 V power supply such as a plug pack or other convenient source. As the controller board doesn’t have a DC socket, you can use an external socket with terminal blocks to make easy, solderless connections, as shown in <a href="#figure14-12" id="figureanchor14-12">Figure 14-12</a>.</p>&#13;
			<figure>&#13;
				<img alt="f14012" src="image_fi/500587c14/f14012.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-12">Figure 14-12</a>: DC socket terminal block</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>&#13;
				You can then connect jumper wires from the + and – connectors on the terminal blocks to those on the stepper motor controller board. To simplify controlling the stepper motor in our Arduino sketches, you can use a neat Arduino library called CheapStepper. You can download it from <a class="LinkURL" href="https://github.com/tyhenry/CheapStepper/archive/master.zip">https://github.com/tyhenry/CheapStepper/archive/master.zip</a> and install it using the method described in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>.</p>&#13;
			<p><span epub:type="pagebreak" id="Page_253" title="253"/>Once you have successfully installed the library and connected your stepper motor as described earlier, enter and upload <a href="#listing14-2" id="listinganchor14-2">Listing 14-2</a>.</p>&#13;
			<pre><code>// Listing 14-2<span aria-label="annotation1" class="CodeAnnotationHang">1</span> #include &lt;CheapStepper.h&gt;<span aria-label="annotation2" class="CodeAnnotationHang">2</span> CheapStepper stepper (8, 9, 10, 11);<span aria-label="annotation3" class="CodeAnnotationHang">3</span> boolean clockwise = true;&#13;
boolean cclockwise = false;<span aria-label="annotation4" class="CodeAnnotationHang">4</span> void setup()&#13;
{ stepper.setRpm(20); Serial.begin(9600);&#13;
}&#13;
void loop()&#13;
{ Serial.println("stepper.moveTo (Clockwise, 0)");<span aria-label="annotation5" class="CodeAnnotationHang">5</span>   stepper.moveTo (clockwise, 0); delay(1000); Serial.println("stepper.moveTo (Clockwise, 1024)");<span aria-label="annotation5" class="CodeAnnotationHang">5</span>   stepper.moveTo (clockwise, 1024); delay(1000); Serial.println("stepper.moveTo (Clockwise, 2048)"); stepper.moveTo (clockwise, 2048); delay(1000); Serial.println("stepper.moveTo (Clockwise, 3072)"); stepper.moveTo (clockwise, 3072); delay(1000); Serial.println("stepper.moveTo (CClockwise, 512)");<span aria-label="annotation5" class="CodeAnnotationHang">5</span>   stepper.moveTo (cclockwise, 512); delay(1000); Serial.println("stepper.moveTo (CClockwise, 1536)");<span aria-label="annotation5" class="CodeAnnotationHang">5</span>   stepper.moveTo (cclockwise, 1536); delay(1000); Serial.println("stepper.moveTo (CClockwise, 2560)"); stepper.moveTo (cclockwise, 2560); delay(1000); Serial.println("stepper.moveTo (CClockwise, 3584)"); stepper.moveTo (cclockwise, 3584); delay(1000);&#13;
}</code></pre>&#13;
			<p class="CodeListingCaption"><a id="listing14-2">Listing 14-2</a>: Testing the stepper motor</p>&#13;
			<p><span epub:type="pagebreak" id="Page_254" title="254"/>Operation of the stepper motor is quite simple. We first include the library at <span aria-label="annotation1" class="CodeAnnotation">1</span> and create an instance of the motor at <span aria-label="annotation2" class="CodeAnnotation">2</span>. (If you wish to change the digital pins used for the controller board, update them here.) The control function uses <code>true</code> and <code>false</code> for clockwise and counterclockwise rotation, respectively, so we assign these to Boolean variables at <span aria-label="annotation3" class="CodeAnnotation">3</span> to make things clearer. Finally, the motor can be instructed to rotate to one of the 4,096 positions using the function:</p>&#13;
			<pre><code>Stepper.moveTo(<em>direction</em>, <em>location</em>);</code></pre>&#13;
			<p class="BodyContinued">where the direction is either <code>clockwise</code> or <code>cclockwise</code> and the location is a value between 0 and 4,095. This is done starting at <span aria-label="annotation5" class="CodeAnnotation">5</span> and repeatedly through the end of the sketch.</p>&#13;
			<p>&#13;
				Furthermore, in <code>void setup()</code> at <span aria-label="annotation4" class="CodeAnnotation">4</span>, we set the motor’s rotational speed to 20 RPM using:</p>&#13;
			<pre><code>stepper.setRpm(20);</code></pre>&#13;
			<p class="BodyContinued">This is the recommended speed for our stepper motor. Other motors will vary, so you should check with the supplier for these details.</p>&#13;
			<p>&#13;
				A few moments after you upload the sketch, your stepper motor will start rotating to various positions, and you can see the commands echoed in the Serial Monitor, as shown in <a href="#figure14-13" id="figureanchor14-13">Figure 14-13</a>.</p>&#13;
			<figure>&#13;
				<img alt="f14013" src="image_fi/500587c14/f14013.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-13">Figure 14-13</a>: Commands sent to the stepper motor</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h2 class="HeadProject" id="h1-500587c14-0006"><span>Project #39: Building and Controlling a Robot Vehicle</span></h2>&#13;
			<p class="BodyFirst">Although controlling the speed of one DC motor can be useful, let’s move into more interesting territory by controlling four DC motors at once and affecting their speed <em>and</em> direction. Our goal is to construct a four-wheeled vehicle-style robot that we’ll continue to work on in the next few chapters. Here I’ll describe the construction and basic control of our robot.</p>&#13;
			<p><span epub:type="pagebreak" id="Page_255" title="255"/>Our robot has four motors that each control one wheel, allowing it to travel at various speeds as well as rotate in place. You will be able to control the speed and direction of travel, and you will also learn how to add parts to enable collision avoidance and remote control. Once you have completed the projects in this book, you will have a solid foundation for creating your own versions of this robot and bringing your ideas to life.</p>&#13;
			<h3 id="h2-500587c14-0012">The Hardware</h3>&#13;
			<p class="BodyFirst">You’ll need the following hardware :</p>&#13;
			<ul>&#13;
				<li>Robot vehicle chassis with four DC motors and wheels</li>&#13;
				<li>Four-cell AA battery holder with wired output</li>&#13;
				<li>Four alkaline AA cells</li>&#13;
				<li>L293D Motor Drive Shield for Arduino</li>&#13;
				<li>Arduino and USB cable</li>&#13;
			</ul>&#13;
			<h4 id="h3-500587c14-0001">The Chassis</h4>&#13;
			<p class="BodyFirst">The foundation of any robot is a solid chassis containing the motors, drivetrain, and power supply. An Arduino-powered robot also needs to have room to mount the Arduino and various external parts.</p>&#13;
			<p>&#13;
				You can choose from many chassis models available on the market. To keep things simple, we’re using an inexpensive robot chassis that includes four small DC motors that operate at around 6 V DC and matching wheels, as shown in <a href="#figure14-14" id="figureanchor14-14">Figure 14-14</a>.</p>&#13;
			<figure>&#13;
				<img alt="f14014" src="image_fi/500587c14/f14014.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-14">Figure 14-14</a>: Our robot chassis</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p><span epub:type="pagebreak" id="Page_256" title="256"/>The task of physically assembling the robot chassis will vary between models, and you may need a few basic tools such as screwdrivers and pliers. If you’re not sure about your final design but wish to get your robot moving, a favored technique is to hold the electronics to the chassis with sticky products such as Blu Tack.</p>&#13;
			<h4 id="h3-500587c14-0002">The Power Supply</h4>&#13;
			<p class="BodyFirst">The motors included with the robot chassis typically operate at around 6 V DC, so we’ll use a four-cell AA battery holder to power our robot, as shown in <a href="#figure14-15" id="figureanchor14-15">Figure 14-15</a>.</p>&#13;
			<figure>&#13;
				<img alt="f14015" src="image_fi/500587c14/f14015.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-15">Figure 14-15</a>: A battery holder for four AA cells</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>&#13;
				Some AA cell battery holders will not have the wiring needed to connect to our project and instead will have connections for a 9 V battery snap (as our unit in <a href="#figure14-15">Figure 14-15</a> does). In this case, you’ll need a battery snap like the one in <a href="#figure14-16" id="figureanchor14-16">Figure 14-16</a>.</p>&#13;
			<figure>&#13;
				<img alt="f14016" src="image_fi/500587c14/f14016.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-16">Figure 14-16</a>: A battery cable used to connect the battery holder to the Arduino</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h3 id="h2-500587c14-0013">The Schematic</h3>&#13;
			<p class="BodyFirst">The final requirement is to create the circuitry to control the four motors in the chassis. Although we could use the circuitry shown in <a href="#figure14-9">Figure 14-9</a> <span epub:type="pagebreak" id="Page_257" title="257"/>for each of the motors, this wouldn’t allow us to control the direction of the motors and could be somewhat inconvenient to wire up ourselves. Instead, we’ll use a <em>motor shield</em>. A motor shield contains the circuitry we need to handle the higher current drawn by the motors and accepts commands from the Arduino to control both the speed and direction of the motors. For our robot, we’ll use an L293D Motor Drive Shield for Arduino, as shown in <a href="#figure14-17" id="figureanchor14-17">Figure 14-17</a>.</p>&#13;
			<figure>&#13;
				<img alt="f14017" src="image_fi/500587c14/f14017.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-17">Figure 14-17</a>: An L293D Motor Drive Shield for Arduino</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h3 id="h2-500587c14-0014">Connecting the Motor Shield</h3>&#13;
			<p class="BodyFirst">Making the required connections to the motor shield is simple: connect the wires from the battery holder to the terminal block at the bottom left of the shield, as shown in <a href="#figure14-18" id="figureanchor14-18">Figure 14-18</a>. The black wire (negative) must be on the right side and the red wire on the left.</p>&#13;
			<figure>&#13;
				<img alt="f14018" src="image_fi/500587c14/f14018.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-18">Figure 14-18</a>: DC power connection</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p><span epub:type="pagebreak" id="Page_258" title="258"/>Next you need to connect each DC motor to the motor shield. We’ll refer to the two DC motors at the front of the chassis as motor 2 (left) and motor 1 (right) and the two DC motors at the rear as motor 3 (left) and motor 4 (right). Each motor will have a red and a black wire, so connect them to the matching terminal blocks on the left-hand and right-hand side of the motor shield, as shown in <a href="#figure14-19" id="figureanchor14-19">Figure 14-19</a>.</p>&#13;
			<figure>&#13;
				<img alt="f14019" src="image_fi/500587c14/f14019.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-19">Figure 14-19</a>: Connecting the motors</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>When connecting the wires from the DC motors, note that the black wires are on the outside ends of the terminal blocks and the red wires are on the internal ends. Furthermore, each terminal block is labeled with our matching motor number (M1, M2, M3, and M4) for easy reference.</p>&#13;
			<p>If your motor’s wires are not color coded, you may have to swap them after the first run to determine which way is forward or backward.</p>&#13;
			<p>&#13;
				After you’ve connected the power and motor wires to the shield and the shield to your Arduino, the robot should look something like the one in <a href="#figure14-20" id="figureanchor14-20">Figure 14-20</a>.</p>&#13;
			<figure>&#13;
				<img alt="f14020" src="image_fi/500587c14/f14020.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-20">Figure 14-20</a>: Our robot is ready for action!</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h3 id="h2-500587c14-0015"><span epub:type="pagebreak" id="Page_259" title="259"/>The Sketch</h3>&#13;
			<p class="BodyFirst">Now to get the robot moving. To simplify its operation, we first need to download and install the Arduino library for the motor drive shield. Follow the instructions outlined in Chapter 7. In the Library Manager, find and then install the “Adafruit Motor Shield library by Adafruit.”</p>&#13;
			<p>&#13;
				After a moment, the Adafruit Motor Shield library v1 will appear. Click <b>Install</b> and wait for the library to be installed. You can then close the Library Manager window.</p>&#13;
			<p>Now we’ll create some functions to operate our robot. Because two motors are involved, we’ll need four movements:</p>&#13;
			<ul>&#13;
				<li>Forward motion</li>&#13;
				<li>Reverse motion</li>&#13;
				<li>Rotate clockwise</li>&#13;
				<li>Rotate counterclockwise</li>&#13;
			</ul>&#13;
			<p>&#13;
				Thus, we’ll need four functions in our sketch to match our four movements: <code>goForward()</code>, <code>goBackward()</code>, <code>rotateLeft()</code>, and <code>rotateRight()</code>. Each accepts a value in milliseconds, which is the length of time required to operate the movement, and a PWM value between 0 and 255. For example, to move forward for 2 seconds at full speed, we’d use <code>goForward(255,2000)</code>.</p>&#13;
			<p>Enter and save the following sketch (but don’t upload it just yet):</p>&#13;
			<pre><code>// Project 39 - Building and Controlling a Robot Vehicle&#13;
#include &lt;AFMotor.h&gt;<span aria-label="annotation1" class="CodeAnnotationHang">1</span> AF_DCMotor motor1(1); // set up instances of each motor&#13;
AF_DCMotor motor2(2);&#13;
AF_DCMotor motor3(3);&#13;
AF_DCMotor motor4(4);<span aria-label="annotation2" class="CodeAnnotationHang">2</span> void goForward(int speed, int duration)&#13;
{ motor1.setSpeed(speed); motor2.setSpeed(speed); motor3.setSpeed(speed); motor4.setSpeed(speed); motor1.run(FORWARD); motor2.run(FORWARD); motor3.run(FORWARD); motor4.run(FORWARD); delay(duration); motor1.run(RELEASE); motor2.run(RELEASE); motor3.run(RELEASE); motor4.run(RELEASE);&#13;
}<span aria-label="annotation2" class="CodeAnnotationHang">2</span> void goBackward(int speed, int duration)<span epub:type="pagebreak" id="Page_260" title="260"/>{ motor1.setSpeed(speed); motor2.setSpeed(speed); motor3.setSpeed(speed); motor4.setSpeed(speed); motor1.run(BACKWARD); motor2.run(BACKWARD); motor3.run(BACKWARD); motor4.run(BACKWARD); delay(duration); motor1.run(RELEASE); motor2.run(RELEASE); motor3.run(RELEASE); motor4.run(RELEASE);&#13;
}<span aria-label="annotation2" class="CodeAnnotationHang">2</span> void rotateLeft(int speed, int duration)&#13;
{ motor1.setSpeed(speed); motor2.setSpeed(speed); motor3.setSpeed(speed); motor4.setSpeed(speed); motor1.run(FORWARD); motor2.run(BACKWARD); motor3.run(BACKWARD); motor4.run(FORWARD); delay(duration); motor1.run(RELEASE); motor2.run(RELEASE); motor3.run(RELEASE); motor4.run(RELEASE);&#13;
}<span aria-label="annotation2" class="CodeAnnotationHang">2</span> void rotateRight(int speed, int duration)&#13;
{ motor1.setSpeed(speed); motor2.setSpeed(speed); motor3.setSpeed(speed); motor4.setSpeed(speed); motor1.run(BACKWARD); motor2.run(FORWARD); motor3.run(FORWARD); motor4.run(BACKWARD); delay(duration); motor1.run(RELEASE); motor2.run(RELEASE); motor3.run(RELEASE); motor4.run(RELEASE);&#13;
}&#13;
void setup()<span epub:type="pagebreak" id="Page_261" title="261"/>{ delay(5000);&#13;
}&#13;
void loop()&#13;
{ goForward(127,5000); delay(1000); rotateLeft(127,2000); delay(1000); goBackward(127,5000); delay(1000); rotateRight(127,5000); delay(5000);&#13;
}</code></pre>&#13;
			<p>&#13;
				Controlling the robot is easy thanks to the four custom functions in the sketch. Each custom function makes use of the library functions used to control a motor. Before you can use these functions, you need to create an instance for each motor, as shown at <span aria-label="annotation1" class="CodeAnnotation">1</span>.</p>&#13;
			<p>The direction of travel for each motor is set using:</p>&#13;
			<pre><code>Motor.run(<em>direction</em>)</code></pre>&#13;
			<p>&#13;
				The value of <var>direction</var> is either <code>FORWARD</code>, <code>REVERSE</code>, or <code>RELEASE</code>, to set the motor’s rotational direction forward or backward or cut power to the motor, respectively.</p>&#13;
			<p>To set the speed of the motor, we use:</p>&#13;
			<pre><code>Motor.setSpeed(<em>speed</em>)</code></pre>&#13;
			<p>&#13;
				The value of <var>speed</var> is between <code>0</code> and <code>255</code>; it is the range of PWM used to control the rotational speed of the motor.</p>&#13;
			<p>&#13;
				Therefore, in each of our four custom functions at <span aria-label="annotation2" class="CodeAnnotation">2</span>, we use the combination of the motor speed and directional controls to control all four motors at once. Each of the custom functions accepts two parameters: <code>speed</code> (our PWM value) and <code>duration</code> (the amount of time to run the motor).</p>&#13;
			<aside epub:type="sidebar">&#13;
				<div class="top hr">&#13;
					<hr/>&#13;
				</div>&#13;
				<section class="note">&#13;
					<h2><span class="NoteHead">WARNING</span></h2>&#13;
					<p>	When you’re ready to upload the sketch, position the robot either by holding it off your work surface or by propping it up so that its treads aren’t in contact with a surface. If you don’t do this, then when the sketch upload completes, the robot will burst into life and might leap off your desk immediately!</p>&#13;
					<div class="bottom hr">&#13;
						<hr/>&#13;
					</div>&#13;
				</section>&#13;
			</aside>&#13;
			<p>Upload the sketch, remove the USB cable, and connect the battery cable to the Arduino power socket. Then place the robot on carpet or a clean surface and let it drive about. Experiment with the movement functions in the sketch to control your robot; this will help you become familiar with the time delays and how they relate to distance traveled.</p>&#13;
			<h2 id="h1-500587c14-0007"><span epub:type="pagebreak" id="Page_262" title="262"/>Connecting Extra Hardware to the Robot</h2>&#13;
			<p class="BodyFirst">Some motor drive shields for Arduino may not have stacking header sockets to enable you to put another shield on top, and they might not allow easy connection of wires from sensors, etc. In this case, you should use a <em>terminal shield </em>for Arduino, an example of which is shown in <a href="#figure14-21" id="figureanchor14-21">Figure 14-21</a>.</p>&#13;
			<figure>&#13;
				<img alt="f14021" src="image_fi/500587c14/f14021.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-21">Figure 14-21</a>: A terminal shield for Arduino</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>Terminal shields allow for easy wiring of hardware or sensors to the Arduino’s input and output pins without any soldering, and they can also be used to build your own circuitry for more permanent uses later.</p>&#13;
			<h2 id="h1-500587c14-0008">Sensing Collisions</h2>&#13;
			<p class="BodyFirst">Now that our robot can move, we can start to add sensors. These will tell the robot when it has bumped into something, or they will measure the distance between the robot and an object in its path so that it can avoid a crash. We’ll use three methods of collision avoidance: microswitches, infrared, and ultrasonic.</p>&#13;
			<h2 class="HeadProject" id="h1-500587c14-0009"><span>Project #40: Detecting Robot Vehicle Collisions with a Microswitch</span></h2>&#13;
			<p class="BodyFirst">A <em>microswitch</em> can act like the simple push button we used in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>, but the microswitch component is physically larger and includes a large metal bar that serves as the actuator (see <a href="#figure14-22" id="figureanchor14-22">Figure 14-22</a>).</p>&#13;
			<span epub:type="pagebreak" id="Page_263" title="263"/>&#13;
			<figure>&#13;
				<img alt="f14022" src="image_fi/500587c14/f14022.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-22">Figure 14-22</a>: A microswitch</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p>When using a microswitch, you connect one wire to the bottom contact and the other to the contact labeled NO (normally open) to ensure that current flows only when the bar is pressed. We’ll mount the microswitch on the front of our robot so that when the robot hits an object, the bar will be pressed, causing current to flow and making the robot reverse direction or take another action.</p>&#13;
			<h3 id="h2-500587c14-0016">The Schematic</h3>&#13;
			<p class="BodyFirst">The microswitch hardware is wired like a single push button, as shown in <a href="#figure14-23" id="figureanchor14-23">Figure 14-23</a>.</p>&#13;
			<figure>&#13;
				<img alt="f14023" src="image_fi/500587c14/f14023.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-23">Figure 14-23</a>: Schematic for Project 40</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h3 id="h2-500587c14-0017"><span epub:type="pagebreak" id="Page_264" title="264"/>The Sketch</h3>&#13;
			<p class="BodyFirst">We connect the microswitch to an interrupt port (digital pin 2). Although you might think we should have a function called by the interrupt to make the robot reverse for a few moments, that’s not possible, because the <code>delay()</code> function doesn’t operate inside functions called by interrupts. We must think a little differently in this case.</p>&#13;
			<p>&#13;
				Instead, the function <code>goForward()</code> will turn on the motors if two conditions are met for the variables <code>crash</code> and the Boolean <code>move</code>. If <code>crash</code> is <code>true</code>, the motors will reverse at a slower speed for 2 seconds to back away from a collision situation.</p>&#13;
			<p>&#13;
				We can’t use <code>delay()</code> because of the interrupt, so we measure the amount of time that the motors run by reading <code>millis()</code> at the start and comparing that against the current value of <code>millis()</code>. When the difference is greater than or equal to the required duration, <code>move</code> is set to <code>false</code> and the motors stop.</p>&#13;
			<p>Enter and upload the following sketch:</p>&#13;
			<pre><code>// Project 40 – Detecting Robot Vehicle Collisions with a Microswitch&#13;
#include &lt;AFMotor.h&gt;&#13;
AF_DCMotor motor1(1); // set up instances of each motor&#13;
AF_DCMotor motor2(2);&#13;
AF_DCMotor motor3(3);&#13;
AF_DCMotor motor4(4);&#13;
boolean crash = false;&#13;
void goBackward(int speed, int duration)&#13;
{ motor1.setSpeed(speed); motor2.setSpeed(speed); motor3.setSpeed(speed); motor4.setSpeed(speed); motor1.run(BACKWARD); motor2.run(BACKWARD); motor3.run(BACKWARD); motor4.run(BACKWARD); delay(duration); motor1.run(RELEASE); motor2.run(RELEASE); motor3.run(RELEASE); motor4.run(RELEASE);&#13;
}<span aria-label="annotation1" class="CodeAnnotationHang">1</span> void backOut()&#13;
{ crash = true;&#13;
}&#13;
void goForward(int duration, int speed)<span epub:type="pagebreak" id="Page_265" title="265"/>{ long a, b; boolean move = true;<span aria-label="annotation2" class="CodeAnnotationHang">2</span>   a = millis(); do { if (crash == false) { motor1.setSpeed(speed); motor2.setSpeed(speed); motor3.setSpeed(speed); motor4.setSpeed(speed); motor1.run(FORWARD); motor2.run(FORWARD); motor3.run(FORWARD); motor4.run(FORWARD); } if (crash == true) {<span aria-label="annotation3" class="CodeAnnotationHang">3</span>       goBackward(200, 2000); crash = false; }<span aria-label="annotation4" class="CodeAnnotationHang">4</span>     b = millis() - a; if (b &gt;= duration) { move = false; } } while (move != false); // stop motors motor1.run(RELEASE); motor2.run(RELEASE); motor3.run(RELEASE); motor4.run(RELEASE);&#13;
}&#13;
void setup()&#13;
{ attachInterrupt(0, backOut, RISING); delay(5000);&#13;
}&#13;
void loop()&#13;
{ goForward(5000, 127); delay(2000);&#13;
} </code></pre>&#13;
			<p>&#13;
				This sketch uses an advanced method of moving forward, in that two variables are used to monitor movement while the robot is in motion. The first is the Boolean variable <code>crash</code>. If the robot bumps into something and activates the microswitch, then an interrupt is called, which runs the function <code>backOut()</code> at <span aria-label="annotation1" class="CodeAnnotation">1</span>. It is here that the variable <code>crash</code> is changed from <code>false</code> <span epub:type="pagebreak" id="Page_266" title="266"/>to <code>true</code>. The second variable that is monitored is the Boolean variable <code>move</code>. In the function <code>goForward()</code>, we use <code>millis()</code> at <span aria-label="annotation2" class="CodeAnnotation">2</span> to calculate constantly whether the robot has finished moving for the required period of time (set by the parameter <code>duration</code>).</p>&#13;
			<p>&#13;
				At <span aria-label="annotation4" class="CodeAnnotation">4</span>, the function calculates whether the elapsed time is less than the required time, and if so, the variable <code>move</code> is set to <code>true</code>. Therefore, the robot is allowed to move forward only if it has not crashed and not run out of time. If a crash has been detected, the function <code>goBackward()</code> at <span aria-label="annotation3" class="CodeAnnotation">3</span> is called, at which point the robot will reverse slowly for 2 seconds and then resume as normal.</p>&#13;
			<aside epub:type="sidebar">&#13;
				<div class="top hr">&#13;
					<hr/>&#13;
				</div>&#13;
				<section class="note">&#13;
					<h2><span class="NoteHead">NOTE</span></h2>&#13;
					<p>	You can add the other movement functions from Project 39 to expand or modify this example.</p>&#13;
					<div class="bottom hr">&#13;
						<hr/>&#13;
					</div>&#13;
				</section>&#13;
			</aside>&#13;
			<h2 id="h1-500587c14-0010">Infrared Distance Sensors</h2>&#13;
			<p class="BodyFirst">Our next method of collision avoidance uses an infrared (IR) distance sensor. This sensor bounces an infrared light signal off a surface in front of it and returns a voltage that is relative to the distance between the sensor and the surface. Infrared sensors are useful for collision detection because they are inexpensive, but they’re not ideal for <em>exact</em> distance measuring. We’ll use the Sharp GP2Y0A21YK0F analog sensor, shown in <a href="#figure14-24" id="figureanchor14-24">Figure 14-24</a>, for our project.</p>&#13;
			<figure>&#13;
				<img alt="f14024" src="image_fi/500587c14/f14024.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-24">Figure 14-24</a>: The Sharp IR sensor</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h3 id="h2-500587c14-0018">Wiring It Up</h3>&#13;
			<p class="BodyFirst">To wire the sensor, connect the red and black wires on the sensor to 5 V and GND, respectively, with the white wire connecting to an analog input pin on your Arduino. We’ll use <code>analogRead()</code> to measure the voltage returned from the sensor. The graph in <a href="#figure14-25" id="figureanchor14-25">Figure 14-25</a> shows the relationship between the distance measured and the output voltage.</p>&#13;
			<span epub:type="pagebreak" id="Page_267" title="267"/>&#13;
			<figure>&#13;
				<img alt="f14025" src="image_fi/500587c14/f14025.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-25">Figure 14-25</a>: Graph of IR sensor distance versus output voltage</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h3 id="h2-500587c14-0019">Testing the IR Distance Sensor</h3>&#13;
			<p class="BodyFirst">Because the relationship between distance and output is not easily represented with an equation, we’ll categorize the readings into 5 cm stages. To demonstrate this, we’ll use a simple example. Connect your infrared sensor’s white lead to analog pin 0, the red lead to 5 V, and the black lead to GND. Then enter and upload the sketch shown in <a href="#listing14-3" id="listinganchor14-3">Listing 14-3</a>.</p>&#13;
			<pre><code>// Listing 14-3&#13;
float sensor = 0;&#13;
int cm = 0;&#13;
void setup()&#13;
{ Serial.begin(9600);&#13;
}&#13;
void loop()&#13;
{<span aria-label="annotation1" class="CodeAnnotationHang">1</span>   sensor = analogRead(0); <span aria-label="annotation2" class="CodeAnnotationHang">2</span>   if (sensor&lt;=90)<span epub:type="pagebreak" id="Page_268" title="268"/>  { Serial.println("Infinite distance!"); } else if (sensor&lt;100) // 80 cm { cm = 80; } else if (sensor&lt;110) // 70 cm { cm = 70; } else if (sensor&lt;118) // 60 cm { cm = 60; } else if (sensor&lt;147) // 50 cm { cm = 50; } else if (sensor&lt;188) // 40 cm { cm = 40; } else if (sensor&lt;230) // 30 cm { cm = 30; } else if (sensor&lt;302) // 25 cm { cm = 25; } else if (sensor&lt;360) // 20 cm { cm = 20; } else if (sensor&lt;505) // 15 cm { cm = 15; } else if (sensor&lt;510) // 10 cm { cm = 10; } else if (sensor&gt;=510) // too close! { Serial.println("Too close!"); }  Serial.print("Distance: "); Serial.print(cm); Serial.println(" cm"); delay(250); &#13;
}</code></pre>&#13;
			<p class="CodeListingCaption"><a id="listing14-3">Listing 14-3</a>: IR sensor demonstration sketch</p>&#13;
			<p>&#13;
				The sketch reads the voltage from the IR sensor at <span aria-label="annotation1" class="CodeAnnotation">1</span> and then uses a series of <code>if</code> statements at <span aria-label="annotation2" class="CodeAnnotation">2</span> to choose which approximate distance is being returned. We determine the distance from the voltage returned by the sensor using two parameters. The first is the voltage-to-distance relationship, as displayed in <a href="#figure14-25">Figure 14-25</a>. Then, using the knowledge (from Project 6 in <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span>) that <code>analogRead()</code> returns a value between 0 and 1,023 relative to a voltage between 0 V and around 5 V, we can calculate the approximate distance returned by the sensor.</p>&#13;
			<p><span epub:type="pagebreak" id="Page_269" title="269"/>After uploading the sketch, open the Serial Monitor and experiment by moving your hand or a piece of paper at various distances from the sensor. The Serial Monitor should return the approximate distance, as shown in <a href="#figure14-26" id="figureanchor14-26">Figure 14-26</a>.</p>&#13;
			<figure>&#13;
				<img alt="f14026" src="image_fi/500587c14/f14026.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-26">Figure 14-26</a>: Results of <a href="#listing14-3">Listing 14-3</a></p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h2 class="HeadProject" id="h1-500587c14-0011"><span>Project #41: Detecting Robot Vehicle Collisions with an IR Distance Sensor</span></h2>&#13;
			<p class="BodyFirst">Now let’s use the IR sensor with our robot vehicle instead of the microswitch. We’ll use a slightly modified version of Project 40. Instead of using an interrupt, we’ll create the function <code>checkDistance()</code>, which changes the variable <code>crash</code> to <code>true</code> if the distance measured by the IR sensor is around 20 cm or less. We’ll use this in the <code>goForward()</code> forward motion <code>do-while</code> loop.</p>&#13;
			<h3 id="h2-500587c14-0020">The Sketch</h3>&#13;
			<p class="BodyFirst">Connect the IR sensor to your robot and then enter and upload this sketch:</p>&#13;
			<pre><code>// Project 41 - Detecting Robot Vehicle Collisions with an IR Distance Sensor&#13;
#include &lt;AFMotor.h&gt;&#13;
AF_DCMotor motor1(1); // set up instances of each motor&#13;
AF_DCMotor motor2(2);&#13;
AF_DCMotor motor3(3);&#13;
AF_DCMotor motor4(4);&#13;
boolean crash = false;&#13;
void goBackward(int speed, int duration)&#13;
{ motor1.setSpeed(speed); motor2.setSpeed(speed); motor3.setSpeed(speed); motor4.setSpeed(speed); motor1.run(BACKWARD); motor2.run(BACKWARD); motor3.run(BACKWARD); motor4.run(BACKWARD); delay(duration);<span epub:type="pagebreak" id="Page_270" title="270"/>  motor1.run(RELEASE); motor2.run(RELEASE); motor3.run(RELEASE); motor4.run(RELEASE);&#13;
}&#13;
void checkDistance()&#13;
{<span aria-label="annotation1" class="CodeAnnotationHang">1</span>   if (analogRead(0) &gt; 460) { crash = true; }&#13;
}&#13;
void goForward(int duration, int speed)&#13;
{ long a, b; boolean move = true; a = millis(); do { checkDistance(); if (crash == false) { motor1.setSpeed(speed); motor2.setSpeed(speed); motor3.setSpeed(speed); motor4.setSpeed(speed); motor1.run(FORWARD); motor2.run(FORWARD); motor3.run(FORWARD); motor4.run(FORWARD); } if (crash == true) { goBackward(200, 2000); crash = false; } b = millis() - a; if (b &gt;= duration) { move = false; } } while (move != false); // stop motors motor1.run(RELEASE); motor2.run(RELEASE); motor3.run(RELEASE); motor4.run(RELEASE);&#13;
}&#13;
void setup()<span epub:type="pagebreak" id="Page_271" title="271"/>{ delay(5000);&#13;
}&#13;
void loop()&#13;
{ goForward(5000, 255); delay(2000);&#13;
}</code></pre>&#13;
			<p>&#13;
				This sketch operates using the same methods used in Project 40, except this version constantly takes distance measurements at <span aria-label="annotation1" class="CodeAnnotation">1</span> and sets the <code>crash</code> variable to <code>true</code> if the distance between the IR sensor and an object is less than about 20 cm.</p>&#13;
			<h3 id="h2-500587c14-0021">Modifying the Sketch: Adding More Sensors</h3>&#13;
			<p class="BodyFirst">After running the robot and using this sensor, you should see the benefits of using a non-contact collision sensor. It’s simple to add more sensors to the same robot, such as sensors at the front and rear or at each corner. You should be able to add code to check each sensor in turn and make a decision based on the returned distance value.</p>&#13;
			<h2 id="h1-500587c14-0012">Ultrasonic Distance Sensors</h2>&#13;
			<p class="BodyFirst">Our final method of collision avoidance uses an <em>ultrasonic distance sensor</em>. This sensor bounces a sound wave of an ultra-high frequency (that cannot be heard by the human ear) off a surface and measures the amount of time it takes for the sound to return to the sensor. We’ll use the common HC-SR04-type ultrasonic distance sensor, shown in <a href="#figure14-27" id="figureanchor14-27">Figure 14-27</a>, for this project, because it’s inexpensive and accurate to around 2 cm.</p>&#13;
			<figure>&#13;
				<img alt="f14027" src="image_fi/500587c14/f14027.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-27">Figure 14-27</a>: The HC-SR04 ultrasonic distance sensor</p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<p><span epub:type="pagebreak" id="Page_272" title="272"/>An ultrasonic sensor’s accuracy and range mean it can measure distances between about 2 and 450 cm. However, because the sound wave needs to be reflected back to the sensor, the sensor must be angled less than 15 degrees away from the direction of travel.</p>&#13;
			<h3 id="h2-500587c14-0022">Connecting the Ultrasonic Sensor</h3>&#13;
			<p class="BodyFirst">To connect the sensor, attach the Vcc (5 V) and GND leads to their connectors on the motor drive shield, attach the Trig pin to digital pin D2, and attach the Echo pin to digital pin D13. We use D2 and D13 as they are not used by the motor drive shield. However, if you’re just testing or experimenting with the sensor without the robot, you can connect the wires directly to your Arduino board.</p>&#13;
			<p>&#13;
				To simplify operation of the sensor, download the Arduino library from <a class="LinkURL" href="https://github.com/Martinsos/arduino-lib-hc-sr04/archive/master.zip">https://github.com/Martinsos/arduino-lib-hc-sr04/archive/master.zip</a> and install it as explained in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>. Once the library is installed, you can run the test sketch in <a href="#listing14-4" id="listinganchor14-4">Listing 14-4</a> to see how the sensor works.</p>&#13;
			<pre><code>// Listing 14-4&#13;
#include &lt;HCSR04.h&gt;<span aria-label="annotation1" class="CodeAnnotationHang">1</span> UltraSonicDistanceSensor HCSR04(2, 13); // trig - D2, echo - D13<span aria-label="annotation2" class="CodeAnnotationHang">2</span> float distance;&#13;
void setup () &#13;
{ Serial.begin(9600);&#13;
}&#13;
void loop () &#13;
{<span aria-label="annotation3" class="CodeAnnotationHang">3</span>   distance = HCSR04.measureDistanceCm(); Serial.print("Distance: "); Serial.print(distance); Serial.println(" cm"); delay(500);&#13;
}</code></pre>&#13;
			<p class="CodeListingCaption"><a id="listing14-4">Listing 14-4</a>: Ultrasonic sensor demonstration sketch</p>&#13;
			<p>&#13;
				Retrieving the distance from the sensor is quite simple thanks to the library. At <span aria-label="annotation1" class="CodeAnnotation">1</span>, we create an instance and declare which digital pins are connected to the sensor. Then at <span aria-label="annotation2" class="CodeAnnotation">2</span>, we have a floating-point variable used to store the distance returned from the sensor’s library function. Finally, the distance is generated at <span aria-label="annotation3" class="CodeAnnotation">3</span> for display in the Serial Monitor.</p>&#13;
			<h3 id="h2-500587c14-0023">Testing the Ultrasonic Sensor</h3>&#13;
			<p class="BodyFirst">After uploading the sketch, open the Serial Monitor and move an object toward and away from the sensor. The distance to the object should be returned in centimeters. See how it works in <a href="#figure14-28" id="figureanchor14-28">Figure 14-28</a>.</p>&#13;
			<span epub:type="pagebreak" id="Page_273" title="273"/>&#13;
			<figure>&#13;
				<img alt="f14028" src="image_fi/500587c14/f14028.png"/>&#13;
				<figcaption>&#13;
					<p><a id="figure14-28">Figure 14-28</a>: Results from <a href="#listing14-4">Listing 14-4</a></p>&#13;
				</figcaption>&#13;
			</figure>&#13;
			<h2 class="HeadProject" id="h1-500587c14-0013"><span>Project #42: Detecting Collisions with an Ultrasonic Distance Sensor</span></h2>&#13;
			<p class="BodyFirst">Now that you understand how the sensor works, let’s use it with our robot.</p>&#13;
			<h3 id="h2-500587c14-0024">The Sketch</h3>&#13;
			<p class="BodyFirst">In the following sketch, we check for distances between the robot and an object of 5 cm or less, which will give the robot a reason to back up. Enter and upload the following sketch to see for yourself:</p>&#13;
			<pre><code>// Project 42 - Detecting Collisions with an Ultrasonic Distance Sensor&#13;
#include &lt;AFMotor.h&gt;&#13;
#include &lt;HCSR04.h&gt;&#13;
// set up instances of each motor&#13;
AF_DCMotor motor1(1); &#13;
AF_DCMotor motor2(2);&#13;
AF_DCMotor motor3(3);&#13;
AF_DCMotor motor4(4);&#13;
// set up ultrasonic sensor&#13;
UltraSonicDistanceSensor HCSR04(2, 13); // trig - D2, echo - D13&#13;
boolean crash=false;&#13;
void checkDistance()&#13;
{ float distance; distance = HCSR04.measureDistanceCm();<span aria-label="annotation1" class="CodeAnnotationHang">1</span>   if (distance &lt; 5) // crash distance is 5 cm or less { crash = true; }&#13;
}&#13;
void goBackward(int speed, int duration)<span epub:type="pagebreak" id="Page_274" title="274"/>{ motor1.setSpeed(speed); motor2.setSpeed(speed); motor3.setSpeed(speed); motor4.setSpeed(speed); motor1.run(BACKWARD); motor2.run(BACKWARD); motor3.run(BACKWARD); motor4.run(BACKWARD); delay(duration); motor1.run(RELEASE); motor2.run(RELEASE); motor3.run(RELEASE); motor4.run(RELEASE);&#13;
}&#13;
void goForward(int duration, int speed)&#13;
{ long a, b; boolean move = true; a = millis(); do { checkDistance(); if (crash == false) { motor1.setSpeed(speed); motor2.setSpeed(speed); motor3.setSpeed(speed); motor4.setSpeed(speed); motor1.run(FORWARD); motor2.run(FORWARD); motor3.run(FORWARD); motor4.run(FORWARD); } if (crash == true) { goBackward(200, 2000); crash = false; } b = millis() - a; if (b &gt;= duration) { move = false; } } while (move != false); // stop motors motor1.run(RELEASE); motor2.run(RELEASE); motor3.run(RELEASE); motor4.run(RELEASE);&#13;
}&#13;
void setup()<span epub:type="pagebreak" id="Page_275" title="275"/>{ delay(5000);&#13;
}&#13;
void loop()&#13;
{ goForward(1000, 255);&#13;
}</code></pre>&#13;
			<p>&#13;
				The operation of this sketch should be quite familiar by now. Once again, we constantly measure the distance at <span aria-label="annotation1" class="CodeAnnotation">1</span> and then change the variable <code>crash</code> to <code>true</code> if the distance between the ultrasonic sensor and an object in its path is less than 5 cm. Watching the robot magically avoid colliding with things or having a battle of wits with a pet can be quite amazing.</p>&#13;
			<h2 id="h1-500587c14-0014">Looking Ahead</h2>&#13;
			<p class="BodyFirst">In this chapter, you learned how to introduce your Arduino-based projects to the world of movement. Using simple motors, or pairs of motors, with a motor shield, you can create projects that can move on their own and even avoid obstacles. We used three types of sensors to demonstrate a range of accuracies and sensor costs, so you can now make decisions based on your requirements and project budget.</p>&#13;
			<p>By now, I hope you are experiencing and enjoying the ability to design and construct such things. But it doesn’t stop here. In the next chapter, we move outdoors and harness the power of satellite navigation.</p>&#13;
		</section>&#13;
	</body></html>