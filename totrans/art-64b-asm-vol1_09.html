<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="377" id="Page_377"/>7</span><br/>
<span class="ChapterTitle">Low-Level Control Structures</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">This chapter discusses how to convert high-level–language control structures into assembly language control statements. The examples up to this point have created assembly control structures in an ad hoc manner. Now it’s time to formalize how to control the operation of your assembly language programs. By the time you finish this chapter, you should be able to convert HLL control structures into assembly language.</p>
<p>Control structures in assembly language consist of conditional branches and indirect jumps. This chapter discusses those instructions and how to emulate HLL control structures (such as <code>if/else</code>, <code>switch</code>, and loop statements). <span epub:type="pagebreak" title="378" id="Page_378"/>This chapter also discusses labels (the targets of conditional branches and jump statements) as well as the scope of labels in an assembly language source file.</p>
<h2 id="h1-501089c07-0001">	7.1	Statement Labels</h2>
<p class="BodyFirst">Before discussing jump instructions and how to emulate control structures using them, an in-depth discussion of assembly language statement labels is necessary. In an assembly language program, <em>labels</em> stand in as symbolic names for addresses. It is far more convenient to refer to a position in your code by using a name such as <code>LoopEntry</code> rather than a numeric address such as 0AF1C002345B7901Eh. For this reason, assembly language low-level control structures make extensive use of labels within source code (see <span class="xref" itemid="xref_target_Brief Detour_An Introduction to Control Transfer Instructions in Chapter 2">“Brief Detour: An Introduction to Control Transfer Instructions” in Chapter 2</span>). </p>
<p>You can do three things with (code) labels: transfer control to a label via a (conditional or unconditional) jump instruction, call a label via the <code>call</code> instruction, and take the address of a label. Taking the address of a label is useful when you want to indirectly transfer control to that address at a later point in your program.</p>
<p>The following code sequence demonstrates two ways to take the address of a label in your program (using the <code>lea</code> instruction and using the <code>offset</code> operator):</p>
<pre><code>stmtLbl:
    .
    .
    .
  mov rcx, offset stmtLbl2
    .
    .
    .
  lea rax, stmtLbl
    .
    .
    .
stmtLbl2:</code></pre>
<p>Because addresses are 64-bit quantities, you’ll typically load an address into a 64-bit general-purpose register by using the <code>lea</code> instruction. Because that instruction uses a 32-bit relative displacement from the current instruction, the instruction encoding is significantly shorter than the <code>mov</code> instruction (which encodes a full 8-byte constant in addition to the opcode bytes).</p>
<h3 id="h2-501089c07-0001">7.1.1	Using Local Symbols in Procedures</h3>
<p class="BodyFirst">Statement labels you define within a <code>proc</code>/<code>endp</code> procedure are <em>local</em> to that procedure, in the sense of <em>lexical </em><em>scope</em>: the statement label is visible only within that procedure; you cannot refer to that statement label outside <span epub:type="pagebreak" title="379" id="Page_379"/>the procedure. <a href="#listing7-1" id="listinganchor7-1">Listing 7-1</a> demonstrates that you cannot refer to a symbol inside another procedure (note that this program will not assemble because of this error).</p>
<pre><code>; Listing 7-1
 
; Demonstration of local symbols.
; Note that this program will not
; compile; it fails with an
; undefined symbol error.

        option  casemap:none

            .code

hasLocalLbl proc

localStmLbl:
            ret
hasLocalLbl endp

; Here is the "asmMain" function.

asmMain     proc

asmLocal:   jmp     asmLocal        ; This is okay
            jmp     localStmtLbl    ; Undefined in asmMain
asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing7-1">Listing 7-1</a>: Demonstration of lexically scoped symbols</p>
<p>The command to assemble this file (and the corresponding diagnostic message) is as follows:</p>
<pre><code>C:\&gt;<b>ml64 /c listing7-1.asm</b>
Microsoft (R) Macro Assembler (x64) Version 14.15.26730.0
Copyright (C) Microsoft Corporation.  All rights reserved.

 Assembling: listing7-1.asm
listing7-1.asm(26) : error A2006:undefined symbol : localStmtLbl</code></pre>
<p>If you really want to access a statement (or any other) label outside a procedure, you can use the <code>option</code> directive to turn off local scope within a section of your program, as noted in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>:</p>
<pre><code>option noscoped
option scoped</code></pre>
<p>The first form tells MASM to stop making symbols (inside <code>proc</code>/<code>endp</code>) local to the procedure containing them. The second form restores the lexical scoping of symbols in procedures. Therefore, using these two directives, you can turn scoping on or off for various sections of your source file (including <span epub:type="pagebreak" title="380" id="Page_380"/>as little as a single statement, if you like). <a href="#listing7-2" id="listinganchor7-2">Listing 7-2</a> demonstrates how to use the <code>option</code> directive to make a single symbol global outside the procedure containing it (note that this program still has compile errors).</p>
<pre><code>; Listing 7-2
 
; Demonstration of local symbols #2.
; Note that this program will not
; compile; it fails with two
; undefined symbol errors.

            option  casemap:none

            .code

hasLocalLbl proc

localStmLbl:
            option noscoped
notLocal:
            option scoped
isLocal:
            ret
hasLocalLbl endp

; Here is the "asmMain" function.

asmMain     proc

            lea     rcx, localStmtLbl  ; Generates an error
            lea     rcx, notLocal      ; Assembles fine
            lea     rcx, isLocal       ; Generates an error
asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing7-2">Listing 7-2</a>: The <code>option scoped</code> and <code>option noscoped</code> directives</p>
<p>Here’s the build command (and diagnostic output) for <a href="#listing7-2">Listing 7-2</a>:</p>
<pre><code>C:\&gt;<b>ml64 /c listing7-2.asm</b>
Microsoft (R) Macro Assembler (x64) Version 14.15.26730.0
Copyright (C) Microsoft Corporation.  All rights reserved.

 Assembling: listing7-2.asm
listing7-2.asm(29) : error A2006:undefined symbol : localStmtLbl
listing7-2.asm(31) : error A2006:undefined symbol : isLocal</code></pre>
<p>As you can see from MASM’s output, the <code>notLocal</code> symbol (appearing after the <code>option noscoped</code> directive) did not generate an undefined symbol error. However, the <code>localStmtLbl</code> and <code>isLocal</code> symbols, which are local to <code>hasLocalLbl</code>, are undefined outside that procedure.</p>
<h3 id="h2-501089c07-0002"><span epub:type="pagebreak" title="381" id="Page_381"/>7.1.2	Initializing Arrays with Label Addresses</h3>
<p class="BodyFirst">MASM also allows you to initialize quad-word variables with the addresses of statement labels. However, labels that appear in the initialization portions of variable declarations have some restrictions. The most important restriction is that the symbol must be in the same lexical scope as the data declaration attempting to use it. So, either the <code>qword</code> directive must appear inside the same procedure as the statement label, or you must use the <code>option noscoped</code> directive to make the symbol(s) global to the procedure. <a href="#listing7-3" id="listinganchor7-3">Listing 7-3</a> demonstrates these two ways to initialize a <code>qword</code> variable with statement label addresses.</p>
<pre><code>; Listing 7-3
 
; Initializing qword values with the
; addresses of statement labels.

        option  casemap:none

            .data
lblsInProc  qword   globalLbl1, globalLbl2  ; From procWLabels
        
            .code

; procWLabels - Just a procedure containing private (lexically scoped)
;               and global symbols. This really isn't an executable
;               procedure.

procWLabels proc
privateLbl:
            nop     ; "No operation" just to consume space
            option  noscoped
globalLbl1: jmp     globalLbl2
globalLbl2: nop
            option  scoped
privateLbl2:
            ret
dataInCode  qword   privateLbl, globalLbl1
            qword   globalLbl2, privateLbl2
procWLabels endp

            end</code></pre>
<p class="CodeListingCaption"><a id="listing7-3">Listing 7-3</a>: Initializing qword variables with the address of statement labels</p>
<p>If you compile <a href="#listing7-3">Listing 7-3</a> with the following command, you’ll get no assembly errors:</p>
<pre><code>ml64 /c /Fl listing7-3.asm</code></pre>
<p><span epub:type="pagebreak" title="382" id="Page_382"/>If you look at the <em>listing7-3.lst</em> output file that MASM produces, you can see that MASM properly initializes the qword declarations with the (section-relative/relocatable) offsets of the statement labels:</p>
<pre><code>00000000                        .data
00000000           lblsInProc   qword   globalLbl1, globalLbl2
       0000000000000001 R
       0000000000000003 R
          .
          .
          .
 00000005           dataInCode  qword   privateLbl, globalLbl1
       0000000000000000 R
       0000000000000001 R
 00000015  0000000000000003 R   qword   globalLbl2, privateLbl2
       0000000000000004 R</code></pre>
<p>Transferring control to a statement label inside a procedure is generally considered bad programming practice. Unless you have a good reason to do so, you probably shouldn’t.</p>
<p>As addresses on the x86-64 are 64-bit quantities, you will typically use the <code>qword</code> directive (as in the previous examples) to initialize a data object with the address of a statement label. However, if your program is (always going to be) smaller than 2GB, and you set the <code>LARGEADDRESSAWARE:NO</code> flag (using <em>sbuild.bat</em>), you can get away with using <code>dword</code> data declarations to hold the address of a label. Of course, as this book has pointed out many times, using 32-bit addresses in your 64-bit programs can lead to problems if you ever exceed 2GB of storage for your program.</p>
<h2 id="h1-501089c07-0002">	7.2	Unconditional Transfer of Control (jmp)</h2>
<p class="BodyFirst">The <code>jmp</code> (<em>jump</em>) instruction unconditionally transfers control to another point in the program. This instruction has three forms: a direct jump and two indirect jumps. These take the following forms:</p>
<pre><code>jmp <var>label</var>
jmp <var>reg</var><sub>64</sub>
jmp <var>mem</var><sub>64</sub> </code></pre>
<p>The first instruction is a <em>direct jump</em>, which you’ve seen in various sample programs up to this point. For direct jumps, you normally specify the target address by using a statement label. The label appears either on the same line as an executable machine instruction or by itself on a line preceding an executable machine instruction. The direct jump is completely equivalent to a <code>goto</code> statement in a high-level language.<sup class="FootnoteReference"><a id="c07-footnoteref-1" href="#c07-footnote-1">1</a></sup></p>
<p><span epub:type="pagebreak" title="383" id="Page_383"/>Here’s an example:</p>
<pre><code><var>           Statements</var>
          jmp laterInPgm
               .
               .
               .
laterInPgm:
<var>           Statements</var></code></pre>
<h3 id="h2-501089c07-0003">7.2.1	Register-Indirect Jumps</h3>
<p class="BodyFirst">The second form of the <code>jmp</code> instruction given earlier—<code>jmp </code><var>reg</var><span class="SubscriptLiteral">64</span>—is a <em>register-</em><em>indirect jump</em> instruction that transfers control to the instruction whose address appears in the specified 64-bit general-purpose register. To use this form of the <code>jmp</code> instruction, you must load a 64-bit register with the address of a machine instruction prior to the execution of the <code>jmp</code>. When several paths, each loading the register with a different address, converge on the same <code>jmp</code> instruction, control transfers to an appropriate location determined by the path up to that point.</p>
<p><a href="#listing7-4" id="listinganchor7-4">Listing 7-4</a> reads a string of characters from the user that contain an integer value. It uses the C Standard Library function <code>strtol()</code> to convert that string to a binary integer value. The <code>strtol()</code> function doesn’t do the greatest job of reporting an error, so this program tests the return results to verify a correct input and uses register-indirect jumps to transfer control to different code paths based on the result.</p>
<p>The first part of <a href="#listing7-4">Listing 7-4</a> contains constants, variables, external declarations, and the (usual) <code>getTitle()</code> function.</p>
<pre><code>; Listing 7-4
 
; Demonstration of register-indirect jumps.

        option  casemap:none

nl          =       10
maxLen      =       256
EINVAL      =       22      ; "Magic" C stdlib constant, invalid argument
ERANGE      =       34      ; Value out of range

            .const
ttlStr      byte    "Listing 7-4", 0
fmtStr1     byte    "Enter an integer value between "
            byte    "1 and 10 (0 to quit): ", 0

badInpStr   byte    "There was an error in readLine "
            byte    "(ctrl-Z pressed?)", nl, 0

invalidStr  byte    "The input string was not a proper number"
            byte    nl, 0

<span epub:type="pagebreak" title="384" id="Page_384"/>rangeStr    byte    "The input value was outside the "
            byte    "range 1-10", nl, 0

unknownStr  byte    "There was a problem with strToInt "
            byte    "(unknown error)", nl, 0

goodStr     byte    "The input value was %d", nl, 0

fmtStr      byte    "result:%d, errno:%d", nl, 0

            .data
            externdef _errno:dword  ; Error return by C code
endStr      qword   ?
inputValue  dword   ?
buffer      byte    maxLen dup (?)

            .code
            externdef readLine:proc
            externdef strtol:proc
            externdef printf:proc

; Return program title to C++ program:

            public  getTitle
getTitle    proc
            lea     rax, ttlStr
            ret
getTitle    endp</code></pre>
<p>The next section of <a href="#listing7-4">Listing 7-4</a> is the <code>strToInt()</code> function, a wrapper around the C Standard Library <code>strtol()</code> function that does a more thorough job of handling erroneous inputs from the user. See the comments for the function’s return values.</p>
<pre><code>; strToInt - Converts a string to an integer, checking for errors.
 
; Argument:
;    RCX -   Pointer to string containing (only) decimal
;            digits to convert to an integer.
 
; Returns:
;    RAX -   Integer value if conversion was successful.
;    RCX -   Conversion state. One of the following:
;            0 - Conversion successful.
;            1 - Illegal characters at the beginning of the
;                string (or empty string).
;            2 - Illegal characters at the end of the string.
;            3 - Value too large for 32-bit signed integer.

strToInt    proc
strToConv   equ     [rbp+16]        ; Flush RCX here
endPtr      equ     [rbp-8]         ; Save ptr to end of str
            push    rbp
<span epub:type="pagebreak" title="385" id="Page_385"/>            mov     rbp, rsp
            sub     rsp, 32h       ; Shadow + 16-byte alignment

            mov     strToConv, rcx ; Save, so we can test later

            ; RCX already contains string parameter for strtol:

            lea     rdx, endPtr    ; Ptr to end of string goes here
            mov     r8d, 10        ; Decimal conversion
            call    strtol

; On return:
 
;    RAX    - Contains converted value, if successful.
;    endPtr - Pointer to 1 position beyond last char in string.
 
; If strtol returns with endPtr == strToConv, then there were no
; legal digits at the beginning of the string.

            mov     ecx, 1         ; Assume bad conversion
            mov     rdx, endPtr
            cmp     rdx, strToConv
            je      returnValue

; If endPtr is not pointing at a zero byte, then we've got
; junk at the end of the string.

            mov     ecx, 2         ; Assume junk at end
            mov     rdx, endPtr
            cmp     byte ptr [rdx], 0
            jne     returnValue

; If the return result is 7FFF_FFFFh or 8000_0000h (max long and
; min long, respectively), and the C global _errno variable 
; contains ERANGE, then we've got a range error.

            mov     ecx, 0         ; Assume good input
            cmp     _errno, ERANGE
            jne     returnValue
            mov     ecx, 3         ; Assume out of range
            cmp     eax, 7fffffffh
            je      returnValue
            cmp     eax, 80000000h
            je      returnValue

; If we get to this point, it's a good number.

            mov     ecx, 0

returnValue:
            leave
            ret
strToInt    endp</code></pre>
<p><span epub:type="pagebreak" title="386" id="Page_386"/>The final section of <a href="#listing7-4">Listing 7-4</a> is the main program. This is the part of code most interesting to us. It loads the RBX register with the address of code to execute based on the <code>strToInt()</code> return results. The <code>strToInt()</code> function returns one of the following states (see the comments in the previous code for an explanation):</p>
<ul>
<li>Valid input</li>
<li>Illegal characters at the beginning of the string</li>
<li>Illegal characters at the end of the string</li>
<li>Range error</li>
</ul>
<p class="BodyContinued">The program then transfers control to different sections of <code>asmMain()</code> based on the value held in RBX (which specifies the type of result <code>strToInt()</code> returns).</p>
<pre><code>; Here is the "asmMain" function.

            public  asmMain
asmMain     proc
saveRBX     equ     qword ptr [rbp-8]      ; Must preserve RBX
            push    rbp
            mov     rbp, rsp
            sub     rsp, 48                ; Shadow storage

            mov     saveRBX, rbx           ; Must preserve RBX

            ; Prompt the user to enter a value
            ; between 1 and 10:

repeatPgm:  lea     rcx, fmtStr1
            call    printf

            ; Get user input:

            lea     rcx, buffer
            mov     edx, maxLen     ; Zero-extends!
            call    readLine
            lea     rbx, badInput   ; Initialize state machine
            test    rax, rax        ; RAX is -1 on bad input
            js      hadError        ; (only neg value readLine returns)

            ; Call strToInt to convert string to an integer and
            ; check for errors:

            lea     rcx, buffer     ; Ptr to string to convert
            call    strToInt
            lea     rbx, invalid
            cmp     ecx, 1
            je      hadError
            cmp     ecx, 2
            je      hadError

<span epub:type="pagebreak" title="387" id="Page_387"/>            lea     rbx, range
            cmp     ecx, 3
            je      hadError

            lea     rbx, unknown
            cmp     ecx, 0
            jne     hadError

; At this point, input is valid and is sitting in EAX.
 
; First, check to see if the user entered 0 (to quit
; the program).

            test    eax, eax        ; Test for zero
            je      allDone

; However, we need to verify that the number is in the
; range 1-10.

            lea     rbx, range
            cmp     eax, 1
            jl      hadError
            cmp     eax, 10
            jg      hadError

; Pretend a bunch of work happens here dealing with the
; input number.

            lea     rbx, goodInput
            mov     inputValue, eax

; The different code streams all merge together here to
; execute some common code (we'll pretend that happens;
; for brevity, no such code exists here).

hadError:

; At the end of the common code (which doesn't mess with
; RBX), separate into five different code streams based
; on the pointer value in RBX:

            jmp     rbx

; Transfer here if readLine returned an error:

badInput:   lea     rcx, badInpStr
            call    printf
            jmp     repeatPgm

; Transfer here if there was a non-digit character
; in the string:

invalid:    lea     rcx, invalidStr
<span epub:type="pagebreak" title="388" id="Page_388"/>            call    printf
            jmp     repeatPgm

; Transfer here if the input value was out of range:

range:      lea     rcx, rangeStr
            call    printf
            jmp     repeatPgm

; Shouldn't ever get here. Happens if strToInt returns
; a value outside the range 0-3.

unknown:    lea     rcx, unknownStr
            call    printf
            jmp     repeatPgm

; Transfer down here on a good user input.

goodInput:  lea     rcx, goodStr
            mov     edx, inputValue ; Zero-extends!
            call    printf
            jmp     repeatPgm

; Branch here when the user selects "quit program" by
; entering the value zero:

allDone:    mov     rbx, saveRBX    ; Must restore before returning
            leave
            ret                     ; Returns to caller

asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing7-4">Listing 7-4</a>: Using register-indirect <code>jmp</code> instructions</p>
<p>Here’s the build command and a sample run of the program in <a href="#listing7-4">Listing 7-4</a>:</p>
<pre><code>C:\&gt;<b>build listing7-4</b>

C:\&gt;<b>echo off</b>
 Assembling: listing7-4.asm
c.cpp

C:\&gt;<b>listing7-4</b>
Calling Listing 7-4:
Enter an integer value between 1 and 10 (0 to quit): ^Z
There was an error in readLine (ctrl-Z pressed?)
Enter an integer value between 1 and 10 (0 to quit): a123
The input string was not a proper number
<span epub:type="pagebreak" title="389" id="Page_389"/>Enter an integer value between 1 and 10 (0 to quit): 123a
The input string was not a proper number
Enter an integer value between 1 and 10 (0 to quit): 1234567890123
The input value was outside the range 1-10
Enter an integer value between 1 and 10 (0 to quit): -1
The input value was outside the range 1-10
Enter an integer value between 1 and 10 (0 to quit): 11
The input value was outside the range 1-10
Enter an integer value between 1 and 10 (0 to quit): 5
The input value was 5
Enter an integer value between 1 and 10 (0 to quit): 0
Listing 7-4 terminated</code></pre>
<h3 id="h2-501089c07-0004">7.2.2	Memory-Indirect Jumps</h3>
<p class="BodyFirst">The third form of the <code>jmp</code> instruction is a <em>memory-indirect</em> <em>jump</em>, which fetches the quad-word value from the memory location and jumps to that address. This is similar to the register-indirect <code>jmp</code> except the address appears in a memory location rather than in a register. </p>
<p><a href="#listing7-5" id="listinganchor7-5">Listing 7-5</a> demonstrates a rather trivial use of this form of the <code>jmp</code> instruction.</p>
<pre><code>; Listing 7-5
 
; Demonstration of memory-indirect jumps.

        option  casemap:none

nl          =       10

            .const
ttlStr      byte    "Listing 7-5", 0
fmtStr1     byte    "Before indirect jump", nl, 0
fmtStr2     byte    "After indirect jump", nl, 0

            .code
            externdef printf:proc

; Return program title to C++ program:

            public  getTitle
getTitle    proc
            lea     rax, ttlStr
            ret
getTitle    endp

; Here is the "asmMain" function.

            public  asmMain
asmMain     proc
            push    rbp
<span epub:type="pagebreak" title="390" id="Page_390"/>            mov     rbp, rsp
            sub     rsp, 48                 ; Shadow storage

            lea     rcx, fmtStr1
            call    printf
            jmp     memPtr

memPtr      qword   ExitPoint

ExitPoint:  lea     rcx, fmtStr2
            call    printf

            leave
            ret     ; Returns to caller

asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing7-5">Listing 7-5</a>: Using memory-indirect <code>jmp</code> instructions</p>
<p>Here’s the build command and output for <a href="#listing7-5">Listing 7-5</a>:</p>
<pre><code>C:\&gt;<b>build listing7-5</b>

C:\&gt;<b>echo off</b>
 Assembling: listing7-5.asm
c.cpp

C:\&gt;<b>listing7-5</b>
Calling Listing 7-5:
Before indirect jump
After indirect jump
Listing 7-5 terminated</code></pre>
<p>Note that you can easily crash your system if you execute an indirect jump with an invalid pointer value.</p>
<h2 id="h1-501089c07-0003">	7.3	Conditional Jump Instructions</h2>
<p class="BodyFirst">Although <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span> provided an overview of the conditional jump instructions, repeating that discussion and expanding upon it here is worthwhile as conditional jumps are the principal tool for creating control structures in assembly language.</p>
<p>Unlike the unconditional <code>jmp</code> instruction, the conditional jump instructions do not provide an indirect form. They only allow a branch to a statement label in your program.</p>
<p>Intel’s documentation defines various synonyms or instruction aliases for many conditional jump instructions. Tables 7-1, 7-2, and 7-3 list all the aliases for a particular instruction, as well as the opposite branches. You’ll soon see the purpose of the opposite branches.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table7-1">Table 7-1</a>: <code>j</code><var>cc</var> Instructions That Test Flags<span epub:type="pagebreak" title="391" id="Page_391"/></p></figcaption>
<table id="table-501089c07-0001" border="1">
<thead>
<tr>
<td><b>Instruction</b></td>
<td><b>Description</b></td>
<td><b>Condition</b></td>
<td><b>Aliases</b></td>
<td><b>Opposite</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>jc</code></td>
<td>Jump if carry</td>
<td>Carry = 1</td>
<td><code>jb</code>, <code>jnae</code></td>
<td><code>jnc</code></td>
</tr>
<tr>
<td><code>jnc</code></td>
<td>Jump if no carry</td>
<td>Carry = 0</td>
<td><code>jnb</code>, <code>jae</code></td>
<td><code>jc</code></td>
</tr>
<tr>
<td><code>jz</code></td>
<td>Jump if zero</td>
<td>Zero = 1</td>
<td><code>je</code></td>
<td><code>jnz</code></td>
</tr>
<tr>
<td><code>jnz</code></td>
<td>Jump if not zero</td>
<td>Zero = 0</td>
<td><code>jne</code></td>
<td><code>jz</code></td>
</tr>
<tr>
<td><code>js</code></td>
<td>Jump if sign</td>
<td>Sign = 1</td>
<td/>
<td><code>jns</code></td>
</tr>
<tr>
<td><code>jns</code></td>
<td>Jump if no sign</td>
<td>Sign = 0</td>
<td/>
<td><code>js</code></td>
</tr>
<tr>
<td><code>jo</code></td>
<td>Jump if overflow</td>
<td>Overflow = 1</td>
<td/>
<td><code>jno</code></td>
</tr>
<tr>
<td><code>jno</code></td>
<td>Jump if no overflow</td>
<td>Overflow = 0</td>
<td/>
<td><code>jo</code></td>
</tr>
<tr>
<td><code>jp</code></td>
<td>Jump if parity</td>
<td>Parity = 1</td>
<td><code>jpe</code></td>
<td><code>jnp</code></td>
</tr>
<tr>
<td><code>jpe</code></td>
<td>Jump if parity even</td>
<td>Parity = 1</td>
<td><code>jp</code></td>
<td><code>jpo</code></td>
</tr>
<tr>
<td><code>jnp</code></td>
<td>Jump if no parity</td>
<td>Parity = 0</td>
<td><code>jpo</code></td>
<td><code>jp</code></td>
</tr>
<tr>
<td><code>jpo</code></td>
<td>Jump if parity odd</td>
<td>Parity = 0</td>
<td><code>jnp</code></td>
<td><code>jpe</code></td>
</tr>
</tbody>
</table>
</figure>
<figure>
<figcaption class="TableTitle"><p><a id="table7-2">Table 7-2</a>: <code>j</code><var>cc</var> Instructions for Unsigned Comparisons</p></figcaption>
<table id="table-501089c07-0002" border="1">
<thead>
<tr>
<td><b>Instruction</b></td>
<td><b>Description</b></td>
<td><b>Condition</b></td>
<td><b>Aliases</b></td>
<td><b>Opposite</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>ja</code></td>
<td>Jump if above (<code>&gt;</code>)</td>
<td>Carry = 0, Zero = 0</td>
<td><code>jnbe</code></td>
<td><code>jna</code></td>
</tr>
<tr>
<td><code>jnbe</code></td>
<td>Jump if not below or equal (not <code>≤</code>)</td>
<td>Carry = 0, Zero = 0</td>
<td><code>ja</code></td>
<td><code>jbe</code></td>
</tr>
<tr>
<td><code>jae</code></td>
<td>Jump if above or equal (<code>≥</code>)</td>
<td>Carry = 0</td>
<td><code>jnc</code>, <code>jnb</code></td>
<td><code>jnae</code></td>
</tr>
<tr>
<td><code>jnb</code></td>
<td>Jump if not below (not <code>&lt;</code>)</td>
<td>Carry = 0</td>
<td><code>jnc</code>, <code>jae</code></td>
<td><code>jb</code></td>
</tr>
<tr>
<td><code>jb</code></td>
<td>Jump if below (<code>&lt;</code>)</td>
<td>Carry = 1</td>
<td><code>jc</code>, <code>jnae</code></td>
<td><code>jnb</code></td>
</tr>
<tr>
<td><code>jnae</code></td>
<td>Jump if not above or equal (not <code>≥</code>)</td>
<td>Carry = 1</td>
<td><code>jc</code>, <code>jb</code></td>
<td><code>jae</code></td>
</tr>
<tr>
<td><code>jbe</code></td>
<td>Jump if below or equal (<code>≤</code>)</td>
<td>Carry = 1 or Zero = 1</td>
<td><code>jna</code></td>
<td><code>jnbe</code></td>
</tr>
<tr>
<td><code>jna</code></td>
<td>Jump if not above (not <code>&gt;</code>)</td>
<td>Carry = 1 or Zero = 1</td>
<td><code>jbe</code></td>
<td><code>ja</code></td>
</tr>
<tr>
<td><code>je</code></td>
<td>Jump if equal (<code>=</code>)</td>
<td>Zero = 1</td>
<td><code>jz</code></td>
<td><code>jne</code></td>
</tr>
<tr>
<td><code>jne</code></td>
<td>Jump if not equal (<code>≠</code>)</td>
<td>Zero = 0</td>
<td><code>jnz</code></td>
<td><code>je</code></td>
</tr>
</tbody>
</table>
</figure>
<figure>
<figcaption class="TableTitle"><p><a id="table7-3">Table 7-3</a>: <code>j</code><var>cc</var> Instructions for Signed Comparisons</p></figcaption>
<table id="table-501089c07-0003" border="1">
<thead>
<tr>
<td><b>Instruction</b></td>
<td><b>Description</b></td>
<td><b>Condition</b></td>
<td><b>Aliases</b></td>
<td><b>Opposite</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>jg</code></td>
<td>Jump if greater (<code>&gt;</code>)</td>
<td>Sign = Overflow or Zero = 0</td>
<td><code>jnle</code></td>
<td><code>jng</code></td>
</tr>
<tr>
<td><code>jnle</code></td>
<td>Jump if not less than or equal (not <code>≤</code>)</td>
<td>Sign = Overflow or Zero = 0</td>
<td><code>jg</code></td>
<td><code>jle</code></td>
</tr>
<tr>
<td><code><span epub:type="pagebreak" title="392" id="Page_392"/>jge</code></td>
<td>Jump if greater than or equal (<code>≥</code>)</td>
<td>Sign = Overflow</td>
<td><code>jnl</code></td>
<td><code>jnge</code></td>
</tr>
<tr>
<td><code>jnl</code></td>
<td>Jump if not less than (not <code>&lt;</code>)</td>
<td>Sign = Overflow</td>
<td><code>jge</code></td>
<td><code>jl</code></td>
</tr>
<tr>
<td><code>jl</code></td>
<td>Jump if less than (<code>&lt;</code>)</td>
<td>Sign <code>≠</code> Overflow</td>
<td><code>jnge</code></td>
<td><code>jnl</code></td>
</tr>
<tr>
<td><code>jnge</code></td>
<td>Jump if not greater or equal (not <code>≥</code>)</td>
<td>Sign <code>≠</code> Overflow</td>
<td><code>jl</code></td>
<td><code>jge</code></td>
</tr>
<tr>
<td><code>jle</code></td>
<td>Jump if less than or equal (<code>≤</code>)</td>
<td>Sign <code>≠</code> Oveflow or Zero = 1</td>
<td><code>jng</code></td>
<td><code>jnle</code></td>
</tr>
<tr>
<td><code>jng</code></td>
<td>Jump if not greater than (not <code>&gt;</code>)</td>
<td>Sign <code>≠</code> Overflow or Zero = 1</td>
<td><code>jle</code></td>
<td><code>jg</code></td>
</tr>
<tr>
<td><code>je</code></td>
<td>Jump if equal (<code>=</code>)</td>
<td>Zero = 1</td>
<td><code>jz</code></td>
<td><code>jne</code></td>
</tr>
<tr>
<td><code>jne</code></td>
<td>Jump if not equal (<code>≠</code>)</td>
<td>Zero = 0</td>
<td><code>jnz</code></td>
<td><code>je</code></td>
</tr>
</tbody>
</table>
</figure>
<p>In many instances, you will need to generate the opposite of a specific branch instruction (examples appear later in this section). With only two exceptions, the <em>opposite branch (N/No N)</em> rule describes how to generate an opposite branch:</p>
<ul>
<li>If the second letter of the <code>j</code><var>cc</var> instruction is not an <code>n</code>, insert an <code>n</code> after the <code>j</code>. For example, <code>je</code> becomes <code>jne</code>, and <code>jl</code> becomes <code>jnl</code>.</li>
<li>If the second letter of the <code>j</code><var>cc</var> instruction is an <code>n</code>, remove that <code>n</code> from the instruction. For example, <code>jng</code> becomes <code>jg</code>, and <code>jne</code> becomes <code>je</code>.</li>
</ul>
<p>The two exceptions to this rule are <code>jpe</code> (<em>jump if parity is even</em>) and <code>jpo</code> (<em>jump if parity is odd</em>).<sup class="FootnoteReference"><a id="c07-footnoteref-2" href="#c07-footnote-2">2</a></sup> However, you can use the aliases <code>jp</code> and <code>jnp</code> as synonyms for <code>jpe</code> and <code>jpo</code>, and the N/No N rule applies to <code>jp</code> and <code>jnp</code>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Though you <em>know</em> that <code>jge</code> is the opposite of <code>jl</code>, get in the habit of using <code>jnl</code> rather than <code>jge</code> as the opposite jump instruction for <code>jl</code>. It’s too easy in an important situation to start thinking, “Greater is the opposite of less,” and substitute <code>jg</code> instead. You can avoid this confusion by always using the N/No N rule.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The x86-64 conditional jump instructions give you the ability to split program flow into one of two paths depending on a certain condition. Suppose you want to increment the AX register if BX is equal to CX. You can accomplish this with the following code:</p>
<pre><code>          cmp bx, cx
          jne SkipStmts;
          inc ax
SkipStmts:</code></pre>
<p><span epub:type="pagebreak" title="393" id="Page_393"/>Instead of checking for equality directly and branching to code to handle that condition, the common approach is to use the opposite branch to skip over the instructions you want to execute if the condition is true. That is, if BX is <em>not</em> equal to CX, jump over the increment instruction. Always use the opposite branch (N/No N) rule given earlier to select the opposite branch.</p>
<p>You can also use the conditional jump instructions to synthesize loops. For example, the following code sequence reads a sequence of characters from the user and stores each character in successive elements of an array until the user presses <span class="KeyCaps">enter</span> (newline):</p>
<pre><code>      mov edi, 0
RdLnLoop:
      call getchar         ; Some function that reads a character
                           ; into the AL register
      mov Input[rdi], al   ; Store away the character
      inc rdi              ; Move on to the next character
      cmp al, nl           ; See if the user pressed ENTER
      jne RdLnLoop</code></pre>
<p>The conditional jump instructions only test the x86-64 flags; they do not affect any of them.</p>
<p>From an efficiency point of view, it’s important to note that each conditional jump has two machine code encodings: a 2-byte form and a 6-byte form.</p>
<p>The 2-byte form consists of the <code>j</code><var>cc</var> opcode followed by a 1-byte PC-relative displacement. The 1-byte displacement allows the instruction to transfer control to a target instruction within about ±127 bytes around the current instruction. Given that the average x86-64 instruction is probably 4 to 5 bytes long, the 2-byte form of <code>j</code><var>cc</var> is capable of branching to a target instruction within about 20 to 25 instructions.</p>
<p>Because a range of 20 to 25 instructions is insufficient for all conditional jumps, the x86-64 provides a second (6-byte) form with a 2-byte opcode and a 4-byte displacement. The 6-byte form gives you the ability to jump to an instruction within approximately ±2GB of the current instruction, which is probably sufficient for any reasonable program out there.</p>
<p>If you have the opportunity to branch to a nearby label rather than one that is far away (and still achieve the same result), branching to the nearby label will make your code shorter and possibly faster.</p>
<h2 id="h1-501089c07-0004">	7.4	Trampolines</h2>
<p class="BodyFirst">In the rare case you need to branch to a location beyond the range of the 6-byte <code>j</code><var>cc</var> instructions, you can use an instruction sequence such as the following:</p>
<pre><code>        jn<var>cc</var>  skipJmp  ; Opposite jump of the one you want to use
        jmp   destPtr  ; JMP PC-relative is also limited to ±2GB
destPtr qword destLbl  ; so code must use indirect jump
skipJmp:</code></pre>
<p><span epub:type="pagebreak" title="394" id="Page_394"/>The opposite conditional branch transfers control to the normal <em>fall-though point</em> in the code (the code you’d normally fall through to if the condition is false). If the condition is true, control transfers to a memory-indirect jump that jumps to the original target location via a 64-bit pointer.</p>
<p>This sequence is known as a <em>trampoline</em>, because a program jumps to this point to jump even further in the program (much like how jumping on a trampoline lets you jump higher and higher). Trampolines are useful for call and unconditional jump instructions that use the PC-relative addressing mode (and, thus, are limited to a ±2GB range around the current instruction).</p>
<p>You’ll rarely use trampolines to transfer to another location within your program. However, trampolines are useful when transferring control to a dynamically linked library or OS subroutine that could be far away in memory.</p>
<h2 id="h1-501089c07-0005">	7.5	Conditional Move Instructions</h2>
<p class="BodyFirst">Sometimes all you need to do after a comparison or other conditional test is to load a value into a register (and, conversely, not load that value if the test or comparison fails). Because branches can be somewhat expensive to execute, the x86-64 CPUs support a set of conditional move instructions, <code>cmov</code><var>cc</var>. These instructions appear in Tables 7-4, 7-5, and 7-6; the generic syntax for these instructions is as follows:</p>
<pre><code>cmov<em>cc</em> <var>reg</var><sub>16</sub>, <var>reg</var><sub>16</sub>
cmov<em>cc</em> <var>reg</var><sub>16</sub>, <var>mem</var><sub>16</sub>
cmov<em>cc</em> <var>reg</var><sub>32</sub>, <var>reg</var><sub>32</sub>
cmov<em>cc</em> <var>reg</var><sub>32</sub>, <var>mem</var><sub>32</sub>
cmov<em>cc</em> <var>reg</var><sub>64</sub>, <var>reg</var><sub>64</sub>
cmov<em>cc</em> <var>reg</var><sub>64</sub>, <var>mem</var><sub>64</sub></code></pre>
<p>The destination is always a general-purpose register (16, 32, or 64 bits). You can use these instructions only to load a register from memory or copy data from one register to another; you cannot use them to conditionally store data to memory.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table7-4">Table 7-4</a>: <code>cmov</code><var>cc</var> Instructions That Test Flags</p></figcaption>
<table id="table-501089c07-0004" border="1">
<thead>
<tr>
<td><b>Instruction</b></td>
<td><b>Description</b></td>
<td><b>Condition</b></td>
<td><b>Aliases</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>cmovc</code></td>
<td>Move if carry</td>
<td>Carry = 1</td>
<td><code>cmovb</code>,<code> cmovnae</code></td>
</tr>
<tr>
<td><code>cmovnc</code></td>
<td>Move if no carry</td>
<td>Carry = 0</td>
<td><code>cmovnb</code>,<code> cmovae</code></td>
</tr>
<tr>
<td><code>cmovz</code></td>
<td>Move if zero</td>
<td>Zero = 1</td>
<td><code>cmove</code></td>
</tr>
<tr>
<td><code>cmovnz</code></td>
<td>Move if not zero</td>
<td>Zero = 0</td>
<td><code>cmovne</code></td>
</tr>
<tr>
<td><code>cmovs</code></td>
<td>Move if sign</td>
<td>Sign = 1</td>
<td/>
</tr>
<tr>
<td><code>cmovns</code></td>
<td>Move if no sign</td>
<td>Sign = 0</td>
<td/>
</tr>
<tr>
<td><code>cmovo</code></td>
<td>Move if overflow</td>
<td>Overflow = 1</td>
<td/>
</tr>
<tr>
<td><code><span epub:type="pagebreak" title="395" id="Page_395"/>cmovno</code></td>
<td>Move if no overflow</td>
<td>Overflow = 0</td>
<td/>
</tr>
<tr>
<td><code>cmovp</code></td>
<td>Move if parity</td>
<td>Parity = 1</td>
<td><code>cmovpe</code></td>
</tr>
<tr>
<td><code>cmovpe</code></td>
<td>Move if parity even</td>
<td>Parity = 1</td>
<td><code>cmovp</code></td>
</tr>
<tr>
<td><code>cmovnp</code></td>
<td>Move if no parity</td>
<td>Parity = 0</td>
<td><code>cmovpo</code></td>
</tr>
<tr>
<td><code>cmovpo</code></td>
<td>Move if parity odd</td>
<td>Parity = 0</td>
<td><code>cmovnp</code></td>
</tr>
</tbody>
</table>
</figure>
<figure>
<figcaption class="TableTitle"><p><a id="table7-5">Table 7-5</a>: <code>cmov</code><var>cc</var> Instructions for Unsigned Comparisons</p></figcaption>
<table id="table-501089c07-0005" border="1">
<thead>
<tr>
<td><b>Instruction</b></td>
<td><b>Description</b></td>
<td><b>Condition</b></td>
<td><b>Aliases</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>cmova</code></td>
<td>Move if above (<code>&gt;</code>)</td>
<td>Carry = 0, Zero = 0</td>
<td><code>cmovnbe</code></td>
</tr>
<tr>
<td><code>cmovnbe</code></td>
<td>Move if not below or equal (not <code>≤</code>)</td>
<td>Carry = 0, Zero = 0</td>
<td><code>cmova</code></td>
</tr>
<tr>
<td><code>cmovae</code></td>
<td>Move if above or equal (<code>≥</code>)</td>
<td>Carry = 0</td>
<td><code>cmovnc</code>,<code> cmovnb</code></td>
</tr>
<tr>
<td><code>cmovnb</code></td>
<td>Move if not below (not <code>&lt;</code>)</td>
<td>Carry = 0</td>
<td><code>cmovnc</code>,<code> cmovae</code></td>
</tr>
<tr>
<td><code>cmovb</code></td>
<td>Move if below (<code>&lt;</code>)</td>
<td>Carry = 1</td>
<td><code>cmovc</code>,<code> cmovnae</code></td>
</tr>
<tr>
<td><code>cmovnae</code></td>
<td>Move if not above or equal (not <code>≥</code>)</td>
<td>Carry = 1</td>
<td><code>cmovc</code>,<code> cmovb</code></td>
</tr>
<tr>
<td><code>cmovbe</code></td>
<td>Move if below or equal (<code>≤</code>)</td>
<td>Carry = 1 or Zero = 1</td>
<td><code>cmovna</code></td>
</tr>
<tr>
<td><code>cmovna</code></td>
<td>Move if not above (not <code>&gt;</code>)</td>
<td>Carry = 1 or Zero = 1</td>
<td><code>cmovbe</code></td>
</tr>
<tr>
<td><code>cmove</code></td>
<td>Move if equal (<code>=</code>)</td>
<td>Zero = 1</td>
<td><code>cmovz</code></td>
</tr>
<tr>
<td><code>cmovne</code></td>
<td>Move if not equal (<code>≠</code>)</td>
<td>Zero = 0</td>
<td><code>cmovnz</code></td>
</tr>
</tbody>
</table>
</figure>
<figure>
<figcaption class="TableTitle"><p><a id="table7-6">Table 7-6</a>: <code>cmov</code><var>cc</var> Instructions for Signed Comparisons</p></figcaption>
<table id="table-501089c07-0006" border="1">
<thead>
<tr>
<td><b>Instruction</b></td>
<td><b>Description</b></td>
<td><b>Condition</b></td>
<td><b>Aliases</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>cmovg</code></td>
<td>Move if greater (<code>&gt;</code>)</td>
<td>Sign = Overflow or Zero = 0</td>
<td><code>cmovnle</code></td>
</tr>
<tr>
<td><code>cmovnle</code></td>
<td>Move if not less than or equal (not <code>≤</code>)</td>
<td>Sign = Overflow or Zero = 0</td>
<td><code>cmovg</code></td>
</tr>
<tr>
<td><code>cmovge</code></td>
<td>Move if greater than or equal (<code>≥</code>)</td>
<td>Sign = Overflow</td>
<td><code>cmovnl</code></td>
</tr>
<tr>
<td><code>cmovnl</code></td>
<td>Move if not less than (not <code>&lt;</code>)</td>
<td>Sign = Overflow</td>
<td><code>cmovge</code></td>
</tr>
<tr>
<td><code>cmovl</code></td>
<td>Move if less than (<code>&lt;</code>)</td>
<td>Sign != Overflow</td>
<td><code>cmovnge</code></td>
</tr>
<tr>
<td><code>cmovnge</code></td>
<td>Move if not greater or equal (not <code>≥</code>)</td>
<td>Sign != Overflow</td>
<td><code>cmovl</code></td>
</tr>
<tr>
<td><code>cmovle</code></td>
<td>Move if less than or equal (<code>≤</code>)</td>
<td>Sign != Overflow or Zero = 1</td>
<td><code>cmovng</code></td>
</tr>
<tr>
<td><code>cmovng</code></td>
<td>Move if not greater than (not <code>&gt;</code>)</td>
<td>Sign != Overflow or Zero = 1</td>
<td><code>cmovle</code></td>
</tr>
<tr>
<td><code>cmove</code></td>
<td>Move if equal (<code>=</code>)</td>
<td>Zero = 1</td>
<td><code>cmovz</code></td>
</tr>
<tr>
<td><code>cmovne</code></td>
<td>Move if not equal (<code>≠</code>)</td>
<td>Zero = 0</td>
<td><code>cmovnz</code></td>
</tr>
</tbody>
</table>
</figure>
<p><span epub:type="pagebreak" title="396" id="Page_396"/>In addition, a set of conditional floating-point move instructions (<code>fcmov</code><var>cc</var>) will move data between ST0 and one of the other FPU registers on the FPU stack. Sadly, these instructions aren’t all that useful in modern programs. See the Intel documentation for more details if you’re interested in using them.</p>
<h2 id="h1-501089c07-0006">	7.6	Implementing Common Control Structures in Assembly Language</h2>
<p class="BodyFirst">This section shows you how to implement decisions, loops, and other control constructs using pure assembly language.</p>
<h3 id="h2-501089c07-0005">7.6.1	Decisions</h3>
<p class="BodyFirst">In its most basic form, a <em>decision</em> is a branch within the code that switches between two possible execution paths based on a certain condition. Normally (though not always), conditional instruction sequences are implemented with the conditional jump instructions. Conditional instructions correspond to the <code>if/then/endif</code> statement in an HLL:</p>
<pre><code>if(<var>expression</var>) then
    <var>Statements</var>
endif;</code></pre>
<p>To convert this to assembly language, you must write statements that evaluate the <var>expression</var> and then branch around the <var>statements</var> if the result is false. For example, if you had the C statements</p>
<pre><code>if(a == b)
{
    printf("a is equal to b \ n");
} </code></pre>
<p class="BodyContinued">you could translate this to assembly as follows:</p>
<pre><code>      mov  eax, a           ; Assume a and b are 32-bit integers
      cmp  eax, b
      jne  aNEb
      lea  rcx, aIsEqlBstr  ; "a is equal to b \ n"
      call printf
aNEb:</code></pre>
<p>In general, conditional statements may be broken into three basic categories: <code>if</code> statements, <code>switch</code>/<code>case</code> statements, and indirect jumps. The following sections describe these program structures, how to use them, and how to write them in assembly language.</p>
<h3 id="h2-501089c07-0006"><span epub:type="pagebreak" title="397" id="Page_397"/>7.6.2	if/then/else Sequences</h3>
<p class="BodyFirst">The most common conditional statements are the <code>if/then/endif</code> and <code>if/then/else/endif</code> statements. These two statements take the form shown in <a href="#figure7-1" id="figureanchor7-1">Figure 7-1</a>.</p>
<figure>
<img src="image_fi/501089c07/f07001.png" alt="f07001" class=""/>
<figcaption><p><a id="figure7-1">Figure 7-1</a>: <span class="LiteralInCaption"><code>if</code></span><span class="LiteralInCaption"><code>/</code></span><span class="LiteralInCaption"><code>then</code></span><span class="LiteralInCaption"><code>/</code></span><span class="LiteralInCaption"><code>else</code></span><span class="LiteralInCaption"><code>/</code></span><span class="LiteralInCaption"><code>endif</code></span> and <span class="LiteralInCaption"><code>if</code></span><span class="LiteralInCaption"><code>/</code></span><span class="LiteralInCaption"><code>then</code></span><span class="LiteralInCaption"><code>/</code></span><span class="LiteralInCaption"><code>endif</code></span> statement flow</p></figcaption>
</figure>
<p>The <code>if/then/endif</code> statement is just a special case of the <code>if/then/else/endif</code> statement (with an empty <code>else</code> block). The basic implementation of an <code>if/then/else/endif</code> statement in x86-64 assembly language looks something like</p>
<pre><code><var>    Sequence of statements to test a condition</var>
          j<var>cc</var> ElseCode;

<var>    Sequence of statements corresponding to the THEN block</var>
          jmp EndOfIf

ElseCode: 
<var>    Sequence of statements corresponding to the ELSE block</var>

EndOfIf:</code></pre>
<p class="BodyContinued">where <code>j</code><var>cc</var> represents a conditional jump instruction.</p>
<p><span epub:type="pagebreak" title="398" id="Page_398"/>For example, to convert the C/C++ statement</p>
<pre><code>if(a == b)
    c = d;
else 
    b = b + 1;</code></pre>
<p class="BodyContinued">to assembly language, you could use the following x86-64 code:</p>
<pre><code>          mov eax, a
          cmp eax, b
          jne ElseBlk
          mov eax, d
          mov c, eax
          jmp EndOfIf;

ElseBlk:
          inc b

EndOfIf: </code></pre>
<p>For simple expressions like <code>(a == b)</code>, generating the proper code for an <code>if/then/else/endif</code> statement is almost trivial. Should the expression become more complex, the code complexity increases as well. Consider the following C/C++ <code>if</code> statement presented earlier:</p>
<pre><code>if(((x &gt; y) &amp;&amp; (z &lt; t)) || (a != b))
    c = d;</code></pre>
<p>To convert complex <code>if</code> statements such as this one, break it into a sequence of three <code>if</code> statements as follows:</p>
<pre><code>if(a != b) c = d;
else if(x &gt; y)
     if(z &lt; t)
           c = d;</code></pre>
<p>This conversion comes from the following C/C++ equivalences:</p>
<pre><code>if(<var>expr1</var> &amp;&amp; <var>expr2</var>) <var>Stmt</var>;</code></pre>
<p class="BodyContinued">is equivalent to</p>
<pre><code>if(<var>expr1</var>) if(<var>expr2</var>) <var>Stmt</var>;</code></pre>
<p class="BodyContinued">and</p>
<pre><code>if(<var>expr1</var> || <var>expr2</var>) <var>Stmt</var>;</code></pre>
<p class="BodyContinued">is equivalent to</p>
<pre><code>if(<var>expr1</var>) <var>Stmt</var>;
else if(<var>expr2</var>) <var>Stmt</var>;</code></pre>
<p><span epub:type="pagebreak" title="399" id="Page_399"/>In assembly language, the former <code>if</code> statement becomes</p>
<pre><code>; if(((x &gt; y) &amp;&amp; (z &lt; t)) || (a != b))c = d;

          mov eax, a
          cmp eax, b
          jne DoIf;
          mov eax, x
          cmp eax, y
          jng EndOfIf;
          mov eax, z
          cmp eax, t
          jnl EndOfIf;
DoIf:
          mov eax, d
          mov c, eax
EndOfIf:</code></pre>
<p>Probably the biggest problem with complex conditional statements in assembly language is trying to figure out what you’ve done after you’ve written the code. High-level language expressions are much easier to read and comprehend. Well-written comments are essential for clear assembly language implementations of <code>if/then/else/endif</code> statements. An elegant implementation of the preceding example follows:</p>
<pre><code>; if ((x &gt; y) &amp;&amp; (z &lt; t)) or (a != b)  c = d;
; Implemented as: 
; if (a != b) then goto DoIf: 

          mov eax, a
          cmp eax, b
          jne DoIf

; if not (x &gt; y) then goto EndOfIf:

          mov eax, x
          cmp eax, y
          jng EndOfIf

; if not (z &lt; t) then goto EndOfIf:

          mov eax, z
          cmp eax, t
          jnl EndOfIf

; THEN block:

DoIf:     
          mov eax, d
          mov c, eax

; End of IF statement.

EndOfIf:</code></pre>
<p><span epub:type="pagebreak" title="400" id="Page_400"/>Admittedly, this goes overboard for such a simple example. The following would probably suffice:</p>
<pre><code>; if (((x &gt; y) &amp;&amp; (z &lt; t)) || (a != b))  c = d;
; Test the Boolean expression:

          mov eax, a
          cmp eax, b
          jne DoIf
          mov eax, x
          cmp eax, y
          jng EndOfIf
          mov eax, z
          cmp eax, t
          jnl EndOfIf

; THEN block:

DoIf:
          mov eax, d
          mov c, eax

; End of IF statement.

EndOfIf: </code></pre>
<p>However, as your <code>if</code> statements become complex, the density (and quality) of your comments becomes more and more important.</p>
<h3 id="h2-501089c07-0007">7.6.3	Complex if Statements Using Complete Boolean Evaluation</h3>
<p class="BodyFirst">Many Boolean expressions involve conjunction (<code>and</code>) or disjunction (<code>or</code>) operations. This section describes how to convert such Boolean expressions into assembly language. We can do this in two ways: using <em>complete Boolean evaluation</em> or using <em>short-circuit Boolean evaluation</em>. This section discusses complete Boolean evaluation. The next section discusses short-circuit Boolean evaluation.</p>
<p>Conversion via complete Boolean evaluation is almost identical to converting arithmetic expressions into assembly language, as covered in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>. However, for Boolean evaluation, you do not need to store the result in a variable; once the evaluation of the expression is complete, you check whether you have a false (0) or true (1, or nonzero) result to take whatever action the Boolean expression dictates. Usually, the last logical instruction (<code>and</code>/<code>or</code>) sets the zero flag if the result is false and clears the zero flag if the result is true, so you don’t have to explicitly test for the result. Consider the following <code>if</code> statement and its conversion to assembly language using complete Boolean evaluation:</p>
<pre><code>;     if(((x &lt; y) &amp;&amp; (z &gt; t)) || (a != b))
;          <var>Stmt1</var> 

          mov  eax, x
<span epub:type="pagebreak" title="401" id="Page_401"/>          cmp   eax, y
          setl  bl        ; Store x &lt; y in BL
          mov   eax, z
          cmp   eax, t
          setg  bh        ; Store z &gt; t in BH
          and   bl, bh    ; Put (x &lt; y) &amp;&amp; (z &gt; t) into BL
          mov   eax, a
          cmp   eax, b
          setne bh        ; Store a != b into BH
          or    bl, bh    ; Put (x &lt; y) &amp;&amp; (z &gt; t) || (a != b) into BL
          je    SkipStmt1 ; Branch if result is false

<var>      Code for Stmt1 goes here</var>

SkipStmt1:</code></pre>
<p>This code computes a Boolean result in the BL register and then, at the end of the computation, tests this value to see whether it contains true or false. If the result is false, this sequence skips over the code associated with <code>Stmt1</code>. The important thing to note in this example is that the program will execute every instruction that computes this Boolean result (up to the <code>je</code> instruction).</p>
<h3 id="h2-501089c07-0008">7.6.4	Short-Circuit Boolean Evaluation</h3>
<p class="BodyFirst">If you are willing to expend a little more effort, you can usually convert a Boolean expression to a much shorter and faster sequence of assembly language instructions by using <em>short-circuit Boolean evaluation</em>. This approach attempts to determine whether an expression is true or false by executing only some of the instructions that would compute the complete expression. </p>
<p>Consider the expression <code>a &amp;&amp; b</code>. Once we determine that <code>a</code> is false, there is no need to evaluate <code>b</code> because there is no way the expression can be true. If <code>b</code> represents a complex subexpression rather than a single Boolean variable, it should be clear that evaluating only <code>a</code> is more efficient. </p>
<p>As a concrete example, consider the subexpression <code>((x &lt; y) &amp;&amp; (z &gt; t))</code> from the previous section. Once you determine that <code>x</code> is not less than <code>y</code>, there is no need to check whether <code>z</code> is greater than <code>t</code> because the expression will be false regardless of <code>z</code>’s and <code>t</code>’s values. The following code fragment shows how you can implement short-circuit Boolean evaluation for this expression:</p>
<pre><code>; if((x &lt; y) &amp;&amp; (z &gt; t)) then ...

          mov eax, x
          cmp eax, y
          jnl TestFails
          mov eax, z
          cmp eax, t
          jng TestFails

<var>      Code for THEN clause of IF statement</var>

TestFails:</code></pre>
<p><span epub:type="pagebreak" title="402" id="Page_402"/>The code skips any further testing once it determines that <code>x</code> is not less than <code>y</code>. Of course, if <code>x</code> is less than <code>y</code>, the program has to test <code>z</code> to see if it is greater than <code>t</code>; if not, the program skips over the <code>then</code> clause. Only if the program satisfies both conditions does the code fall through to the <code>then</code> clause.</p>
<p>For the logical <code>or</code> operation, the technique is similar. If the first subexpression evaluates to true, there is no need to test the second operand. Whatever the second operand’s value is at that point, the full expression still evaluates to true. The following example demonstrates the use of short-circuit evaluation with disjunction (<code>or</code>):</p>
<pre><code>; if(ch &lt; 'A' || ch &gt; 'Z')
;     then printf("Not an uppercase char");
; endif;

          cmp ch, 'A'
          jb ItsNotUC
          cmp ch, 'Z'
          jna ItWasUC

ItsNotUC:
<var>  Code to process ch if it's not an uppercase character</var>

ItWasUC:</code></pre>
<p>Because the conjunction and disjunction operators are commutative, you can evaluate the left or right operand first if it is more convenient to do so.<sup class="FootnoteReference"><a id="c07-footnoteref-3" href="#c07-footnote-3">3</a></sup> As one last example in this section, consider the full Boolean expression from the previous section:</p>
<pre><code>; if(((x &lt; y) &amp;&amp; (z &gt; t)) || (a != b)) <var> Stmt1 </var>;

          mov eax, a
          cmp eax, b
          jne DoStmt1
          mov eax, x
          cmp eax, y
          jnl SkipStmt1
          mov eax, z
          cmp eax, t
          jng SkipStmt1

DoStmt1:
<var>       Code for Stmt1 goes here</var>

SkipStmt1:</code></pre>
<p><span epub:type="pagebreak" title="403" id="Page_403"/>The code in this example evaluates <code>a != b</code> first, because it is shorter and faster,<sup class="FootnoteReference"><a id="c07-footnoteref-4" href="#c07-footnote-4">4</a></sup> and the remaining subexpression last. This is a common technique assembly language programmers use to write better code.<sup class="FootnoteReference"><a id="c07-footnoteref-5" href="#c07-footnote-5">5</a></sup></p>
<h3 id="h2-501089c07-0009">7.6.5	Short-Circuit vs. Complete Boolean Evaluation</h3>
<p class="BodyFirst">When using complete Boolean evaluation, every statement in the sequence for that expression will execute; short-circuit Boolean evaluation, on the other hand, may not require the execution of every statement associated with the Boolean expression. As you’ve seen in the previous two sections, code based on short-circuit evaluation is usually shorter and faster.</p>
<p>However, short-circuit Boolean evaluation may not produce the correct result in some cases. Given an expression with <em>side effects</em>, short-circuit Boolean evaluation will produce a different result than complete Boolean evaluation. Consider the following C/C++ example:</p>
<pre><code>if((x == y) &amp;&amp; (++z != 0)) <var> Stmt </var>;</code></pre>
<p>Using complete Boolean evaluation, you might generate the following code:</p>
<pre><code>          mov   eax, x      ; See if x == y
          cmp   eax, y
          sete  bl 
          inc   z           ; ++z
          cmp   z, 0        ; See if incremented z is 0
          setne bh
          and   bl, bh      ; Test x == y &amp;&amp; ++z != 0
          jz    SkipStmt

<var>          Code for Stmt goes here</var>

SkipStmt:</code></pre>
<p>Using short-circuit Boolean evaluation, you might generate this:</p>
<pre><code>          mov eax, x      ; See if x == y
          cmp eax, y
          jne SkipStmt
          inc z           ; ++z - sets ZF if z becomes zero
          je  SkipStmt    ; See if incremented z is 0

<var>          Code for Stmt goes here</var>

SkipStmt:</code></pre>
<p><span epub:type="pagebreak" title="404" id="Page_404"/>Notice a subtle but important difference between these two conversions: if <code>x</code> is equal to <code>y</code>, the first version still <em>increments</em> <var>z</var> <em>and compares it to 0</em> before it executes the code associated with <code>Stmt</code>; the short-circuit version, on the other hand, skips the code that increments <code>z</code> if it turns out that <code>x</code> is equal to <code>y</code>. Therefore, the behavior of these two code fragments is different if <code>x</code> is equal to <code>y</code>. </p>
<p>Neither implementation is particularly wrong; depending on the circumstances, you may or may not want the code to increment <code>z</code> if <code>x</code> is equal to <code>y</code>. However, it is important to realize that these two schemes produce different results, so you can choose an appropriate implementation if the effect of this code on <code>z</code> matters to your program.</p>
<p>Many programs take advantage of short-circuit Boolean evaluation and rely on the program not evaluating certain components of the expression. The following C/C++ code fragment demonstrates perhaps the most common example that requires short-circuit Boolean evaluation:</p>
<pre><code>if(pntr != NULL &amp;&amp; *pntr == 'a')  <var>Stmt </var>;</code></pre>
<p>If it turns out that <code>pntr</code> is <code>NULL</code>, the expression is false, and there is no need to evaluate the remainder of the expression. This statement relies on short-circuit Boolean evaluation for correct operation. Were C/C++ to use complete Boolean evaluation, the second half of the expression would attempt to dereference a <code>NULL</code> pointer, when <code>pntr</code> is <code>NULL</code>.</p>
<p>Consider the translation of this statement using complete Boolean evaluation:</p>
<pre><code>; Complete Boolean evaluation:

          mov   rax, pntr
          test  rax, rax   ; Check to see if RAX is 0 (NULL is 0)
          setne bl
          mov   al, [rax]  ; Get *pntr into AL
          cmp   al, 'a'
          sete  bh
          and   bl, bh
          jz    SkipStmt

<var>          Code for Stmt goes here</var>

SkipStmt:</code></pre>
<p>If <code>pntr</code> contains <code>NULL (0)</code>, this program will attempt to access the data at location 0 in memory via the <code>mov al, [rax]</code> instruction. Under most operating systems, this will cause a memory access fault (general protection fault).</p>
<p>Now consider the short-circuit Boolean conversion:</p>
<pre><code>; Short-circuit Boolean evaluation:

      mov  rax, pntr   ; See if pntr contains NULL (0) and
      test rax, rax    ; immediately skip past Stmt if this
      jz   SkipStmt    ; is the case

<span epub:type="pagebreak" title="405" id="Page_405"/>      mov  al, [rax]   ; If we get to this point, pntr contains
      cmp  al, 'a'     ; a non-NULL value, so see if it points
      jne  SkipStmt    ; at the character "a"

<var>           Code for Stmt goes here</var>

SkipStmt:</code></pre>
<p>In this example, the problem with dereferencing the <code>NULL</code> pointer doesn’t exist. If <code>pntr</code> contains <code>NULL</code>, this code skips over the statements that attempt to access the memory address <code>pntr</code> contains.</p>
<h3 id="h2-501089c07-0010">7.6.6	Efficient Implementation of if Statements in Assembly Language</h3>
<p class="BodyFirst">Encoding <code>if</code> statements efficiently in assembly language takes a bit more thought than simply choosing short-circuit evaluation over complete Boolean evaluation. To write code that executes as quickly as possible in assembly language, you must carefully analyze the situation and generate the code appropriately. The following paragraphs provide suggestions you can apply to your programs to improve their performance.</p>
<h4 id="h3-501089c07-0001">7.6.6.1	Know Your Data!</h4>
<p class="BodyFirst">Programmers often mistakenly assume that data is random. In reality, data is rarely random, and if you know the types of values that your program commonly uses, you can write better code. To see how, consider the following C/C++ statement:</p>
<pre><code>if((a == b) &amp;&amp; (c &lt; d)) ++i;</code></pre>
<p>Because C/C++ uses short-circuit evaluation, this code will test whether <code>a</code> is equal to <code>b</code>. If so, it will test whether <code>c</code> is less than <code>d</code>. If you expect <code>a</code> to be equal to <code>b</code> most of the time but don’t expect <code>c</code> to be less than <code>d</code> most of the time, this statement will execute slower than it should. Consider the following MASM implementation of this code:</p>
<pre><code>          mov eax, a
          cmp eax, b
          jne DontIncI

          mov eax, c
          cmp eax, d
          jnl DontIncI

          inc i

DontIncI:</code></pre>
<p>As you can see, if <code>a</code> is equal to <code>b</code> most of the time and <code>c</code> is not less than <code>d</code> most of the time, you will have to execute all six instructions nearly every time in order to determine that the expression is false. Now consider the <span epub:type="pagebreak" title="406" id="Page_406"/>following implementation that takes advantage of this knowledge and the fact that the <code>&amp;&amp;</code> operator is commutative:</p>
<pre><code>          mov eax, c
          cmp eax, d
          jnl DontIncI

          mov eax, a
          cmp eax, b
          jne DontIncI

          inc i

DontIncI:</code></pre>
<p>The code first checks whether <code>c</code> is less than <code>d</code>. If most of the time <code>c</code> is less than <code>d</code>, this code determines that it has to skip to the label <code>DontIncI</code> after executing only three instructions in the typical case (compared with six instructions in the previous example).</p>
<p>This fact is much more obvious in assembly language than in a high-level language, one of the main reasons assembly programs are often faster than their HLL counterparts: optimizations are more obvious in assembly language than in a high-level language. Of course, the key here is to understand the behavior of your data so you can make intelligent decisions such as the preceding one.</p>
<h4 id="h3-501089c07-0002">7.6.6.2	Rearranging Expressions</h4>
<p class="BodyFirst">Even if your data is random (or you can’t determine how the input values will affect your decisions), rearranging the terms in your expressions may still be beneficial. Some calculations take far longer to compute than others. For example, the <code>div</code> instruction is much slower than a simple <code>cmp</code> instruction. Therefore, if you have a statement like the following, you may want to rearrange the expression so that the <code>cmp</code> comes first:</p>
<pre><code>if((x % 10 = 0) &amp;&amp; (x != y) ++x;</code></pre>
<p>Converted to assembly code, this <code>if</code> statement becomes the following:</p>
<pre><code>          mov  eax, x        ; Compute X % 10
          cdq                ; Must sign-extend EAX -&gt; EDX:EAX
          idiv ten           ; "ten dword 10" in .const section
          test edx, edx      ; Remainder is in EDX, test for 0
          jnz  SkipIf

          mov  eax, x
          cmp  eax, y
          je   SkipIf

          inc  x

SkipIf:</code></pre>
<p><span epub:type="pagebreak" title="407" id="Page_407"/>The <code>idiv</code> instruction is expensive (often 50 to 100 times slower than most of the other instructions in this example). Unless it is 50 to 100 times more likely that the remainder is 0 rather than <code>x</code> is equal to <code>y</code>, it would be better to do the comparison first and the remainder calculation afterward:</p>
<pre><code>          mov  eax, x
          cmp  eax, y
          je   SkipIf

          mov  eax, x     ; Compute X % 10
          cdq             ; Must sign-extend EAX -&gt; EDX:EAX
          idiv ten        ; "ten dword 10" in .const section
          test edx, edx   ; See if remainder (EDX) is 0
          jnz  SkipIf

          inc  x

SkipIf:</code></pre>
<p>Because the <code>&amp;&amp;</code> and <code>||</code> operators are not commutative when short-circuit evaluation occurs, do consider such transformations carefully when making them. This example works fine because there are no side effects or possible exceptions being shielded by the reordered evaluation of the <code>&amp;&amp;</code> operator.</p>
<h4 id="h3-501089c07-0003">7.6.6.3	Destructuring Your Code</h4>
<p class="BodyFirst">Structured code is sometimes less efficient than unstructured code because it introduces code duplication or extra branches that might not be present in unstructured code.<sup class="FootnoteReference"><a id="c07-footnoteref-6" href="#c07-footnote-6">6</a></sup> Most of the time, this is tolerable because unstructured code is difficult to read and maintain; sacrificing some performance in exchange for maintainable code is often acceptable. In certain instances, however, you may need all the performance you can get and might choose to compromise the readability of your code.</p>
<p>Taking previously written structured code and rewriting it in an unstructured fashion to improve performance is known as <em>destructuring code</em>. The difference between unstructured code and destructured code is that unstructured code was written that way in the first place; destructured code started out as structured code and was purposefully written in an unstructured fashion to make it more efficient. Pure unstructured code is usually hard to read and maintain. Destructured code isn’t quite as bad because you limit the damage (unstructuring the code) to only those sections where it is absolutely necessary.</p>
<p>One classic way to destructure code is to use <em>code movement</em> (physically moving sections of code elsewhere in the program) to move code that your program rarely uses out of the way of code that executes most of the time. Code movement can improve the efficiency of a program in two ways. </p>
<p><span epub:type="pagebreak" title="408" id="Page_408"/>First, a branch that is taken is more expensive (time-consuming) than a branch that is not taken.<sup class="FootnoteReference"><a id="c07-footnoteref-7" href="#c07-footnote-7">7</a></sup> If you move the rarely used code to another spot in the program and branch to it on the rare occasion the branch is taken, most of the time you will fall straight through to the code that executes most frequently.</p>
<p>Second, sequential machine instructions consume cache storage. If you move rarely executed statements out of the normal code stream to another section of the program (that is rarely loaded into cache), this will improve the cache performance of the system.</p>
<p>For example, consider the following pseudo C/C++ statement:</p>
<pre><code>if(<var>see_if_an_error_has_occurred</var>)
{
<var>    Statements to execute if no error</var>
}
else
{
<var>    Error-handling statements</var>
}</code></pre>
<p>In normal code, we don’t expect errors to be frequent. Therefore, you would normally expect the <code>then</code> section of the preceding <code>if</code> to execute far more often than the <code>else</code> clause. The preceding code could translate into the following assembly code:</p>
<pre><code>     cmp <var>see_if_an_error_has_occurred</var>, true
     je HandleTheError

<var>           Statements to execute if no error</var>

     jmp EndOfIf;

HandleTheError:
<var>           Error-handling statements</var>
EndOfIf:</code></pre>
<p>If the expression is false, this code falls through to the normal statements and then jumps over the error-handling statements. Instructions that transfer control from one point in your program to another (for example, <code>jmp</code> instructions) tend to be slow. It is much faster to execute a sequential set of instructions rather than jump all over the place in your program. Unfortunately, the preceding code doesn’t allow this.</p>
<p>One way to rectify this problem is to move the <code>else</code> clause of the code somewhere else in your program. You could rewrite the code as follows:</p>
<pre><code>     cmp <var>see_if_an_error_has_occurred</var>, true
     je HandleTheError

<span epub:type="pagebreak" title="409" id="Page_409"/><var>          Statements to execute if no error</var>

EndOfIf:</code></pre>
<p>At some other point in your program (typically after a <code>jmp</code> instruction), you would insert the following code:</p>
<pre><code>HandleTheError:
<var>  Error-handling statements</var>
     jmp EndOfIf;</code></pre>
<p>The program isn’t any shorter. The <code>jmp</code> you removed from the original sequence winds up at the end of the <code>else</code> clause. However, because the <code>else</code> clause rarely executes, moving the <code>jmp</code> instruction from the <code>then</code> clause (which executes frequently) to the <code>else</code> clause is a big performance win because the <code>then</code> clause executes using only straight-line code. This technique is surprisingly effective in many time-critical code segments.</p>
<h4 id="h3-501089c07-0004">7.6.6.4	Calculation Rather Than Branching</h4>
<p class="BodyFirst">On many processors in the x86-64 family, branches (jumps) are expensive compared to many other instructions. For this reason, it is sometimes better to execute more instructions in a sequence than fewer instructions that involve branching.</p>
<p>For example, consider the simple assignment <code>eax = abs(eax)</code>. Unfortunately, no x86-64 instruction computes the absolute value of an integer. The obvious way to handle this is with an instruction sequence that uses a conditional jump to skip over the <code>neg</code> instruction (which creates a positive value in EAX if EAX was negative):</p>
<pre><code>          test eax, eax
          jns ItsPositive;

          neg eax

ItsPositive:</code></pre>
<p>Now consider the following sequence that will also do the job:</p>
<pre><code>; Set EDX to 0FFFF_FFFFh if EAX is negative, 0000_0000 if EAX is
; 0 or positive:

          cdq

; If EAX was negative, the following code inverts all the bits in
; EAX; otherwise, it has no effect on EAX.

          xor eax, edx

; If EAX was negative, the following code adds 1 to EAX;
; otherwise, it doesn't modify EAX's value.

<span epub:type="pagebreak" title="410" id="Page_410"/>          and edx, 1   ; EDX = 0 or 1 (1 if EAX was negative)
          add eax, edx</code></pre>
<p>This code will invert all the bits in EAX and then add 1 to EAX if EAX was negative prior to the sequence; that is, it negates the value in EAX. If EAX was zero or positive, this code does not change the value in EAX.</p>
<p>Though this sequence takes four instructions rather than the three that the previous example requires, there are no transfer-of-control instructions, so it may execute faster on many CPUs in the x86-64 family. Of course, if you use the <code>cmovns</code> instruction presented earlier, this can be done with the following three instructions (with no transfer of control):</p>
<pre><code>mov    edx, eax
neg    edx
cmovns eax, edx </code></pre>
<p>This demonstrates why it’s good to know the instruction set!</p>
<h3 id="h2-501089c07-0011">7.6.7	switch/case Statements </h3>
<p class="BodyFirst">The C/C++ <code>switch</code> statement takes the following form:</p>
<pre><code><code> </code>     switch(<var>expression</var>)
      {
          case <var>const1</var>:
<var>            Stmts1: Code to execute if</var>
<var>                    expression equals const1</var>

          case <var>const2</var>:
<var>            Stmts2: Code to execute if</var>
<var>                    expression equals const2</var>
            .
            .
            .
          case <var>constn</var>:
<var>            Stmtsn: Code to execute if</var>
<var>                    expression equals constn</var>

          default:  ; Note that the default section is optional
<var>            Stmts_default: Code to execute if expression</var>
                           <var>does not equal</var>
                           <var>any of the case values</var>
      }</code></pre>
<p>When this statement executes, it checks the value of the <var>expression</var> against the constants <var>const1</var> to <var>constn</var>. If it finds a match, the corresponding statements execute. </p>
<p>C/C++ places a few restrictions on the <code>switch</code> statement. First, the <code>switch</code> statement allows only an integer expression (or something whose underlying type can be an integer). Second, all the constants in the <code>case</code> clauses must be unique. The reason for these restrictions will become clear in a moment.</p>
<h4 id="h3-501089c07-0005"><span epub:type="pagebreak" title="411" id="Page_411"/>7.6.7.1	switch Statement Semantics</h4>
<p class="BodyFirst">Most introductory programming texts introduce the <code>switch/case</code> statement by explaining it as a sequence of <code>if/then/elseif/else/endif</code> statements. They might claim that the following two pieces of C/C++ code are equivalent:</p>
<pre><code>switch(<var>expression</var>)
{
    case 0: printf("i=0"); break;
    case 1: printf("i=1"); break;
    case 2: printf("i=2"); break;
}

if(eax == 0)
    printf("i=0");
else if(eax == 1)
    printf("i=1");
else if(eax == 2)
    printf("i=2");</code></pre>
<p>While semantically these two code segments may be the same, their implementation is usually different. Whereas the <code>if/then/elseif/else/endif</code> chain does a comparison for each conditional statement in the sequence, the <code>switch</code> statement normally uses an indirect jump to transfer control to any one of several statements with a single computation.</p>
<h4 id="h3-501089c07-0006">7.6.7.2	if/else Implementation of switch</h4>
<p class="BodyFirst">The <code>switch</code> (and <code>if/else/elseif</code>) statements could be written in assembly language with the following code:</p>
<pre><code>; if/then/else/endif form:

          mov eax, i
          test eax, eax   ; Check for 0
          jnz Not0

<var>          Code to print "i = 0"</var>
          jmp EndCase

Not0:
          cmp eax, 1
          jne Not1

<var>          Code to print "i = 1"</var>
          jmp EndCase

Not1:
          cmp eax, 2
          jne EndCase;

<var>          Code to print "i = 2"</var>
EndCase: </code></pre>
<p><span epub:type="pagebreak" title="412" id="Page_412"/>Probably the only thing worth noting about this code is that it takes longer to determine the last case than it does to determine whether the first case executes. This is because the <code>if/else/elseif</code> version implements a <em>linear search</em> through the case values, checking them one at a time from first to last until it finds a match.</p>
<h4 id="h3-501089c07-0007">7.6.7.3	Indirect Jump switch Implementation</h4>
<p class="BodyFirst">A faster implementation of the <code>switch</code> statement is possible using an <em>indirect jump table</em>. This implementation uses the switch expression as an index into a table of addresses; each address points at the target case’s code to execute. Consider the following example:</p>
<pre><code>; Indirect Jump Version.

        mov eax, i
        lea rcx, JmpTbl
        jmp qword ptr [rcx][rax * 8]

JmpTbl  qword Stmt0, Stmt1, Stmt2

Stmt0:
<var>        Code to print "i = 0"</var>
        jmp EndCase;

Stmt1:
<var>        Code to print "i = 1"</var>
        jmp EndCase;

Stmt2:
<var>        Code to print "i = 2"</var>

EndCase: </code></pre>
<p>To begin with, a <code>switch</code> statement requires that you create an array of pointers with each element containing the address of a statement label in your code (those labels must be attached to the sequence of instructions to execute for each case in the <code>switch</code> statement). In the preceding example, the <code>JmpTbl</code> array, initialized with the address of the statement labels <code>Stmt0</code>, <code>Stmt1</code>, and <code>Stmt2</code>, serves this purpose. I’ve placed this array in the procedure itself because the labels are local to the procedure. Note, however, that you must place the array in a location that will never be executed as code (such as immediately after a <code>jmp</code> instruction, as in this example).</p>
<p>The program loads the RAX register with <code>i</code>’s value (assuming <code>i</code> is a 32-bit integer, the <code>mov</code> instruction zero-extends EAX into RAX), then uses this value as an index into the <code>JmpTbl</code> array (RCX holds the base address of the <code>JmpTbl</code> array) and transfers control to the 8-byte address found at the specified location. For example, if RAX contains 0, the <code>jmp [rcx][rax * 8]</code> instruction will fetch the quad word at address <code>JmpTbl+0</code> (RAX × 8 = 0). Because the first quad word in the table contains the address of <code>Stmt0</code>, the <code>jmp</code> instruction transfers control to the first instruction following the <code>Stmt0</code> <span epub:type="pagebreak" title="413" id="Page_413"/>label. Likewise, if <code>i</code> (and therefore, RAX) contains 1, then the indirect <code>jmp</code> instruction fetches the quad word at offset 8 from the table and transfers control to the first instruction following the <code>Stmt1</code> label (because the address of <code>Stmt1</code> appears at offset 8 in the table). Finally, if <code>i</code> / RAX contains 2, then this code fragment transfers control to the statements following the <code>Stmt2</code> label because it appears at offset 16 in the <code>JmpTbl</code> table.</p>
<p>As you add more (consecutive) cases, the jump table implementation becomes more efficient (in terms of both space and speed) than the <code>if/elseif</code> form. Except for simple cases, the <code>switch</code> statement is almost always faster, and usually by a large margin. As long as the <code>case</code> values are consecutive, the <code>switch</code> statement version is usually smaller as well.</p>
<h4 id="h3-501089c07-0008">7.6.7.4	Noncontiguous Jump Table Entries and Range Limiting</h4>
<p class="BodyFirst">What happens if you need to include nonconsecutive <code>case</code> labels or cannot be sure that the <code>switch</code> value doesn’t go out of range? With the C/C++ <code>switch</code> statement, such an occurrence will transfer control to the first statement after the <code>switch</code> statement (or to a <code>default</code> case, if one is present in the switch).</p>
<p>However, this doesn’t happen in the preceding example. If variable <code>i</code> does not contain 0, 1, or 2, executing the previous code produces undefined results. For example, if <code>i</code> contains 5 when you execute the code, the indirect <code>jmp</code> instruction will fetch the qword at offset 40 (5 × 8) in <code>JmpTbl</code> and transfer control to that address. Unfortunately, <code>JmpTbl</code> doesn’t have six entries, so the program will fetch the value of the sixth quad word following <code>JmpTbl</code> and use that as the target address, which will often crash your program or transfer control to an unexpected location.</p>
<p>The solution is to place a few instructions before the indirect <code>jmp</code> to verify that the <code>switch</code> selection value is within a reasonable range. In the previous example, we’d probably want to verify that <code>i</code>’s value is in the range 0 to 2 before executing the <code>jmp</code> instruction. If <code>i</code>’s value is outside this range, the program should simply jump to the <code>endcase</code> label (this corresponds to dropping down to the first statement after the entire <code>switch</code> statement). The following code provides this modification:</p>
<pre><code>        mov eax, i
        cmp eax, 2
        ja  EndCase
        lea rcx, JmpTbl
        jmp qword ptr [rcx][rax * 8]

JmpTbl  qword Stmt0, Stmt1, Stmt2

Stmt0:
<var>        Code to print "i = 0"</var>
        jmp EndCase;

Stmt1:
<var>        Code to print "i = 1"</var>
        jmp EndCase;

<span epub:type="pagebreak" title="414" id="Page_414"/>Stmt2:
<var>        Code to print "i = 2"</var>

EndCase:</code></pre>
<p>Although the preceding example handles the problem of selection values being outside the range 0 to 2, it still suffers from a couple of severe restrictions:</p>
<ul>
<li>The cases must start with the value 0. That is, the minimum <code>case</code> constant has to be 0 in this example.</li>
<li>The case values must be contiguous.</li>
</ul>
<p>Solving the first problem is easy, and you deal with it in two steps. First, you compare the case selection value against a lower and upper bound before determining if the case value is legal. For example:</p>
<pre><code>; SWITCH statement specifying cases 5, 6, and 7:
; WARNING: This code does *NOT* work.
; Keep reading to find out why.

     mov eax, i
     cmp eax, 5
     jb  EndCase
     cmp eax, 7              ; Verify that i is in the range
     ja  EndCase             ; 5 to 7 before the indirect jmp
     lea rcx, JmpTbl
     jmp qword ptr [rcx][rax * 8]

JmpTbl  qword Stmt5, Stmt6, Stmt7

Stmt5:
<var>        Code to print "i = 5"</var>
        jmp EndCase;

Stmt6:
<var>        Code to print "i = 6"</var>
        jmp EndCase;

Stmt7:
<var>        Code to print "i = 7"</var>

EndCase:</code></pre>
<p>This code adds a pair of extra instructions, <code>cmp</code> and <code>jb</code>, to test the selection value to ensure it is in the range 5 to 7. If not, control drops down to the <code>EndCase</code> label; otherwise, control transfers via the indirect <code>jmp</code> instruction. Unfortunately, as the comments point out, this code is broken.</p>
<p>Consider what happens if variable <code>i</code> contains the value 5: the code will verify that 5 is in the range 5 to 7 and then will fetch the dword at offset 40 (5 × 8) and jump to that address. As before, however, this loads 8 bytes outside the bounds of the table and does not transfer control to a defined location. <span epub:type="pagebreak" title="415" id="Page_415"/>One solution is to subtract the smallest case selection value from EAX before executing the <code>jmp</code> instruction, as shown in the following example:</p>
<pre><code>; SWITCH statement specifying cases 5, 6, and 7.
; WARNING: There is a better way to do this; keep reading.

     mov eax, i
     cmp eax, 5
     jb  EndCase
     cmp eax, 7              ; Verify that i is in the range
     ja  EndCase             ; 5 to 7 before the indirect jmp
     sub eax, 5              ; 5 to 7 -&gt; 0 to 2
     lea rcx, JmpTbl
     jmp qword ptr [rcx][rax * 8]

JmpTbl  qword Stmt5, Stmt6, Stmt7

Stmt5:
<var>        Code to print "i = 5"</var>
        jmp EndCase;

Stmt6:
<var>        Code to print "i = 6"</var>
        jmp EndCase;

Stmt7:
<var>        Code to print "i = 7"</var>

EndCase: </code></pre>
<p>By subtracting 5 from the value in EAX, we force EAX to take on the value 0, 1, or 2 prior to the <code>jmp</code> instruction. Therefore, case-selection value 5 jumps to <code>Stmt5</code>, case-selection value 6 transfers control to <code>Stmt6</code>, and case-selection value 7 jumps to <code>Stmt7</code>.</p>
<p>To improve this code, you can eliminate the <code>sub</code> instruction by merging it into the <code>jmp</code> instruction’s address expression. The following code does this:</p>
<pre><code>; SWITCH statement specifying cases 5, 6, and 7:

     mov eax, i
     cmp eax, 5
     jb  EndCase
     cmp eax, 7                           ; Verify that i is in the range
     ja  EndCase                          ; 5 to 7 before the indirect jmp
     lea rcx, JmpTbl
     jmp qword ptr [rcx][rax * 8 – 5 * 8] ; 5 * 8 compensates for zero index

JmpTbl  qword Stmt5, Stmt6, Stmt7

Stmt5:
<var>        Code to print "i = 5"</var>
        jmp EndCase;

Stmt6:
<var>        Code to print "i = 6"</var>
<span epub:type="pagebreak" title="416" id="Page_416"/>        jmp EndCase;

Stmt7:
<var>        Code to print "i = 7"</var>

EndCase:</code></pre>
<p>The C/C++ <code>switch</code> statement provides a <code>default</code> clause that executes if the case-selection value doesn’t match any of the case values. For example:</p>
<pre><code>switch(<var>expression</var>)
{

    case 5:  printf("ebx = 5"); break;
    case 6:  printf("ebx = 6"); break;
    case 7:  printf("ebx = 7"); break;
    default
        printf("ebx does not equal 5, 6, or 7");
}</code></pre>
<p>Implementing the equivalent of the <code>default</code> clause in pure assembly language is easy. Just use a different target label in the <code>jb</code> and <code>ja</code> instructions at the beginning of the code. The following example implements a MASM <code>switch</code> statement similar to the preceding one:</p>
<pre><code>; SWITCH statement specifying cases 5, 6, and 7
; with a DEFAULT clause:

     mov eax, i
     cmp eax, 5 
     jb  DefaultCase
     cmp eax, 7                           ; Verify that i is in the range
     ja  DefaultCase                      ; 5 to 7 before the indirect jmp
     lea rcx, JmpTbl
     jmp qword ptr [rcx][rax * 8 – 5 * 8] ; 5 * 8 compensates for zero index

JmpTbl  qword Stmt5, Stmt6, Stmt7

Stmt5:
<var>        Code to print "i = 5"</var>
        jmp EndCase

Stmt6:
<var>        Code to print "i = 6"</var>
        jmp EndCase

Stmt7:
<var>        Code to print "i = 7"</var>
        jmp EndCase

DefaultCase:
<var>        Code to print "EBX does not equal 5, 6, or 7"</var>

EndCase:</code></pre>
<p><span epub:type="pagebreak" title="417" id="Page_417"/>The second restriction noted earlier, (that is, the case values need to be contiguous) is easy to handle by inserting extra entries into the jump table. Consider the following C/C++ <code>switch</code> statement:</p>
<pre><code>switch(i)
{
    case 1  printf("i = 1"); break;
    case 2  printf("i = 2"); break;
    case 4  printf("i = 4"); break;
    case 8  printf("i = 8"); break;
    default:
        printf("i is not 1, 2, 4, or 8");
}</code></pre>
<p>The minimum switch value is 1, and the maximum value is 8. Therefore, the code before the indirect <code>jmp</code> instruction needs to compare the value in <code>i</code> against 1 and 8. If the value is between 1 and 8, it’s still possible that <code>i</code> might not contain a legal case-selection value. However, because the <code>jmp</code> instruction indexes into a table of quad words using the case-selection table, the table must have eight quad-word entries.</p>
<p>To handle the values between 1 and 8 that are not case-selection values, simply put the statement label of the <code>default</code> clause (or the label specifying the first instruction after the <code>endswitch</code> if there is no <code>default</code> clause) in each of the jump table entries that don’t have a corresponding <code>case</code> clause. The following code demonstrates this technique:</p>
<pre><code>; SWITCH statement specifying cases 1, 2, 4, and 8
; with a DEFAULT clause:

     mov eax, i
     cmp eax, 1
     jb  DefaultCase
     cmp eax, 8                           ; Verify that i is in the range
     ja  DefaultCase                      ; 1 to 8 before the indirect jmp
     lea rcx, JmpTbl
     jmp qword ptr [rcx][rax * 8 – 1 * 8] ; 1 * 8 compensates for zero index

JmpTbl  qword Stmt1, Stmt2, DefaultCase, Stmt4
        qword DefaultCase, DefaultCase, DefaultCase, Stmt8

Stmt1:
<var>        Code to print "i = 1"</var>
        jmp EndCase

Stmt2:
<var>        Code to print "i = 2"</var>
        jmp EndCase

Stmt4:
<var>        Code to print "i = 4"</var>
        jmp EndCase

<span epub:type="pagebreak" title="418" id="Page_418"/>Stmt8:
<var>        Code to print "i = 8"</var>
        jmp EndCase

DefaultCase:
<var>        Code to print "i does not equal 1, 2, 4, or 8"</var>

EndCase: </code></pre>
<h4 id="h3-501089c07-0009">7.6.7.5	Sparse Jump Tables</h4>
<p class="BodyFirst">The current implementation of the <code>switch</code> statement has a problem. If the <code>case</code> values contain nonconsecutive entries that are widely spaced, the jump table could become exceedingly large. The following <code>switch</code> statement would generate an extremely large code file:</p>
<pre><code>switch(i)
{
    case 1:       <var> Stmt1 </var>;
    case 100:     <var> Stmt2 </var>;
    case 1000:    <var> Stmt3 </var>;
    case 10000:   <var> Stmt4 </var>;
    default:      <var> Stmt5 </var>;

}</code></pre>
<p>In this situation, your program will be much smaller if you implement the <code>switch</code> statement with a sequence of <code>if</code> statements rather than using an indirect jump statement. However, keep one thing in mind: the size of the jump table does not normally affect the execution speed of the program. If the jump table contains two entries or two thousand, the <code>switch</code> statement will execute the multiway branch in a constant amount of time. The <code>if</code> statement implementation requires a linearly increasing amount of time for each <code>case</code> label appearing in the <code>case</code> statement.</p>
<p>Probably the biggest advantage to using assembly language over an HLL like Pascal or C/C++ is that you get to choose the actual implementation of statements like <code>switch</code>. In some instances, you can implement a <code>switch</code> statement as a sequence of <code>if/then/elseif</code> statements, or you can implement it as a jump table, or you can use a hybrid of the two:</p>
<pre><code>switch(i)
{
    case 0:   <var> Stmt0 </var>;
    case 1:   <var> Stmt1 </var>;
    case 2:   <var> Stmt2 </var>;
    case 100: <var> Stmt3 </var>;
    default:  <var> Stmt4 </var>;

}</code></pre>
<p><span epub:type="pagebreak" title="419" id="Page_419"/>That could become the following:</p>
<pre><code>mov eax, i
cmp eax, 100
je  DoStmt3;
cmp eax, 2
ja  TheDefaultCase
lea rcx, JmpTbl
jmp qword ptr [rcx][rax * 8]
 .
 .
 .</code></pre>
<p>If you are willing to live with programs that cannot exceed 2GB in size (and use the <code>LARGEADDRESSAWARE:NO</code> command line option), you can improve the implementation of the <code>switch</code> statement and save one instruction:</p>
<pre><code>; SWITCH statement specifying cases 5, 6, and 7
; with a DEFAULT clause:

     mov eax, i
     cmp eax, 5
     jb  DefaultCase
     cmp eax, 7                  ; Verify that i is in the range
     ja  DefaultCase             ; 5 to 7 before the indirect jmp
     jmp JmpTbl[rax * 8 – 5 * 8] ; 5 * 8 compensates for zero index

JmpTbl  qword Stmt5, Stmt6, Stmt7

Stmt5:
<var>        Code to print "i = 5"</var>
        jmp EndCase

Stmt6:
<var>        Code to print "i = 6"</var>
        jmp EndCase

Stmt7:
<var>        Code to print "i = 7"</var>
        jmp EndCase

DefaultCase:
<var>        Code to print "EBX does not equal 5, 6, or 7"</var>

EndCase:</code></pre>
<p>This code removed the <code>lea rcx, JmpTbl</code> instruction and replaced <code>jmp [rcx][rax * 8 – 5 * 8]</code> with <code>jmp JmpTbl[rax * 8 – 5 * 8]</code>. This is a small improvement, but an improvement nonetheless (this sequence not only is one instruction shorter but also uses one less register). Of course, constantly be aware of the danger of writing 64-bit programs that are not large-address aware.</p>
<p><span epub:type="pagebreak" title="420" id="Page_420"/>Some <code>switch</code> statements have sparse cases but with groups of contiguous cases within the overall set of cases. Consider the following C/C++ <code>switch</code> statement:</p>
<pre><code>switch(<var>expression</var>)
{
    case 0:
<var>        Code for case 0</var>
        break;

    case 1:
<var>        Code for case 1</var>
        break;

    case 2:
<var>        Code for case 2</var>
        break;

    case 10:
<var>        Code for case 10</var>
        break;

    case 11:
<var>        Code for case 11</var>
        break;

    case 100:
<var>        Code for case 100</var>
        break;

    case 101:
<var>        Code for case 101</var>
        break;

    case 103:
<var>        Code for case 101</var>
        break;

    case 1000:
<var>        Code for case 1000</var>
        break;

    case 1001:
<var>        Code for case 1001</var>
        break;

    case 1003:
<var>        Code for case 1001</var>
        break;

    default:
<var>        Code for default case</var>
        break;
} // end switch</code></pre>
<p><span epub:type="pagebreak" title="421" id="Page_421"/>You can convert a <code>switch</code> statement that consists of widely separated groups of (nearly) contiguous cases to assembly language code using one jump table implementation for each contiguous group, and you can then use compare instructions to determine which jump table instruction sequence to execute. Here’s one possible implementation of the previous C/C++ code:</p>
<pre><code>; Assume expression has been computed and is sitting in EAX/RAX
; at this point...

         cmp   eax, 100
         jb    try0_11
         cmp   eax, 103
         ja    try1000_1003
         cmp   eax, 100
         jb    default
         lea   rcx, jt100
         jmp   qword ptr [rcx][rax * 8 – 100 * 8]
jt100    qword case100, case101, default, case103

try0_11: cmp   ecx, 11 ; Handle cases 0-11 here
         ja    defaultCase
         lea   rcx, jt0_11
         jmp   qword ptr [rcx][rax * 8]
jt0_11   qword case0, case1, case2, defaultCase 
         qword defaultCase, defaultCase, defaultCase
         qword defaultCase, defaultCase, defaultCase
         qword case10, case11

try1000_1003:
         cmp   eax, 1000
         jb    defaultCase
         cmp   eax, 1003
         ja    defaultCase
         lea   rcx, jt1000
         jmp   qword ptr [rcx][rax * 8 – 1000 * 8]
jt1000   qword case1000, case1001, defaultCase, case1003
           .
           .
           .
<var> Code for the actual cases here</var></code></pre>
<p>This code sequence combines groups 0 to 2 and 10 to 11 into a single group (requiring seven additional jump table entries) in order to save having to write an additional jump table sequence.</p>
<p>Of course, for a set of cases this simple, it’s probably easier to just use compare-and-branch sequences. This example was simplified a bit just to make a point.</p>
<h4 id="h3-501089c07-0010">7.6.7.6	Other switch Statement Alternatives</h4>
<p class="BodyFirst">What happens if the cases are too sparse to do anything but compare the expression’s value case by case? Is the code doomed to being translated <span epub:type="pagebreak" title="422" id="Page_422"/>into the equivalent of an <code>if/elseif/else/endif</code> sequence? Not necessarily. However, before we consider other alternatives, it’s important to mention that not all <code>if/elseif/else/endif</code> sequences are created equal. Look back at the previous example. A straightforward implementation might have been something like this:</p>
<pre><code>if(unsignedExpression &lt;= 11)
{
<var>  Switch for 0 to 11</var>
}
else if(unsignedExpression &gt;= 100 &amp;&amp; unsignedExpression &lt;= 101)
{
<var>  Switch for 100 to 101</var>
}
else if(unsignedExpression &gt;= 1000 &amp;&amp; unsignedExpression &lt;= 1001)
{
<var>  Switch for 1000 to 1001</var>
}
else
{
<var>  Code for default case</var>
}</code></pre>
<p>Instead, the former implementation first tests against the value 100 and branches based on the comparison being less than (cases 0 to 11) or greater than (cases 1000 to 1001), effectively creating a small <em>binary search</em> that reduces the number of comparisons. It’s hard to see the savings in the HLL code, but in assembly code you can count the number of instructions that would be executed in the best and worst cases and see an improvement over the standard linear search approach of simply comparing the values in the cases in the order they appear in the <code>switch</code> statement.<sup class="FootnoteReference"><a id="c07-footnoteref-8" href="#c07-footnote-8">8</a></sup></p>
<p>If your cases are too sparse (no meaningful groups at all), such as the 1, 10, 100, 1000, 10,000 example given earlier in this chapter, you’re not going to be able to (reasonably) implement the <code>switch</code> statement by using a jump table. Rather than devolving into a straight linear search (which can be slow), a better solution is to sort your cases and test them using a binary search.</p>
<p>With a binary search, you first compare the expression value against the middle case value. If it’s less than the middle value, you repeat the search on the first half of the list of values; if it’s greater than the middle value, you repeat the test on the second half of the values; if it’s equal, obviously you drop into the code to handle that test. Here’s the binary search version of the 1, 10, 100, . . . example:</p>
<pre><code>; Assume expression has been calculated into EAX.

        cmp eax, 100
        jb  try1_10
<span epub:type="pagebreak" title="423" id="Page_423"/>        ja  try1000_10000

<var>    Code to handle case 100 goes here</var>
        jmp AllDone

try1_10:
        cmp eax,1
        je  case1
        cmp eax, 10
        jne defaultCase

<var>    Code to handle case 10 goes here</var>
        jmp AllDone
case1:
<var>    Code to handle case 1 goes here</var>
        jmp AllDone

try1000_10000:
        cmp eax, 1000
        je  case1000
        cmp eax, 10000
        jne defaultCase

<var>    Code to handle case 10000 goes here</var>
        jmp AllDone

case1000:
<var>    Code to handle case 1000 goes here</var>
        jmp AllDone

defaultCase:
<var>    Code to handle defaultCase goes here</var>

AllDone:</code></pre>
<p>The techniques presented in this section have many possible alternatives. For example, one common solution is to create a table containing a set of records (structures), with each record entry a two-tuple containing a case value and a jump address. Rather than having a long sequence of compare instructions, a short loop can sequence through all the table elements, searching for the case value and transferring control to the corresponding jump address if there is a match. This scheme is slower than the other techniques in this section but can be much shorter than the traditional <code>if/elseif/else/endif</code> implementation.<sup class="FootnoteReference"><a id="c07-footnoteref-9" href="#c07-footnote-9">9</a></sup></p>
<p>Note, by the way, that the <code>defaultCase</code> label often appears in several <code>j</code><var>cc</var> instructions in a (non-jump-table) <code>switch</code> implementation. Since the conditional jump instructions have two encodings, a 2-byte form and a 6-byte form, you should try to place the <code>defaultCase</code> near these conditional jumps so you can use the short form of the instruction as much as possible. Although the examples in this section have typically put the jump tables (which consume a <span epub:type="pagebreak" title="424" id="Page_424"/>large number of bytes) immediately after their corresponding indirect jump, you could move these tables elsewhere in the procedure to help keep the conditional jump instructions short. Here’s the earlier 1, 10, 100, . . . example coded with this in mind:</p>
<pre><code>; Assume expression has been computed and is sitting in EAX/RAX
; at this point...

         cmp   eax, 100
         jb    try0_13
         cmp   eax, 103
         ja    try1000_1003
         lea   rcx, jt100
         jmp   qword ptr [rcx][rax * 8 – 100 * 8]

try0_13: cmp   ecx, 13      ; Handle cases 0 to 13 here
         ja    defaultCase
         lea   rcx, jt0_13
         jmp   qword ptr [rcx][rax * 8]

try1000_1003:
         cmp   eax, 1000    ; Handle cases 1000 to 1003 here
         jb    defaultCase
         cmp   eax, 1003
         ja    defaultCase
         lea   rcx, jt1000
         jmp   qword ptr [rcx][rax * 8 – 1000 * 8]

defaultCase:
<var>  Put defaultCase here to keep it near all the</var>
<var>      conditional jumps to defaultCase </var>

         jmp   AllDone

jt0_13   qword case0, case1, case2, case3
         qword defaultCase, defaultCase, defaultCase
         qword defaultCase, defaultCase, defaultCase
         qword case10, case11, case12, case13
jt100    qword case100, case101, case102, case103
jt1000   qword case1000, case1001, case1002, case1003
           .
           .
           .
<var> Code for the actual cases here</var></code></pre>
<h2 id="h1-501089c07-0007">	7.7	State Machines and Indirect Jumps </h2>
<p class="BodyFirst">Another control structure commonly found in assembly language programs is the <em>state machine</em>. A state machine uses a <em>state variable</em> to control program flow. The FORTRAN programming language provides this capability with the assigned <code>goto</code> statement. Certain variants of C (for example, GNU’s GCC <span epub:type="pagebreak" title="425" id="Page_425"/>from the Free Software Foundation) provide similar features. In assembly language, the indirect jump can implement state machines.</p>
<p>So what is a state machine? In basic terms, it is a piece of code that keeps track of its execution history by entering and leaving certain <em>states</em>. For the purposes of this chapter, we’ll just assume that a state machine is a piece of code that (somehow) remembers the history of its execution (its <em>state</em>) and executes sections of code based on that history.</p>
<p>In a real sense, all programs are state machines. The CPU registers and values in memory constitute the state of that machine. However, we’ll use a much more constrained view. Indeed, for most purposes, only a single variable (or the value in the RIP register) will denote the current state.</p>
<p>Now let’s consider a concrete example. Suppose you have a procedure and want to perform one operation the first time you call it, a different operation the second time you call it, yet something else the third time you call it, and then something new again on the fourth call. After the fourth call, it repeats these four operations in order. </p>
<p>For example, suppose you want the procedure to add EAX and EBX the first time, subtract them on the second call, multiply them on the third, and divide them on the fourth. You could implement this procedure as shown in <a href="#listing7-6" id="listinganchor7-6">Listing 7-6</a>.</p>
<pre><code>; Listing 7-6
 
; A simple state machine example.

        option  casemap:none

nl          =       10

            .const
ttlStr      byte    "Listing 7-6", 0
fmtStr0     byte    "Calling StateMachine, "
            byte    "state=%d, EAX=5, ECX=6", nl, 0

fmtStr0b    byte    "Calling StateMachine, "
            byte    "state=%d, EAX=1, ECX=2", nl, 0

fmtStrx     byte    "Back from StateMachine, "
            byte    "state=%d, EAX=%d", nl, 0

fmtStr1     byte    "Calling StateMachine, "
            byte    "state=%d, EAX=50, ECX=60", nl, 0

fmtStr2     byte    "Calling StateMachine, "
            byte    "state=%d, EAX=10, ECX=20", nl, 0

fmtStr3     byte    "Calling StateMachine, "
            byte    "state=%d, EAX=50, ECX=5", nl, 0

            .data
state       byte    0

<span epub:type="pagebreak" title="426" id="Page_426"/>            .code
            externdef printf:proc

; Return program title to C++ program:

            public  getTitle
getTitle    proc
            lea     rax, ttlStr
            ret
getTitle    endp

StateMachine proc
             cmp    state, 0
             jne    TryState1

; State 0: Add ECX to EAX and switch to state 1:

             add    eax, ecx
             inc    state           ; State 0 becomes state 1
             jmp    exit

TryState1:
             cmp    state, 1
             jne    TryState2

; State 1: Subtract ECX from EAX and switch to state 2:

             sub    eax, ecx
             inc    state           ; State 1 becomes state 2
             jmp    exit

TryState2:   cmp    state, 2
             jne    MustBeState3

; If this is state 2, multiply ECX by EAX and switch to state 3:

             imul   eax, ecx
             inc    state           ; State 2 becomes state 3
             jmp    exit

; If it isn't one of the preceding states, we must be in state 3,
; so divide EAX by ECX and switch back to state 0.

MustBeState3:
             push   rdx          ; Preserve this 'cause it
                                 ; gets whacked by div
             xor    edx, edx     ; Zero-extend EAX into EDX
             div    ecx
             pop    rdx          ; Restore EDX's value preserved above
             mov    state, 0     ; Reset the state back to 0
             
exit:        ret

StateMachine endp

<span epub:type="pagebreak" title="427" id="Page_427"/>; Here is the "asmMain" function.

            public  asmMain
asmMain     proc
            push    rbp
            mov     rbp, rsp
            sub     rsp, 48         ; Shadow storage

            mov     state, 0        ; Just to be safe

; Demonstrate state 0:

            lea     rcx, fmtStr0
            movzx   rdx, state
            call    printf

            mov     eax, 5
            mov     ecx, 6
            call    StateMachine

            lea     rcx, fmtStrx
            mov     r8, rax
            movzx   edx, state
            call    printf

; Demonstrate state 1:

            lea     rcx, fmtStr1
            movzx   rdx, state
            call    printf

            mov     eax, 50
            mov     ecx, 60
            call    StateMachine

            lea     rcx, fmtStrx
            mov     r8, rax
            movzx   edx, state
            call    printf

; Demonstrate state 2:

            lea     rcx, fmtStr2
            movzx   rdx, state
            call    printf

            mov     eax, 10
            mov     ecx, 20
            call    StateMachine

            lea     rcx, fmtStrx
            mov     r8, rax
            movzx   edx, state
            call    printf

<span epub:type="pagebreak" title="428" id="Page_428"/>; Demonstrate state 3:

            lea     rcx, fmtStr3
            movzx   rdx, state
            call    printf

            mov     eax, 50
            mov     ecx, 5
            call    StateMachine

            lea     rcx, fmtStrx
            mov     r8, rax
            movzx   edx, state
            call    printf

; Demonstrate back in state 0:

            lea     rcx, fmtStr0b
            movzx   rdx, state
            call    printf

            mov     eax, 1
            mov     ecx, 2
            call    StateMachine

            lea     rcx, fmtStrx
            mov     r8, rax
            movzx   edx, state
            call    printf

            leave
            ret     ; Returns to caller

asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing7-6">Listing 7-6</a>: A state machine example</p>
<p>Here’s the build command and program output:</p>
<pre><code>C:\&gt;<b>build listing7-6</b>

C:\&gt;<b>echo off</b>
 Assembling: listing7-6.asm
c.cpp

C:\&gt;<b>listing7-6</b>
Calling Listing 7-6:
Calling StateMachine, state=0, EAX=5, ECX=6
Back from StateMachine, state=1, EAX=11
Calling StateMachine, state=1, EAX=50, ECX=60
Back from StateMachine, state=2, EAX=-10
Calling StateMachine, state=2, EAX=10, ECX=20
Back from StateMachine, state=3, EAX=200
Calling StateMachine, state=3, EAX=50, ECX=5
<span epub:type="pagebreak" title="429" id="Page_429"/>Back from StateMachine, state=0, EAX=10
Calling StateMachine, state=0, EAX=1, ECX=2
Back from StateMachine, state=1, EAX=3
Listing 7-6 terminated</code></pre>
<p>Technically, this procedure is not the state machine. Instead, the variable <code>state</code> and the <code>cmp/jne</code> instructions constitute the state machine. The procedure is little more than a <code>switch</code> statement implemented via the <code>if/then/elseif</code> construct. The only unique thing is that it remembers how many times it has been called<sup class="FootnoteReference"><a id="c07-footnoteref-10" href="#c07-footnote-10">10</a></sup> and behaves differently depending upon the number of calls. </p>
<p>While this is a <em>correct</em> implementation of the desired state machine, it is not particularly efficient. The astute reader, of course, would recognize that this code could be made a little faster using an actual <code>switch</code> statement rather than the <code>if/then/elseif/endif</code> implementation. However, an even better solution exists.</p>
<p>It’s common to use an indirect jump to implement a state machine in assembly language. Rather than having a <code>state</code> variable that contains a value like 0, 1, 2, or 3, we could load the <code>state</code> variable with the <em>address</em> of the code to execute upon entry into the procedure. By simply jumping to that address, the state machine could save the tests needed to select the proper code fragment. Consider the implementation in <a href="#listing7-7" id="listinganchor7-7">Listing 7-7</a> using the indirect jump.</p>
<pre><code>; Listing 7-7
 
; An indirect jump state machine example.

        option  casemap:none

nl          =       10

            .const
ttlStr      byte    "Listing 7-7", 0
fmtStr0     byte    "Calling StateMachine, "
            byte    "state=0, EAX=5, ECX=6", nl, 0

fmtStr0b    byte    "Calling StateMachine, "
            byte    "state=0, EAX=1, ECX=2", nl, 0

fmtStrx     byte    "Back from StateMachine, "
            byte    "EAX=%d", nl, 0

fmtStr1     byte    "Calling StateMachine, "
            byte    "state=1, EAX=50, ECX=60", nl, 0

fmtStr2     byte    "Calling StateMachine, "
            byte    "state=2, EAX=10, ECX=20", nl, 0

<span epub:type="pagebreak" title="430" id="Page_430"/>fmtStr3     byte    "Calling StateMachine, "
            byte    "state=3, EAX=50, ECX=5", nl, 0

             .data
state        qword  state0

            .code
            externdef printf:proc

; Return program title to C++ program:

            public  getTitle
getTitle    proc
            lea     rax, ttlStr
            ret
getTitle    endp

; StateMachine version 2.0 - using an indirect jump.

             option noscoped     ; state<var>x</var> labels must be global
StateMachine proc

             jmp    state

; State 0: Add ECX to EAX and switch to state 1:

state0:      add    eax, ecx
             lea    rcx, state1
             mov    state, rcx
             ret

; State 1: Subtract ECX from EAX and switch to state 2:

state1:      sub    eax, ecx
             lea    rcx, state2
             mov    state, rcx
             ret

; If this is state 2, multiply ECX by EAX and switch to state 3:

state2:      imul   eax, ecx
             lea    rcx, state3
             mov    state, rcx
             ret

state3:      push   rdx          ; Preserve this 'cause it 
                                 ; gets whacked by div
             xor    edx, edx     ; Zero-extend EAX into EDX
             div    ecx
             pop    rdx          ; Restore EDX's value preserved above
             lea    rcx, state0
             mov    state, rcx
             ret

<span epub:type="pagebreak" title="431" id="Page_431"/>StateMachine endp
             option scoped

; Here is the "asmMain" function.

            public  asmMain
asmMain     proc
            push    rbp
            mov     rbp, rsp
            sub     rsp, 48         ; Shadow storage

            lea     rcx, state0
            mov     state, rcx      ; Just to be safe

; Demonstrate state 0:

            lea     rcx, fmtStr0
            call    printf

            mov     eax, 5
            mov     ecx, 6
            call    StateMachine

            lea     rcx, fmtStrx
            mov     rdx, rax
            call    printf

; Demonstrate state 1:

            lea     rcx, fmtStr1
            call    printf

            mov     eax, 50
            mov     ecx, 60
            call    StateMachine

            lea     rcx, fmtStrx
            mov     rdx, rax
            call    printf

; Demonstrate state 2:

            lea     rcx, fmtStr2
            call    printf

            mov     eax, 10
            mov     ecx, 20
            call    StateMachine

            lea     rcx, fmtStrx
            mov     rdx, rax
            call    printf

<span epub:type="pagebreak" title="432" id="Page_432"/>; Demonstrate state 3:

            lea     rcx, fmtStr3
            call    printf

            mov     eax, 50
            mov     ecx, 5
            call    StateMachine

            lea     rcx, fmtStrx
            mov     rdx, rax
            call    printf

; Demonstrate back in state 0:

            lea     rcx, fmtStr0b
            call    printf

            mov     eax, 1
            mov     ecx, 2
            call    StateMachine

            lea     rcx, fmtStrx
            mov     rdx, rax
            call    printf

            leave
            ret     ; Returns to caller

asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing7-7">Listing 7-7</a>: A state machine using an indirect jump</p>
<p>Here’s the build command and program output:</p>
<pre><code>C:\&gt;<b>build listing7-7</b>

C:\&gt;<b>echo off</b>
 Assembling: listing7-7.asm
c.cpp

C:\&gt;<b>listing7-7</b>
Calling Listing 7-7:
Calling StateMachine, state=0, EAX=5, ECX=6
Back from StateMachine, EAX=11
Calling StateMachine, state=1, EAX=50, ECX=60
Back from StateMachine, EAX=-10
Calling StateMachine, state=2, EAX=10, ECX=20
Back from StateMachine, EAX=200
Calling StateMachine, state=3, EAX=50, ECX=5
Back from StateMachine, EAX=10
Calling StateMachine, state=0, EAX=1, ECX=2
Back from StateMachine, EAX=3
Listing 7-7 terminated</code></pre>
<p><span epub:type="pagebreak" title="433" id="Page_433"/>The <code>jmp</code> instruction at the beginning of the <code>StateMachine</code> procedure transfers control to the location pointed at by the <code>state</code> variable. The first time you call <code>StateMachine</code>, it points at the <code>State0</code> label. Thereafter, each subsection of code sets the <code>state</code> variable to point at the appropriate successor code.</p>
<h2 id="h1-501089c07-0008">	7.8	Loops</h2>
<p class="BodyFirst"><em>Loops</em> represent the final basic control structure (sequences, decisions, and loops) that make up a typical program. As with so many other structures in assembly language, you’ll find yourself using loops in places you’ve never dreamed of using loops.</p>
<p>Most HLLs have implied loop structures hidden away. For example, consider the BASIC statement <code>if A$ = B$ then 100</code>. This <code>if</code> statement compares two strings and jumps to statement 100 if they are equal. In assembly language, you would need to write a loop to compare each character in <code>A$</code> to the corresponding character in <code>B$</code> and then jump to statement 100 if and only if all the characters matched.<sup class="FootnoteReference"><a id="c07-footnoteref-11" href="#c07-footnote-11">11</a></sup></p>
<p>Program loops consist of three components: an optional <em>initialization component</em>, an optional <em>loop-termination test</em>, and the <em>body</em> of the loop. The order in which you assemble these components can dramatically affect the loop’s operation. Three permutations of these components appear frequently in programs: <code>while</code> loops, <code>repeat/until</code> loops (<code>do/while</code> in C/C++), and infinite loops (for example, <code>for(;;)</code> in C/C++).</p>
<h3 id="h2-501089c07-0012">7.8.1	while Loops</h3>
<p class="BodyFirst">The most general loop is the <code>while</code> loop. In C/C++, it takes the following form:</p>
<pre><code>while(<var>expression</var>) <var>statement(s)</var>;</code></pre>
<p>In the <code>while</code> loop, the termination test appears at the beginning of the loop. As a direct consequence of the position of the termination test, the body of the loop may never execute if the Boolean expression is always false.</p>
<p>Consider the following C/C++ <code>while</code> loop:</p>
<pre><code>i = 0;
while(i &lt; 100)
{
    ++i;
}</code></pre>
<p>The <code>i = 0;</code> statement is the initialization code for this loop. <code>i</code> is a loop-control variable, because it controls the execution of the body of the loop. <code>i &lt; 100</code> is the loop-termination condition: the loop will not terminate as long as <code>i</code> is less than 100. The single statement <code>++i;</code> (<em>increment i</em>) is the loop body that executes on each loop iteration.</p>
<p><span epub:type="pagebreak" title="434" id="Page_434"/>A C/C++ <code>while</code> loop can be easily synthesized using <code>if</code> and <code>goto</code> statements. For example, you may replace the previous C <code>while</code> loop with the following C code:</p>
<pre><code>i = 0;
WhileLp:
if(i &lt; 100)
{

    ++i;
      goto WhileLp;

}</code></pre>
<p>More generally, you can construct any <code>while</code> loop as follows:</p>
<pre><code><var>Optional initialization code</var>

UniqueLabel:
if(<var>not_termination_condition</var>)
{
<var>    Loop body</var>
    goto UniqueLabel;

}</code></pre>
<p>Therefore, you can use the techniques from earlier in this chapter to convert <code>if</code> statements to assembly language and add a single <code>jmp</code> instruction to produce a <code>while</code> loop. The example in this section translates to the following pure x86-64 assembly code:<sup class="FootnoteReference"><a id="c07-footnoteref-12" href="#c07-footnote-12">12</a></sup></p>
<pre><code>          mov i, 0
WhileLp:
          cmp i, 100
          jnl WhileDone
          inc i
          jmp WhileLp;

WhileDone:</code></pre>
<h3 id="h2-501089c07-0013">7.8.2	repeat/until Loops</h3>
<p class="BodyFirst">The <code>repeat/until</code> (<code>do/while</code>) loop tests for the termination condition at the end of the loop rather than at the beginning. In Pascal, the <code>repeat/until</code> loop takes the following form:</p>
<pre><code><var>Optional initialization code</var>
repeat

<span epub:type="pagebreak" title="435" id="Page_435"/><var>    Loop body</var>

until(<var>termination_condition</var>);</code></pre>
<p>This is comparable to the following C/C++ <code>do/while</code> loop:</p>
<pre><code><var>Optional initialization code</var>
do
{
<var>    Loop body</var>

}while(<var>not_termination_condition</var>);</code></pre>
<p>This sequence executes the initialization code, then executes the loop body, and finally tests a condition to see whether the loop should repeat. If the Boolean expression evaluates to false, the loop repeats; otherwise, the loop terminates. The two things you should note about the <code>repeat/until</code> loop are that the termination test appears at the end of the loop and, as a direct consequence, the loop body always executes at least once.</p>
<p>Like the <code>while</code> loop, the <code>repeat/until</code> loop can be synthesized with an <code>if</code> statement and a <code>jmp</code>. You could use the following:</p>
<pre><code><var>Initialization code</var>
SomeUniqueLabel:

<var>    Loop body</var>

if(<var>not_termination_condition</var>) goto SomeUniqueLabel;</code></pre>
<p>Based on the material presented in the previous sections, you can easily synthesize <code>repeat/until</code> loops in assembly language. The following is a simple example:</p>
<pre><code>     repeat (<var>Pascal code</var>)

          write('Enter a number greater than 100:');
          readln(i);

     until(i &gt; 100);

// This translates to the following if/jmp code:

     RepeatLabel:

          write('Enter a number greater than 100:');
          readln(<var>i</var>);

     if(<var>i</var> &lt;= 100) then goto RepeatLabel;

// It also translates into the following assembly code:

RepeatLabel:

<span epub:type="pagebreak" title="436" id="Page_436"/>          call print
          byte "Enter a number greater than 100: ", 0
          call readInt  ; Function to read integer from user

          cmp  eax, 100 ; Assume readInt returns integer in EAX
          jng  RepeatLabel</code></pre>
<h3 id="h2-501089c07-0014">7.8.3	forever/endfor Loops</h3>
<p class="BodyFirst">If <code>while</code> loops test for termination at the beginning of the loop and <code>repeat/until/do/while</code> loops check for termination at the end of the loop, the only place left to test for termination is in the middle of the loop. The C/C++ high-level <code>for(;;)</code> loop, combined with the <code>break</code> statement, provides this capability. The C/C++ infinite loop takes the following form:</p>
<pre><code>for(;;)
{
<var>    Loop body</var>

}</code></pre>
<p>There is no explicit termination condition. Unless otherwise provided, the <code>for(;;)</code> construct forms an infinite loop. A <code>break</code> statement usually handles loop termination. Consider the following C++ code that employs a <code>for(;;)</code> construct:</p>
<pre><code>for(;;)
{
     cin &gt;&gt; <var>character</var>;
     if(<var>character</var> == '.') break;
     cout <var>&lt;&lt; character</var>;

}</code></pre>
<p>Converting a <code>for</code>(ever) loop to pure assembly language is easy. All you need is a label and a <code>jmp</code> instruction. The <code>break</code> statement in this example is also nothing more than a <code>jmp</code> instruction (or conditional jump). The pure assembly language version of the preceding code looks something like the following:</p>
<pre><code>foreverLabel:

          call getchar    ; Assume it returns char in AL
          cmp  al, '.'
          je   ForIsDone

          mov  cl, al     ; Pass char read from getchar to putchar
          call putcchar   ; Assume this prints the char in CL
          jmp  foreverLabel

ForIsDone:</code></pre>
<h3 id="h2-501089c07-0015"><span epub:type="pagebreak" title="437" id="Page_437"/>7.8.4	for Loops</h3>
<p class="BodyFirst">The standard <code>for</code> loop is a special form of the <code>while</code> loop that repeats the loop body a specific number of times (this is known as a <em>definite</em> loop). In C/C++, the <code>for</code> loop takes the form</p>
<pre><code>for(<var>initialization_Stmt</var>; <var>termination_expression</var>; <var>inc_Stmt</var>)
{
<var>    Statements</var>

}</code></pre>
<p class="BodyContinued">which is equivalent to the following:</p>
<pre><code><var>initialization_Stmt</var>;
while(<var>termination_expression</var>)
{
<var>    Statements </var>

    inc_Stmt;

}</code></pre>
<p>Traditionally, programs use the <code>for</code> loop to process arrays and other objects accessed in sequential order. We normally initialize a loop-control variable with the initialization statement and then use the loop-control variable as an index into the array (or other data type). For example:</p>
<pre><code>for(i = 0; i &lt; 7; ++i)
{
     printf("Array Element = %d \ n", SomeArray[i]);

}</code></pre>
<p>To convert this to pure assembly language, begin by translating the <code>for</code> loop into an equivalent <code>while</code> loop:</p>
<pre><code>i = 0;
while(i &lt; 7)
{
    printf("Array Element = %d \ n", SomeArray[i]);
    ++i;
}</code></pre>
<p>Now, using the techniques from <span class="xref" itemid="xref_target_“while Loops” on page 433">“while Loops” on page 433</span>, translate the code into pure assembly language:</p>
<pre><code>          xor  rbx, rbx      ; Use RBX to hold loop index
WhileLp:  cmp  ebx, 7
          jnl  EndWhileLp

          lea  rcx, fmtStr   ; fmtStr = "Array Element = %d", nl, 0
          lea  rdx, SomeArray
<span epub:type="pagebreak" title="438" id="Page_438"/>          mov  rdx, [rdx][rbx * 4] ; Assume SomeArray is 4-byte ints
          call printf

          inc  rbx
          jmp  WhileLp;

EndWhileLp:</code></pre>
<h3 id="h2-501089c07-0016">7.8.5	The break and continue Statements</h3>
<p class="BodyFirst">The C/C++ <code>break</code> and <code>continue</code> statements both translate into a single <code>jmp</code> instruction. The <code>break</code> instruction exits the loop that immediately contains the <code>break</code> statement; the <code>continue</code> statement restarts the loop that contains the <code>continue</code> statement.</p>
<p>To convert a <code>break</code> statement to pure assembly language, just emit a <code>goto/jmp</code> instruction that transfers control to the first statement following the <code>end</code> of the loop to exit. You can do this by placing a label after the loop body and jumping to that label. The following code fragments demonstrate this technique for the various loops.</p>
<pre><code>// Breaking out of a FOR(;;) loop:

for(;;)
{
<var>      Stmts</var>
          // break;
          goto BreakFromForever;
<var>      Stmts</var>
}
BreakFromForever:

// Breaking out of a FOR loop:

for(initStmt; expr; incStmt)
{
<var>      Stmts</var>
          // break;
          goto BrkFromFor;
<var>      Stmts</var>
}
BrkFromFor:

// Breaking out of a WHILE loop:

while(expr)
{
<var>      Stmts</var>
          // break;
          goto BrkFromWhile;
<var>      Stmts</var>
}
<span epub:type="pagebreak" title="439" id="Page_439"/>BrkFromWhile:

// Breaking out of a REPEAT/UNTIL loop (DO/WHILE is similar):

repeat
<var>      Stmts</var>
          // break;
          goto BrkFromRpt;
<var>      Stmts</var>
until(expr);
BrkFromRpt:</code></pre>
<p>In pure assembly language, convert the appropriate control structures to assembly and replace the <code>goto</code> with a <code>jmp</code> instruction.</p>
<p>The <code>continue</code> statement is slightly more complex than the <code>break</code> statement. The implementation is still a single <code>jmp</code> instruction; however, the target label doesn’t wind up going in the same spot for each of the different loops. Figures 7-2, 7-3, 7-4, and 7-5 show where the <code>continue</code> statement transfers control for each of the loops.</p>
<figure>
<img src="image_fi/501089c07/f07002.png" alt="f07002" class=""/>
<figcaption><p><a id="figure7-2">Figure 7-2</a>: <span class="LiteralInCaption"><code>continue</code></span> destination for the <span class="LiteralInCaption"><code>for(;;)</code></span> loop</p></figcaption>
</figure>
<figure>
<img src="image_fi/501089c07/f07003.png" alt="f07003" class=""/>
<figcaption><p><a id="figure7-3">Figure 7-3</a>: <span class="LiteralInCaption"><code>continue</code></span> destination and the <span class="LiteralInCaption"><code>while</code></span> loop</p></figcaption>
</figure>
<figure>
<img src="image_fi/501089c07/f07004.png" alt="f07004" class=""/>
<figcaption><p><a id="figure7-4">Figure 7-4</a>: <span class="LiteralInCaption"><code>continue</code></span> destination and the <span class="LiteralInCaption"><code>for</code></span> loop </p></figcaption>
</figure>
<span epub:type="pagebreak" title="440" id="Page_440"/><figure>
<img src="image_fi/501089c07/f07005.png" alt="f07005" class=""/>
<figcaption><p><a id="figure7-5">Figure 7-5</a>: <span class="LiteralInCaption"><code>continue</code></span> destination and the <span class="LiteralInCaption"><code>repeat</code></span><span class="LiteralInCaption"><code>/</code></span><span class="LiteralInCaption"><code>until</code></span> loop</p></figcaption>
</figure>
<p>The following code fragments demonstrate how to convert the <code>continue</code> statement into an appropriate <code>jmp</code> instruction for each of these loop types:</p>
<p class="ListHead"><b><code class="bold">for(;;)/continue/endfor</code></b></p>
<pre><code>; Conversion of FOREVER loop with continue
; to pure assembly:
 for(;;)
 {
<var>       Stmts</var>
      continue;
<var>       Stmts</var>
 }

; Converted code:

foreverLbl:
<var>      Stmts</var>
          ; continue;
          jmp foreverLbl
<var>      Stmts</var>
     jmp foreverLbl</code></pre>
<p class="ListHead"><b><code class="bold">while/continue/endwhile</code></b></p>
<pre><code>; Conversion of WHILE loop with continue
; into pure assembly:
 
 while(expr)
 {
<var>       Stmts</var>
      continue;
<var>       Stmts</var>
 }

; Converted code:

whlLabel:
<var> Code to evaluate expr</var>
     jcc EndOfWhile    ; Skip loop on expr failure
<var>      Stmts</var>
          ; continue;
          jmp whlLabel ; Jump to start of loop on continue
<span epub:type="pagebreak" title="441" id="Page_441"/><var>      Stmts</var>
     jmp whlLabel      ; Repeat the code
EndOfWhile:</code></pre>
<p class="ListHead"><b><code class="bold">for/continue/endfor</code></b></p>
<pre><code>; Conversion for a FOR loop with continue
; into pure assembly:
 
 for(initStmt; expr; incStmt)
 {
<var>      Stmts</var>
     continue;
<var>      Stmts</var>
 }

; Converted code:

<var>        initStmt</var>
ForLpLbl:
<var>    Code to evaluate expr</var>
          jcc EndOfFor     ; Branch if expression fails
<var>           Stmts</var>

          ; continue;
          jmp ContFor      ; Branch to incStmt on continue

<var>           Stmts</var>

ContFor:
<var>          incStmt</var>
          jmp ForLpLbl

EndOfFor:</code></pre>
<p class="ListHead"><b><code class="bold">repeat/continue/until</code></b></p>
<pre><code> repeat
      <var> Stmts</var>
      continue;
      <var> Stmts</var>
 until(expr);
 
 do
 {
      <var> Stmts</var>
      continue;
      <var> Stmts</var>

 }while(!expr);

; Converted code:

<span epub:type="pagebreak" title="442" id="Page_442"/>RptLpLbl:
     <var> Stmts</var>
          ; continue;
          jmp ContRpt  ; Continue branches to termination test
          <var> Stmts</var>
ContRpt:
     <var> Code to test expr</var>
     j<var>cc</var> RptLpLbl      ; Jumps if expression evaluates false</code></pre>
<h3 id="h2-501089c07-0017">7.8.6	Register Usage and Loops  </h3>
<p class="BodyFirst">Given that the x86-64 accesses registers more efficiently than memory locations, registers are the ideal spot to place loop-control variables (especially for small loops). However, registers are a limited resource; there are only 16 general-purpose registers (and some, such as RSP and RBP, are reserved for special purposes). Compared with memory, you cannot place much data in the registers, despite them being more efficient to use than memory.</p>
<p>Loops present a special challenge for registers. Registers are perfect for loop-control variables because they’re efficient to manipulate and can serve as indexes into arrays and other data structures (a common use for loop-control variables). However, the limited availability of registers often creates problems when using registers in this fashion. Consider the following code that will not work properly because it attempts to reuse a register (CX) that is already in use (leading to the corruption of the outer loop’s loop-control variable):</p>
<pre><code>          mov cx, 8
loop1:    
          mov cx, 4
loop2:
<var>           Stmts</var>
          dec cx
          jnz loop2

          dec cx
          jnz loop1</code></pre>
<p>The intent here, of course, was to create a set of nested loops; that is, one loop inside another. The inner loop (<code>loop2</code>) should repeat four times for each of the eight executions of the outer loop (<code>loop1</code>). Unfortunately, both loops use the same register as a loop-control variable. Therefore, this will form an infinite loop. Because CX is always 0 upon encountering the second <code>dec</code> instruction, control will always transfer to the <code>loop1</code> label (because decrementing 0 produces a nonzero result). The solution here is to save and restore the CX register or to use a different register in place of CX for the outer loop:</p>
<pre><code>          mov cx, 8
loop1:
          push rcx
          mov  cx, 4
<span epub:type="pagebreak" title="443" id="Page_443"/>loop2:
<var>           Stmts</var>
          dec cx
          jnz loop2;

          pop rcx
          dec cx
          jnz loop1
or
          mov dx,8
loop1:
          mov cx, 4
loop2:
<var>           Stmts</var>
          dec cx
          jnz loop2

          dec dx
          jnz loop1</code></pre>
<p>Register corruption is one of the primary sources of bugs in loops in assembly language programs, so always keep an eye out for this problem.</p>
<h2 id="h1-501089c07-0009">	7.9	Loop Performance Improvements</h2>
<p class="BodyFirst">Because loops are the primary source of performance problems within a program, they are the place to look when attempting to speed up your software. While a treatise on how to write efficient programs is beyond the scope of this chapter, you should be aware of the following concepts when designing loops in your programs. They’re all aimed at removing unnecessary instructions from your loops in order to reduce the time it takes to execute a single iteration of the loop.</p>
<h3 id="h2-501089c07-0018">7.9.1	Moving the Termination Condition to the End of a Loop</h3>
<p class="BodyFirst">Consider the following flow graphs for the three types of loops presented earlier:</p>
<pre><code>REPEAT/UNTIL loop:
     Initialization code
          Loop body
     Test for termination
     Code following the loop

WHILE loop:
     Initialization code
     Loop-termination test
          Loop body
          Jump back to test
     Code following the loop

<span epub:type="pagebreak" title="444" id="Page_444"/>FOREVER/ENDFOR loop:
     Initialization code
          Loop body part one
          Loop-termination test
          Loop body part two
          Jump back to Loop body part one
     Code following the loop</code></pre>
<p>As you can see, the <code>repeat/until</code> loop is the simplest of the bunch. This is reflected in the assembly language implementation of these loops. Consider the following <code>repeat/until</code> and <code>while</code> loops that are semantically identical:</p>
<pre><code>; Example involving a WHILE loop:

         mov  esi, edi
         sub  esi, 20

; while(ESI &lt;= EDI)

whileLp: cmp  esi, edi
         jnle endwhile

<var>           Stmts</var>

         inc  esi
         jmp  whileLp
endwhile:

; Example involving a REPEAT/UNTIL loop:

         mov esi, edi
         sub esi, 20
repeatLp:

<var>          Stmts</var>

         inc  esi
         cmp  esi, edi
         jng  repeatLp</code></pre>
<p>Testing for the termination condition at the end of the loop allows us to remove a <code>jmp</code> instruction from the loop, which can be significant if the loop is nested inside other loops. Given the definition of the loop, you can easily see that the loop will execute exactly 20 times, which suggests that the conversion to a <code>repeat/until</code> loop is trivial and always possible. </p>
<p>Unfortunately, it’s not always quite this easy. Consider the following C code:</p>
<pre><code>while(esi &lt;= edi)
{
<var>     Stmts</var>
    ++esi;
}</code></pre>
<p><span epub:type="pagebreak" title="445" id="Page_445"/>In this particular example, we haven’t the slightest idea what ESI contains upon entry into the loop. Therefore, we cannot assume that the loop body will execute at least once. So, we must test for loop termination before executing the body of the loop. The test can be placed at the end of the loop with the inclusion of a single <code>jmp</code> instruction:</p>
<pre><code>          jmp WhlTest
TopOfLoop:
<var>           Stmts</var>
          inc  esi 
WhlTest:  cmp  esi, edi
          jle TopOfLoop</code></pre>
<p>Although the code is as long as the original <code>while</code> loop, the <code>jmp</code> instruction executes only once rather than on each repetition of the loop. However, the slight gain in efficiency is obtained via a slight loss in readability (so be sure to comment it). The second code sequence is closer to spaghetti code than the original implementation. Such is often the price of a small performance gain. Therefore, you should carefully analyze your code to ensure that the performance boost is worth the loss of clarity.</p>
<h3 id="h2-501089c07-0019">7.9.2	Executing the Loop Backward</h3>
<p class="BodyFirst">Because of the nature of the flags on the x86-64, loops that repeat from some number down to (or up to) 0 are more efficient than loops that execute from 0 to another value. Compare the following C/C++ <code>for</code> loop and the comparable assembly language code:</p>
<pre><code>for(j = 1; j &lt;= 8; ++j)
{
<var>      Stmts</var>
}

; Conversion to pure assembly (as well as using a
; REPEAT/UNTIL form):

mov j, 1
ForLp:
<var>      Stmts</var>
     inc j
     cmp j, 8
     jle ForLp</code></pre>
<p>Now consider another loop that also has eight iterations but runs its loop-control variable from 8 down to 1 rather than 1 up to 8, thereby saving a comparison on each repetition of the loop:</p>
<pre><code>     mov j, 8
LoopLbl:
<var>      Stmts</var>
     dec j
     jnz LoopLbl</code></pre>
<p><span epub:type="pagebreak" title="446" id="Page_446"/>Saving the execution time of the <code>cmp</code> instruction on each iteration of the loop may result in faster code. Unfortunately, you cannot force all loops to run backward. However, with a little effort and some coercion, you should be able to write many <code>for</code> loops so that they operate backward.</p>
<p>The preceding example worked out well because the loop ran from 8 down to 1. The loop terminated when the loop-control variable became 0. What happens if you need to execute the loop when the loop-control variable goes to 0? For example, suppose that the preceding loop needed to range from 7 down to 0. As long as the lower bound is non-negative, you can substitute the <code>jns</code> instruction in place of the <code>jnz</code> instruction in the earlier code:</p>
<pre><code>     mov j, 7
LoopLbl:
<var>      Stmts</var>
     dec j
     jns LoopLbl</code></pre>
<p>This loop will repeat eight times, with <code>j</code> taking on the values 7 to 0. When it decrements 0 to –1, it sets the sign flag and the loop terminates.</p>
<p>Keep in mind that some values may look positive but are actually negative. If the loop-control variable is a byte, values in the range 128 to 255 are negative in the two’s complement system. Therefore, initializing the loop-control variable with any 8-bit value in the range 129 to 255 (or, of course, 0) terminates the loop after a single execution. This can get you into trouble if you’re not careful.</p>
<h3 id="h2-501089c07-0020">7.9.3	Using Loop-Invariant Computations</h3>
<p class="BodyFirst">A <em>loop-invariant computation</em> is a calculation that appears within a loop that always yields the same result. You needn’t do such computations inside the loop. You can compute them outside the loop and reference the value of the computations inside the loop. The following C code demonstrates an invariant computation:</p>
<pre><code>for(i = 0; i &lt; n; ++i)
{
    k = (j - 2) + i
}</code></pre>
<p>Because <code>j</code> never changes throughout the execution of this loop, the subexpression <code>j - 2</code> can be computed outside the loop:</p>
<pre><code>jm2 = j - 2;
for(i = 0; i &lt; n; ++i)
{
    k = jm2 + i;
}</code></pre>
<p><span epub:type="pagebreak" title="447" id="Page_447"/>Although we’ve eliminated a single instruction by computing the subexpression <code>j - 2</code> outside the loop, there is still an invariant component to this calculation: adding <code>j - 2</code> to <code>i</code> <em>n</em> times. Because this invariant component executes <em>n</em> times in the loop, we can translate the previous code to the following:</p>
<pre><code>k = (j - 2) * n;
for(i = 0; i &lt; n; ++i)
{
    k = k + i;
}</code></pre>
<p>This translates to the following assembly code:</p>
<pre><code>      mov  eax, j
      sub  eax, 2
      imul eax, n
      mov  ecx, 0
lp:   cmp  ecx, n
      jnl  loopDone
      add  eax, ecx   ; Single instruction implements loop body!
      inc  ecx
      jmp  lp
loopDone:
      mov  k, eax</code></pre>
<p>For this particular loop, you can actually compute the result without using a loop at all (a formula corresponds to the preceding iterative calculation). Still, this simple example demonstrates how to eliminate loop-invariant calculations from a loop.</p>
<h3 id="h2-501089c07-0021">7.9.4	Unraveling Loops</h3>
<p class="BodyFirst">For small loops—those whose body is only a few statements—the overhead required to process a loop may constitute a significant percentage of the total processing time. For example, look at the following Pascal code and its associated x86-64 assembly language code:</p>
<pre><code>     for i := 3 downto 0 do A[i] := 0;

          mov i, 3
          lea rcx, A
LoopLbl:
          mov ebx, i
          mov [rcx][rbx * 4], 0
          dec i
          jns LoopLbl</code></pre>
<p>Four instructions execute on each repetition of the loop. Only one instruction is doing the desired operation (moving a 0 into an element of <code/><span epub:type="pagebreak" title="448" id="Page_448"/>A). The remaining three instructions control the loop. Therefore, it takes 16 instructions to do the operation logically required by 4.</p>
<p>While we could make many improvements to this loop based on the information presented thus far, consider carefully exactly what this loop is doing—it’s storing four 0s into <code>A[0]</code> through <code>A[3]</code>. A more efficient approach is to use four <code>mov</code> instructions to accomplish the same task. For example, if <code>A</code> is an array of double words, the following code initializes <code>A</code> much faster than the preceding code:</p>
<pre><code>mov  A[0], 0
mov  A[4], 0
mov  A[8], 0
mov  A[12], 0</code></pre>
<p>Although this is a simple example, it shows the benefit of <em>loop unraveling</em> (also known as <em>loop </em><em>unrolling</em>). If this simple loop appeared buried inside a set of nested loops, the 4:1 instruction reduction could possibly double the performance of that section of your program.</p>
<p>Of course, you cannot unravel all loops. Loops that execute a variable number of times are difficult to unravel because there is rarely a way to determine at assembly time the number of loop iterations. Therefore, unraveling a loop is a process best applied to loops that execute a known number of times, with the number of times known at assembly time.</p>
<p>Even if you repeat a loop a fixed number of iterations, it may not be a good candidate for loop unraveling. Loop unraveling produces impressive performance improvements when the number of instructions controlling the loop (and handling other overhead operations) represents a significant percentage of the total number of instructions in the loop. Had the previous loop contained 36 instructions in the body (exclusive of the four overhead instructions),  the performance improvement would be, at best, only 10 percent (compared with the 300 to 400 percent it now enjoys).</p>
<p>Therefore, the costs of unraveling a loop—all the extra code that must be inserted into your program—quickly reach a point of diminishing returns as the body of the loop grows larger or as the number of iterations increases. Furthermore, entering that code into your program can become quite a chore. Therefore, loop unraveling is a technique best applied to small loops.</p>
<p>Note that the superscalar 80x86 chips (Pentium and later) have <em>branch-prediction hardware</em> and use other techniques to improve performance. Loop unrolling on such systems may actually <em>slow </em>the code because these processors are optimized to execute short loops. Whenever applying “improvements” to speed up your code, you should always measure the performance before and after to ensure there was sufficient gain to justify the change.</p>
<h3 id="h2-501089c07-0022">7.9.5	Using Induction Variables </h3>
<p class="BodyFirst">Consider the following Pascal loop:</p>
<pre><code>for i := 0 to 255 do csetVar[i] := [];</code></pre>
<p><span epub:type="pagebreak" title="449" id="Page_449"/>Here the program is initializing each element of an array of character sets to the empty set. The straightforward code to achieve this is the following:</p>
<pre><code>     mov  i, 0
     lea  rcx, csetVar
FLp:

     ; Compute the index into the array (assume that each
     ; element of a csetVar array contains 16 bytes).

     mov  ebx, i  ; Zero-extends into RBX!
     shl  ebx, 4

     ; Set this element to the empty set (all 0 bits).

     xor  rax, rax
     mov  qword ptr [rcx][rbx], rax
     mov  qword ptr [rcx][rbx + 8], rax

     inc  i
     cmp  i, 256
     jb   FLp;</code></pre>
<p>Although unraveling this code will still improve performance, it will take 1024 instructions to accomplish this task, too many for all but the most time-critical applications. However, you can reduce the execution time of the body of the loop by using induction variables. An <em>induction variable</em> is one whose value depends entirely on the value of another variable. </p>
<p>In the preceding example, the index into the array <code>csetVar</code> tracks the loop-control variable (it’s always equal to the value of the loop-control variable times 16). Because <code>i</code> doesn’t appear anywhere else in the loop, there is no sense in performing the computations on <code>i</code>. Why not operate directly on the array index value? The following code demonstrates this technique:</p>
<pre><code>     xor  rbx, rbx     ; i * 16 in RBX
     xor  rax, rax     ; Loop invariant
     lea  rcx, csetVar ; Base address of csetVar array
FLp:
     mov  qword ptr [rcx][rbx], rax
     mov  qword ptr [rcx][rbx + 8], rax

     add  ebx, 16
     cmp  ebx, 256 * 16
     jb   FLp
;    mov  ebx, 256    ; If you care to maintain same semantics as C code</code></pre>
<p>The induction that takes place in this example occurs when the code increments the loop-control variable (moved into EBX for efficiency) by 16 on each iteration of the loop rather than by 1. Multiplying the loop-control variable by 16 (and the final loop-termination constant value) allows the <span epub:type="pagebreak" title="450" id="Page_450"/>code to eliminate multiplying the loop-control variable by 16 on each iteration of the loop (that is, this allows us to remove the <code>shl</code> instruction from the previous code). Further, because this code no longer refers to the original loop-control variable (<code>i</code>), the code can maintain the loop-control variable strictly in the EBX register.</p>
<h2 id="h1-501089c07-0010">	7.10	For More Information</h2>
<p class="BodyFirst"><em>Write Great Code</em>, Volume 2, by this author (Second Edition, No Starch Press, 2020) provides a good discussion of the implementation of various HLL control structures in low-level assembly language. It also discusses optimizations such as induction, unrolling, strength reduction, and so on, that apply to optimizing loops.</p>
<h2 id="h1-501089c07-0011">	7.11	Test Yourself</h2>
<ol class="decimal">
<li value="1">What are the two typical mechanisms for obtaining the address of a label appearing in a program?</li>
<li value="2">What statement can you use to make all symbols global that appear within a procedure?</li>
<li value="3">What statement can you use to make all symbols local that appear within a procedure?</li>
<li value="4">What are the two forms of the indirect <code>jmp</code> instruction?</li>
<li value="5">What is a state machine?</li>
<li value="6">What is the general rule for converting a branch to its opposite branch?</li>
<li value="7">What are the two exceptions to the rule for converting a branch to its opposite branch?</li>
<li value="8">What is a trampoline?</li>
<li value="9">What is the general syntax of the conditional move instruction?</li>
<li value="10">What is the advantage of a conditional move instruction over a conditional jump?</li>
<li value="11">What are some disadvantages of conditional moves?</li>
<li value="12">Explain the difference between short-circuit and complete Boolean evaluation.</li>
<li value="13">Convert the following <code>if</code> statements to assembly language sequences by using complete Boolean evaluation (assume all variables are unsigned 32-bit integer values):
<pre><code>if(x == y || z &gt; t)
{
<var>    Do something</var>
}

<span epub:type="pagebreak" title="451" id="Page_451"/>if(x != y &amp;&amp; z &lt; t)
{
<var>    THEN statements</var>
}
else
{
<var>    ELSE statements</var>
}</code></pre></li>
<li value="14">Convert the preceding statements to assembly language by using short-circuit Boolean evaluation (assume all variables are signed 16-bit integer values).</li>
<li value="15">Convert the following <code>switch</code> statements to assembly language (assume all variables are unsigned 32-bit integers):
<pre><code>switch(s)
{
   case 0:  <var> case 0 code </var> break;
   case 1:  <var> case 1 code </var> break;
   case 2:  <var> case 2 code </var> break;
   case 3:  <var> case 3 code </var> break;
}

switch(t)
{
   case 2:  <var> case 0 code </var> break;
   case 4:  <var> case 4 code </var> break;
   case 5:  <var> case 5 code </var> break;
   case 6:  <var> case 6 code </var> break;
   default:  <var>Default code</var>
}

switch(u)
{
   case 10:  <var> case 10 code </var> break;
   case 11:  <var> case 11 code </var> break;
   case 12:  <var> case 12 code </var> break;
   case 25:  <var> case 25 code </var> break;
   case 26:  <var> case 26 code </var> break;
   case 27:  <var> case 27 code </var> break;
   default:   <var>Default code</var>
}</code></pre></li>
<li value="16">Convert the following <code>while</code> loops to assembly code (assume all variables are signed 32-bit integers):
<pre><code>while(i &lt; j)
{
    <var>Code for loop body</var>
}

<span epub:type="pagebreak" title="452" id="Page_452"/>while(i &lt; j &amp;&amp; k != 0)
{
    <var> Code for loop body, part a</var>
    if(m == 5) continue;
    <var> Code for loop body, part b</var>
    if(n &lt; 6) break;
    <var> Code for loop body, part c</var>
}

do
{
   <var>Code for loop body</var>
} while(i != j);

do
{
    <var> Code for loop body, part a</var>
    if(m != 5) continue;
    <var> Code for loop body, part b</var>
    if(n == 6) break;
<var>     Code for loop body, part c</var>
} while(i &lt; j &amp;&amp; k &gt; j);

for(int i = 0; i &lt; 10; ++i)
{
   <var>Code for loop body</var>
}</code></pre></li>
</ol>
<section class="footnotes">
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c07-footnote-1" href="#c07-footnoteref-1">1</a></sup>. Unlike HLLs, for which your instructors usually forbid you to use <span class="LiteralFootnote"><code>goto</code></span> statements, you will find that the use of the <span class="LiteralFootnote"><code>jmp</code></span> instruction in assembly language is essential.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c07-footnote-2" href="#c07-footnoteref-2">2</a></sup>. Technically, this opposite branch rule doesn’t apply to the <span class="LiteralFootnote"><code>jcxz</code></span>, <span class="LiteralFootnote"><code>jecxz</code></span>, and <span class="LiteralFootnote"><code>jrcxz</code></span> instructions either, in addition to the <span class="LiteralFootnote"><code>jpe</code></span> and <span class="LiteralFootnote"><code>jpo</code></span> instructions. So, arguably, the rule has five exceptions. However, this section doesn’t mention the <span class="LiteralFootnote"><code>jcxz</code></span>, <span class="LiteralFootnote"><code>jecxz</code></span>, and <span class="LiteralFootnote"><code>jrcxz</code></span> instructions, so it mentions only the two exceptions.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c07-footnote-3" href="#c07-footnoteref-3">3</a></sup>. However, be aware that some expressions depend on the leftmost subexpression evaluating one way in order for the rightmost subexpression to be valid; for example, a common test in C/C++ is <span class="LiteralFootnote"><code>if(x != NULL &amp;&amp; x -&gt; y)</code></span> <span class="LiteralFootnote"><code>...</code></span> .</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c07-footnote-4" href="#c07-footnoteref-4">4</a></sup>. Of course, if you can predict that the subexpression <span class="LiteralFootnote"><code>a != b</code></span> will be false the vast majority of the time, it would be best to test that condition last.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c07-footnote-5" href="#c07-footnoteref-5">5</a></sup>. This assumes, of course, that all comparisons are equally likely to be true or false.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c07-footnote-6" href="#c07-footnoteref-6">6</a></sup>. In HLLs, you can often get away with this because the compiler will optimize the code, producing unstructured machine code. Unfortunately, when writing in assembly language, you get machine code that is exactly equivalent to the assembly code you write.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c07-footnote-7" href="#c07-footnoteref-7">7</a></sup>. Most of the time, this is true. On some architectures, special <em>branch-prediction hardware</em> reduces the cost of branches.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c07-footnote-8" href="#c07-footnoteref-8">8</a></sup>. Of course, if you have a large number of groups in a sparse <span class="LiteralFootnote"><code>switch</code></span> statement, a binary search will be much faster, on average, than a linear search.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c07-footnote-9" href="#c07-footnoteref-9">9</a></sup>. With a bit of effort, you could use a binary search if the table is sorted.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c07-footnote-10" href="#c07-footnoteref-10">10</a></sup>. Actually, it remembers how many times, modulo 4, that it has been called.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c07-footnote-11" href="#c07-footnoteref-11">11</a></sup>. Of course, the C Standard Library provides the <span class="LiteralFootnote"><code>strcmp</code></span> routine that compares the strings for you, effectively hiding the loop. However, if you were to write this function yourself, the looping nature of the operation would be obvious.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c07-footnote-12" href="#c07-footnoteref-12">12</a></sup>. MASM will actually convert most <span class="LiteralFootnote"><code>while</code></span> statements to different x86-64 code than this section presents. The reason for the difference appears in <span class="xref" itemid="xref_target_“Moving the Termination Condition to the End of a Loop” on page 443">“Moving the Termination Condition to the End of a Loop” on page 443</span>, when we explore how to write more efficient loop code.</p></aside>
</section>
</section>
</body></html>