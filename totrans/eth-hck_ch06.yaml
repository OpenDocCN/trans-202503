- en: '**6'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TLS AND DIFFIE-HELLMAN**
  prefs: []
  type: TYPE_NORMAL
- en: '*The world is a dangerous place to live, not because of the people who are
    evil, but because of the people who don’t do anything about it.*'
  prefs: []
  type: TYPE_NORMAL
- en: –Albert Einstein
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 4](ch04.xhtml#ch4), you used TCP and UDP sockets to send data between
    machines on the internet. But, as you observed, the data sent through these sockets
    wasn’t encrypted, so anybody who captured it could read it.
  prefs: []
  type: TYPE_NORMAL
- en: To communicate securely, you must encrypt data before sending it. Figuring out
    how to do this effectively proved challenging to the security community at first
    because asymmetric cryptography techniques are too slow to encrypt a stream of
    data without causing lags. Efficient encryption requires both parties to first
    set up a shared symmetric key, which is used to encrypt traffic with less overhead.
    The *transport layer security (TLS)* protocol uses asymmetric cryptography techniques
    to set up this shared symmetric key. TLS is used in all sorts of applications
    that require secure communication, such as apps that control military drones or
    transmit large bank transactions. These days, most websites use HTTPS to secure
    their communication, and HTTPS depends on TLS.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn how TLS communications work and how the Diffie-Hellman
    key exchange algorithm generates the keys required for it. Then, you’ll write
    a Python program that uses TLS to establish a secure communication channel. We’ll
    conclude by discussing how an attacker might decrypt an encrypted channel.
  prefs: []
  type: TYPE_NORMAL
- en: '**Transport Layer Security**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recall from [Chapter 5](ch05.xhtml#ch5) that symmetric-key cryptography uses
    a single key to both encrypt and decrypt a file. This technique is fast, but it
    has a downside: both parties must share the key somehow. On the other hand, asymmetrickey
    cryptography relies on a public-private key pair to send a message, meaning that
    it doesn’t have this limitation.'
  prefs: []
  type: TYPE_NORMAL
- en: Using both techniques, TLS establishes an encrypted communication channel between
    two parties. To set up their encrypted channel, the two parties must exchange
    only two messages. [Figure 6-1](ch06.xhtml#ch6fig1) shows a simplified overview
    of the process for TLS 1.3 (currently the most secure version).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch06fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-1: The TLS message exchange*'
  prefs: []
  type: TYPE_NORMAL
- en: The client starts the connection by sending a *Client Hello* message, which
    contains the client’s public key share and nonce. The server then combines its
    private key with the client’s public-key share to compute a new symmetric key.
    The server can now use this symmetric key to encrypt and decrypt future messages.
    However, the server still needs to share some information with the client so that
    the client can also calculate the same symmetric key. To do this, the server sends
    a *Server Hello* message that contains an unencrypted copy of the server’s public-key
    share and nonce. The client then combines its private key with the server’s public
    key share to calculate the same symmetric key, which it will use to encrypt and
    decrypt all future messages. Voilà! Now the client and server have both calculated
    the same symmetric key without directly sending the key. How is this possible?
    They both combined different pieces of information but still calculated the same
    key. In this chapter, I’ll talk about the algorithms that makes this possible.
  prefs: []
  type: TYPE_NORMAL
- en: Because the server knows that the client will be able to decrypt information
    after it receives the server’s public-key share and nonce, the server will also
    include some encrypted information about the server’s identity (its certificate)
    and proof of the message’s authenticity. Let’s delve into TLS further by exploring
    how the client proves the message’s authenticity.
  prefs: []
  type: TYPE_NORMAL
- en: '***Message Authentication***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Encryption prevents hackers from deciphering messages, but it doesn’t prevent
    tampering. In a public network, a hacker can alter a decrypted message by changing
    bits in the encrypted message. [Figure 6-2](ch06.xhtml#ch6fig2) shows how modifying
    an encrypted message can change the decrypted outcome.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch06fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-2: How a hacker can modify an encrypted message and affect the decrypted
    outcome*'
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t an issue for TLS users, because they can detect when a message has
    changed and reject it. Imagine that whenever you sent a package through the mail,
    you wrote the package’s weight on a tag. A recipient could verify the package
    by comparing its weight to the one listed on the tag. If the weight matches, the
    recipient can be confident nothing has been added or removed.
  prefs: []
  type: TYPE_NORMAL
- en: TLS uses *hash-based message authentication codes (HMACs)* to verify messages.
    The HMAC function uses a cryptographic hash function to generate a unique hash
    of each message. A *hash function* creates the same fixed-length string when given
    the same input. The message’s recipient reapplies HMAC and compares the two hashes.
    If a message is altered, its hash will be different, but if the hashes match,
    the message is authentic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hash functions by themselves do not provide authenticity. Because they’re publicly
    commutable, a hacker could modify a message and recompute its hash. To ensure
    that the hash was generated by a trusted party, it must be combined with the shared
    symmetric key computed during the key exchange. This *signed* hash is called a
    *message authentication code*. Following is the equation for the HMAC function:'
  prefs: []
  type: TYPE_NORMAL
- en: HMAC(*K*, *m*) = H((*K^′* ⊕ *opad*) ∥ ((*K^′* ⊕ *ipad*) ∥ *m*))
  prefs: []
  type: TYPE_NORMAL
- en: Here, *K* represents the shared symmetric key, and *m* represents the encrypted
    message. *H* represents the hash function, most commonly SHA3256\. *K^′* is a
    block size version of the key. The ∥ operator represents bit-level concatenating
    of two pieces of information. Lastly, *opad* and *ipad* are two constants that
    are there for legacy reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Once a message is encrypted, it’s then hashed and signed by the HMAC function.
    The MAC is then attached to the message and sent. Only a person with the secret
    symmetric key can change the hash.
  prefs: []
  type: TYPE_NORMAL
- en: '***Certificate Authorities and Signatures***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A hacker can pretend to be any machine on the network, so how can Bob be confident
    he is communicating with Alice? At the beginning of the TLS handshake, Alice provides
    Bob with her *certificate*, a digital document that proves Alice owns the public
    key she provided. Bob validates Alice’s certificate by checking its signature
    using the signature verification algorithm ([Figure 6-3](ch06.xhtml#ch6fig3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch06fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-3: The signature creation and verification process*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Signatures**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You could use the RSA algorithm discussed in [Chapter 5](ch05.xhtml#ch5) to
    create a signature algorithm. To sign a certificate message *m*, first compute
    a hash *H*(*m*) with SHA-256 and then encrypt the result with a private key *sk*
    (which stands for secret key). The resulting cipher text represents your signature
    *s*:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign(*m*, *sk*) = *E*(*H*(*m*), *sk*) = *s*
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify the certificate or message (*m*) by using the public key (*pk*) to decrypt
    (*D*) the signature (*s*). The signature is valid if *H*(*m*) matches *s*:'
  prefs: []
  type: TYPE_NORMAL
- en: Ver(*m*, *s*, *pk*) = *D*(*s*, *pk*) == *H*(*m*)
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-3](ch06.xhtml#ch6fig3) shows an overview of the process of signing
    a message that Alice sends to Bob.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Certificate Authorities***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For a certificate to be valid, the internet’s trusted *public key infrastructure
    (PKI)* must have signed it. The PKI is a collection of secure servers that sign
    and store certified copies of certificates. Alice pays to register her certificate
    with an *intermediate certificate authority (ICA)*, so Bob can verify Alice’s
    certificate during the TLS handshake.
  prefs: []
  type: TYPE_NORMAL
- en: How does Bob know that he can trust the ICA? Bob’s browser has been preprogrammed
    with the ICA’s public key, so it trusts messages signed with the ICA’s private
    key. [Figure 6-4](ch06.xhtml#ch6fig4) shows an overview of the certificate validation
    process.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch06fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-4: An overview of the certificate validation process*'
  prefs: []
  type: TYPE_NORMAL
- en: Alice’s certificate contains her public key and an ICA-signed hash of the certificate.
    When Bob’s browser receives the certificate, it decrypts the hash and verifies
    the certificate by comparing the computed hash with the decrypted hash.
  prefs: []
  type: TYPE_NORMAL
- en: Browsers sometimes receive a certificate from an ICA whose public key they haven’t
    stored. In these cases, the browser must use its other public keys to validate
    the ICA’s certificate. There are 14 root certificate authorities (CAs) in the
    world, and all browsers must include their public keys. When a root CA trusts
    an ICA, it signs that ICA’s certificate. When Alice provides her certificate,
    she also provides a signed copy of all the CA certificates Bob needs to verify
    her certificate. [Figure 6-5](ch06.xhtml#ch6fig5) shows the list of certificates
    used to trust the *virginia.edu* certificate. You can view the certification path
    in Google Chrome by clicking the lock icon on the left-hand side of the URL bar
    and then selecting the certificate from the drop-down menu.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch06fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-5: The path of official certificates*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine this certificate path. The root CA (Sectigo) validates the ICA
    (InCommon) by signing a hash of InCommon’s certificate. When Bob’s browser receives
    *virginia.edu*’s certificate, it first validates InCommon’s certificate by verifying
    the hash Sectigo provided. If the hashes match, Bob’s browser can trust InCommon’s
    certificate and will use InCommon’s public key to decrypt the hash of *virginia.edu*’s
    certificate.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the certification path is only three levels deep. For longer
    paths, the browser starts at the root certificate and follows the path until it
    reaches the last certificate, validating each certificate along the way.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Diffie-Hellman to Compute a Shared Key**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before two parties can encrypt packets, they must compute a shared key. One
    way they can do that is with the *Diffie-Hellman* key exchange algorithm. In this
    section, we’ll look at the six steps of the Diffie-Hellman key exchange. [Table
    6-1](ch06.xhtml#ch6tab1) provides a summary of all the steps. Don’t worry if it
    seems complicated; I’ll explain each of these steps in the subsections that follow.
  prefs: []
  type: TYPE_NORMAL
- en: Often, hackers manage to break some encryption because they discover mistakes
    in the design or implementation of a cryptographic algorithm. At the end of this
    section, we’ll examine how state actors like the NSA could break Diffie-Hellman
    encryption.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-1:** The Steps Used to Establish a Shared Key in a Diffie-Hellman
    Key Exchange'
  prefs: []
  type: TYPE_NORMAL
- en: '| Step | Alice | Bob |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Shared Parameter: *g* |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | *A* = *random* | *B* = *random* |'
  prefs: []
  type: TYPE_TB
- en: '|  | *a* = *g^A* | *b* = *g^B* |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | {*a*, *nonce[a]*} *→* |'
  prefs: []
  type: TYPE_TB
- en: '|  | *←* {*b*, *nonce[b]*} |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | *S* = *b^A* = (*g^B*)^(*A*) | *S* = *a^B* = (*g^A*)^(*B*) |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | *K* = *HKDF*(*S*, *nonce[a]*, *nonce[b]*) | *K* = *HKDF*(*S*, *nonce[a]*,
    *nonce[b]*) |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | *←* *E*(*K*, *data*) *→* |'
  prefs: []
  type: TYPE_TB
- en: '***Step 1: Generating the Shared Parameters***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first step in the Diffie-Hellman key exchange algorithm is generating the
    shared parameters, *p* and *g*, which will be used to compute the public and shared
    secret keys. The generator, *g*, is usually set to a value of 2\. This parameter
    is called the generator because we use it to generate the public key by computing
    *g^A*. All our public keys are generated from a base *g*, so we say they’re in
    the same group. You can think of a group as a series of numbers like *g*¹, *g*²,
    *g*³. . ., which we can also write as *g*, *g* *** *g*, *g* *** *g* *** *g*. .
    . Notice that we could create everything in the group by multiplying *g* by itself.
  prefs: []
  type: TYPE_NORMAL
- en: The parameter *p* is a large prime number that constrains the public and computed
    keys to values between 1 and (*p* – 1) by computing the results of modulo *p*.
    We have omitted the (mod *p*) operations from the table because it makes the math
    more straightforward without affecting the validity. A secure implementation of
    Diffie-Hellman uses a large prime, where (*p* – 1)/2 is also prime.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can generate these parameters by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `openssl` program `genpkey` generates the keys, the `-genparam` and (`-algorithm
    DH`) flags direct `openssl` to generate the parameters for the Diffie-Hellman
    key exchange algorithm, and the `-out` flag specifies the name of the output file,
    in this case *parametersPG.pem*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve generated the parameters, you can view them by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `openssl` program `pkeyparam` extracts the parameters from the *.pem* file
    and the `text` flag outputs a human-readable version of the key. After you run
    the command, you should see output that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The top section shows the Base64-encoded parameters, and the bottom section
    shows their human-readable representations. Both the prime (*p*) and generator
    (*g*) parameters are represented in hex. You’ll use these parameters to generate
    a public key.
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 2: Generating the Public–Private Key Pair***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before Alice and Bob can generate their public keys, they must each randomly
    select a number to serve as their private keys. Alice and Bob then calculate their
    public keys by respectively computing *g^A* and *g^B*, where *A* and *B* represent
    their respective private keys. The NSA recommends using keys that are 3,072 bits
    or larger; however, selecting keys longer than 3,072 bits may be inconvenient
    because longer keys take more time to generate. For example, it takes a standard
    desktop machine more than seven hours to generate a 6,144 bit RSA key. Thus, `openssl`
    defaults to key sizes of 2,048 bits. [Table 6-2](ch06.xhtml#ch6tab2) illustrates
    this key generation process.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-2:** Generating the Public–Private Key Pair'
  prefs: []
  type: TYPE_NORMAL
- en: '| Keys | Alice | Bob |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Private (A and B) | A = random value | B = random value |'
  prefs: []
  type: TYPE_TB
- en: '| Public (a and b) | *a* = *g^A* | *b* = *g^B* |'
  prefs: []
  type: TYPE_TB
- en: 'We can generate Alice’s public–private key pair by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-paramfile` flag instructs `openssl` to use the parameters in the file
    *parametersPG.pem*, and `genpkey`, to generate a new public-private key pair.
    When you’ve generated the key pair, you can view it by running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `openssl` utility `pkey` parses private keys. The output of this command
    represents both keys as 2,048-bit hexadecimal numbers, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Remember that you should never share your private key. If an attacker is able
    to steal or calculate your private key, they’ll be able to decrypt your communications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, use the same public parameters to generate Bob’s public-private key pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It is critical that Alice and Bob use the same parameters, because they’ll calculate
    different secret keys if they don’t.
  prefs: []
  type: TYPE_NORMAL
- en: '***Why Can’t a Hacker Calculate the Private Key?***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You might be wondering why a hacker couldn’t use the public parameter *g* and
    public key *a* to calculate Alice’s private key. For example, it would seem that
    an attacker could calculate *A* by computing the discrete log base *g* of public
    key *a*, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*a* = *g^A* *⇒* *A* = *log[g]*(*a*)'
  prefs: []
  type: TYPE_NORMAL
- en: This would be possible if a *a* were a small number; however, *a* is a very
    large number, 2,048 bits in our case. If you wrote out the largest possible 2,048-bit
    number in decimal, it would be 617 digits long and equivalent to multiplying a
    trillion by itself 50 times. Because calculating the discrete log is a much slower
    process than calculating the original exponent, it would take an attacker the
    remaining life of the sun to calculate the private random value *A* from the public
    key *a* using known classical algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: However, researchers expect that quantum computers will someday be able to quickly
    calculate the discrete log, at which point these encryption algorithms will no
    longer be safe. If you’re worried about this, you can take one of two approaches
    to future proofing your encrypted files.
  prefs: []
  type: TYPE_NORMAL
- en: • **Choose longer keys.** A key size of 3,072 bits should buy you some time;
    however, as quantum computers improve even those keys won’t be long enough.
  prefs: []
  type: TYPE_NORMAL
- en: '• **Use a quantum-safe encryption algorithm.** The team at *[https://openquantumsafe.org/](https://openquantumsafe.org/)*
    is working on open source implementations of quantum-safe algorithms. One of the
    most promising approaches is lattice-based cryptography. However, a discussion
    of these is outside the scope of this book. If you’re curious, I recommend [Chapter
    16](ch16.xhtml#ch16) of *A Graduate Course in Applied Cryptography* by Dan Boneh
    and Victor Shoup. You can access it by visiting: *[https://toc.cryptobook.us/](https://toc.cryptobook.us/)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 3: Exchanging Key Shares and Nonces***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, Alice and Bob exchange their public keys and nonces (random numbers).
    Recall from [Chapter 5](ch05.xhtml#ch5) that nonces ensure that each cipher text
    is unique. [Table 6-3](ch06.xhtml#ch6tab3) describes this step.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-3:** Exchanging Public-Key Shares and Nonces'
  prefs: []
  type: TYPE_NORMAL
- en: '| Step | Alice | Bob |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | {*a*, *nonce[a]*} *→* |'
  prefs: []
  type: TYPE_TB
- en: '|  | *←* {*b*, *nonce[b]*} |'
  prefs: []
  type: TYPE_TB
- en: 'Use the `openssl pkey` utility to extract Alice’s public key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pubout` flag instructs `openssl` to output Alice’s public key only. Extract
    Bob’s public key using the same method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can view a human-readable version of Bob’s public key by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the generated file contains only Bob’s public key and the public
    parameters *p* and *g*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 4: Calculating the Shared Secret Key***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that Alice and Bob have each other’s public keys and public parameters,
    they can independently calculate the same secret symmetric key. Alice calculates
    the shared key by raising Bob’s public key *b* to the value of her secret key
    *A*, resulting in a new shared key *S*. Bob does the same with Alice’s public
    key *a* and his secret key *B*, resulting in *the same secret key*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see why the two public keys generate the same secret key, remember that
    we calculated Alice’s public key *a* by raising *g* to the value of her secret
    key (*a* = *g^A*). If we substitute this into Bob’s calculation of his secret
    key, we get: *S* = *a^B* = (*g^A*)*^B* = *g^(AB)*. If you repeat this process
    for Alice, you’ll see that she calculates the same secret key: *S* = *b^A* = (*g^B*)*^A*
    = *g^(BA)*. [Table 6-4](ch06.xhtml#ch6tab4) summarizes these calculations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-4:** Calculating the Shared Key'
  prefs: []
  type: TYPE_NORMAL
- en: '| Step | Alice | Bob |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | *S* = *b^A* = (*g^B*)*A* | *S* = *a^B* = (*g^A*)*B* |'
  prefs: []
  type: TYPE_TB
- en: 'Now, let’s use the `openssl` public-key utility, `pkeyutil`, to derive (`-derive`)
    Alice’s shared secret key by using Bob’s public key (`-peerkey`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also derive Bob’s shared secret key by using the same command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can view a human-readable version of Alice’s secret key by using the `xxd`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s use the `cmp` command to compare Alice’s and Bob’s shared secret
    keys. If the keys are the same, the command won’t print anything; however, if
    they don’t match, it will print out the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If everything worked correctly, you should receive no output.
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 5: Key Derivation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Although we now have a shared key, we can’t use it directly, because it is
    in the wrong form. The shared key is a number, but block ciphers require a uniform
    random string. Thus, we must use the *HKDF* key derivation function to derive
    a uniform random string from the calculated number. The HKDF function uses the
    shared key and both nonces to generate the final symmetric key: *K* = *HKDF*(*S*,
    *nonce[a]*, *nonce[b]*). [Table 6-5](ch06.xhtml#ch6tab5) shows how both parties
    convert the shared number into a key by using the HKDF key derivation function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-5:** Converting *S* into a Key Using the HKDF Key Derivation Function'
  prefs: []
  type: TYPE_NORMAL
- en: '| Alice | Bob |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *K* = *HKDF*(*S*, *nonce[a]*, *nonce[b]*) | *K* = *HKDF*(*S*, *nonce[a]*,
    *nonce[b]*) |'
  prefs: []
  type: TYPE_TB
- en: Let’s use a key derivation function to derive a key and encrypt a file. Instead
    of using HKDF, we will use the PBKDF2 function supported by `openssl`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once you’ve run this command, it will derive a key from the binary value stored
    in *AliceSharedsecret.bin*. Next, `openssl` will use the derived key to encrypt
    the *plain.txt* file, and write the encrypted result to the *encrypted.txt* file.
  prefs: []
  type: TYPE_NORMAL
- en: '***Attacking Diffie-Hellman***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you understand the Diffie-Hellman algorithm, let’s examine how state
    actors could recover private keys from 1,024-bit public keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, when choosing shared parameters, a browser would randomly select *p*
    from a large set of primes. (Remember: all operations are mod *p*). However, most
    browsers use only a small subset of prime numbers. A state actor with access to
    large computing resources could precompute all 1,024-bit public-private key pairs
    for given prime numbers. They can achieve this by using the fastest known algorithm
    for computing the inverse log: the *general number field sieve (GNFS)*. GNFS consists
    of four steps. State actors precompute the first three steps and can then easily
    compute the last step when needed.'
  prefs: []
  type: TYPE_NORMAL
- en: In a previous version of TLS (TLS 1.2), the client and server negotiated encryption
    type and key length using unencrypted packets. This allowed hackers to intercept
    packets and downgrade the key to a length of 1,024 bits. Luckily, the newest version
    of TLS (TLS 1.3) is not vulnerable to this type of attack.
  prefs: []
  type: TYPE_NORMAL
- en: '**Elliptic-Curve Diffie-Hellman**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Elliptic-curve Diffie-Hellman* is a faster implementation of the Diffie-Hellman
    key exchange algorithm that achieves similar security with shorter keys. For example,
    a 256-bit elliptic-curve cryptography (ECC) key is the equivalent of a 3,072-bit
    RSA key. (Keys are considered equivalent if it would take the same amount of computer
    resources to break them.)'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of calculating exponents, elliptic-curve Diffie-Hellman performs mathematical
    operations on an *elliptic curve*, a type of curve that looks like the one shown
    in [Figure 6-6](ch06.xhtml#ch6fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch06fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-6: Plot of the secp256k1 curve along example values for the generator,
    private key, and associated public key*'
  prefs: []
  type: TYPE_NORMAL
- en: In elliptic-curve Diffie-Hellman, Alice’s public key *a[xy]* is a point on the
    elliptic curve that is calculated by multiplying a randomly selected private integer
    *A* by the shared point *G[x]*[,]*[y]*, called the *generator*. The generator
    is preselected to be a point on the curve that maximizes the number of possible
    public keys that can be calculated from it.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive into how this works.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Math of Elliptic Curves***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An elliptic curve is defined by
  prefs: []
  type: TYPE_NORMAL
- en: '*y*² = *x*³ + *ax* + *b*'
  prefs: []
  type: TYPE_NORMAL
- en: where *a* and *b* are the parameters of the curve.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-6](ch06.xhtml#ch6fig6) shows a popular elliptic curve, the secp256k1
    curve, which is used in several cryptographic applications, including Bitcoin.
    The secp256k1 curve is defined by the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*y*² = *x*³ + 7'
  prefs: []
  type: TYPE_NORMAL
- en: The National Institute of Standards and Technology (NIST) recommends the P-256
    or Curve25519 elliptic curves, which are the most widely used curves on the web
    today. We’ll use the secp256k1 curve shown in [Figure 6-6](ch06.xhtml#ch6fig6)
    in this discussion; however, the same concepts apply to P-256 and Curve25519.
  prefs: []
  type: TYPE_NORMAL
- en: Like the original Diffie-Hellman algorithm, the eliptic-curve Diffie-Hellman
    uses a shared parameter *G* and a public-private key pair. The public key is a
    point on the curve, and the private key is a randomly chosen integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 6-6](ch06.xhtml#ch6tab6) summarizes the steps in the elliptic-curve
    Diffie-Hellman key exchange algorithm. As with the original Diffie-Hellman algorithm,
    all operations are mod *p*; however, I’ve omitted this from the table for clarity.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-6:** The Steps Used to Establish a Shared Key in an Elliptic-Curve
    Diffie-Hellman Key Exchange'
  prefs: []
  type: TYPE_NORMAL
- en: '| Step | Alice | Bob |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Shared point: *G[xy]* |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | *A* = *random* | *B* = *random* |'
  prefs: []
  type: TYPE_TB
- en: '|  | *a[xy]* = *A* *×* *G[xy]* | *b[xy]* = *B* *×* *G[xy]* |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | {*a[xy]*, *nonce[a]*} *![image](../images/arrow01.jpg)* |'
  prefs: []
  type: TYPE_TB
- en: '|  | *←* {*b[xy]*, *nonce[b]*} |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | *K[xy]* = *A* *×* *b[xy]* = *A* *×* *B* *×* *G[xy]* | *K[xy]* = *B* *×*
    *a[xy]* = *B* *×* *A* *×* *G[xy]* |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | *K* = *HKDF*(*K[x]*, *nonce[a]*, *nonce[b]*) | *K* = *HKDF*(*K[x]*, *nonce[a]*,
    *nonce[b]*) |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | *←* *E*(*K*, *data*) *![image](../images/arrow01.jpg)* |'
  prefs: []
  type: TYPE_TB
- en: Notice that these steps are similar to those of the original Diffie-Hellman
    algorithm. For that reason, I won’t walk through them in detail. However, note
    that the elliptic-curve Diffie-Hellman uses the multiplication of points on the
    elliptic curve instead of exponentiation to generate key pairs.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Double and Add Algorithm***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unless you’ve worked with elliptic curves before, you’re probably not sure what
    it means to perform mathematical operations on points of a curve. For example,
    what does it mean to multiply the point *G[xy]* by an integer *A*?
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiplying point *G[xy]* by an integer 4 is equivalent to adding the point
    to itself three times:'
  prefs: []
  type: TYPE_NORMAL
- en: 4 *×* *G[xy]* = *G[xy]* + *G[xy]* + *G[xy]* + *G[xy]*
  prefs: []
  type: TYPE_NORMAL
- en: Adding a point *G[xy]* to itself is geometrically equivalent to taking the tangent
    of the point and reflecting its intersection with the elliptic curve about the
    x-axis. [Figure 6-7](ch06.xhtml#ch6fig7) graphically represents the process of
    adding a point to itself.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch06fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-7: An example of adding the point* *G[xy]* *to itself*'
  prefs: []
  type: TYPE_NORMAL
- en: A more efficient way of computing 4 *×* *G[xy]* would be to first compute 2*G[xy]*
    = *G[xy]* + *G[xy]* and then compute 4*G[xy]* = 2*G[xy]* + 2*G[xy]*, which would
    reduce the number of additions needed. For that reason, the algorithm used in
    practice to calculate elliptic-curve Diffie-Hellman keys is called the *double
    and add algorithm*.
  prefs: []
  type: TYPE_NORMAL
- en: 'When Alice computes her public key *a[xy]* = *A* *×* *G[xy]*, she sends it
    to Bob and includes a nonce. Bob does the same. Once Alice receives Bob’s public
    key, she calculates the point representing the shared key by multiplying Bob’s
    public point *b[xy]* by her secret integer *A*, resulting in a new point: *K[xy]*
    = *A* *×* *b[xy]* = *A* *×* *B* *×* *G[xy]*. Bob does the same and gets *K[xy]*
    = *B* *×* *a[xy]* = *B* *×* *A* *×* *G[xy]*. By convention, the x value is extracted
    for key point *K[xy]* and passed to the HKDF key derivation function to calculate
    the final shared key.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Why Can’t a Hacker Use G[xy] and a[xy] to Calculate the Private Key A?***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once again, you might be wondering: Why can’t a hacker who knows *G[xy]* and
    *a[xy]* compute *A*? Recall that we chose the generator *G[x]y* so that we could
    reach the maximum number of points on the elliptic curve. This, combined with
    the fact that all operations are modulo, a large prime *p* means that it is very
    difficult to recover *A* from *a[xy]* and *G[xy]*. If (*A* *×* *G[xy]*) is smaller
    than *p*, you might attempt to compute *A* by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A* = *a[xy]*/*G[xy]*'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you’re not dividing two numbers, but rather two points on an elliptic
    curve, which is why we can perform only addition and subtraction. To solve the
    preceding equation, we would need an algorithm that efficiently computes division
    using only addition and subtraction. However, no currently known classical algorithms
    can do this. That said, it’s important to note that you want to use a good source
    of randomness when generating *A*. An attacker can easily determine *A* if it
    is generated from a predictable or pseudo-random sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '**Writing TLS Sockets**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s use the *secure sockets layer (SSL)* library to implement a secure
    socket in Python. We’ll use the Python `with` syntax, like we did in [Chapter
    5](ch05.xhtml#ch5), to help manage our socket resources.
  prefs: []
  type: TYPE_NORMAL
- en: To encrypt our sockets, we’ll use the *AES-GCM (Galois/counter mode) cipher*
    block cipher. AES-GCM combines the ideas of message authentication with the counter
    mode block ciphers introduced in [Chapter 5](ch05.xhtml#ch5) to provide confidentiality,
    and message integrity. Consider an example of encrypting a TCP packet. We want
    to encrypt the packet’s contents, but routers need the packet’s IP addresses,
    so we want to ensure that this information remains unchanged. Therefore, we need
    integrity checks for both the encrypted and unencrypted parts of our packet. We
    call this approach *authenticated encryption with associated data*, and AES-GCM
    supports it.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin by writing a secure client socket.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Secure Client Socket***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s implement the client socket, which will establish a secure connection
    to the server that we’ll implement in the next subsection. Create a new file called
    *secureSocket.py* and copy the following code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we import the Python socket and SSL libraries ➊. Next, we create a new
    SSL context ➋. The SSL context is the class that manages the certificates and
    other socket settings. Instead of relying on public-key infrastructure to verify
    certificates, the client and server each contain a copy of both certificates.
    Let’s generate the server’s private key and public certificate by running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `req` and `-new` flags specify that we’re requesting a new key. The `-newkey
    rsa:3072` flag generates a new RSA key that is 3,072 bits long. The `-days` flag
    specifies the number of days that you want the certificate to be valid, in this
    case 365 days. The `-nodes` flag directs `openssl` to generate an unencrypted
    private key and the `-x509` flag specifies the output format of the certificate.
    The `-keyout` flag specifies the name of the output file (*server.key*) that will
    contain the public-private key pair, and the `-out` flag specifies the name of
    the output file (*server.crt*) that will contain the certificate.
  prefs: []
  type: TYPE_NORMAL
- en: When you run this command, it should ask you to enter the information you want
    to include in your certificate. You can leave all the fields blank or make up
    your information; it’s your certificate after all. Remember that any information
    you include in the certificate will be visible to anyone who attempts to connect
    to your server.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you’ve created the server’s X.509-formatted certificate, pass it to the
    SSL context. Repeat the above process to generate the client’s certificate and
    private key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Load the client’s private key and certificate ➌. The server will use these to
    verify the client’s identity.
  prefs: []
  type: TYPE_NORMAL
- en: Select a key-exchange algorithm by setting the appropriate bit in the context’s
    options. Here, we recommend that you use elliptic-curve Diffie-Hellman. We set
    the appropriate bit by OR-ing the options with the ssl constant `ssl.OP_SINGLE_ECDH_USE`
    ➍. One of the great advantages of the Diffie-Hellman key exchange is that we can
    calculate a new shared secret for every connection. This means that if someone
    steals your private key, they’ll be able to decrypt only past communications and
    not future ones. This is commonly known as *forward secrecy*.
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve configured the options, create a new socket ➎ and wrap the socket
    in an SSL context ➏. The socket wrapper ensures that all information is encrypted
    before it is sent to the socket.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Secure Server Socket***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s implement the server socket, the program that accepts secure connections
    from your client. Create a new file called *secureServer.py* and copy the following
    code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We set up the default context to support client authentication ➊. This means
    that only clients with authorized certificates can connect to the server. We then
    ensure that the server checks client certificates ➋. Next, we provide the client
    and server certificate locations ➌. Lastly, we ban all the previous versions of
    TLS, ensuring that the server uses the highest TLS version available ➍. In this
    case, this is TLS 1.3.
  prefs: []
  type: TYPE_NORMAL
- en: Run *secureServer.py* in your Kali Linux terminal. Then, open another terminal,
    run *secureSocket.py*, and add a message if you choose.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The terminal in which you ran *secureServer.py* should resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you’re having issues establishing a secure connection to the server from
    these scripts, your Kali Linux virtual machine may have been polluted by libraries
    used in prior chapters. In that case, you might need to create a new virtual machine.
    See [Chapter 1](ch01.xhtml#ch1) for details on doing this.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SSL Stripping and HSTS Bypass**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How might an attacker get around TLS? If a hacker executes an ARP spoofing attack
    like the one we performed in [Chapter 2](ch02.xhtml#ch2), they’ll be able to intercept
    all of the user’s traffic. But if this traffic is encrypted, the attacker will
    be unable to read it.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the victim downloads an unencrypted page containing secure links,
    the attacker could attempt to downgrade the connection from HTTPS (indicating
    the use of TLS) to an unencrypted HTTP connection by replacing the secure HTTPS
    link
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'with an insecure HTTP link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Modern browsers defend against these attacks by implementing *httP Strict Transport
    Security (HSTS)* rules. Servers use HSTS rules to force browsers to use the HTTPS
    protocol exclusively; however, the server might not correctly enforce these rules
    on certain subdomains. By changing the subdomain, a hacker might be able to bypass
    the HSTS rules. For example, notice the extra `w` in following domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Though the domain *wwww.exampleTestDomain.com* might support HSTS, the system
    administrator might have forgotten to add HSTS for that subdomain. By accessing
    a new subdomain *wwww.exampleTestDomain.com* or *support.exampleTestDomain.com*,
    the attacker might still be able to perform an SSL stripping attack.
  prefs: []
  type: TYPE_NORMAL
- en: You can use a tool like bettercap to perform this attack. The bettercap tool
    is a great network hacking utility that’s well worth learning. For example, it
    could quickly ARP spoof every machine on a network, route the traffic through
    an HTTP proxy with SSL stripping and HSTS bypass, and inject malicious JavaScript
    into web pages where HSTS is misconfigured.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise: Add Encryption to your Ransomware Server**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Chapter 4](ch04.xhtml#ch4), we explored a popular hacker tool: the botnet.
    However, the design of our bot was flawed because the bots used unencrypted TCP
    sockets to communicate with its server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same is true for the ransomware server we built in [Chapter 5](ch05.xhtml#ch5).
    In this exercise, you’ll implement a new version of your ransomware server that
    can accept secure connections. I’ve provided an example implementation of a server
    that supports multiple secure connections. Use this as a template to modify your
    own code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to use the certificates *client.crt* and *server.crt*, and keys *server.key*
    and *client.key* that you generated earlier in the chapter. You’ll need to specify
    their file paths ➊. Also, if you didn’t install the `thread` library in an earlier
    chapter, you might need to install it here by using `pip`.
  prefs: []
  type: TYPE_NORMAL
- en: I defined the function that handles each incoming connection ➋. You’ll add your
    decryption code here. Then, we set a backlog of five connections ➌. As new connections
    come in, they’ll be added to the backlog, and as each connection is handled, it
    will be removed from the backlog. We continually accept new connections ➍, and
    we create a new thread to handle each connection ”.
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve implemented your secure ransomware server, try encrypting your
    botnet’s communications, too.
  prefs: []
  type: TYPE_NORMAL
