- en: '**6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6'
- en: TLS AND DIFFIE-HELLMAN**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: TLS与迪菲-赫尔曼密钥交换**
- en: '*The world is a dangerous place to live, not because of the people who are
    evil, but because of the people who don’t do anything about it.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*世界是一个危险的地方，不是因为那些邪恶的人，而是因为那些不采取任何行动的人。*'
- en: –Albert Einstein
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: –阿尔伯特·爱因斯坦
- en: '![image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: In [Chapter 4](ch04.xhtml#ch4), you used TCP and UDP sockets to send data between
    machines on the internet. But, as you observed, the data sent through these sockets
    wasn’t encrypted, so anybody who captured it could read it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.xhtml#ch4)中，你使用了TCP和UDP套接字在互联网上的计算机之间发送数据。但是，正如你所观察到的，通过这些套接字发送的数据并没有加密，因此任何捕获到这些数据的人都可以读取它。
- en: To communicate securely, you must encrypt data before sending it. Figuring out
    how to do this effectively proved challenging to the security community at first
    because asymmetric cryptography techniques are too slow to encrypt a stream of
    data without causing lags. Efficient encryption requires both parties to first
    set up a shared symmetric key, which is used to encrypt traffic with less overhead.
    The *transport layer security (TLS)* protocol uses asymmetric cryptography techniques
    to set up this shared symmetric key. TLS is used in all sorts of applications
    that require secure communication, such as apps that control military drones or
    transmit large bank transactions. These days, most websites use HTTPS to secure
    their communication, and HTTPS depends on TLS.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全地进行通信，你必须在发送数据之前进行加密。最初，安全领域的专家发现如何有效地做到这一点具有挑战性，因为非对称加密技术太慢，无法在不引起延迟的情况下加密数据流。高效的加密需要双方首先建立一个共享的对称密钥，用于以较低的开销加密流量。*传输层安全（TLS）*协议使用非对称加密技术来建立这个共享的对称密钥。TLS被广泛应用于需要安全通信的各种场景，例如控制军用无人机或传输大型银行交易的应用程序。如今，大多数网站使用HTTPS来确保它们的通信安全，而HTTPS依赖于TLS。
- en: In this chapter, you’ll learn how TLS communications work and how the Diffie-Hellman
    key exchange algorithm generates the keys required for it. Then, you’ll write
    a Python program that uses TLS to establish a secure communication channel. We’ll
    conclude by discussing how an attacker might decrypt an encrypted channel.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将学习TLS通信是如何工作的，以及迪菲-赫尔曼密钥交换算法是如何生成所需的密钥的。然后，你将编写一个使用TLS建立安全通信通道的Python程序。最后，我们将讨论攻击者可能如何解密一个加密的通道。
- en: '**Transport Layer Security**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**传输层安全性**'
- en: 'Recall from [Chapter 5](ch05.xhtml#ch5) that symmetric-key cryptography uses
    a single key to both encrypt and decrypt a file. This technique is fast, but it
    has a downside: both parties must share the key somehow. On the other hand, asymmetrickey
    cryptography relies on a public-private key pair to send a message, meaning that
    it doesn’t have this limitation.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第5章](ch05.xhtml#ch5)中提到的，对称密钥加密使用一个单一的密钥来加密和解密文件。这个技术非常快速，但它也有一个缺点：双方必须以某种方式共享这个密钥。另一方面，非对称密钥加密依赖于一对公钥和私钥来发送消息，这意味着它没有这种限制。
- en: Using both techniques, TLS establishes an encrypted communication channel between
    two parties. To set up their encrypted channel, the two parties must exchange
    only two messages. [Figure 6-1](ch06.xhtml#ch6fig1) shows a simplified overview
    of the process for TLS 1.3 (currently the most secure version).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两种技术，TLS在双方之间建立了一个加密的通信通道。为了建立这个加密通道，双方只需交换两条消息。[图6-1](ch06.xhtml#ch6fig1)展示了TLS
    1.3（目前最安全的版本）过程的简化概述。
- en: '![image](../images/ch06fig01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch06fig01.jpg)'
- en: '*Figure 6-1: The TLS message exchange*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-1：TLS消息交换*'
- en: The client starts the connection by sending a *Client Hello* message, which
    contains the client’s public key share and nonce. The server then combines its
    private key with the client’s public-key share to compute a new symmetric key.
    The server can now use this symmetric key to encrypt and decrypt future messages.
    However, the server still needs to share some information with the client so that
    the client can also calculate the same symmetric key. To do this, the server sends
    a *Server Hello* message that contains an unencrypted copy of the server’s public-key
    share and nonce. The client then combines its private key with the server’s public
    key share to calculate the same symmetric key, which it will use to encrypt and
    decrypt all future messages. Voilà! Now the client and server have both calculated
    the same symmetric key without directly sending the key. How is this possible?
    They both combined different pieces of information but still calculated the same
    key. In this chapter, I’ll talk about the algorithms that makes this possible.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端通过发送一个*客户端你好*消息来开始连接，该消息包含客户端的公钥共享和随机数。然后，服务器将其私钥与客户端的公钥共享结合起来，计算出一个新的对称密钥。服务器现在可以使用这个对称密钥来加密和解密未来的消息。然而，服务器仍然需要与客户端共享一些信息，以便客户端也能够计算出相同的对称密钥。为此，服务器发送一个*服务器你好*消息，其中包含服务器的公钥共享和随机数的未加密副本。然后，客户端将其私钥与服务器的公钥共享结合起来，计算出相同的对称密钥，客户端将使用该密钥来加密和解密所有未来的消息。瞧！现在，客户端和服务器都已计算出相同的对称密钥，而无需直接发送密钥。这怎么可能？他们都结合了不同的信息片段，但仍然计算出了相同的密钥。在本章中，我将讨论使这一切成为可能的算法。
- en: Because the server knows that the client will be able to decrypt information
    after it receives the server’s public-key share and nonce, the server will also
    include some encrypted information about the server’s identity (its certificate)
    and proof of the message’s authenticity. Let’s delve into TLS further by exploring
    how the client proves the message’s authenticity.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因为服务器知道客户端在收到服务器的公钥共享和随机数后能够解密信息，所以服务器还会包括一些加密的信息，关于服务器的身份（其证书）以及消息真实性的证明。让我们通过探索客户端如何证明消息的真实性，进一步深入了解
    TLS。
- en: '***Message Authentication***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***消息认证***'
- en: Encryption prevents hackers from deciphering messages, but it doesn’t prevent
    tampering. In a public network, a hacker can alter a decrypted message by changing
    bits in the encrypted message. [Figure 6-2](ch06.xhtml#ch6fig2) shows how modifying
    an encrypted message can change the decrypted outcome.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 加密可以防止黑客解密消息，但它并不能防止篡改。在公共网络中，黑客可以通过更改加密消息中的位来篡改解密后的消息。[图 6-2](ch06.xhtml#ch6fig2)展示了修改加密消息如何改变解密后的结果。
- en: '![image](../images/ch06fig02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch06fig02.jpg)'
- en: '*Figure 6-2: How a hacker can modify an encrypted message and affect the decrypted
    outcome*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：黑客如何修改加密消息并影响解密结果*'
- en: This isn’t an issue for TLS users, because they can detect when a message has
    changed and reject it. Imagine that whenever you sent a package through the mail,
    you wrote the package’s weight on a tag. A recipient could verify the package
    by comparing its weight to the one listed on the tag. If the weight matches, the
    recipient can be confident nothing has been added or removed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 TLS 用户来说，这不是一个问题，因为他们可以检测消息是否发生变化，并拒绝它。想象一下，每次你通过邮件发送一个包裹时，都会在标签上写下包裹的重量。收件人可以通过将包裹的重量与标签上列出的重量进行比较来验证包裹。如果重量匹配，收件人可以确信没有任何东西被添加或移除。
- en: TLS uses *hash-based message authentication codes (HMACs)* to verify messages.
    The HMAC function uses a cryptographic hash function to generate a unique hash
    of each message. A *hash function* creates the same fixed-length string when given
    the same input. The message’s recipient reapplies HMAC and compares the two hashes.
    If a message is altered, its hash will be different, but if the hashes match,
    the message is authentic.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 使用*基于哈希的消息认证码（HMACs）*来验证消息。HMAC 函数使用加密哈希函数生成每个消息的唯一哈希值。*哈希函数*在给定相同输入时，会生成相同的固定长度字符串。消息的接收者会重新应用
    HMAC，并比较两个哈希值。如果消息被更改，其哈希值将不同，但如果哈希值匹配，则消息是可信的。
- en: 'Hash functions by themselves do not provide authenticity. Because they’re publicly
    commutable, a hacker could modify a message and recompute its hash. To ensure
    that the hash was generated by a trusted party, it must be combined with the shared
    symmetric key computed during the key exchange. This *signed* hash is called a
    *message authentication code*. Following is the equation for the HMAC function:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数本身并不能提供真实性。由于它们是公开可交换的，黑客可以修改消息并重新计算其哈希值。为了确保哈希是由可信方生成的，它必须与在密钥交换过程中计算的共享对称密钥结合使用。这个*签名*哈希叫做*消息认证码*。以下是
    HMAC 函数的公式：
- en: HMAC(*K*, *m*) = H((*K^′* ⊕ *opad*) ∥ ((*K^′* ⊕ *ipad*) ∥ *m*))
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: HMAC(*K*, *m*) = H((*K^′* ⊕ *opad*) ∥ ((*K^′* ⊕ *ipad*) ∥ *m*))
- en: Here, *K* represents the shared symmetric key, and *m* represents the encrypted
    message. *H* represents the hash function, most commonly SHA3256\. *K^′* is a
    block size version of the key. The ∥ operator represents bit-level concatenating
    of two pieces of information. Lastly, *opad* and *ipad* are two constants that
    are there for legacy reasons.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*K* 代表共享的对称密钥，*m* 代表加密的消息。*H* 代表哈希函数，最常用的是 SHA3256。*K^′* 是密钥的块大小版本。∥ 运算符表示将两部分信息按位连接。最后，*opad*
    和 *ipad* 是为了兼容性而使用的常量。
- en: Once a message is encrypted, it’s then hashed and signed by the HMAC function.
    The MAC is then attached to the message and sent. Only a person with the secret
    symmetric key can change the hash.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦消息被加密，它就会被哈希处理，并通过 HMAC 函数进行签名。然后，MAC 被附加到消息上并发送出去。只有拥有秘密对称密钥的人才能更改哈希值。
- en: '***Certificate Authorities and Signatures***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***证书颁发机构和签名***'
- en: A hacker can pretend to be any machine on the network, so how can Bob be confident
    he is communicating with Alice? At the beginning of the TLS handshake, Alice provides
    Bob with her *certificate*, a digital document that proves Alice owns the public
    key she provided. Bob validates Alice’s certificate by checking its signature
    using the signature verification algorithm ([Figure 6-3](ch06.xhtml#ch6fig3)).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客可以假装成网络上的任何机器，那么 Bob 如何确认他在与 Alice 通信？在 TLS 握手的开始阶段，Alice 向 Bob 提供了她的*证书*，这是一份数字文档，证明
    Alice 拥有她提供的公钥。Bob 通过使用签名验证算法来验证 Alice 的证书的签名（[图 6-3](ch06.xhtml#ch6fig3)）。
- en: '![image](../images/ch06fig03.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch06fig03.jpg)'
- en: '*Figure 6-3: The signature creation and verification process*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：签名创建和验证过程*'
- en: '**Signatures**'
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**签名**'
- en: 'You could use the RSA algorithm discussed in [Chapter 5](ch05.xhtml#ch5) to
    create a signature algorithm. To sign a certificate message *m*, first compute
    a hash *H*(*m*) with SHA-256 and then encrypt the result with a private key *sk*
    (which stands for secret key). The resulting cipher text represents your signature
    *s*:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用在[第 5 章](ch05.xhtml#ch5)中讨论的 RSA 算法来创建签名算法。要签署一个证书消息 *m*，首先使用 SHA-256 计算哈希
    *H*(*m*)，然后使用私钥 *sk*（表示秘密密钥）对结果进行加密。生成的密文表示你的签名 *s*：
- en: Sign(*m*, *sk*) = *E*(*H*(*m*), *sk*) = *s*
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Sign(*m*, *sk*) = *E*(*H*(*m*), *sk*) = *s*
- en: 'Verify the certificate or message (*m*) by using the public key (*pk*) to decrypt
    (*D*) the signature (*s*). The signature is valid if *H*(*m*) matches *s*:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用公钥 (*pk*) 解密 (*D*) 签名 (*s*) 来验证证书或消息 (*m*)。如果 *H*(*m*) 与 *s* 匹配，则签名有效：
- en: Ver(*m*, *s*, *pk*) = *D*(*s*, *pk*) == *H*(*m*)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Ver(*m*, *s*, *pk*) = *D*(*s*, *pk*) == *H*(*m*)
- en: '[Figure 6-3](ch06.xhtml#ch6fig3) shows an overview of the process of signing
    a message that Alice sends to Bob.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](ch06.xhtml#ch6fig3)展示了 Alice 向 Bob 发送消息时签名过程的概览。'
- en: '***Certificate Authorities***'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***证书颁发机构***'
- en: For a certificate to be valid, the internet’s trusted *public key infrastructure
    (PKI)* must have signed it. The PKI is a collection of secure servers that sign
    and store certified copies of certificates. Alice pays to register her certificate
    with an *intermediate certificate authority (ICA)*, so Bob can verify Alice’s
    certificate during the TLS handshake.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要使证书有效，互联网的信任的*公钥基础设施（PKI）*必须对其进行签名。PKI 是一组安全的服务器，它们签署并存储经过认证的证书副本。Alice 为注册她的证书支付费用，并将其注册到*中介证书颁发机构（ICA）*，这样
    Bob 就可以在 TLS 握手过程中验证 Alice 的证书。
- en: How does Bob know that he can trust the ICA? Bob’s browser has been preprogrammed
    with the ICA’s public key, so it trusts messages signed with the ICA’s private
    key. [Figure 6-4](ch06.xhtml#ch6fig4) shows an overview of the certificate validation
    process.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Bob 如何知道他可以信任 ICA？Bob 的浏览器已经预先编程了 ICA 的公钥，因此它信任由 ICA 的私钥签名的消息。[图 6-4](ch06.xhtml#ch6fig4)展示了证书验证过程的概览。
- en: '![image](../images/ch06fig04.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch06fig04.jpg)'
- en: '*Figure 6-4: An overview of the certificate validation process*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-4：证书验证过程概述*'
- en: Alice’s certificate contains her public key and an ICA-signed hash of the certificate.
    When Bob’s browser receives the certificate, it decrypts the hash and verifies
    the certificate by comparing the computed hash with the decrypted hash.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝的证书包含她的公钥和由 ICA 签名的证书哈希。当鲍勃的浏览器收到证书时，它会解密哈希，并通过将计算出的哈希与解密后的哈希进行比较来验证证书。
- en: Browsers sometimes receive a certificate from an ICA whose public key they haven’t
    stored. In these cases, the browser must use its other public keys to validate
    the ICA’s certificate. There are 14 root certificate authorities (CAs) in the
    world, and all browsers must include their public keys. When a root CA trusts
    an ICA, it signs that ICA’s certificate. When Alice provides her certificate,
    she also provides a signed copy of all the CA certificates Bob needs to verify
    her certificate. [Figure 6-5](ch06.xhtml#ch6fig5) shows the list of certificates
    used to trust the *virginia.edu* certificate. You can view the certification path
    in Google Chrome by clicking the lock icon on the left-hand side of the URL bar
    and then selecting the certificate from the drop-down menu.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器有时会收到来自 ICA 的证书，而它们的公钥尚未存储。在这种情况下，浏览器必须使用其他公钥来验证 ICA 的证书。全球有 14 个根证书颁发机构（CAs），所有浏览器都必须包含它们的公钥。当根
    CA 信任某个 ICA 时，它会签署该 ICA 的证书。当爱丽丝提供她的证书时，她还会提供一份签名副本，包括鲍勃验证她的证书所需的所有 CA 证书。[图 6-5](ch06.xhtml#ch6fig5)展示了用于信任
    *virginia.edu* 证书的证书列表。你可以通过点击 URL 栏左侧的锁形图标，然后从下拉菜单中选择证书，查看 Google Chrome 中的认证路径。
- en: '![image](../images/ch06fig05.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch06fig05.jpg)'
- en: '*Figure 6-5: The path of official certificates*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-5：官方证书路径*'
- en: Let’s examine this certificate path. The root CA (Sectigo) validates the ICA
    (InCommon) by signing a hash of InCommon’s certificate. When Bob’s browser receives
    *virginia.edu*’s certificate, it first validates InCommon’s certificate by verifying
    the hash Sectigo provided. If the hashes match, Bob’s browser can trust InCommon’s
    certificate and will use InCommon’s public key to decrypt the hash of *virginia.edu*’s
    certificate.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个证书路径。根 CA（Sectigo）通过签署 InCommon 证书的哈希来验证 ICA（InCommon）。当鲍勃的浏览器收到 *virginia.edu*
    的证书时，它首先验证 InCommon 的证书，方法是验证 Sectigo 提供的哈希。如果哈希匹配，鲍勃的浏览器可以信任 InCommon 的证书，并使用
    InCommon 的公钥来解密 *virginia.edu* 证书的哈希。
- en: In this example, the certification path is only three levels deep. For longer
    paths, the browser starts at the root certificate and follows the path until it
    reaches the last certificate, validating each certificate along the way.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，认证路径只有三层深。对于更长的路径，浏览器从根证书开始，沿路径验证每个证书，直到最后一个证书。
- en: '**Using Diffie-Hellman to Compute a Shared Key**'
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Diffie-Hellman 计算共享密钥**'
- en: Before two parties can encrypt packets, they must compute a shared key. One
    way they can do that is with the *Diffie-Hellman* key exchange algorithm. In this
    section, we’ll look at the six steps of the Diffie-Hellman key exchange. [Table
    6-1](ch06.xhtml#ch6tab1) provides a summary of all the steps. Don’t worry if it
    seems complicated; I’ll explain each of these steps in the subsections that follow.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在两方能够加密数据包之前，它们必须计算一个共享密钥。它们可以通过 *Diffie-Hellman* 密钥交换算法来实现这一点。在本节中，我们将介绍 Diffie-Hellman
    密钥交换的六个步骤。[表 6-1](ch06.xhtml#ch6tab1)提供了所有步骤的总结。如果看起来有些复杂，不要担心；我会在接下来的小节中逐一解释这些步骤。
- en: Often, hackers manage to break some encryption because they discover mistakes
    in the design or implementation of a cryptographic algorithm. At the end of this
    section, we’ll examine how state actors like the NSA could break Diffie-Hellman
    encryption.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 经常有黑客通过发现加密算法设计或实现中的漏洞来破解加密。在本节的最后，我们将讨论像 NSA 这样的国家级行为者如何突破 Diffie-Hellman 加密。
- en: '**Table 6-1:** The Steps Used to Establish a Shared Key in a Diffie-Hellman
    Key Exchange'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-1：** 在 Diffie-Hellman 密钥交换中建立共享密钥的步骤'
- en: '| Step | Alice | Bob |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 | 爱丽丝 | 鲍勃 |'
- en: '| --- | --- | --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | Shared Parameter: *g* |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 共享参数：*g* |'
- en: '| 2 | *A* = *random* | *B* = *random* |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *A* = *random* | *B* = *random* |'
- en: '|  | *a* = *g^A* | *b* = *g^B* |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '|  | *a* = *g^A* | *b* = *g^B* |'
- en: '| 3 | {*a*, *nonce[a]*} *→* |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 3 | {*a*, *nonce[a]*} *→* |'
- en: '|  | *←* {*b*, *nonce[b]*} |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '|  | *←* {*b*, *nonce[b]*} |'
- en: '| 4 | *S* = *b^A* = (*g^B*)^(*A*) | *S* = *a^B* = (*g^A*)^(*B*) |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 4 | *S* = *b^A* = (*g^B*)^(*A*) | *S* = *a^B* = (*g^A*)^(*B*) |'
- en: '| 5 | *K* = *HKDF*(*S*, *nonce[a]*, *nonce[b]*) | *K* = *HKDF*(*S*, *nonce[a]*,
    *nonce[b]*) |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 5 | *K* = *HKDF*(*S*, *nonce[a]*, *nonce[b]*) | *K* = *HKDF*(*S*, *nonce[a]*,
    *nonce[b]*) |'
- en: '| 6 | *←* *E*(*K*, *data*) *→* |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 6 | *←* *E*(*K*, *data*) *→* |'
- en: '***Step 1: Generating the Shared Parameters***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 1：生成共享参数***'
- en: The first step in the Diffie-Hellman key exchange algorithm is generating the
    shared parameters, *p* and *g*, which will be used to compute the public and shared
    secret keys. The generator, *g*, is usually set to a value of 2\. This parameter
    is called the generator because we use it to generate the public key by computing
    *g^A*. All our public keys are generated from a base *g*, so we say they’re in
    the same group. You can think of a group as a series of numbers like *g*¹, *g*²,
    *g*³. . ., which we can also write as *g*, *g* *** *g*, *g* *** *g* *** *g*. .
    . Notice that we could create everything in the group by multiplying *g* by itself.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Diffie-Hellman 密钥交换算法的第一步是生成共享参数 *p* 和 *g*，这些参数将用于计算公钥和共享的秘密密钥。生成器 *g* 通常设置为
    2。这个参数被称为生成器，因为我们使用它通过计算 *g^A* 来生成公钥。所有的公钥都是从基数 *g* 生成的，因此我们说它们属于同一个组。你可以将一个组想象成一系列数字，如
    *g*¹、*g*²、*g*³……，我们也可以将其写为 *g*、*g* *** *g*、*g* *** *g* *** *g*…… 请注意，我们可以通过将 *g*
    自己相乘来生成组中的所有内容。
- en: The parameter *p* is a large prime number that constrains the public and computed
    keys to values between 1 and (*p* – 1) by computing the results of modulo *p*.
    We have omitted the (mod *p*) operations from the table because it makes the math
    more straightforward without affecting the validity. A secure implementation of
    Diffie-Hellman uses a large prime, where (*p* – 1)/2 is also prime.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 *p* 是一个大素数，它通过计算模 *p* 的结果将公钥和计算得到的密钥约束在 1 和 (*p* – 1) 之间。我们在表中省略了（mod *p*）运算，因为这样做不会影响数学的简洁性且不会改变其有效性。Diffie-Hellman
    的安全实现使用一个大素数，其中 (*p* – 1)/2 也是素数。
- en: 'You can generate these parameters by running the following command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令来生成这些参数：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `openssl` program `genpkey` generates the keys, the `-genparam` and (`-algorithm
    DH`) flags direct `openssl` to generate the parameters for the Diffie-Hellman
    key exchange algorithm, and the `-out` flag specifies the name of the output file,
    in this case *parametersPG.pem*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`openssl` 程序中的 `genpkey` 命令生成密钥，`-genparam` 和（`-algorithm DH`）标志告诉 `openssl`
    生成 Diffie-Hellman 密钥交换算法的参数，`-out` 标志指定输出文件的名称，在这种情况下是 *parametersPG.pem*。'
- en: 'Once you’ve generated the parameters, you can view them by running the following
    command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成了参数，你可以通过运行以下命令来查看它们：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `openssl` program `pkeyparam` extracts the parameters from the *.pem* file
    and the `text` flag outputs a human-readable version of the key. After you run
    the command, you should see output that looks like the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`openssl` 程序中的 `pkeyparam` 命令从 *.pem* 文件中提取参数，`text` 标志输出密钥的可读版本。运行命令后，你应该会看到类似以下内容的输出：'
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The top section shows the Base64-encoded parameters, and the bottom section
    shows their human-readable representations. Both the prime (*p*) and generator
    (*g*) parameters are represented in hex. You’ll use these parameters to generate
    a public key.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部部分显示了 Base64 编码的参数，底部部分显示了它们的可读版本。素数 (*p*) 和生成器 (*g*) 参数以十六进制表示。你将使用这些参数来生成公钥。
- en: '***Step 2: Generating the Public–Private Key Pair***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 2：生成公私钥对***'
- en: Before Alice and Bob can generate their public keys, they must each randomly
    select a number to serve as their private keys. Alice and Bob then calculate their
    public keys by respectively computing *g^A* and *g^B*, where *A* and *B* represent
    their respective private keys. The NSA recommends using keys that are 3,072 bits
    or larger; however, selecting keys longer than 3,072 bits may be inconvenient
    because longer keys take more time to generate. For example, it takes a standard
    desktop machine more than seven hours to generate a 6,144 bit RSA key. Thus, `openssl`
    defaults to key sizes of 2,048 bits. [Table 6-2](ch06.xhtml#ch6tab2) illustrates
    this key generation process.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Alice 和 Bob 生成他们的公钥之前，他们必须分别随机选择一个数字作为他们的私钥。然后，Alice 和 Bob 分别通过计算 *g^A* 和
    *g^B* 来计算他们的公钥，其中 *A* 和 *B* 代表他们各自的私钥。美国国家安全局建议使用 3,072 位或更大的密钥；然而，选择超过 3,072
    位的密钥可能不太方便，因为更长的密钥生成所需的时间更长。例如，标准的桌面计算机生成一个 6,144 位的 RSA 密钥需要超过七个小时。因此，`openssl`
    默认为 2,048 位的密钥大小。[表 6-2](ch06.xhtml#ch6tab2) 演示了这个密钥生成过程。
- en: '**Table 6-2:** Generating the Public–Private Key Pair'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-2：生成公私钥对**'
- en: '| Keys | Alice | Bob |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 密钥 | Alice | Bob |'
- en: '| --- | --- | --- |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Private (A and B) | A = random value | B = random value |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 私钥 (A 和 B) | A = 随机值 | B = 随机值 |'
- en: '| Public (a and b) | *a* = *g^A* | *b* = *g^B* |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 公钥 (a 和 b) | *a* = *g^A* | *b* = *g^B* |'
- en: 'We can generate Alice’s public–private key pair by running:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令生成 Alice 的公私钥对：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `-paramfile` flag instructs `openssl` to use the parameters in the file
    *parametersPG.pem*, and `genpkey`, to generate a new public-private key pair.
    When you’ve generated the key pair, you can view it by running this command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`-paramfile` 标志指示 `openssl` 使用文件 *parametersPG.pem* 中的参数，并使用 `genpkey` 生成新的公私钥对。当你生成完密钥对后，可以通过运行此命令查看它：'
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `openssl` utility `pkey` parses private keys. The output of this command
    represents both keys as 2,048-bit hexadecimal numbers, as shown here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`openssl` 工具的 `pkey` 用于解析私钥。此命令的输出表示两个密钥，都是 2,048 位的十六进制数字，如下所示：'
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Remember that you should never share your private key. If an attacker is able
    to steal or calculate your private key, they’ll be able to decrypt your communications.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你绝不应该分享你的私钥。如果攻击者能够窃取或计算出你的私钥，他们将能够解密你的通信内容。
- en: 'Next, use the same public parameters to generate Bob’s public-private key pair:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用相同的公共参数生成 Bob 的公私钥对：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is critical that Alice and Bob use the same parameters, because they’ll calculate
    different secret keys if they don’t.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Alice 和 Bob 使用相同的参数至关重要，因为如果使用不同的参数，他们将计算出不同的秘密密钥。
- en: '***Why Can’t a Hacker Calculate the Private Key?***'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***为什么黑客无法计算私钥？***'
- en: 'You might be wondering why a hacker couldn’t use the public parameter *g* and
    public key *a* to calculate Alice’s private key. For example, it would seem that
    an attacker could calculate *A* by computing the discrete log base *g* of public
    key *a*, like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么黑客不能利用公共参数 *g* 和公钥 *a* 来计算 Alice 的私钥。例如，攻击者似乎可以通过计算公钥 *a* 的离散对数，以 *g*
    为底，来计算 *A*，像这样：
- en: '*a* = *g^A* *⇒* *A* = *log[g]*(*a*)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* = *g^A* *⇒* *A* = *log[g]*(*a*)'
- en: This would be possible if a *a* were a small number; however, *a* is a very
    large number, 2,048 bits in our case. If you wrote out the largest possible 2,048-bit
    number in decimal, it would be 617 digits long and equivalent to multiplying a
    trillion by itself 50 times. Because calculating the discrete log is a much slower
    process than calculating the original exponent, it would take an attacker the
    remaining life of the sun to calculate the private random value *A* from the public
    key *a* using known classical algorithms.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *a* 是一个小数字，这将是可能的；然而，*a* 是一个非常大的数字，在我们的案例中是 2,048 位。如果你将最大的 2,048 位数字写成十进制，它将有
    617 位长，相当于将一万亿自乘 50 次。因为计算离散对数的过程比计算原始指数要慢得多，攻击者需要太阳余下的寿命才能使用已知的经典算法从公钥 *a* 计算出私有随机值
    *A*。
- en: However, researchers expect that quantum computers will someday be able to quickly
    calculate the discrete log, at which point these encryption algorithms will no
    longer be safe. If you’re worried about this, you can take one of two approaches
    to future proofing your encrypted files.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，研究人员预计量子计算机有朝一日将能够快速计算离散对数，到那时这些加密算法将不再安全。如果你对此感到担忧，你可以采取两种方法来为你的加密文件做未来保障。
- en: • **Choose longer keys.** A key size of 3,072 bits should buy you some time;
    however, as quantum computers improve even those keys won’t be long enough.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: • **选择更长的密钥。** 3,072 位的密钥应该能为你争取一些时间；然而，随着量子计算机的进步，即便是这些密钥也将不足够长。
- en: '• **Use a quantum-safe encryption algorithm.** The team at *[https://openquantumsafe.org/](https://openquantumsafe.org/)*
    is working on open source implementations of quantum-safe algorithms. One of the
    most promising approaches is lattice-based cryptography. However, a discussion
    of these is outside the scope of this book. If you’re curious, I recommend [Chapter
    16](ch16.xhtml#ch16) of *A Graduate Course in Applied Cryptography* by Dan Boneh
    and Victor Shoup. You can access it by visiting: *[https://toc.cryptobook.us/](https://toc.cryptobook.us/)*.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: • **使用量子安全的加密算法。** 来自 *[https://openquantumsafe.org/](https://openquantumsafe.org/)*
    的团队正在研究量子安全算法的开源实现。最有前景的方法之一是基于格的密码学。然而，讨论这些内容超出了本书的范围。如果你感兴趣，我推荐阅读 Dan Boneh
    和 Victor Shoup 合著的 *A Graduate Course in Applied Cryptography* 中的 [第 16 章](ch16.xhtml#ch16)。你可以通过访问
    *[https://toc.cryptobook.us/](https://toc.cryptobook.us/)* 来查看。
- en: '***Step 3: Exchanging Key Shares and Nonces***'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 3：交换密钥份额和随机数***'
- en: Next, Alice and Bob exchange their public keys and nonces (random numbers).
    Recall from [Chapter 5](ch05.xhtml#ch5) that nonces ensure that each cipher text
    is unique. [Table 6-3](ch06.xhtml#ch6tab3) describes this step.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Alice 和 Bob 交换他们的公钥和随机数（nonce）。回顾 [第 5 章](ch05.xhtml#ch5)，随机数确保每个密文是唯一的。[表
    6-3](ch06.xhtml#ch6tab3) 描述了这一步骤。
- en: '**Table 6-3:** Exchanging Public-Key Shares and Nonces'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-3：** 交换公钥份额和随机数'
- en: '| Step | Alice | Bob |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 | Alice | Bob |'
- en: '| --- | --- | --- |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 3 | {*a*, *nonce[a]*} *→* |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 3 | {*a*, *nonce[a]*} *→* |'
- en: '|  | *←* {*b*, *nonce[b]*} |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '|  | *←* {*b*, *nonce[b]*} |'
- en: 'Use the `openssl pkey` utility to extract Alice’s public key:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `openssl pkey` 工具提取 Alice 的公钥：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `pubout` flag instructs `openssl` to output Alice’s public key only. Extract
    Bob’s public key using the same method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`pubout` 标志指示 `openssl` 仅输出 Alice 的公钥。使用相同的方法提取 Bob 的公钥：'
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can view a human-readable version of Bob’s public key by running the following
    command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令来查看 Bob 公钥的可读版本：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that the generated file contains only Bob’s public key and the public
    parameters *p* and *g*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，生成的文件仅包含 Bob 的公钥以及公有参数 *p* 和 *g*。
- en: '***Step 4: Calculating the Shared Secret Key***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 4：计算共享密钥***'
- en: Now that Alice and Bob have each other’s public keys and public parameters,
    they can independently calculate the same secret symmetric key. Alice calculates
    the shared key by raising Bob’s public key *b* to the value of her secret key
    *A*, resulting in a new shared key *S*. Bob does the same with Alice’s public
    key *a* and his secret key *B*, resulting in *the same secret key*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Alice 和 Bob 拥有对方的公钥和公有参数，他们可以独立计算相同的对称密钥。Alice 通过将 Bob 的公钥 *b* 提升到她的私钥 *A*
    的值来计算共享密钥，从而得到新的共享密钥 *S*。Bob 也使用 Alice 的公钥 *a* 和他的私钥 *B* 进行相同的操作，得到 *相同的共享密钥*。
- en: 'To see why the two public keys generate the same secret key, remember that
    we calculated Alice’s public key *a* by raising *g* to the value of her secret
    key (*a* = *g^A*). If we substitute this into Bob’s calculation of his secret
    key, we get: *S* = *a^B* = (*g^A*)*^B* = *g^(AB)*. If you repeat this process
    for Alice, you’ll see that she calculates the same secret key: *S* = *b^A* = (*g^B*)*^A*
    = *g^(BA)*. [Table 6-4](ch06.xhtml#ch6tab4) summarizes these calculations.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解为什么这两个公钥会生成相同的共享密钥，请记住，我们通过将 *g* 提升到她的私钥值来计算 Alice 的公钥 *a*（*a* = *g^A*）。如果我们将此代入
    Bob 计算私钥的公式，我们得到：*S* = *a^B* = (*g^A*)*^B* = *g^(AB)*。如果你为 Alice 重复这个过程，你会发现她也计算出了相同的共享密钥：*S*
    = *b^A* = (*g^B*)*^A* = *g^(BA)*。[表 6-4](ch06.xhtml#ch6tab4) 概述了这些计算过程。
- en: '**Table 6-4:** Calculating the Shared Key'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-4：** 计算共享密钥'
- en: '| Step | Alice | Bob |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 | Alice | Bob |'
- en: '| --- | --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 4 | *S* = *b^A* = (*g^B*)*A* | *S* = *a^B* = (*g^A*)*B* |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 4 | *S* = *b^A* = (*g^B*)*A* | *S* = *a^B* = (*g^A*)*B* |'
- en: 'Now, let’s use the `openssl` public-key utility, `pkeyutil`, to derive (`-derive`)
    Alice’s shared secret key by using Bob’s public key (`-peerkey`):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `openssl` 公钥工具 `pkeyutil`，通过使用 Bob 的公钥（`-peerkey`）来派生（`-derive`）Alice
    的共享密钥：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can also derive Bob’s shared secret key by using the same command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用相同的命令派生 Bob 的共享密钥：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can view a human-readable version of Alice’s secret key by using the `xxd`
    command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `xxd` 命令来查看 Alice 私钥的可读版本：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let’s use the `cmp` command to compare Alice’s and Bob’s shared secret
    keys. If the keys are the same, the command won’t print anything; however, if
    they don’t match, it will print out the differences:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `cmp` 命令来比较 Alice 和 Bob 的共享密钥。如果密钥相同，命令不会打印任何内容；然而，如果它们不匹配，命令将打印出差异：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If everything worked correctly, you should receive no output.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，你应该没有输出。
- en: '***Step 5: Key Derivation***'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 5：密钥派生***'
- en: 'Although we now have a shared key, we can’t use it directly, because it is
    in the wrong form. The shared key is a number, but block ciphers require a uniform
    random string. Thus, we must use the *HKDF* key derivation function to derive
    a uniform random string from the calculated number. The HKDF function uses the
    shared key and both nonces to generate the final symmetric key: *K* = *HKDF*(*S*,
    *nonce[a]*, *nonce[b]*). [Table 6-5](ch06.xhtml#ch6tab5) shows how both parties
    convert the shared number into a key by using the HKDF key derivation function.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们现在有了共享密钥，但我们不能直接使用它，因为它的形式不正确。共享密钥是一个数字，但对称加密算法需要一个均匀的随机字符串。因此，我们必须使用 *HKDF*
    密钥派生函数，从计算出的数字中派生出一个均匀的随机字符串。HKDF 函数使用共享密钥和两个 nonce 来生成最终的对称密钥：*K* = *HKDF*(*S*,
    *nonce[a]*, *nonce[b]*)。[表 6-5](ch06.xhtml#ch6tab5) 展示了双方如何使用 HKDF 密钥派生函数将共享数字转换为密钥。
- en: '**Table 6-5:** Converting *S* into a Key Using the HKDF Key Derivation Function'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-5：** 使用 HKDF 密钥派生函数将 *S* 转换为密钥'
- en: '| Alice | Bob |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| Alice | Bob |'
- en: '| --- | --- |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| *K* = *HKDF*(*S*, *nonce[a]*, *nonce[b]*) | *K* = *HKDF*(*S*, *nonce[a]*,
    *nonce[b]*) |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| *K* = *HKDF*(*S*, *nonce[a]*, *nonce[b]*) | *K* = *HKDF*(*S*, *nonce[a]*,
    *nonce[b]*) |'
- en: Let’s use a key derivation function to derive a key and encrypt a file. Instead
    of using HKDF, we will use the PBKDF2 function supported by `openssl`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用密钥派生函数来派生一个密钥并加密一个文件。我们将使用支持`openssl`的PBKDF2函数，而不是使用HKDF。
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once you’ve run this command, it will derive a key from the binary value stored
    in *AliceSharedsecret.bin*. Next, `openssl` will use the derived key to encrypt
    the *plain.txt* file, and write the encrypted result to the *encrypted.txt* file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你运行了这个命令，它将从存储在*AliceSharedsecret.bin*中的二进制值派生一个密钥。接下来，`openssl`将使用派生出的密钥加密*plain.txt*文件，并将加密后的结果写入*encrypted.txt*文件。
- en: '***Attacking Diffie-Hellman***'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***攻击Diffie-Hellman***'
- en: Now that you understand the Diffie-Hellman algorithm, let’s examine how state
    actors could recover private keys from 1,024-bit public keys.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了Diffie-Hellman算法，让我们看看国家级攻击者是如何从1,024位公钥中恢复私钥的。
- en: 'Ideally, when choosing shared parameters, a browser would randomly select *p*
    from a large set of primes. (Remember: all operations are mod *p*). However, most
    browsers use only a small subset of prime numbers. A state actor with access to
    large computing resources could precompute all 1,024-bit public-private key pairs
    for given prime numbers. They can achieve this by using the fastest known algorithm
    for computing the inverse log: the *general number field sieve (GNFS)*. GNFS consists
    of four steps. State actors precompute the first three steps and can then easily
    compute the last step when needed.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，在选择共享参数时，浏览器会从一大批素数中随机选择*p*。（记住：所有操作都是模*p*运算）。然而，大多数浏览器仅使用少数几个素数子集。一个具有大规模计算资源的国家级攻击者可以预先计算出给定素数的所有1,024位公私钥对。它们可以通过使用已知最快的逆对数计算算法：*通用数域筛法（GNFS）*，来实现这一点。GNFS由四个步骤组成。国家级攻击者预计算前三个步骤，然后在需要时可以轻松计算最后一步。
- en: In a previous version of TLS (TLS 1.2), the client and server negotiated encryption
    type and key length using unencrypted packets. This allowed hackers to intercept
    packets and downgrade the key to a length of 1,024 bits. Luckily, the newest version
    of TLS (TLS 1.3) is not vulnerable to this type of attack.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在TLS的早期版本（TLS 1.2）中，客户端和服务器使用未加密的数据包协商加密类型和密钥长度。这使得黑客能够拦截数据包并将密钥降级到1,024位。幸运的是，最新版本的TLS（TLS
    1.3）不容易受到这种攻击。
- en: '**Elliptic-Curve Diffie-Hellman**'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**椭圆曲线Diffie-Hellman**'
- en: '*Elliptic-curve Diffie-Hellman* is a faster implementation of the Diffie-Hellman
    key exchange algorithm that achieves similar security with shorter keys. For example,
    a 256-bit elliptic-curve cryptography (ECC) key is the equivalent of a 3,072-bit
    RSA key. (Keys are considered equivalent if it would take the same amount of computer
    resources to break them.)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*椭圆曲线Diffie-Hellman*是Diffie-Hellman密钥交换算法的一个更快速的实现，能够在使用更短的密钥时实现类似的安全性。例如，一个256位的椭圆曲线加密（ECC）密钥相当于一个3,072位的RSA密钥。（如果破解这些密钥所需的计算资源相同，则认为它们是等效的。）'
- en: Instead of calculating exponents, elliptic-curve Diffie-Hellman performs mathematical
    operations on an *elliptic curve*, a type of curve that looks like the one shown
    in [Figure 6-6](ch06.xhtml#ch6fig6).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线Diffie-Hellman不是计算指数，而是对*椭圆曲线*（一种类似于[图6-6](ch06.xhtml#ch6fig6)中所示的曲线）进行数学运算。
- en: '![image](../images/ch06fig06.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch06fig06.jpg)'
- en: '*Figure 6-6: Plot of the secp256k1 curve along example values for the generator,
    private key, and associated public key*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：secp256k1曲线的图像，示例值包括生成器、私钥和相关的公钥*'
- en: In elliptic-curve Diffie-Hellman, Alice’s public key *a[xy]* is a point on the
    elliptic curve that is calculated by multiplying a randomly selected private integer
    *A* by the shared point *G[x]*[,]*[y]*, called the *generator*. The generator
    is preselected to be a point on the curve that maximizes the number of possible
    public keys that can be calculated from it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在椭圆曲线Diffie-Hellman中，爱丽丝的公钥*a[xy]*是椭圆曲线上的一个点，它是通过将随机选择的私有整数*A*与共享点*G[x]*[,]*[y]*（称为*生成器*）相乘计算得出的。生成器是预先选择的，确保它是曲线上的一个点，从该点可以计算出尽可能多的公钥。
- en: Let’s dive into how this works.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下这是如何实现的。
- en: '***The Math of Elliptic Curves***'
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***椭圆曲线的数学原理***'
- en: An elliptic curve is defined by
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线由以下方程定义：
- en: '*y*² = *x*³ + *ax* + *b*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*² = *x*³ + *ax* + *b*'
- en: where *a* and *b* are the parameters of the curve.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*a*和*b*是曲线的参数。
- en: '[Figure 6-6](ch06.xhtml#ch6fig6) shows a popular elliptic curve, the secp256k1
    curve, which is used in several cryptographic applications, including Bitcoin.
    The secp256k1 curve is defined by the following equation:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-6](ch06.xhtml#ch6fig6)展示了一个流行的椭圆曲线——secp256k1曲线，该曲线在多个加密应用中使用，包括比特币。secp256k1曲线由以下方程定义：'
- en: '*y*² = *x*³ + 7'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: The National Institute of Standards and Technology (NIST) recommends the P-256
    or Curve25519 elliptic curves, which are the most widely used curves on the web
    today. We’ll use the secp256k1 curve shown in [Figure 6-6](ch06.xhtml#ch6fig6)
    in this discussion; however, the same concepts apply to P-256 and Curve25519.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Like the original Diffie-Hellman algorithm, the eliptic-curve Diffie-Hellman
    uses a shared parameter *G* and a public-private key pair. The public key is a
    point on the curve, and the private key is a randomly chosen integer.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 6-6](ch06.xhtml#ch6tab6) summarizes the steps in the elliptic-curve
    Diffie-Hellman key exchange algorithm. As with the original Diffie-Hellman algorithm,
    all operations are mod *p*; however, I’ve omitted this from the table for clarity.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-6:** The Steps Used to Establish a Shared Key in an Elliptic-Curve
    Diffie-Hellman Key Exchange'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '| Step | Alice | Bob |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| 1 | Shared point: *G[xy]* |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| 2 | *A* = *random* | *B* = *random* |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: '|  | *a[xy]* = *A* *×* *G[xy]* | *b[xy]* = *B* *×* *G[xy]* |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| 3 | {*a[xy]*, *nonce[a]*} *![image](../images/arrow01.jpg)* |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '|  | *←* {*b[xy]*, *nonce[b]*} |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '| 4 | *K[xy]* = *A* *×* *b[xy]* = *A* *×* *B* *×* *G[xy]* | *K[xy]* = *B* *×*
    *a[xy]* = *B* *×* *A* *×* *G[xy]* |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: '| 5 | *K* = *HKDF*(*K[x]*, *nonce[a]*, *nonce[b]*) | *K* = *HKDF*(*K[x]*, *nonce[a]*,
    *nonce[b]*) |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: '| 6 | *←* *E*(*K*, *data*) *![image](../images/arrow01.jpg)* |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: Notice that these steps are similar to those of the original Diffie-Hellman
    algorithm. For that reason, I won’t walk through them in detail. However, note
    that the elliptic-curve Diffie-Hellman uses the multiplication of points on the
    elliptic curve instead of exponentiation to generate key pairs.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '***The Double and Add Algorithm***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unless you’ve worked with elliptic curves before, you’re probably not sure what
    it means to perform mathematical operations on points of a curve. For example,
    what does it mean to multiply the point *G[xy]* by an integer *A*?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiplying point *G[xy]* by an integer 4 is equivalent to adding the point
    to itself three times:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 4 *×* *G[xy]* = *G[xy]* + *G[xy]* + *G[xy]* + *G[xy]*
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Adding a point *G[xy]* to itself is geometrically equivalent to taking the tangent
    of the point and reflecting its intersection with the elliptic curve about the
    x-axis. [Figure 6-7](ch06.xhtml#ch6fig7) graphically represents the process of
    adding a point to itself.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch06fig07.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-7: An example of adding the point* *G[xy]* *to itself*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: A more efficient way of computing 4 *×* *G[xy]* would be to first compute 2*G[xy]*
    = *G[xy]* + *G[xy]* and then compute 4*G[xy]* = 2*G[xy]* + 2*G[xy]*, which would
    reduce the number of additions needed. For that reason, the algorithm used in
    practice to calculate elliptic-curve Diffie-Hellman keys is called the *double
    and add algorithm*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'When Alice computes her public key *a[xy]* = *A* *×* *G[xy]*, she sends it
    to Bob and includes a nonce. Bob does the same. Once Alice receives Bob’s public
    key, she calculates the point representing the shared key by multiplying Bob’s
    public point *b[xy]* by her secret integer *A*, resulting in a new point: *K[xy]*
    = *A* *×* *b[xy]* = *A* *×* *B* *×* *G[xy]*. Bob does the same and gets *K[xy]*
    = *B* *×* *a[xy]* = *B* *×* *A* *×* *G[xy]*. By convention, the x value is extracted
    for key point *K[xy]* and passed to the HKDF key derivation function to calculate
    the final shared key.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '***Why Can’t a Hacker Use G[xy] and a[xy] to Calculate the Private Key A?***'
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once again, you might be wondering: Why can’t a hacker who knows *G[xy]* and
    *a[xy]* compute *A*? Recall that we chose the generator *G[x]y* so that we could
    reach the maximum number of points on the elliptic curve. This, combined with
    the fact that all operations are modulo, a large prime *p* means that it is very
    difficult to recover *A* from *a[xy]* and *G[xy]*. If (*A* *×* *G[xy]*) is smaller
    than *p*, you might attempt to compute *A* by the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '*A* = *a[xy]*/*G[xy]*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you’re not dividing two numbers, but rather two points on an elliptic
    curve, which is why we can perform only addition and subtraction. To solve the
    preceding equation, we would need an algorithm that efficiently computes division
    using only addition and subtraction. However, no currently known classical algorithms
    can do this. That said, it’s important to note that you want to use a good source
    of randomness when generating *A*. An attacker can easily determine *A* if it
    is generated from a predictable or pseudo-random sequence.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '**Writing TLS Sockets**'
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s use the *secure sockets layer (SSL)* library to implement a secure
    socket in Python. We’ll use the Python `with` syntax, like we did in [Chapter
    5](ch05.xhtml#ch5), to help manage our socket resources.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: To encrypt our sockets, we’ll use the *AES-GCM (Galois/counter mode) cipher*
    block cipher. AES-GCM combines the ideas of message authentication with the counter
    mode block ciphers introduced in [Chapter 5](ch05.xhtml#ch5) to provide confidentiality,
    and message integrity. Consider an example of encrypting a TCP packet. We want
    to encrypt the packet’s contents, but routers need the packet’s IP addresses,
    so we want to ensure that this information remains unchanged. Therefore, we need
    integrity checks for both the encrypted and unencrypted parts of our packet. We
    call this approach *authenticated encryption with associated data*, and AES-GCM
    supports it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin by writing a secure client socket.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '***The Secure Client Socket***'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s implement the client socket, which will establish a secure connection
    to the server that we’ll implement in the next subsection. Create a new file called
    *secureSocket.py* and copy the following code into it:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'First, we import the Python socket and SSL libraries ➊. Next, we create a new
    SSL context ➋. The SSL context is the class that manages the certificates and
    other socket settings. Instead of relying on public-key infrastructure to verify
    certificates, the client and server each contain a copy of both certificates.
    Let’s generate the server’s private key and public certificate by running the
    following command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入 Python 的 socket 和 SSL 库 ➊。接下来，我们创建一个新的 SSL 上下文 ➋。SSL 上下文是管理证书和其他 socket
    设置的类。客户端和服务器各自持有两份证书，而不是依赖公钥基础设施来验证证书。让我们通过运行以下命令来生成服务器的私钥和公证书：
- en: '[PRE16]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `req` and `-new` flags specify that we’re requesting a new key. The `-newkey
    rsa:3072` flag generates a new RSA key that is 3,072 bits long. The `-days` flag
    specifies the number of days that you want the certificate to be valid, in this
    case 365 days. The `-nodes` flag directs `openssl` to generate an unencrypted
    private key and the `-x509` flag specifies the output format of the certificate.
    The `-keyout` flag specifies the name of the output file (*server.key*) that will
    contain the public-private key pair, and the `-out` flag specifies the name of
    the output file (*server.crt*) that will contain the certificate.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`req` 和 `-new` 标志表示我们正在请求一个新的密钥。`-newkey rsa:3072` 标志生成一个长度为 3,072 位的新 RSA
    密钥。`-days` 标志指定证书的有效天数，这里是 365 天。`-nodes` 标志指示 `openssl` 生成一个未加密的私钥，而 `-x509`
    标志指定证书的输出格式。`-keyout` 标志指定输出文件的名称（*server.key*），该文件将包含公私钥对，`-out` 标志指定输出文件的名称（*server.crt*），该文件将包含证书。'
- en: When you run this command, it should ask you to enter the information you want
    to include in your certificate. You can leave all the fields blank or make up
    your information; it’s your certificate after all. Remember that any information
    you include in the certificate will be visible to anyone who attempts to connect
    to your server.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行此命令时，它应该会要求你输入想要包含在证书中的信息。你可以将所有字段留空或随便填写；毕竟这是你的证书。记住，任何你在证书中包含的信息都会被任何试图连接到你的服务器的人看到。
- en: 'After you’ve created the server’s X.509-formatted certificate, pass it to the
    SSL context. Repeat the above process to generate the client’s certificate and
    private key:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了服务器的 X.509 格式证书后，将其传递给 SSL 上下文。重复上述过程生成客户端的证书和私钥：
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Load the client’s private key and certificate ➌. The server will use these to
    verify the client’s identity.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 加载客户端的私钥和证书 ➌。服务器将使用这些来验证客户端的身份。
- en: Select a key-exchange algorithm by setting the appropriate bit in the context’s
    options. Here, we recommend that you use elliptic-curve Diffie-Hellman. We set
    the appropriate bit by OR-ing the options with the ssl constant `ssl.OP_SINGLE_ECDH_USE`
    ➍. One of the great advantages of the Diffie-Hellman key exchange is that we can
    calculate a new shared secret for every connection. This means that if someone
    steals your private key, they’ll be able to decrypt only past communications and
    not future ones. This is commonly known as *forward secrecy*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在上下文选项中设置适当的位来选择密钥交换算法。在这里，我们建议使用椭圆曲线 Diffie-Hellman。我们通过将选项与 ssl 常量 `ssl.OP_SINGLE_ECDH_USE`
    进行 OR 运算来设置适当的位 ➍。Diffie-Hellman 密钥交换的一个巨大优势是我们可以为每个连接计算一个新的共享密钥。这意味着如果有人窃取了你的私钥，他们只能解密过去的通信，而无法解密未来的通信。这通常被称为
    *前向保密性*。
- en: After you’ve configured the options, create a new socket ➎ and wrap the socket
    in an SSL context ➏. The socket wrapper ensures that all information is encrypted
    before it is sent to the socket.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好选项后，创建一个新的 socket ➎，并将 socket 包装在 SSL 上下文中 ➏。socket 包装器确保所有信息在发送到 socket
    之前都已加密。
- en: '***The Secure Server Socket***'
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安全服务器套接字***'
- en: 'Let’s implement the server socket, the program that accepts secure connections
    from your client. Create a new file called *secureServer.py* and copy the following
    code into it:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现服务器套接字，这是接收来自客户端的安全连接的程序。创建一个名为 *secureServer.py* 的新文件，并将以下代码复制到其中：
- en: '[PRE18]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We set up the default context to support client authentication ➊. This means
    that only clients with authorized certificates can connect to the server. We then
    ensure that the server checks client certificates ➋. Next, we provide the client
    and server certificate locations ➌. Lastly, we ban all the previous versions of
    TLS, ensuring that the server uses the highest TLS version available ➍. In this
    case, this is TLS 1.3.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Run *secureServer.py* in your Kali Linux terminal. Then, open another terminal,
    run *secureSocket.py*, and add a message if you choose.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The terminal in which you ran *secureServer.py* should resemble the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**NOTE**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '*If you’re having issues establishing a secure connection to the server from
    these scripts, your Kali Linux virtual machine may have been polluted by libraries
    used in prior chapters. In that case, you might need to create a new virtual machine.
    See [Chapter 1](ch01.xhtml#ch1) for details on doing this.*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '**SSL Stripping and HSTS Bypass**'
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How might an attacker get around TLS? If a hacker executes an ARP spoofing attack
    like the one we performed in [Chapter 2](ch02.xhtml#ch2), they’ll be able to intercept
    all of the user’s traffic. But if this traffic is encrypted, the attacker will
    be unable to read it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: However, if the victim downloads an unencrypted page containing secure links,
    the attacker could attempt to downgrade the connection from HTTPS (indicating
    the use of TLS) to an unencrypted HTTP connection by replacing the secure HTTPS
    link
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'with an insecure HTTP link:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Modern browsers defend against these attacks by implementing *httP Strict Transport
    Security (HSTS)* rules. Servers use HSTS rules to force browsers to use the HTTPS
    protocol exclusively; however, the server might not correctly enforce these rules
    on certain subdomains. By changing the subdomain, a hacker might be able to bypass
    the HSTS rules. For example, notice the extra `w` in following domain:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Though the domain *wwww.exampleTestDomain.com* might support HSTS, the system
    administrator might have forgotten to add HSTS for that subdomain. By accessing
    a new subdomain *wwww.exampleTestDomain.com* or *support.exampleTestDomain.com*,
    the attacker might still be able to perform an SSL stripping attack.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: You can use a tool like bettercap to perform this attack. The bettercap tool
    is a great network hacking utility that’s well worth learning. For example, it
    could quickly ARP spoof every machine on a network, route the traffic through
    an HTTP proxy with SSL stripping and HSTS bypass, and inject malicious JavaScript
    into web pages where HSTS is misconfigured.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise: Add Encryption to your Ransomware Server**'
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Chapter 4](ch04.xhtml#ch4), we explored a popular hacker tool: the botnet.
    However, the design of our bot was flawed because the bots used unencrypted TCP
    sockets to communicate with its server.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'The same is true for the ransomware server we built in [Chapter 5](ch05.xhtml#ch5).
    In this exercise, you’ll implement a new version of your ransomware server that
    can accept secure connections. I’ve provided an example implementation of a server
    that supports multiple secure connections. Use this as a template to modify your
    own code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[第五章](ch05.xhtml#ch5)中我们构建的勒索软件服务器也是如此。在这个练习中，你将实现一个新版本的勒索软件服务器，它能够接受安全连接。我提供了一个支持多重安全连接的服务器示例实现。你可以使用这个作为模板来修改自己的代码：'
- en: '[PRE24]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Feel free to use the certificates *client.crt* and *server.crt*, and keys *server.key*
    and *client.key* that you generated earlier in the chapter. You’ll need to specify
    their file paths ➊. Also, if you didn’t install the `thread` library in an earlier
    chapter, you might need to install it here by using `pip`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 随时可以使用你在本章之前生成的证书*client.crt*和*server.crt*，以及密钥*server.key*和*client.key*。你需要指定它们的文件路径
    ➊。此外，如果你在之前的章节没有安装`thread`库，你可能需要在这里使用`pip`进行安装。
- en: I defined the function that handles each incoming connection ➋. You’ll add your
    decryption code here. Then, we set a backlog of five connections ➌. As new connections
    come in, they’ll be added to the backlog, and as each connection is handled, it
    will be removed from the backlog. We continually accept new connections ➍, and
    we create a new thread to handle each connection ”.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我定义了处理每个传入连接的函数 ➋。你将在这里添加解密代码。然后，我们设置了一个五个连接的待处理队列 ➌。随着新连接的到来，它们将被添加到待处理队列中，每处理一个连接，就将其从队列中移除。我们不断地接受新连接
    ➍，并为每个连接创建一个新线程来处理。
- en: After you’ve implemented your secure ransomware server, try encrypting your
    botnet’s communications, too.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了安全的勒索软件服务器后，尝试加密你的僵尸网络通信。
