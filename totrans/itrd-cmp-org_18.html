<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch18"><span epub:type="pagebreak" id="page_387"/><strong><span class="big">18</span><br/>OBJECT-ORIENTED PROGRAMMING</strong></h2>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image" width="190" height="190"/></div>&#13;
<p class="noindentz">So far in this book, I have been using the procedural programming paradigm (described in “Exploring Data Formats with C” on <a href="ch02.xhtml#ch02lev1sec4">page 23</a>). In this chapter, I’ll introduce how object-oriented programming is implemented at the assembly language level in C++.</p>&#13;
<p class="indent">In object-oriented programming, we can create <em>objects</em>, each of which is an instance of a class. A class has a set of <em>attributes</em>, the data items that define the state of the object, and <em>methods</em> that can query or change the attributes of an object of the class. A software solution typically consists of constructing objects and then programming the sending of messages to the objects, which use the methods to act on the attributes.</p>&#13;
<p class="indent">I’ll use C++, an object-oriented extension of C, to illustrate some of these concepts. You’ll learn how a record can be used to store the attributes of an object and how methods are implemented as functions associated with the record.</p>&#13;
<p class="indent">Many other features of C++ are important for creating good object-oriented programming solutions, but I won’t go into them in this book. If you’re new to C++, Josh Lospinoso’s <em>C++ Crash Course</em> (No Starch Press, 2019) would be a good place to start. If you want to dig into the design of <span epub:type="pagebreak" id="page_388"/>C++ after learning how to use it, I recommend <em>A Tour of C++</em>, 3rd edition, by Bjarne Stroustrup, the creator of C++ (Addison-Wesley Professional, 2022). A good online resource for using C++ is the C++ Core Guidelines at <em><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines</a></em>. It’s kept up to date by Bjarne Stroustrup and Herb Sutter.</p>&#13;
<p class="indent">Let’s start with a very simple C++ class and then look at some assembly language generated by the C++ compiler.</p>&#13;
<h3 class="h3" id="ch18lev1sec1"><strong>Objects in C++</strong></h3>&#13;
<p class="noindent">C++ allows us to create <em>classes</em>, which are like blueprints for creating objects. A C++ class is very much like a C record, but in addition to the <em>data members</em> that define the attributes of the object, it can include functions as members of the class. In C++, we send a message to an object telling it to perform a method by calling a class <em>member function</em>.</p>&#13;
<p class="indent">C++ specifies six special member functions that are used to create and delete objects. I’ll only cover the two most commonly used ones in this book: the constructor and the destructor. The <em>constructor</em> function is used to create an instance of an object, which is called <em>instantiation</em>. The job of a constructor is to allocate the necessary memory resources and place the object in a known state before sending messages to it.</p>&#13;
<p class="indent">The C++ compiler generates the code to call our constructor function automatically at the point where we instantiate an object. A constructor function has the same name as the class. It cannot have a return value—not even <code>void</code>. The <em>default constructor</em> does not take any arguments. We can also write constructors that take arguments, and a class can have more than one constructor.</p>&#13;
<p class="indent">The job of a <em>destructor</em> function is to release any resources that were allocated by a constructor, thus deleting the object. For example, a constructor might allocate memory from the heap (described in <a href="ch10.xhtml">Chapter 10</a>), which the destructor would deallocate. There can be only one destructor function, which has the same name as the class, preceded by the <code>~</code> (tilde) character. The destructor cannot have a return value and takes no arguments. The C++ compiler will generate the code to call the destructor automatically when program flow leaves the scope of the object.</p>&#13;
<p class="indent">To demonstrate these concepts, we’ll look at a simple <code>Fraction</code> class whose attributes are two <code>int</code>s: a <code>numerator</code> and a <code>denominator</code>. We’ll include a constructor, a destructor, and some member functions to work with our <code>Fraction</code> objects. If we don’t supply constructor or destructor member functions, the C++ compiler will supply appropriate code to perform the construction and destruction of an object; we’ll explore what this means in “Writing a Constructor and Destructor via the Compiler” on <a href="ch18.xhtml#ch18lev1sec2">page 399</a>.</p>&#13;
<p class="indent">We’ll start with the declaration of our <code>Fraction</code> class, which we’ll place in a header file so it can be included in any file that uses the class, as shown in <a href="ch18.xhtml#ch18list1">Listing 18-1</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><span epub:type="pagebreak" id="page_389"/><em>fraction.h</em></p>&#13;
</div>&#13;
<pre class="pre">   // A simple Fraction class&#13;
 &#13;
   #ifndef FRACTION_H&#13;
   #define FRACTION_H&#13;
   class Fraction {&#13;
<span class="ent">❶</span> public:&#13;
       Fraction();               // Default constructor&#13;
       ~Fraction();              // Destructor&#13;
       void get();               // Get user's values&#13;
       void display();           // Display fraction&#13;
       void add_integer(int x);  // Add x to fraction&#13;
<span class="ent">❷</span> private:&#13;
       int numerator;&#13;
       int denominator;&#13;
  };&#13;
  #endif</pre>&#13;
<p class="list" id="ch18list1"><em>Listing 18-1: The C++</em> <span class="codeitalic">Fraction</span> <em>class</em></p>&#13;
<p class="indent">The overall syntax of a <code>class</code> declaration is similar to a record declaration in C, but it adds the capability to include the methods of the class as member functions. Access to members of a class can be <em>private</em>, <em>protected</em>, or <em>public</em>. We’ll look only at basic public and private access control here and leave the more complex access control concepts to books on C++.</p>&#13;
<p class="indent">We declare the member functions to be <code>public</code> <span class="ent">❶</span>. This means they can be used from outside the class to send messages to objects of this class. They provide an interface to the object.</p>&#13;
<p class="indent">We place the data members in the <code>private</code> part of the <code>class</code> declaration <span class="ent">❷</span>. This means only member functions can access them directly, thus giving the member functions control over <code>numerator</code> and <code>denominator</code>, the attributes of our <code>Fraction</code> class. Code outside this class can access them only through the public interface.</p>&#13;
<p class="indent">Access to a <code>class</code> is private by default. If we listed the attributes before the <code>public</code> area, we wouldn’t need to use the <code>private</code> keyword, but I like to list the public interface of a <code>class</code> first.</p>&#13;
<p class="indent">The <code>struct</code> keyword can also be used to declare a C++ class, as shown in <a href="ch18.xhtml#ch18list2">Listing 18-2</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>fraction.h</em></p>&#13;
</div>&#13;
<pre class="pre">// A simple Fraction class&#13;
 &#13;
#ifndef FRACTION_H&#13;
#define FRACTION_H&#13;
struct Fraction {&#13;
public:&#13;
    Fraction();               // Default constructor&#13;
    ~Fraction();              // Destructor&#13;
    void get();               // Get user's values&#13;
    void display();           // Display fraction<span epub:type="pagebreak" id="page_390"/>&#13;
    void add_integer(int x);  // Add x to fraction&#13;
private:&#13;
    int numerator;&#13;
    int denominator;&#13;
};&#13;
#endif</pre>&#13;
<p class="list" id="ch18list2"><em>Listing 18-2: The C++</em> <span class="codeitalic">Fraction struct</span></p>&#13;
<p class="indent">The default access scope for a C++ <code>struct</code> is public, but I like to be explicit. The <code>private</code> declaration is required for the private scope.</p>&#13;
<p class="indent">Although <code>class</code> and <code>struct</code> are the same except for the default access scope, I prefer using the <code>class</code> keyword because it emphasizes that there is more to it than a simple record. However, this is a personal choice. Next, we’ll look at how to create objects and how to send messages to them.</p>&#13;
<h4 class="h4" id="ch18lev2sec1"><em><strong>Creating an Object</strong></em></h4>&#13;
<p class="noindent">I’ll illustrate how to create an object and send messages to it using a simple program that allows the user to enter the numerator and denominator values of a fraction and then adds 1 to the fraction. This program is shown in <a href="ch18.xhtml#ch18list3">Listing 18-3</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>inc_fraction.cpp</em></p>&#13;
</div>&#13;
<pre class="pre">// Get a fraction from the user and add 1.&#13;
&#13;
#include "fraction.h"&#13;
&#13;
int main(void)&#13;
{&#13;
 <span class="ent">❶</span> Fraction my_fraction;&#13;
 &#13;
 <span class="ent">❷</span> my_fraction.display();&#13;
    my_fraction.get();&#13;
    my_fraction.add_integer(1);&#13;
    my_fraction.display();&#13;
 &#13;
    return 0;&#13;
}</pre>&#13;
<p class="list" id="ch18list3"><em>Listing 18-3: A program to add 1 to a fraction</em></p>&#13;
<p class="indent">We instantiate an object by using the class name and providing a name for the object <span class="ent">❶</span>, just like when defining a variable. The dot operator (<code>.</code>) is used to send a message to a method in the class <span class="ent">❷</span>, which calls the respective member function in the class the object belongs to. This program displays the state of the fraction before getting user input values and then again after adding 1 to the user’s fraction.</p>&#13;
<p class="indent">Next, we’ll look at the assembly language generated by the C++ compiler to implement the <code>main</code> function in <a href="ch18.xhtml#ch18list3">Listing 18-3</a>. The C++ compiler in our environment is called <code>g++</code>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_391"/>I used the following command to generate the assembly language in <a href="ch18.xhtml#ch18list4">Listing 18-4</a>:</p>&#13;
<pre class="pre">$ <span class="codestrong1">g++ -S -Wall -O0 -fno-unwind-tables -fno-asynchronous-unwind-tables</span>&#13;
      <span class="codestrong1">-fno-exceptions inc_fraction.cpp</span></pre>&#13;
<p class="noindent">This is the same as the command we’ve been using for C code, except I’ve added the <code>-fno-exceptions</code> option. C++ provides an <em>exception</em> mechanism for dealing with detected runtime errors. The compiler provides the information for this feature through assembler directives, which would tend to obscure the discussion here of how objects are implemented. Using the <code>-fno-exceptions</code> option turns off this feature.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>inc_fraction.s</em></p>&#13;
</div>&#13;
<pre class="pre">        .arch armv8-a&#13;
        .file   "inc_fraction.cpp"&#13;
        .text&#13;
        .align   2&#13;
        .global  main&#13;
        .type    main, %function&#13;
main:&#13;
     <span class="ent">❶</span> stp      x29, x30, [sp, -48]!&#13;
        mov      x29, sp&#13;
        str      x19, [sp, 16]&#13;
     <span class="ent">❷</span> add      x0, sp, 40&#13;
     <span class="ent">❸</span> bl       _ZN8FractionC1Ev          /// Construct my_fraction&#13;
        add      x0, sp, 40&#13;
     <span class="ent">❹</span> bl       _ZN8Fraction7displayEv&#13;
        add      x0, sp, 40&#13;
        bl       _ZN8Fraction3getEv&#13;
        add      x0, sp, 40&#13;
        mov      w1, 1&#13;
     <span class="ent">❺</span> bl       _ZN8Fraction11add_integerEi&#13;
        add      x0, sp, 40&#13;
        bl       _ZN8Fraction7displayEv&#13;
        mov      w19, 0&#13;
        add      x0, sp, 40&#13;
     <span class="ent">❻</span> bl       _ZN8FractionD1Ev         /// Destruct my_fraction&#13;
        mov      w0, w19&#13;
        ldr      x19, [sp, 16]&#13;
        ldp      x29, x30, [sp], 48&#13;
        ret&#13;
        .size    main, .-main&#13;
        .ident   "GCC: (Debian 10.2.1-6) 10.2.1 20210110"&#13;
        .section         .note.GNU-stack,"",@progbits</pre>&#13;
<p class="list" id="ch18list4"><em>Listing 18-4: The compiler-generated assembly language for the</em> <span class="codeitalic">main</span> <em>function in <a href="ch18.xhtml#ch18list3">Listing 18-3</a></em></p>&#13;
<p class="indent">The first thing to note is that <code>my_fraction</code> (<span class="ent">➊</span> in <a href="ch18.xhtml#ch18list3">Listing 18-3</a>) is an automatic local variable, so memory space is allocated on the stack for this <span epub:type="pagebreak" id="page_392"/><code>Fraction</code> object in the <code>main</code> function’s prologue <span class="ent">❶</span>. The address of this memory area is passed to the constructor function, <code>_ZN8FractionC1Ev</code>, which will initialize the object <span class="ent">❷</span>.</p>&#13;
<p class="indent">The C++ compiler has decorated the name of our constructor function <code>Fraction</code>, declared in <a href="ch18.xhtml#ch18list1">Listing 18-1</a>, to be <code>_ZN8FractionC1Ev</code> <span class="ent">❸</span>. You learned about the C compiler decorating the names of static local variables in <a href="ch15.xhtml">Chapter 15</a>. The purpose there was to distinguish between different static local variables with the same name in different functions defined in the same file.</p>&#13;
<p class="indent">C++ uses name decorating to associate member functions with their class. Looking at the calls to the class member functions in <a href="ch18.xhtml#ch18list4">Listing 18-4</a>, you can see that they all begin with <code>_ZN8Fraction</code>. Since function names are global in scope, including the class name allows us to define other classes in the program that have the same names for member functions. For example, we might have more than one class in a program that has a <code>display</code> member function. Name decorating identifies each <code>display</code> member function with the class it belongs to <span class="ent">❹</span>.</p>&#13;
<p class="indent">C++ name decorating also allows <em>function overloading</em>, which is the ability to have more than one class member function with the same name but that differ in the number of arguments and their types. In <a href="ch18.xhtml#ch18list4">Listing 18-4</a>, the decorated <code>_ZN8Fraction11add_integerEi</code>, which is our <code>add_integer</code> member function, ends with an appended <code>i</code>; this shows that the function takes a single <code>int</code> argument <span class="ent">❺</span>. Including the number and types of the arguments in the name decorating differentiates overloaded functions. You’ll get a chance to overload the default constructor in “Your Turn” <a href="ch18.xhtml#ch18exe1">exercise 18.1</a> on <a href="ch18.xhtml#ch18you1">page 406</a>.</p>&#13;
<p class="indent">There is no standard for how name decorating is done, so each compiler may do it differently. This means that all C++ code in a program must be compiled and linked using compatible compilers and linkers.</p>&#13;
<p class="indent">Look at the instruction just before each call to a member function <span class="ent">❷</span>. The address of the object is passed as the first argument to each of them. This is an <em>implicit argument</em> that doesn’t show up in the C++ code. You’ll see how to access this address in a member function when we look inside the member functions in the following section.</p>&#13;
<p class="indent">Although it doesn’t show in the C++ code that we write, the compiler generates a call to our destructor function at the point where program flow leaves the scope of the object <span class="ent">❻</span>. In some more advanced programming techniques, we would call the destructor explicitly, but we won’t cover them in the book. Most of the time, we let the compiler decide when to call the destructor.</p>&#13;
<p class="indent">Next, we’ll look at the constructor and destructor and the other member functions of this <code>Fraction</code> class.</p>&#13;
<h4 class="h4" id="ch18lev2sec2"><em><strong>Defining Class Member Functions</strong></em></h4>&#13;
<p class="noindent">Although it’s common to put each C function definition in its own file, C++ source files are commonly organized to include all the function definitions in a class. <a href="ch18.xhtml#ch18list5">Listing 18-5</a> shows the definitions of the member functions for our <code>Fraction</code> class.</p>&#13;
<div class="note6">&#13;
<p class="notep"><span epub:type="pagebreak" id="page_393"/><em>fraction.cpp</em></p>&#13;
</div>&#13;
<pre class="pre">   // A simple Fraction class&#13;
     &#13;
   #include "fraction.h"&#13;
   #include &lt;iostream&gt;&#13;
<span class="ent">❶</span> using namespace std;&#13;
 &#13;
<span class="ent">❷</span> Fraction::Fraction()&#13;
   {&#13;
    <span class="ent">❸</span> numerator = 0;&#13;
       denominator = 1;&#13;
   }&#13;
 &#13;
   Fraction::~Fraction() {}&#13;
   // Nothing to do for this object&#13;
     &#13;
   void Fraction::get()&#13;
   {&#13;
    <span class="ent">❹</span> cout &lt;&lt; "Enter numerator: ";&#13;
    <span class="ent">❺</span> cin &gt;&gt; numerator;&#13;
 &#13;
       cout &lt;&lt; "Enter denominator: ";&#13;
       cin &gt;&gt; denominator;&#13;
 &#13;
       if (denominator == 0) {&#13;
           cout &lt;&lt; "WARNING: Setting 0 denominator to 1\n";&#13;
           denominator = 1;&#13;
       }&#13;
   }&#13;
 &#13;
   void Fraction::display()&#13;
   {&#13;
       cout &lt;&lt; numerator &lt;&lt; '/' &lt;&lt; denominator &lt;&lt; '\n';&#13;
   }&#13;
 &#13;
   void Fraction::add_integer(int x)&#13;
   {&#13;
       numerator += x * denominator;&#13;
   }</pre>&#13;
<p class="list" id="ch18list5"><em>Listing 18-5: The member function definitions for our</em> <span class="codeitalic">Fraction</span> <em>class</em></p>&#13;
<p class="indent">C++ adds some scoping rules to the C scoping rules you learned about in <a href="ch14.xhtml">Chapter 14</a>. Even though the member functions declared in <a href="ch18.xhtml#ch18list1">Listing 18-1</a> are public, they have <em>class scope</em>, meaning their names need to be associated with the class. The compiler does this by decorating the names when it uses them, but we need to use the <em>scope resolution operator</em> (<code>::</code>) to make this association when defining the member functions outside the class scope <span class="ent">❷</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_394"/>One of the primary purposes of a constructor is to initialize the object. We’ll set our <code>Fraction</code> object to <code>0/1</code> <span class="ent">❸</span>, a reasonable initial value for a fraction.</p>&#13;
<p class="indent">The C++ standard library provides objects for writing to the screen and reading from the keyboard. The <code>cout</code> object in the <code>ostream</code> class writes a character stream to standard output, which is typically connected to the screen <span class="ent">❹</span>. It uses the <em>insertion operator</em> (<code>&lt;&lt;</code>) and converts the data to the appropriate character string. The <code>cin</code> object in the <code>istream</code> class reads a character stream from standard input, which is typically connected to the keyboard <span class="ent">❺</span>. It uses the <em>extraction operator</em> (<code>&gt;&gt;</code>) and converts the character string to the appropriate data type for the variable it’s reading into.</p>&#13;
<p class="indent">In addition to its class scope, C++ allows us to collect names of things into a <em>namespace scope</em>. The <code>iostream</code> header file places the <code>cout</code> and <code>cin</code> objects in the <code>std</code> namespace. We need to specify this namespace when using these objects <span class="ent">❶</span>.</p>&#13;
<p class="indent">Next, we’ll look at the compiler-generated assembly language for these member functions. To simplify the discussion, we’ll look at each function in the file separately, in <a href="ch18.xhtml#ch18list6">Listings 18-6</a> through <a href="ch18.xhtml#ch18list11">18-11</a>. As we go through them, keep in mind that this is one file, so the labels are visible across all six of the listings.</p>&#13;
<p class="indent">The beginning of the <em>fraction.s</em> file, shown in <a href="ch18.xhtml#ch18list6">Listing 18-6</a>, is code that allocates memory used by functions in the C++ I/O library for the <code>cin</code> and <code>cout</code> I/O objects. Our inclusion of the <code>iostream</code> header file in <a href="ch18.xhtml#ch18list5">Listing 18-5</a> tells the compiler to insert this code.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>fraction.s(a)</em></p>&#13;
</div>&#13;
<pre class="pre">        .arch armv8-a&#13;
        .file   "fraction.cpp"&#13;
        .text&#13;
        .section        .rodata       /// For operating system&#13;
        .align   3&#13;
        .type    _ZStL19piecewise_construct, %object&#13;
        .size    _ZStL19piecewise_construct, 1&#13;
_ZStL19piecewise_construct:&#13;
        .zero    1&#13;
     <span class="ent">❶</span> .local   _ZStL8__ioinit&#13;
     <span class="ent">❷</span> .comm    _ZStL8__ioinit,1,8</pre>&#13;
<p class="list" id="ch18list6"><em>Listing 18-6: A byte used by the</em> <span class="codeitalic">cin</span> <em>and</em> <span class="codeitalic">cout</span> <em>I/O objects</em></p>&#13;
<p class="indent">The <code>.local</code> assembler directive limits the <code>_ZStL8__ioinit</code> label to this object <span class="ent">❶</span>. The <code>.comm</code> directive allocates 1 byte in memory, which is aligned to an 8-byte address and labeled <code>_ZStL8__ioinit</code> <span class="ent">❷</span>. If there are other <code>.comm</code> directives with the same label in our program, they will share the same memory. This memory is for use by the <code>cin</code> and <code>cout</code> I/O objects; the details of its usage are beyond the scope of this book.</p>&#13;
<p class="indent"><a href="ch18.xhtml#ch18list7">Listing 18-7</a> shows the second part of the file, the constructor for our <code>Fraction</code> object.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>fraction.s(b)</em></p>&#13;
</div>&#13;
<pre class="pre">        .text&#13;
        .align  2&#13;
<span epub:type="pagebreak" id="page_395"/>        .global _ZN8FractionC2Ev&#13;
        .type   _ZN8FractionC2Ev, %function&#13;
_ZN8FractionC2Ev:&#13;
        sub     sp, sp, #16&#13;
     <span class="ent">❶</span> str      x0, [sp, 8]                    /// Save this pointer&#13;
        ldr     x0, [sp, 8]&#13;
     <span class="ent">❷</span> str      wzr, [x0]                      /// numerator = 0;&#13;
        ldr     x0, [sp, 8]&#13;
        mov     w1, 1&#13;
     <span class="ent">❸</span> str      w1, [x0, 4]                    /// denominator = 1;&#13;
        nop&#13;
        add     sp, sp, 16&#13;
        ret&#13;
        .size   _ZN8FractionC2Ev, .-_ZN8FractionC2Ev&#13;
        .global _ZN8FractionC1Ev&#13;
        .set    _ZN8FractionC1Ev,_ZN8FractionC2Ev</pre>&#13;
<p class="list" id="ch18list7"><em>Listing 18-7: The compiler-generated assembly language for the constructor in <a href="ch18.xhtml#ch18list5">Listing 18-5</a></em></p>&#13;
<p class="indent">Our constructor initializes the <code>numerator</code> <span class="ent">❷</span> and <code>denominator</code> <span class="ent">❸</span> data members in the <code>Fraction</code> object located in our stack frame. Back in <a href="ch18.xhtml#ch18list4">Listing 18-4</a>, you saw that the first argument to each member function is the address of the object that the member function is operating on. But looking at the class declaration in <a href="ch18.xhtml#ch18list1">Listing 18-1</a>, this address doesn’t show up in the member function’s parameter list. It’s called the <em>hidden parameter</em>.</p>&#13;
<p class="indent">If a member function is accessing another object in the same class as the object it was called from, it needs to be able to distinguish between the two objects. Although it doesn’t show up in the parameter list, C++ uses the name <code>this</code> for the hidden parameter, which is a pointer variable that contains the address of the object that called the member function <span class="ent">❶</span>.</p>&#13;
<p class="indent">The compiler assumes that our member functions are working with the object at the address in the <code>this</code> pointer variable, so we usually don’t need to use it. But some situations require that we explicitly use the pointer. For example, we might write a <code>Fraction</code> constructor that allows us to specify the initialization values like this:</p>&#13;
<pre class="pre">Fraction::Fraction(int numerator, int denominator) {&#13;
    this-&gt;numerator = numerator;&#13;
    this-&gt;denominator = denominator;&#13;
}</pre>&#13;
<p class="noindent">The parameter names have precedence over the member names, so we had to disambiguate with the <code>this</code> pointer.</p>&#13;
<p class="indent">Now that you know where the <code>Fraction</code> object’s data members are located within the object, you can see in <a href="ch18.xhtml#ch18fig1">Figure 18-1</a> how the object is stored in <code>main</code>’s stack frame.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_396"/><img id="ch18fig1" src="../images/pg424_Image_290.jpg" alt="Image" width="543" height="289"/></div>&#13;
<p class="figcap"><em>Figure 18-1: The</em> <span class="codeitalic">my_fraction</span> <em>object in</em> <span class="codeitalic">main</span><em>’s stack frame</em></p>&#13;
<p class="indent">I don’t know why the compiler included 16 bytes in this stack frame that are not used in the program.</p>&#13;
<p class="indent">The constructor is followed by the destructor, shown in <a href="ch18.xhtml#ch18list8">Listing 18-8</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>fraction.s(c)</em></p>&#13;
</div>&#13;
<pre class="pre">        .align  2&#13;
        .global _ZN8FractionD2Ev&#13;
        .type   _ZN8FractionD2Ev, %function&#13;
_ZN8FractionD2Ev:&#13;
        sub     sp, sp, #16&#13;
        str     x0, [sp, 8]&#13;
        nop&#13;
        add     sp, sp, 16&#13;
        ret&#13;
        .size   _ZN8FractionD2Ev, .-_ZN8FractionD2Ev&#13;
        .global _ZN8FractionD1Ev&#13;
        .set    _ZN8FractionD1Ev,_ZN8FractionD2Ev</pre>&#13;
<p class="list" id="ch18list8"><em>Listing 18-8: The compiler-generated assembly language for the destructor in <a href="ch18.xhtml#ch18list5">Listing 18-5</a></em></p>&#13;
<p class="indent">There is nothing for the destructor to do in this simple class. Earlier, in <a href="ch18.xhtml#ch18list4">Listing 18-4</a>, you saw that the memory for the object was allocated in the stack frame by the <code>main</code> function’s prologue, not by the constructor. Similarly, the object’s memory is deleted from the stack in <code>main</code>’s epilogue code, after the call to the destructor. Some constructors allocate memory from the heap, in which case the destructor should release that memory.</p>&#13;
<p class="indent">The assembly language for the destructor is followed by that for the member functions. <a href="ch18.xhtml#ch18list9">Listing 18-9</a> shows the assembly language for the <code>get</code> member function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>fraction.s(d)</em></p>&#13;
</div>&#13;
<pre class="pre">        .section          .rodata&#13;
        .align   3&#13;
        .LC0:&#13;
        .string  "Enter numerator: "&#13;
        .align   3 <span epub:type="pagebreak" id="page_397"/>&#13;
.LC1:&#13;
        .string  "Enter denominator: "&#13;
        .align   3&#13;
.LC2:&#13;
        .string  "WARNING: Setting 0 denominator to 1"&#13;
        .text&#13;
        .align   2&#13;
        .global  _ZN8Fraction3getEv&#13;
        .type    _ZN8Fraction3getEv, %function&#13;
_ZN8Fraction3getEv:&#13;
        stp      x29, x30, [sp, -32]!&#13;
        mov      x29, sp&#13;
        str      x0, [sp, 24]&#13;
        adrp     x0, .LC0&#13;
        add      x1, x0, :lo12:.LC0&#13;
      <span class="ent">❶</span> adrp     x0, :got:_ZSt4cout         /// From global library&#13;
        ldr      x0, [x0, #:got_lo12:_ZSt4cout]&#13;
        bl       _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc&#13;
        ldr      x0, [sp, 24]&#13;
        mov      x1, x0&#13;
      <span class="ent">❷</span> adrp     x0, :got:_ZSt3cin          /// From global library&#13;
        ldr      x0, [x0, #:got_lo12:_ZSt3cin]&#13;
        bl       _ZNSirsERi&#13;
        adrp     x0, .LC1&#13;
        add      x1, x0, :lo12:.LC1&#13;
        adrp     x0, :got:_ZSt4cout&#13;
        ldr      x0, [x0, #:got_lo12:_ZSt4cout]&#13;
        bl       _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc&#13;
        ldr      x0, [sp, 24]&#13;
        add      x0, x0, 4&#13;
        mov      x1, x0&#13;
        adrp     x0, :got:_ZSt3cin&#13;
        ldr      x0, [x0, #:got_lo12:_ZSt3cin]&#13;
        bl       _ZNSirsERi&#13;
        ldr      x0, [sp, 24]&#13;
        ldr      w0, [x0, 4]&#13;
        cmp      w0, 0                       /// Check for 0 denominator&#13;
        bne      .L5&#13;
        adrp     x0, .LC2&#13;
        add      x1, x0, :lo12:.LC2&#13;
        adrp     x0, :got:_ZSt4cout&#13;
        ldr      x0, [x0, #:got_lo12:_ZSt4cout]&#13;
        bl       _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc&#13;
        ldr      x0, [sp, 24]&#13;
        mov      w1, 1&#13;
        str      w1, [x0, 4]<span epub:type="pagebreak" id="page_398"/>&#13;
.L5:&#13;
        nop&#13;
        ldp      x29, x30, [sp], 32&#13;
        ret&#13;
        .size    _ZN8Fraction3getEv, .-_ZN8Fraction3getEv</pre>&#13;
<p class="list" id="ch18list9"><em>Listing 18-9: The compiler-generated assembly language for</em> <span class="codeitalic">get</span> <em>in <a href="ch18.xhtml#ch18list5">Listing 18-5</a></em></p>&#13;
<p class="indent">When the program is loaded into memory, the location of the <code>cout</code> object is loaded into our global offset table (GOT) <span class="ent">❶</span>. The location of the <code>cin</code> object is also loaded into our GOT <span class="ent">❷</span>.</p>&#13;
<p class="indent">Next, we’ll look at the <code>display</code> member function, shown in <a href="ch18.xhtml#ch18list10">Listing 18-10</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>fraction.s(e)</em></p>&#13;
</div>&#13;
<pre class="pre">        .align   2&#13;
        .global _ZN8Fraction7displayEv&#13;
        .type   _ZN8Fraction7displayEv, %function&#13;
_ZN8Fraction7displayEv:&#13;
        stp     x29, x30, [sp, -32]!&#13;
        mov     x29, sp&#13;
        str     x0, [sp, 24]&#13;
        ldr     x0, [sp, 24]&#13;
        ldr     w0, [x0]&#13;
        mov     w1, w0&#13;
        adrp    x0, :got:_ZSt4cout&#13;
        ldr     x0, [x0, #:got_lo12:_ZSt4cout]&#13;
      <span class="ent">❶</span> bl      _ZNSolsEi&#13;
        mov     w1, 47          /// '/' character&#13;
      <span class="ent">❷</span> bl      _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_c&#13;
        mov     x2, x0&#13;
        ldr     x0, [sp, 24]&#13;
        ldr     w0, [x0, 4]&#13;
        mov     w1, w0&#13;
        mov     x0, x2&#13;
        bl      _ZNSolsEi&#13;
        mov     w1, 10          /// '/ n'   character&#13;
        bl      _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_c&#13;
        nop&#13;
        ldp     x29, x30, [sp], 32&#13;
        ret&#13;
        .size   _ZN8Fraction7displayEv, .-_ZN8Fraction7displayEv</pre>&#13;
<p class="list" id="ch18list10"><em>Listing 18-10: The compiler-generated assembly language for</em> <span class="codeitalic">display</span> <em>in <a href="ch18.xhtml#ch18list5">Listing 18-5</a></em></p>&#13;
<p class="indent">In our C++ code (see <a href="ch18.xhtml#ch18list5">Listing 18-5</a>), we chain insertions to the <code>cout</code> object. The compiler matches the data item type with the <code>ostream</code> class member function it calls. The first value is an <code>int</code> <span class="ent">❶</span>, the second a <code>char</code> <span class="ent">❷</span>, and so forth.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_399"/><a href="ch18.xhtml#ch18list11">Listing 18-11</a> shows the compiler-generated assembly language for the <code>add_integer</code> member function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>fraction.s(f)</em></p>&#13;
</div>&#13;
<pre class="pre">        .align  2&#13;
        .global _ZN8Fraction11add_integerEi&#13;
        .type   _ZN8Fraction11add_integerEi, %function&#13;
_ZN8Fraction11add_integerEi:&#13;
        sub     sp, sp, #16&#13;
      <span class="ent">❶</span> str     x0, [sp, 8]&#13;
        str     w1, [sp, 4]&#13;
        ldr     x0, [sp, 8]&#13;
        ldr     w1, [x0]&#13;
        ldr     x0, [sp, 8]&#13;
        ldr     w2, [x0, 4]&#13;
        ldr     w0, [sp, 4]&#13;
        mul     w0, w2, w0&#13;
        add     w1, w1, w0&#13;
        ldr     x0, [sp, 8]&#13;
        str     w1, [x0]&#13;
        nop&#13;
        add     sp, sp, 16&#13;
        ret&#13;
        .size   _ZN8Fraction11add_integerEi, .-_ZN8Fraction11add_integerEi</pre>&#13;
<p class="list" id="ch18list11"><em>Listing 18-11: The compiler-generated assembly language for</em> <span class="codeitalic">add_integer</span> <em>in <a href="ch18.xhtml#ch18list5">Listing 18-5</a></em></p>&#13;
<p class="indent">The <code>this</code> pointer variable is created in this function’s stack frame <span class="ent">❶</span>. This is a leaf function, so the compiler doesn’t generate a frame record in the stack frame.</p>&#13;
<p class="indent">If you use the <code>g++</code> compiler to generate the assembly language yourself, you’ll see two other functions, <code>_Z41__static_initialization_and_destruction_0ii</code> and <code>_GLOBAL__sub_I__ZN8FractionC2Ev</code>. The operating system calls these functions when the program is loaded to set up the <code>cout</code> and <code>cin</code> I/O streams. The details are beyond the scope of this book, so I won’t show them here.</p>&#13;
<p class="indent">The purpose of a constructor is to allocate any system resources an object needs and to initialize the object. The destructor then releases the resources allocated by the constructor. In the next section, you’ll see that the compiler can automatically generate a constructor and a destructor for simple objects such as in our <code>Fraction</code> class.</p>&#13;
<h3 class="h3" id="ch18lev1sec2"><strong>Writing a Constructor and Destructor via the Compiler</strong></h3>&#13;
<p class="noindent">Initialization of objects in C++ is complex, because there are many ways to do it. The previous section covered the most basic way. Now, I’ll show you some simple C++ syntax that tells the compiler to figure out how to do the initialization itself.</p>&#13;
<p class="indent">Recommendation C.45 in the C++ Core Guidelines (see <em><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-default">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-default</a></em> states: “Don’t <span epub:type="pagebreak" id="page_400"/>define a default constructor that only initializes data members; use in-class member initializers instead.”</p>&#13;
<p class="indent"><a href="ch18.xhtml#ch18list12">Listing 18-12</a> shows how we can rewrite our <code>Fraction</code> class to tell the compiler to generate a constructor and destructor for us.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>fraction_dflt.h</em></p>&#13;
</div>&#13;
<pre class="pre">// A simple Fraction class&#13;
&#13;
#ifndef FRACTION_DFLT_H&#13;
#define FRACTION_DFLT_H&#13;
class Fraction {&#13;
public:&#13;
 <span class="ent">❶</span> Fraction() = default;     // Tell compiler to generate default&#13;
    ~Fraction() = default;    //   constructor and destructor&#13;
    void get();               // Get user's values&#13;
    void display();           // Display fraction&#13;
    void add_integer(int x);  // Add x to fraction&#13;
private:&#13;
 <span class="ent">❷</span> int numerator {};&#13;
    int denominator {1};&#13;
};&#13;
#endif</pre>&#13;
<p class="list" id="ch18list12"><em>Listing 18-12: The C++</em> <span class="codeitalic">Fraction</span> <em>class specifying the default constructor and destructor</em></p>&#13;
<p class="indent">The C++11 standard published in September 2011 added <em>explicitly defaulted functions</em>, which are specified with the <code>= default</code> notation <span class="ent">❶</span>. The standard says that the compiler must generate the function body and place it inline if possible.</p>&#13;
<p class="indent">Following the recommendation of the C++ Core Guidelines, I’ve used <em>in-class member initializers</em> in <a href="ch18.xhtml#ch18list12">Listing 18-12</a> to specify the initialization values for the data members <span class="ent">❷</span>. The initial value for the data member is specified in curly brackets, <code>{}</code>; an empty set of curly brackets tells the compiler to use <code>0</code>. C++ also allows the following syntaxes, using an equal sign for data member initialization:</p>&#13;
<pre class="pre">int numerator = 0;&#13;
int numerator = {};</pre>&#13;
<p class="indent">I like the plain curly brackets initialization syntax because it conveys the message that the actual assignment to the variable doesn’t take place until an object is instantiated, as you’ll see shortly. The differences are covered in Josh Lospinoso’s book, cited at the beginning of this chapter.</p>&#13;
<p class="indent">Since we have told the compiler to create a default constructor and destructor, we can eliminate these functions from our member function definition file, as shown in <a href="ch18.xhtml#ch18list13">Listing 18-13</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>fraction_dflt.cpp</em></p>&#13;
</div>&#13;
<pre class="pre">// A simple Fraction class&#13;
&#13;
#include "fraction_dflt.h"&#13;
#include &lt;iostream&gt;&#13;
<span epub:type="pagebreak" id="page_401"/>&#13;
using namespace std;&#13;
&#13;
void Fraction::get()&#13;
{&#13;
    cout &lt;&lt; "Enter numerator: ";&#13;
    cin &gt;&gt; numerator;&#13;
&#13;
    cout &lt;&lt; "Enter denominator: ";&#13;
    cin &gt;&gt; denominator;&#13;
&#13;
    if (denominator == 0) {&#13;
        cout &lt;&lt; "WARNING: Setting 0 denominator to 1\n";&#13;
        denominator = 1;&#13;
    }&#13;
}&#13;
&#13;
void Fraction::display()&#13;
{&#13;
    cout &lt;&lt; numerator &lt;&lt; '/' &lt;&lt; denominator &lt;&lt; '\n';&#13;
}&#13;
&#13;
void Fraction::add_integer(int x)&#13;
{&#13;
    numerator += x * denominator;&#13;
}</pre>&#13;
<p class="list" id="ch18list13"><em>Listing 18-13: The C++</em> <span class="codeitalic">Fraction</span> <em>class with a compiler-generated constructor and destructor</em></p>&#13;
<p class="indent"><a href="ch18.xhtml#ch18list14">Listing 18-14</a> shows the <code>main</code> function for this program.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>inc_fraction_dflt.cpp</em></p>&#13;
</div>&#13;
<pre class="pre">   // Get a fraction from the user and add 1.&#13;
&#13;
<span class="ent">❶</span> #include "fraction_dflt.h"&#13;
&#13;
   int main(void)&#13;
   {&#13;
       Fraction my_fraction;&#13;
&#13;
       my_fraction.display();&#13;
       my_fraction.get();&#13;
       my_fraction.add_integer(1);&#13;
       my_fraction.display();&#13;
&#13;
       return 0;&#13;
   }</pre>&#13;
<p class="list" id="ch18list14"><em>Listing 18-14: A program to add 1 to a fraction</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_402"/>This is the same <code>main</code> function as in <a href="ch18.xhtml#ch18list3">Listing 18-3</a>, except that we’re using the <em>fraction_dflt.h</em> header file from <a href="ch18.xhtml#ch18list12">Listing 18-12</a> to match the member function definitions in <a href="ch18.xhtml#ch18list13">Listing 18-13</a> <span class="ent">❶</span>.</p>&#13;
<p class="indent">This header file tells the compiler that it needs to write the constructor and destructor for us, as shown in <a href="ch18.xhtml#ch18list15">Listing 18-15</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>inc_fraction_dflt.s</em></p>&#13;
</div>&#13;
<pre class="pre">       .arch armv8-a&#13;
       .file   "inc_fraction_dflt.cpp"&#13;
       .text&#13;
       .align  2&#13;
       .global main&#13;
       .type   main, %function&#13;
main:&#13;
     <span class="ent">❶</span> stp     x29, x30, [sp, -32]!&#13;
       mov     x29, sp&#13;
     <span class="ent">❷</span> str     wzr, [sp, 24]                  /// int numerator {};&#13;
       mov     w0, 1&#13;
       str     w0, [sp, 28]                    /// int denominator {1};&#13;
       add     x0, sp, 24&#13;
       bl      _ZN8Fraction7displayEv&#13;
       add     x0, sp, 24&#13;
       bl      _ZN8Fraction3getEv&#13;
       add     x0, sp, 24&#13;
       mov     w1, 1&#13;
       bl      _ZN8Fraction11add_integerEi&#13;
       add     x0, sp, 24&#13;
       bl      _ZN8Fraction7displayEv&#13;
       mov     w0, 0&#13;
       ldp     x29, x30, [sp], 32&#13;
       ret&#13;
       .size   main, .-main&#13;
       .ident  "GCC: (Debian 10.2.1-6) 10.2.1 20210110"&#13;
       .section       .note.GNU-stack,"",@progbits</pre>&#13;
<p class="list" id="ch18list15"><em>Listing 18-15: The compiler-generated assembly language from <a href="ch18.xhtml#ch18list14">Listing 18-14</a>, showing the default constructor and destructor specified in <a href="ch18.xhtml#ch18list12">Listing 18-12</a></em></p>&#13;
<p class="indent">Comparing this with <a href="ch18.xhtml#ch18list4">Listing 18-4</a>, you can see that the compiler has allocated 16 fewer bytes in the stack frame for the <code>Fraction</code> object than when we provided a constructor member function <span class="ent">❶</span>. It then places the initialization of the data members inline instead of calling a function to do it <span class="ent">❷</span>.</p>&#13;
<p class="indent">The default constructor takes no arguments, but we might want to pass some arguments to a constructor at the point of instantiating an object. C++ allows us to have multiple constructors, as long as their parameter lists differ. You’ll see how this works in the next section.</p>&#13;
<h3 class="h3" id="ch18lev1sec3"><span epub:type="pagebreak" id="page_403"/><strong>Overloading the Default Constructor in C++</strong></h3>&#13;
<p class="noindent"><em>Function overloading</em> is when two or more functions in a class have the same name but differ in their parameter list or return type. To demonstrate, we’ll overload our default constructor, which takes no arguments, with one that takes a single <code>int</code> argument that allows us to specify the value of the numerator when instantiating a <code>Fraction</code> object. <a href="ch18.xhtml#ch18list16">Listing 18-16</a> shows our new class.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>fraction_2.h</em></p>&#13;
</div>&#13;
<pre class="pre">// The Fraction class with two constructors&#13;
&#13;
#ifndef FRACTION_2_H&#13;
#define FRACTION_2_H&#13;
class Fraction {&#13;
public:&#13;
     Fraction() = default;    // Tell compiler to generate default&#13;
  <span class="ent">❶</span> Fraction(int n) : numerator{n} {};  // Allow setting numerator&#13;
&#13;
    ~Fraction() = default;&#13;
    void get();               // Get user's values&#13;
    void display();           // Display fraction&#13;
    void add_integer(int x);  // Add x to fraction&#13;
private:&#13;
  <span class="ent">❷</span> int numerator {123};     // Weird values so we can see&#13;
     int denominator {456};   //   what the compiler is doing&#13;
};&#13;
#endif</pre>&#13;
<p class="list" id="ch18list16"><em>Listing 18-16: Adding a second constructor to the</em> <span class="codeitalic">Fraction</span> <em>class</em></p>&#13;
<p class="indent">The second constructor differs from the default only in its parameter list <span class="ent">❶</span>. We’re using the C++ syntax that tells the compiler how to use the parameter to initialize the <code>numerator</code> data member.</p>&#13;
<p class="indent">I’m using weird in-class member initialization values to make it easier for you to see what the assembly language is doing to initialize our object <span class="ent">❷</span>.</p>&#13;
<p class="indent">Let’s modify our <code>main</code> function to add another <code>Fraction</code> object that uses our overloaded constructor, as shown in <a href="ch18.xhtml#ch18list17">Listing 18-17</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>inc_fractions.cpp</em></p>&#13;
</div>&#13;
<pre class="pre">// Get two fractions from the user and increment each by 1.&#13;
&#13;
#include "fraction_2.h"&#13;
&#13;
int main(void)&#13;
{&#13;
    Fraction x;&#13;
    x.display();&#13;
    x.get();&#13;
    x.add_integer(1);&#13;
    x.display(); <span epub:type="pagebreak" id="page_404"/>&#13;
  <span class="ent">❶</span> Fraction y(78);&#13;
    y.display();&#13;
    y.get();&#13;
    y.add_integer(1);&#13;
    y.display();&#13;
&#13;
    return 0;&#13;
}</pre>&#13;
<p class="list" id="ch18list17"><em>Listing 18-17: A program to add 1 to two fractions that use different constructors</em></p>&#13;
<p class="indent">For the second <code>Fraction</code> object, we’re passing 78 to the constructor as the initial value <code>numerator</code> <span class="ent">❶</span>.</p>&#13;
<p class="indent"><a href="ch18.xhtml#ch18list18">Listing 18-18</a> shows how the compiler implements this second constructor in assembly language.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>inc_fractions.s</em></p>&#13;
</div>&#13;
<pre class="pre">           .arch armv8-a&#13;
           .file   "inc_fractions.cpp"&#13;
           .text&#13;
         <span class="ent">❶</span> .section .text._ZN8FractionC2Ei,"axG",@progbits,_ZN8FractionC5Ei,comdat&#13;
           .align  2&#13;
         <span class="ent">❷</span> .weak   _ZN8FractionC2Ei    /// Define label once&#13;
           .type   _ZN8FractionC2Ei, %function&#13;
<span class="ent">❸</span> _ZN8FractionC2Ei:&#13;
           sub     sp, sp, #16&#13;
           str     x0, [sp, 8]&#13;
           str     w1, [sp, 4]         /// Save n&#13;
           ldr     x0, [sp, 8]&#13;
         <span class="ent">❹</span> ldr     w1, [sp, 4]&#13;
           str     w1, [x0]            /// Initialize numerator&#13;
           ldr     x0, [sp, 8]&#13;
         <span class="ent">❺</span> mov     w1, 456             /// Initialize denominator&#13;
           str     w1, [x0, 4]&#13;
           nop&#13;
           add     sp, sp, 16&#13;
           ret&#13;
           .size   _ZN8FractionC2Ei, .-_ZN8FractionC2Ei&#13;
           .weak   _ZN8FractionC1Ei&#13;
           .set    _ZN8FractionC1Ei,_ZN8FractionC2Ei&#13;
           .text&#13;
           .align  2&#13;
           .global main&#13;
           .type   main, %function&#13;
    main:&#13;
           stp     x29, x30, [sp, -32]!&#13;
           mov     x29, sp&#13;
           mov     w0, 123&#13;
           str     w0, [sp, 24]<span epub:type="pagebreak" id="page_405"/>&#13;
           mov     w0, 456&#13;
           str     w0, [sp, 28]&#13;
           add     x0, sp, 24&#13;
           bl      _ZN8Fraction7displayEv&#13;
           add     x0, sp, 24&#13;
           bl      _ZN8Fraction3getEv&#13;
           add     x0, sp, 24&#13;
           mov     w1, 1&#13;
           bl      _ZN8Fraction11add_integerEi&#13;
           add     x0, sp, 24&#13;
           bl      _ZN8Fraction7displayEv&#13;
           add     x0, sp, 16&#13;
         <span class="ent">❻</span> mov     w1, 78               /// Constant supplied in main&#13;
           bl     _ZN8FractionC1Ei&#13;
           add    x0, sp, 16&#13;
           bl     _ZN8Fraction7displayEv&#13;
           add    x0, sp, 16&#13;
           bl     _ZN8Fraction3getEv&#13;
           add    x0, sp, 16&#13;
           mov    w1, 1&#13;
           bl     _ZN8Fraction11add_integerEi&#13;
           add    x0, sp, 16&#13;
           bl     _ZN8Fraction7displayEv&#13;
           mov    w0, 0&#13;
           ldp    x29, x30, [sp], 32&#13;
           ret&#13;
           .size  main, .-main&#13;
           .ident "GCC: (Debian 10.2.1-6) 10.2.1 20210110"&#13;
           .section       .note.GNU-stack,"",@progbits</pre>&#13;
<p class="list" id="ch18list18"><em>Listing 18-18: The compiler-generated assembly language for the function in <a href="ch18.xhtml#ch18list17">Listing 18-17</a></em></p>&#13;
<p class="indent">The compiler generates a separate function for our constructor, which takes an argument <span class="ent">❸</span>. The compiler places this constructor in a special section, marked <code>comdat</code>, where it can be called from functions in other files that use this same constructor to instantiate a <code>Fraction</code> object <span class="ent">❶</span>. The <code>.weak</code> assembler directive tells the compiler to generate this label only once in this file <span class="ent">❷</span>. Although we’re passing an explicit integer to the constructor in our <code>main</code> function <span class="ent">❻</span>, the separate function is more efficient if we’re instantiating several <code>Fraction</code> objects with variables whose values aren’t known until the program is running.</p>&#13;
<p class="indent">The argument passed to the <code>_ZN8FractionC2Ei</code> constructor is used to initialize the <code>numerator</code> attribute of our <code>Fraction</code> object <span class="ent">❹</span>. Our default in-class value is used to initialize the <code>denominator</code> attribute <span class="ent">❺</span>.</p>&#13;
<p class="indent">Since the compiler wrote this constructor for us, we only need to change <code>#include "fraction_dflt.h"</code> to <code>#include "fraction_2.h"</code> in the file that defines our other member functions, <a href="ch18.xhtml#ch18list13">Listing 18-13</a>. I won’t repeat that listing here.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_406"/>It doesn’t really make sense to write an object-oriented program in assembly language. We could invent a name decoration scheme for all our functions, but we would still be using the procedural programming paradigm to call them, not the object-oriented paradigm. However, there are situations in which we may wish to call functions written in assembly language. We’ll look at how to do this in the next section.</p>&#13;
<div class="box">&#13;
<p class="box-title" id="ch18you1"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list" id="ch18exe1">18.1   Add another constructor to the C++ program in <a href="ch18.xhtml#ch18list1">Listings 18-1</a>, <a href="ch18.xhtml#ch18list3">18-3</a>, and <a href="ch18.xhtml#ch18list5">18-5</a> that takes two integer arguments to initialize <code>Fraction</code>. Add an object that uses your second constructor. For example, <code>Fraction y(1,2);</code> would create the <code>Fraction</code> object initialized to <code>1/2</code>. Modify the <code>main</code> function to display this second <code>Fraction</code> object, get a new value for it, add an integer to the second object, and display it again.</p>&#13;
<p class="box-list" id="ch18exe2">18.2   Write a program in C++ that prompts the user to enter a numerator and a denominator and then instantiates a <code>Fraction</code> object using the user’s values. Display the new object, add 1 to it, and display the new state of the object.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch18lev1sec4"><strong>Calling Assembly Language Functions in C++</strong></h3>&#13;
<p class="noindent">To show you how to call assembly language functions in C++, I’ll change our <code>Fraction</code> member functions to use our assembly language functions <code>write_str</code>, <code>write_char</code>, <code>put_int</code>, and <code>get_int</code> for writing to the screen and reading from the keyboard. <a href="ch18.xhtml#ch18list19">Listing 18-19</a> shows the changes we need to make in the definitions of our member functions.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>fraction_asm.cpp</em></p>&#13;
</div>&#13;
<pre class="pre">   // A simple Fraction class&#13;
&#13;
   #include "fraction_dflt.h"&#13;
   // Use the following C functions.&#13;
<span class="ent">❶</span>  extern "C" {&#13;
        #include "write_str.h"&#13;
        #include "write_char.h"&#13;
        #include "get_int.h"&#13;
        #include "put_int.h"&#13;
   }&#13;
   // Use char arrays because write_str is a C function.&#13;
   char num_msg[] = "Enter numerator: ";&#13;
   char den_msg[] = "Enter denominator: ";&#13;
     &#13;
   void Fraction::get()&#13;
   {&#13;
       write_str(num_msg);&#13;
       numerator = get_int();&#13;
       write_str(den_msg); <span epub:type="pagebreak" id="page_407"/>&#13;
       denominator = get_int();&#13;
   }&#13;
   &#13;
   void Fraction::display()&#13;
   {&#13;
       put_int(numerator);&#13;
       write_char('/');&#13;
       put_int(denominator);&#13;
       write_char('\n');&#13;
   }&#13;
     &#13;
   void Fraction::add_integer(int x)&#13;
   {&#13;
       numerator += x * denominator;&#13;
   }</pre>&#13;
<p class="list" id="ch18list19"><em>Listing 18-19: Calling assembly language functions in the</em> <span class="codeitalic">Fraction</span> <em>class</em></p>&#13;
<p class="indent">The <code>extern "C"</code> tells the C++ compiler that the items in these header files have C linkage, so the compiler doesn’t decorate their names <span class="ent">❶</span>.</p>&#13;
<p class="indent"><a href="ch18.xhtml#ch18list20">Listing 18-20</a> shows how this affects the <code>get</code> member function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>fraction_asm.s</em></p>&#13;
</div>&#13;
<pre class="pre">        .arch armv8-a&#13;
        .file   "fraction_asm.cpp"&#13;
        .text&#13;
        .global num_msg&#13;
        .data&#13;
        .align  3&#13;
        .type   num_msg, %object&#13;
        .size   num_msg, 18&#13;
num_msg:&#13;
        .string "Enter numerator: "&#13;
        .global den_msg&#13;
        .align  3&#13;
        .type   den_msg, %object&#13;
        .size   den_msg, 20&#13;
den_msg:&#13;
        .string "Enter denominator: "&#13;
        .text&#13;
        .align  2&#13;
        .global _ZN8Fraction3getEv&#13;
        .type   _ZN8Fraction3getEv, %function&#13;
_ZN8Fraction3getEv:&#13;
        stp     x29, x30, [sp, -32]!&#13;
        mov     x29, sp&#13;
        str     x0, [sp, 24]&#13;
        adrp    x0, num_msg&#13;
        add     x0, x0, :lo12:num_msg&#13;
      <span class="ent">❶</span> bl      write_str <span epub:type="pagebreak" id="page_408"/>&#13;
        bl      get_int&#13;
        mov     w1, w0&#13;
        ldr     x0, [sp, 24]&#13;
        str     w1, [x0]&#13;
        adrp    x0, den_msg&#13;
        add     x0, x0, :lo12:den_msg&#13;
        bl      write_str&#13;
        bl      get_int&#13;
        mov     w1, w0&#13;
        ldr     x0, [sp, 24]&#13;
        str     w1, [x0, 4]&#13;
        nop&#13;
        ldp     x29, x30, [sp], 32&#13;
        ret&#13;
        .size   _ZN8Fraction3getEv, .-_ZN8Fraction3getEv&#13;
--<span class="codeitalic1">snip</span>--</pre>&#13;
<p class="list" id="ch18list20"><em>Listing 18-20: The compiler-generated assembly language for</em> <span class="codeitalic">get</span> <em>in <a href="ch18.xhtml#ch18list19">Listing 18-19</a></em></p>&#13;
<p class="indent">The assembly language functions are called by the names we’ve given them, without any decoration <span class="ent">❶</span>. If you use <code>g++</code> to generate the assembly language for the <code>display</code> member function, you’ll see similar results for the <code>put_int</code> and <code>write_char</code> function calls.</p>&#13;
<h3 class="h3" id="ch18lev1sec5"><strong>What You’ve Learned</strong></h3>&#13;
<p class="noindentin"><strong>Class</strong>   The declaration of the data members that define the state of an object, along with any member functions used to access these data members.</p>&#13;
<p class="noindentin"><strong>Objects in C++</strong>   A named area of memory that contains the data members declared in a class.</p>&#13;
<p class="noindentin"><strong>Methods or member functions</strong>   The member functions declared in a class can be called to access the state of an object of the same class.</p>&#13;
<p class="noindentin"><strong>Name decoration</strong>   The compiler creates member function names that include the function name, the class it belongs to, and the number and types of any arguments to the function.</p>&#13;
<p class="noindentin"><strong>Constructor</strong>   A member function used to initialize an object.</p>&#13;
<p class="noindentin"><strong>Destructor</strong>   A member function used to clean up resources that are no longer needed.</p>&#13;
<p class="indenta">This chapter has been a brief introduction to the way C++ implements basic object-oriented programming features.</p>&#13;
<p class="indent">Now that you’ve learned several techniques for organizing data in programs, I’ll turn back to how data is stored in binary. So far in this book, I’ve used only integral values in our programs. In the next chapter, you’ll see how fractional values are represented in memory and learn about some of the CPU instructions to manipulate them.</p>&#13;
</div>
</div>
</body></html>