<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch03"><span epub:type="pagebreak" id="page_37"/><strong><span class="big">3</span><br/>COMPUTER ARITHMETIC</strong></h2>&#13;
<div class="image1"><img src="../images/pg23_Image_2.jpg" alt="Image" width="191" height="190"/></div>&#13;
<p class="noindentz">The reality of computing is that we have a finite number of bits. In the previous chapter, you learned that each data item must fit within a fixed number of bits, depending on its data type. This chapter will show you that this limit complicates even our most basic mathematical operations. For both signed and unsigned numbers, a limited number of bits is a constraint we don’t normally think about when doing math on paper or in our heads.</p>&#13;
<p class="indent">The CPU includes memory for a set of single-bit <em>condition flags</em>. Among them are a <em>carry flag (</em><span class="codeitalic">C</span><em>)</em> and an <em>overflow flag (</em><span class="codeitalic">V</span><em>)</em> that enable us to detect when adding or subtracting binary numbers yields results that exceed the allocated number of bits for the data type. We’ll dig deeper into the carry flag and the overflow flag in subsequent chapters, but for now, let’s take a look at how addition and subtraction affect them.</p>&#13;
<span epub:type="pagebreak" id="page_38"/>&#13;
<h3 class="h3" id="ch03lev1sec1"><strong>Unsigned Integers in the Decimal Number System</strong></h3>&#13;
<p class="noindent">When computers do arithmetic, they do it in the binary number system. The operations may seem difficult at first, but if you remember the details of performing decimal arithmetic by hand, binary arithmetic becomes much easier. Although most people do addition on a calculator these days, reviewing all the steps required to do it by hand will help us develop the algorithms to do addition and subtraction in binary and hexadecimal.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Most computer architectures provide arithmetic instructions in other number systems, but those are somewhat specialized. We will not consider them in this book.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch03lev2sec1"><em><strong>Addition</strong></em></h4>&#13;
<p class="noindent">Let’s restrict ourselves to two-digit decimal numbers. Consider two of these, <em>x</em> = 67 and <em>y</em> = 79. Adding these by hand on paper would look like this:</p>&#13;
<div class="image1"><img src="../images/pg66_Image_18.jpg" alt="Image" width="194" height="110"/></div>&#13;
<p class="indent">We start by working from the right, adding the two decimal digits in the ones place: 7 + 9 = 16, which exceeds 10 by 6. We show this by placing a 6 in the sum’s ones place and carrying a 1 to the tens place:</p>&#13;
<div class="image1"><img src="../images/pg66_Image_19.jpg" alt="Image" width="210" height="122"/></div>&#13;
<p class="indent">Next, we add the three decimal digits in the tens place: 1 (the carry from the ones place) + 6 + 7. The sum of these three digits exceeds 10 by 4, which we show by placing a 4 in the tens place and then recording the fact that there is an ultimate carry of 1. Because we’re using only two digits, there is no hundreds place.</p>&#13;
<p class="indent">The following algorithm shows the procedure for adding two decimal integers, <em>x</em> and <em>y</em>. In this algorithm, <em>x<sub>i</sub></em> and <em>y<sub>i</sub></em> are the <em>i</em>th digits of <em>x</em> and <em>y</em>, respectively, numbered from right to left:</p>&#13;
<pre class="pre">Let Carry<sub>0</sub> = 0 &#13;
Repeat for each i = 0, ..., (N - 1)               // Starting in ones place &#13;
 &#13;
    Sum<sub>i</sub> = (x<sub>i</sub> + y<sub>i</sub> + Carry<sub>i</sub>) % 10                // Remainder &#13;
    Carry<sub>i + 1</sub> = (x<sub>i</sub> + y<sub>i</sub> + Carry<sub>i</sub>) / 10           // Integer division</pre>&#13;
<p class="indent">This algorithm works because we use positional notation when writing numbers; a digit one place to the left counts 10 times more. The carry from the current position one place to the left is always 0 or 1.</p>&#13;
<span epub:type="pagebreak" id="page_39"/>&#13;
<p class="indent">We use 10 in the <span class="literal">/</span> and <span class="literal">%</span> operations because there are exactly 10 digits in the decimal number system: 0, 1, 2, . . . , 9. Since we are working in an <em>N</em>-digit system, we restrict our result to <em>N</em> digits. The ultimate carry, <em>Carry<sub>N</sub></em>, is either 0 or 1 and is part of the result, along with the <em>N</em>-digit sum.</p>&#13;
<h4 class="h4" id="ch03lev2sec2"><em><strong>Subtraction</strong></em></h4>&#13;
<p class="noindent">For subtraction, you sometimes have to borrow from the next higher-order digit in the <em>minuend</em> (the number being subtracted from). We’ll do the subtraction with the same numbers we used earlier (67 and 79) and go through this in steps so you can understand the process. “Scratch” work will be in the borrowing row above the two numbers:</p>&#13;
<div class="image1"><img src="../images/pg67_Image_20.jpg" alt="Image" width="226" height="78"/></div>&#13;
<p class="indent">First, we need to borrow 1 from the 6 in the tens place and add it to the 7 in the ones place. Then, we can subtract 9 from 17 and get 8:</p>&#13;
<div class="image1"><img src="../images/pg67_Image_21.jpg" alt="Image" width="237" height="110"/></div>&#13;
<p class="indent">Next, we need to borrow from beyond the two digits, which we mark by placing a 1 in the “carry” position. That gives us 15 in the tens place, from which we subtract 7:</p>&#13;
<div class="image1"><img src="../images/pg67_Image_22.jpg" alt="Image" width="235" height="143"/></div>&#13;
<p class="indent">This is shown in the following algorithm, where <em>x</em> is the minuend and <em>y</em> is the number being subtracted from it (the <em>subtrahend</em>). If <em>Borrow</em> is 1 at the end of this algorithm, it shows that you had to borrow from beyond the <em>N</em> digits of the two values, so the <em>N</em>-digit result is incorrect. Although it’s called the <em>carry flag</em>, its purpose is to show when the operation gives a result that will not fit within the number of bits for the data type. Thus, the carry flag shows the value of <em>Borrow</em> (from beyond the size of the data type) at the completion of the subtraction operation:</p>&#13;
<pre class="pre">Let Borrow = 0&#13;
Repeat for each i = 0, ..., (N - 1)&#13;
<span epub:type="pagebreak" id="page_40"/><span class="ent">➊</span> If y<sub>i</sub> ≤ x<sub>i</sub>&#13;
       Let Difference<sub>i</sub> = x<sub>i</sub> - y<sub>i</sub>&#13;
   Else&#13;
    <span class="ent">➋</span> Let j = i + 1&#13;
    <span class="ent">➌</span> While (x<sub>j</sub> = 0) and (j &lt; N)&#13;
           Add 1 to j&#13;
    <span class="ent">➍</span> If j = N&#13;
        <span class="ent">➎</span> Let Borrow = 1&#13;
           Subtract 1 from j&#13;
           Add 10 to x<sub>j</sub>&#13;
    <span class="ent">❻</span> While j &gt; i&#13;
           Subtract 1 from x<sub>j</sub>&#13;
           Subtract 1 from j&#13;
           Add 10 to x<sub>j</sub>&#13;
    <span class="ent">❼</span> Let Difference<sub>i</sub> = x<sub>i</sub> - y<sub>i</sub></pre>&#13;
<p class="indent">This algorithm isn’t nearly as complicated as it first looks (but it took me a long time to figure it out!). If the digit we’re subtracting from is the same as or larger than the one we’re subtracting <span class="ent">❶</span>, we’re done with that place in the number. Otherwise, we need to borrow from the next place to the left <span class="ent">❷</span>. If the next digit we’retrying to borrow from is 0, then we need to continue moving to the left until we find a nonzero digit or until we reach the leftmost end of the number <span class="ent">❸</span>. If we reach the number of digits allocated for the number <span class="ent">❹</span>, we indicate that by setting <em>Borrow</em> to 1 <span class="ent">❺</span>.</p>&#13;
<p class="indent">After we have borrowed from positions to the left, we work our way back to the position we’re dealing with <span class="ent">❻</span> and perform the subtraction <span class="ent">❼</span>. When you do subtraction on paper, you do all these things automatically, in your head, but that probably won’t be as intuitive for you in the binary and hexadecimal systems. (I cheat and write my intermediate borrows in decimal.)</p>&#13;
<p class="indent">If you’re having trouble, don’t worry. You don’t need a thorough understanding of this algorithm to understand the material in this book, but I think working through it can help you learn how to develop algorithms for other computing problems. Translating everyday procedures into the logical statements used by programming languages is often a difficult task.</p>&#13;
<h3 class="h3" id="ch03lev1sec2"><strong>Unsigned Integers in the Binary System</strong></h3>&#13;
<p class="noindent">In this section, you’ll learn how to perform addition and subtraction operations on unsigned binary integers. Before going any further, take a good look at <a href="ch03.xhtml#ch3tab1">Table 3-1</a> (especially the binary bit patterns). You probably won’t memorize this table right away, but after you have worked with the binary and hexadecimal number systems for a while, it will become natural to think of, say, 10, <span class="literal">a</span>, or <span class="literal">1010</span> as being the same numbers, just in different number systems.</p>&#13;
<span epub:type="pagebreak" id="page_41"/>&#13;
<p class="tabcap" id="ch3tab1"><strong>Table 3-1:</strong> Corresponding Bit Patterns and Unsigned Decimal Values for the Hexadecimal Digits</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>One hexadecimal digit</strong></th>&#13;
<th class="tab_th"><strong>Four binary digits (bits)</strong></th>&#13;
<th class="tab_th"><strong>Unsigned decimal</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0000</span></td>&#13;
<td class="bg1">0</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0001</span></td>&#13;
<td class="bg">1</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">2</span></td>&#13;
<td class="bg1"><span class="literal">0010</span></td>&#13;
<td class="bg1">2</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">3</span></td>&#13;
<td class="bg"><span class="literal">0011</span></td>&#13;
<td class="bg">3</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">4</span></td>&#13;
<td class="bg1"><span class="literal">0100</span></td>&#13;
<td class="bg1">4</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">5</span></td>&#13;
<td class="bg"><span class="literal">0101</span></td>&#13;
<td class="bg">5</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">6</span></td>&#13;
<td class="bg1"><span class="literal">0110</span></td>&#13;
<td class="bg1">6</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">7</span></td>&#13;
<td class="bg"><span class="literal">0111</span></td>&#13;
<td class="bg">7</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">8</span></td>&#13;
<td class="bg1"><span class="literal">1000</span></td>&#13;
<td class="bg1">8</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">9</span></td>&#13;
<td class="bg"><span class="literal">1001</span></td>&#13;
<td class="bg">9</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">a</span></td>&#13;
<td class="bg1"><span class="literal">1010</span></td>&#13;
<td class="bg1">10</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">b</span></td>&#13;
<td class="bg"><span class="literal">1011</span></td>&#13;
<td class="bg">11</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">c</span></td>&#13;
<td class="bg1"><span class="literal">1100</span></td>&#13;
<td class="bg1">12</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">d</span></td>&#13;
<td class="bg"><span class="literal">1101</span></td>&#13;
<td class="bg">13</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">e</span></td>&#13;
<td class="bg1"><span class="literal">1110</span></td>&#13;
<td class="bg1">14</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">f</span></td>&#13;
<td class="bg"><span class="literal">1111</span></td>&#13;
<td class="bg">15</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Now that you’ve become familiar with <a href="ch03.xhtml#ch3tab1">Table 3-1</a>, let’s discuss unsigned integers. As we do so, don’t forget that as far as the value of the number goes, it doesn’t matter whether we think of an integer as being in decimal, hexadecimal, or binary—they are all mathematically equivalent. However, we might wonder whether a computer performing arithmetic in binary gets the same results we do when doing the same calculation using decimal arithmetic. Let’s take a closer look at some specific operations.</p>&#13;
<h4 class="h4" id="ch03lev2sec3"><em><strong>Addition</strong></em></h4>&#13;
<p class="noindent">In the following examples, we use 4-bit values. First, consider adding the two unsigned integers 2 and 4:</p>&#13;
<div class="image1"><img src="../images/pg69_Image_23.jpg" alt="Image" width="293" height="114"/></div>&#13;
<p class="indent">The decimal value 2 is represented in binary as <span class="literal">0010</span>, and decimal 4 is represented by <span class="literal">0100</span>. The carry flag, or <span class="literal">C</span>, is equal to <span class="literal">0</span>, because the result of the addition operation is also 4 bits long. We add the digits (shown in both binary and hex here, though the carries are shown only in binary) in the same relative positions as we do in decimal.</p>&#13;
<span epub:type="pagebreak" id="page_42"/>&#13;
<p class="indent">Next, consider two larger integers. Keeping our 4-bit storage space, we’ll add the two unsigned integers 4 and 14:</p>&#13;
<div class="image1"><img src="../images/pg70_Image_24.jpg" alt="Image" width="310" height="114"/></div>&#13;
<p class="indent">In this case, the carry flag equals <span class="literal">1</span>, because the result of the operation exceeded the 4 bits that we allocated for storing the integers. Thus, our result is incorrect. If we included the carry flag in the result, we would get a 5-bit value and the result would be <span class="literal">10010</span><sub>2</sub> = 18<sub>10</sub>, which is correct. In this case, we’d have to account for the carry flag in software.</p>&#13;
<h4 class="h4" id="ch03lev2sec4"><em><strong>Subtraction</strong></em></h4>&#13;
<p class="noindent">Let’s subtract 14 from 4, or <span class="literal">1110</span> from <span class="literal">0100</span>:</p>&#13;
<div class="image1"><img src="../images/pg70_Image_25.jpg" alt="Image" width="342" height="114"/></div>&#13;
<p class="indent">The CPU can indicate that we had to borrow from beyond the 4 bits by setting the carry flag to <span class="literal">1</span>, which means the 4-bit result in this subtraction is incorrect.</p>&#13;
<p class="indent">These 4-bit arithmetic examples generalize to any size arithmetic performed by the computer. The AArch64 architecture has an addition instruction that sets the carry flag to <span class="literal">0</span> if there is no ultimate (or final) carry and sets it to <span class="literal">1</span> if there is an ultimate carry as a result of the addition. Similarly, there is a subtraction instruction that sets the carry flag to <span class="literal">0</span> if no borrow from the “outside” is required or to <span class="literal">1</span> if a borrow is required as a result of the subtraction.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Our C compiler does not use these addition and subtraction instructions. There is no indication of carry or borrow when performing an addition or subtraction operation. We’ll look at this more closely in <a href="ch15.xhtml">Chapter 15</a>, when we discuss embedding assembly language in C code.</em></p>&#13;
</div>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list" id="ch3exe1">3.1     How many bits are required to store a single decimal digit? Invent a code for storing eight decimal digits in 32 bits. Using this code, does binary addition produce the correct results? You saw such a code in <a href="ch02.xhtml">Chapter 2</a>, with some reasons for its usefulness.</p>&#13;
<span epub:type="pagebreak" id="page_43"/>&#13;
<p class="box-list" id="ch3exe2">3.2     Develop an algorithm for adding fixed-width integers in the binary number system.</p>&#13;
<p class="box-list" id="ch3exe3">3.3     Develop an algorithm for adding fixed-width integers in the hexadecimal number system.</p>&#13;
<p class="box-list" id="ch3exe4">3.4     Develop an algorithm for subtracting fixed-width integers in the binary number system.</p>&#13;
<p class="box-list" id="ch3exe5">3.5     Develop an algorithm for subtracting fixed-width integers in the hexadecimal number system.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch03lev1sec3"><strong>Adding and Subtracting Signed Integers</strong></h3>&#13;
<p class="noindent">When representing nonzero signed decimal integers, there are two possibilities: they can be positive or negative. With only two options, we need to use only 1 bit for the sign. We could use a <em>sign-magnitude code</em> by simply using the highest-order bit for signed numbers—say, where <span class="literal">0</span> means + and <span class="literal">1</span> means –. But if we do this, we’ll run into some problems. As an example, consider adding +2 and –2:</p>&#13;
<div class="image1"><img src="../images/pg71_Image_26.jpg" alt="Image" width="300" height="94"/></div>&#13;
<p class="indent">The result, <span class="literal">1100</span><sub>2</sub>, is equal to –4<sub>10</sub> in our code, which is arithmetically incorrect. The simple addition we used for unsigned numbers will not work correctly for signed numbers when using a sign-magnitude code.</p>&#13;
<p class="indent">Some computer architectures do use 1 bit for the sign when using signed decimal integers. They have a special <em>signed add</em> instruction that handles cases like this. (A fun aside: such computers have both a +0 and a –0!) But most computers employ a different encoding to represent signed numbers that allows the use of a simple add instruction for signed addition. Let’s look at this now.</p>&#13;
<h4 class="h4" id="ch03lev2sec5"><em><strong>Understanding Two’s Complement</strong></em></h4>&#13;
<p class="noindent">In mathematics, the <em>complement</em> of a quantity is the amount that must be added to make it “whole.” When applying this concept to numbers, the definition of <em>whole</em> depends on the radix (or base) you’re working in and the number of digits you allow to represent the numbers. If <em>x</em> is an <em>n</em>-digit number in radix <em>r</em>, its <em>radix complement</em>, ¬<em>x</em>, is defined such that <em>x</em> + (¬<em>x</em>) = <em>radix<sup>n</sup></em>, where <em>radix<sup>n</sup></em> is 1 followed by <em>n</em> 0s. For example, if we’re working with two-digit decimal numbers, then the radix complement of 37 is 63, because 37 + 63 = 10<sup>2</sup> = 100. Another way of saying this is that adding a number to its radix complement results in 0, with a carry beyond the <em>n</em> digits.</p>&#13;
<p class="indent">Another useful concept is the <em>diminished radix complement</em>, which is defined such that <em>x</em> + <em>diminished_radix_complement</em> = <em>radix<sup>n</sup></em> – 1. For example, <span epub:type="pagebreak" id="page_44"/>the diminished radix complement of 37 is 62, because 37 + 62 = 10<sup>2</sup> – 1 = 99. If you add a number to its diminished radix complement, the result is <em>n</em> of the largest digits in the radix: two 9s in this example of two digits in radix 10.</p>&#13;
<p class="indent">To see how the radix complement can be used to represent negative numbers, consider an audiotape cassette player, which plays a cassette tape containing magnetic tape wound back and forth between two spools.</p>&#13;
<p class="indent">The audio recording on the tape is an analog signal that does not include information about the position along the tape. Many audiotape cassette players have a four-digit counter that represents the tape position. You can insert a tape cassette and push a reset button to set the counter to 0000. As you move the tape forward and backward, the counter registers the movement. These counters provide a “coded” representation of the relative tape position in arbitrary units. Now, assume we can insert a cassette, somehow move it to its center, and push the reset button. Moving the tape forward—in the positive direction—will cause the counter to increment. Moving the tape backward—in the negative direction—will cause the counter to decrement. In particular, if we start at 0000 and move to +1, the “code” on the tape counter will show 0001. On the other hand, if we start at 0000 and move to –1, the “code” on the tape counter will show 9999.</p>&#13;
<p class="indent">We can use our tape system to perform the arithmetic in the previous example, (+2) + (–2):</p>&#13;
<ol>&#13;
<li class="noindent">Move the tape forward to (+2); the counter shows 0002.</li>&#13;
<li class="noindent">Add (–2) by moving the tape backward two steps on the counter; the counter now shows 0000, which is 0 according to our code.</li>&#13;
</ol>&#13;
<p class="indent">Next, we’ll perform the same arithmetic starting with (–2) and then adding (+2):</p>&#13;
<ol>&#13;
<li class="noindent">Move the tape backward to (–2); the counter shows 9998.</li>&#13;
<li class="noindent">Add (+2) by moving the tape forward two steps on the counter; the counter now shows 0000, but there is a carry (9998 + 2 = 0000 with carry = 1).</li>&#13;
</ol>&#13;
<p class="indent">If we ignore the carry, the answer is correct: 9998 is the 10’s complement (the radix is 10) of 0002. When adding two signed integers using radix complement notation, the carry is irrelevant. Adding two signed numbers can give a result that will not fit within the number of bits allocated for storing the result, just as with unsigned numbers. But our tape example just illustrated that the carry flag will probably not show us that the result will not fit. We will discuss this issue in the next section.</p>&#13;
<p class="indent">Computers work in the binary number system, where the radix is 2. Let’s look at the <em>two’s complement</em> notation for representing signed integers. It uses the same general pattern as the tape counter for representing signed decimal integers in bit patterns.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch3tab2">Table 3-2</a> shows the correspondence between hexadecimal, binary, and signed decimal (in two’s complement notation) for 4-bit values. In binary, moving the “tape” one place back (negative) from 0 would go from <span class="literal">0000</span> to <span class="literal">1111</span>. In hexadecimal, it would go from <span class="literal">0</span> to <span class="literal">f</span>.</p>&#13;
<span epub:type="pagebreak" id="page_45"/>&#13;
<p class="tabcap" id="ch3tab2"><strong>Table 3-2:</strong> Four-Bit Two’s Complement Notation</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:40%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><strong>One hexadecimal digit</strong></th>&#13;
<th class="tab_th"><strong>Four binary digits (bits)</strong></th>&#13;
<th class="tab_th"><strong>Signed decimal</strong></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">8</span></td>&#13;
<td class="bg1"><span class="literal">1000</span></td>&#13;
<td class="bg1">–8</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">9</span></td>&#13;
<td class="bg"><span class="literal">1001</span></td>&#13;
<td class="bg">–7</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">a</span></td>&#13;
<td class="bg1"><span class="literal">1010</span></td>&#13;
<td class="bg1">–6</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">b</span></td>&#13;
<td class="bg"><span class="literal">1011</span></td>&#13;
<td class="bg">–5</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">c</span></td>&#13;
<td class="bg1"><span class="literal">1100</span></td>&#13;
<td class="bg1">–4</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">d</span></td>&#13;
<td class="bg"><span class="literal">1101</span></td>&#13;
<td class="bg">–3</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">e</span></td>&#13;
<td class="bg1"><span class="literal">1110</span></td>&#13;
<td class="bg1">–2</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">f</span></td>&#13;
<td class="bg"><span class="literal">1111</span></td>&#13;
<td class="bg">–1</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">0</span></td>&#13;
<td class="bg1"><span class="literal">0000</span></td>&#13;
<td class="bg1">  0</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">1</span></td>&#13;
<td class="bg"><span class="literal">0001</span></td>&#13;
<td class="bg">+1</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">2</span></td>&#13;
<td class="bg1"><span class="literal">0010</span></td>&#13;
<td class="bg1">+2</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">3</span></td>&#13;
<td class="bg"><span class="literal">0011</span></td>&#13;
<td class="bg">+3</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">4</span></td>&#13;
<td class="bg1"><span class="literal">0100</span></td>&#13;
<td class="bg1">+4</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">5</span></td>&#13;
<td class="bg"><span class="literal">0101</span></td>&#13;
<td class="bg">+5</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">6</span></td>&#13;
<td class="bg1"><span class="literal">0110</span></td>&#13;
<td class="bg1">+6</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">7</span></td>&#13;
<td class="bg"><span class="literal">0111</span></td>&#13;
<td class="bg">+7</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Here are some important observations about this table:</p>&#13;
<ul>&#13;
<li class="noindent">The high-order bit of each positive number is <span class="literal">0</span>, and the high-order bit of each negative number is <span class="literal">1</span>.</li>&#13;
<li class="noindent">Although changing the sign of (<em>negating</em>) a number is more complicated than simply changing the high-order bit, it is common to call the high-order bit the <em>sign bit</em>.</li>&#13;
<li class="noindent">The notation allows for one more negative number than positive numbers.</li>&#13;
<li class="noindent">The range of integers, <em>x</em>, that can be represented in this notation (with 4 bits) is</li>&#13;
</ul>&#13;
<div class="image1"><img src="../images/pg73_Image_27.jpg" alt="Image" width="144" height="20"/></div>&#13;
<p class="indent">or:</p>&#13;
<div class="image1"><img src="../images/pg73_Image_28.jpg" alt="Image" width="249" height="26"/></div>&#13;
<p class="indent">The last observation can be generalized for <em>n</em> bits to the following:</p>&#13;
<div class="image1"><img src="../images/pg73_Image_29.jpg" alt="Image" width="250" height="25"/></div>&#13;
<p class="indent">When using two’s complement notation, the negative of any <em>n</em>-bit integer <em>x</em> is defined as:</p>&#13;
<div class="image1"><img src="../images/pg73_Image_30.jpg" alt="Image" width="105" height="21"/></div>&#13;
<p class="indent">Notice that 2<em><sup>n</sup></em> written in binary is <span class="literal">1</span> followed by <em>n</em> <span class="literal">0</span>s. In other words, in the <em>n</em>-bit two’s complement notation, adding a number to its negative produces <em>n</em> <span class="literal">0</span>s and a carry of <span class="literal">1</span>.</p>&#13;
<span epub:type="pagebreak" id="page_46"/>&#13;
<h4 class="h4" id="ch03lev2sec6"><em><strong>Computing Two’s Complement</strong></em></h4>&#13;
<p class="noindent">We’ll derive a way to compute the negative of a number by using two’s complement notation. Solving the defining equation for –<em>x</em>, we get:</p>&#13;
<div class="image1"><img src="../images/pg74_Image_31.jpg" alt="Image" width="92" height="17"/></div>&#13;
<p class="indent">This may look odd to a mathematician, but keep in mind that <em>x</em> in this equation is restricted to <em>n</em> bits, while 2<em><sup>n</sup></em> has <em>n</em> + 1 bits (<span class="literal">1</span> followed by <em>n</em> <span class="literal">0</span>s).</p>&#13;
<p class="indent">For example, if we want to compute –123 in binary (using two’s complement notation) in 8 bits, we perform the arithmetic:</p>&#13;
<div class="image1"><img src="../images/pg74_Image_32.jpg" alt="Image" width="280" height="56"/></div>&#13;
<p class="indent">This subtraction operation is error-prone, so let’s do a bit of algebra on our equation for computing –<em>x</em>. We’ll subtract 1 from both sides and rearrange a little:</p>&#13;
<div class="image1"><img src="../images/pg74_Image_33.jpg" alt="Image" width="167" height="51"/></div>&#13;
<p class="indent">This gives us:</p>&#13;
<div class="image1"><img src="../images/pg74_Image_34.jpg" alt="Image" width="179" height="21"/></div>&#13;
<p class="indent">If this looks more complicated than our first equation, don’t worry. Let’s consider the quantity (2<em><sup>n</sup></em> – 1). Since 2<em><sup>n</sup></em> is written in binary as <span class="literal">1</span> followed by <em>n</em> <span class="literal">0</span>s, (2<em><sup>n</sup></em> – 1) is written as <em>n</em> <span class="literal">1</span>s. For example, for <em>n</em> = 8:</p>&#13;
<div class="image1"><img src="../images/pg74_Image_35.jpg" alt="Image" width="171" height="25"/></div>&#13;
<p class="indent">Thus, we can say</p>&#13;
<div class="image1"><img src="../images/pg74_Image_36.jpg" alt="Image" width="221" height="24"/></div>&#13;
<p class="noindent">where 11 <em>. . .</em> 1<sub>2</sub> designates <em>n</em> <span class="literal">1</span>s.</p>&#13;
<p class="indent">Although it may not be immediately obvious, you’ll see how easy this subtraction is when you consider the previous example of computing –123 in 8-bit binary. Let <em>x</em> = 123, giving:</p>&#13;
<div class="image1"><img src="../images/pg74_Image_37.jpg" alt="Image" width="318" height="83"/></div>&#13;
<p class="noindent">Or, in hexadecimal, giving:</p>&#13;
<div class="image1"><img src="../images/pg74_Image_38.jpg" alt="Image" width="265" height="83"/></div>&#13;
<span epub:type="pagebreak" id="page_47"/>&#13;
<p class="indent">Since all the quantities here have <em>n</em> bits, this computation is easy—simply flip all the bits, giving the diminished radix complement, also called the <em>one’s complement</em> in the binary number system. A <span class="literal">1</span> becomes a <span class="literal">0</span> and a <span class="literal">0</span> becomes a <span class="literal">1</span>.</p>&#13;
<p class="indent">All that remains to compute the negative is to add <span class="literal">1</span> to the result. Finally, we have the following:</p>&#13;
<div class="image1"><img src="../images/pg75_Image_39.jpg" alt="Image" width="181" height="83"/></div>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">HINT</span></strong></p>&#13;
<p class="notep"><em>To double-check your arithmetic, pay attention to whether the value you are converting is even or odd. It will be the same in all number bases.</em></p>&#13;
</div>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list" id="ch3exe6">3.6     Develop an algorithm to convert signed decimal integers to two’s complement binary.</p>&#13;
<p class="box-list" id="ch3exe7">3.7     Develop an algorithm to convert integers in two’s complement binary notation to signed decimal.</p>&#13;
<p class="box-list" id="ch3exe8">3.8     The following 16-bit hexadecimal values are stored in two’s complement notation. What are the equivalent signed decimal numbers?</p>&#13;
<p class="alpha">(a)     <span class="literal">1234</span></p>&#13;
<p class="alpha">(b)     <span class="literal">ffff</span></p>&#13;
<p class="alpha">(c)     <span class="literal">8000</span></p>&#13;
<p class="alpha">(d)     <span class="literal">7fff</span></p>&#13;
<p class="box-list" id="ch3exe9">3.9     Show how each of the following signed decimal integers would be stored in 16-bit two’s complement notation. Give your answers in hexadecimal:</p>&#13;
<p class="alpha">(a)     +1,024</p>&#13;
<p class="alpha">(b)     –1,024</p>&#13;
<p class="alpha">(c)     –256</p>&#13;
<p class="alpha">(d)     –32,767</p>&#13;
</div>&#13;
<h3 class="h3" id="ch03lev1sec4"><strong>Adding and Subtracting Signed Integers in Binary</strong></h3>&#13;
<p class="noindent">The number of bits used to represent a value is determined at the time a program is written by the computer architecture and programming language used. This is why you can’t just add more digits (bits) if the result is too large, as you would on paper. For unsigned integers, the solution to this problem is the carry flag, which indicates when the sum of two unsigned integers exceeds the number of bits allocated for it. In this section, you’ll learn that adding two signed numbers can also produce a result that exceeds the allocated number of bits, but in this case, the carry flag alone does not indicate the error.</p>&#13;
<span epub:type="pagebreak" id="page_48"/>&#13;
<p class="indent">The CPU can indicate when the sum of signed numbers has gotten too big for its bits by using the <em>overflow flag</em>, <span class="literal">V</span>. The value of the overflow flag is given by an operation that may not seem intuitive at first: the <em>exclusive or (XOR)</em> of the penultimate and ultimate carries. As an example, let’s say we’re adding the two 8-bit numbers <span class="literal">15</span><sub>16</sub> and <span class="literal">6f</span><sub>16</sub>:</p>&#13;
<div class="image1"><img src="../images/pg76_Image_40.jpg" alt="Image" width="424" height="112"/></div>&#13;
<p class="indent">In this example, the carry is <span class="literal">0</span> and the penultimate carry is <span class="literal">1</span>. The <span class="literal">V</span> flag is equal to the XOR of the ultimate carry and penultimate carry, <span class="literal">V</span> = <span class="literal">C</span> ⊻ <em>(penultimate_carry)</em>, where ⊻ is the XOR operator. In this case, <span class="literal">V</span> = <span class="literal">0</span> ⊻ <span class="literal">1</span> = <span class="literal">1</span>.</p>&#13;
<p class="indent">Case by case, we’ll see why the <span class="literal">V</span> flag indicates the validity of adding two signed integers in the two’s complement representation. In the next three sections, we’ll discuss the three possible cases: the two numbers can have opposite signs, both be positive, or both be negative.</p>&#13;
<h4 class="h4" id="ch03lev2sec7"><em><strong>Two Numbers of the Opposite Sign</strong></em></h4>&#13;
<p class="noindent">Let <em>x</em> be the negative number and <em>y</em> the positive number. We can express <em>x</em> and <em>y</em> in binary as follows:</p>&#13;
<div class="image1"><img src="../images/f0076-01.jpg" alt="Image" width="139" height="18"/></div>&#13;
<p class="noindent">That is, the high-order (sign) bit of one number is <span class="literal">1</span> and the high-order (sign) bit of the other is <span class="literal">0</span>, regardless of what the other bits are.</p>&#13;
<p class="indent">The result of <em>x</em> + <em>y</em> always remains within the range of the two’s complement representation:</p>&#13;
<div class="image1"><img src="../images/pg76_Image_41.jpg" alt="Image" width="278" height="99"/></div>&#13;
<p class="indent">If we add <em>x</em> and <em>y</em>, there are two possible carry results:</p>&#13;
<ul>&#13;
<li class="noindent">If the penultimate carry is <span class="literal">0</span>:</li>&#13;
</ul>&#13;
<div class="image1"><img src="../images/pg76_Image_42.jpg" alt="Image" width="486" height="158"/></div>&#13;
<span epub:type="pagebreak" id="page_49"/>&#13;
<ul>&#13;
<li class="noindent">If the penultimate carry is <span class="literal">1</span>:</li>&#13;
</ul>&#13;
<div class="image1"><img src="../images/pg77_Image_43.jpg" alt="Image" width="485" height="158"/></div>&#13;
<p class="indent">Adding two integers of opposite signs always yields <span class="literal">0</span> for the overflow flag, so the sum is always within the allocated range.</p>&#13;
<h4 class="h4" id="ch03lev2sec8"><em><strong>Two Positive Numbers</strong></em></h4>&#13;
<p class="noindent">If both <em>x</em> and <em>y</em> are positive, we can express them in binary as follows:</p>&#13;
<div class="image1"><img src="../images/pg77_Image_44.jpg" alt="Image" width="139" height="17"/></div>&#13;
<p class="noindent">Here, the high-order (sign) bit of both numbers is <span class="literal">0</span>, regardless of what the other bits are.</p>&#13;
<p class="indent">Again, if we add <em>x</em> and <em>y</em>, there are two possible carry results:</p>&#13;
<ul>&#13;
<li class="noindent">If the penultimate carry is <span class="literal">0</span>:</li>&#13;
</ul>&#13;
<div class="image1"><img src="../images/pg77_Image_45.jpg" alt="Image" width="352" height="112"/></div>&#13;
<p class="noindent">This addition produces <span class="literal">V = 0</span> ⊻ <span class="literal">0 = 0</span>. The high-order bit of the sum is <span class="literal">0</span>, so it’s a positive number, and the sum is in range.</p>&#13;
<ul>&#13;
<li class="noindent">If the penultimate carry is <span class="literal">1</span>:</li>&#13;
</ul>&#13;
<div class="image1"><img src="../images/pg77_Image_46.jpg" alt="Image" width="352" height="112"/></div>&#13;
<p class="noindent">This addition produces <span class="literal">V = 0</span> ⊻ <span class="literal">1 = 1</span>. The high-order bit of the sum is <span class="literal">1</span>, so it’s a negative number. Adding two positive numbers cannot give a negative sum, so the sum must have exceeded the allocated range.</p>&#13;
<h4 class="h4" id="ch03lev2sec9"><em><strong>Two Negative Numbers</strong></em></h4>&#13;
<p class="noindent">If both <em>x</em> and <em>y</em> are negative, we can express them in binary as follows:</p>&#13;
<div class="image1"><img src="../images/pg77_Image_47.jpg" alt="Image" width="139" height="17"/></div>&#13;
<span epub:type="pagebreak" id="page_50"/>&#13;
<p class="indent">In this case, the high-order (sign) bit of both numbers is <span class="literal">1</span>, regardless of what the other bits are.</p>&#13;
<p class="indent">If we add <em>x</em> and <em>y</em>, there are two possible carry results:</p>&#13;
<ul>&#13;
<li class="noindent">If the penultimate carry is <span class="literal">0</span>:&#13;
<div class="image1"><img src="../images/pg78_Image_48.jpg" alt="Image" width="352" height="112"/></div>&#13;
<p class="noindent">This gives <span class="literal">V = 1</span> ⊻ <span class="literal">0 = 1</span>. The high-order bit of the sum is <span class="literal">0</span>, so it’s a positive number. But adding two negative numbers cannot give a positive sum, so the sum has exceeded the allocated range.</p></li>&#13;
<li class="noindent">If the penultimate carry is <span class="literal">1</span>:&#13;
<div class="image1"><img src="../images/pg78_Image_49.jpg" alt="Image" width="352" height="112"/></div>&#13;
<p class="noindent">This gives <span class="literal">V = 1</span> ⊻ <span class="literal">1 = 0</span>. The high-order bit of the sum is <span class="literal">1</span>, so it’s a negative number and the sum is within range.</p></li>&#13;
</ul>&#13;
<p class="indent">We won’t go into subtraction here. The same rules apply there, and I invite you to explore them on your own.</p>&#13;
<p class="indent">We can state the following rules for adding or subtracting two <em>n</em>-bit numbers, based on what you just learned and what we did in “Unsigned Integers in the Binary System” on <a href="ch03.xhtml#ch03lev1sec2">page 40</a>:</p>&#13;
<ul>&#13;
<li class="noindent">When the program treats the result as unsigned, the carry flag, <span class="literal">C</span>, is <span class="literal">0</span> if and only if the result is within the <em>n</em>-bit range; <span class="literal">V</span> is irrelevant.</li>&#13;
<li class="noindent">When the program treats the result as signed, the overflow flag, <span class="literal">V</span>, is <span class="literal">0</span> if and only if the result is within the <em>n</em>-bit range; <span class="literal">C</span> is irrelevant.</li>&#13;
</ul>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Using two’s complement notation means the CPU does not need additional instructions for signed addition and subtraction, thus simplifying the hardware. The CPU just sees bit patterns. The AArch64 architecture includes add and subtract instructions that set</em> <span class="codeitalic">C</span> <em>and</em> <span class="codeitalic">V</span> <em>according to the rules of the respective binary arithmetic operation, regardless of how the program treats the numbers. The distinction between signed and unsigned is completely determined by the program. After each addition or subtraction operation, the program should check the state of</em> <span class="codeitalic">C</span> <em>for unsigned integers or</em> <span class="codeitalic">V</span> <em>for signed integers and at least indicate when the sum is in error. Many high-level languages do not perform this check, which can lead to some obscure program bugs.</em></p>&#13;
</div>&#13;
<span epub:type="pagebreak" id="page_51"/>&#13;
<h3 class="h3" id="ch03lev1sec5"><strong>The Circular Nature of Integer Codes</strong></h3>&#13;
<p class="noindent">The notations used for both unsigned integers and signed integers are circular in nature—for a given number of bits, each code “wraps around.” <a href="ch03.xhtml#ch3fig1">Figure 3-1</a> shows this using the “decoder ring” for 3-bit numbers.</p>&#13;
<div class="image"><img id="ch3fig1" src="../images/pg79_Image_50.jpg" alt="Image" width="362" height="361"/></div>&#13;
<p class="figcap"><em>Figure 3-1: A “decoder ring” for 3-bit signed and unsigned integers</em></p>&#13;
<p class="indent">To use this decoder ring to add or subtract two integers, follow these steps:</p>&#13;
<ol>&#13;
<li class="noindent">Pick the ring corresponding to the type of integer you’re using (signed or unsigned).</li>&#13;
<li class="noindent">Move to the location on that ring corresponding to the first integer.</li>&#13;
<li class="noindent">Move along that ring the number of “spokes” equal to the second integer. Move clockwise to add and counterclockwise to subtract.</li>&#13;
</ol>&#13;
<p class="indent">The result is correct if you do not cross the top for unsigned integers or cross the bottom for signed integers.</p>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list1" id="ch3exe10">3.10     Use the decoder ring in <a href="ch03.xhtml#ch3fig1">Figure 3-1</a> to perform the following arithmetic. Indicate whether the result is “right” or “wrong”:</p>&#13;
<p class="alpha">(a)     Unsigned integers: 1 + 3</p>&#13;
<p class="alpha">(b)     Unsigned integers: 3 + 4</p>&#13;
<p class="alpha">(c)     Unsigned integers: 5 + 6</p>&#13;
<p class="alpha">(d)     Signed integers: (+1) + (+3)</p>&#13;
<p class="alpha">(e)     Signed integers: (–3) – (+3)</p>&#13;
<p class="alpha">(f)     Signed integers: (+3) + (–4)</p>&#13;
<span epub:type="pagebreak" id="page_52"/>&#13;
<p class="box-list1" id="ch3exe11">3.11     Add the following pairs of 8-bit numbers (shown in hexadecimal) and indicate whether your result is “right” or “wrong.” First treat them as unsigned values and then as signed values (stored in two’s complement):</p>&#13;
<p class="alpha">(a)     <span class="literal">55 + aa</span></p>&#13;
<p class="alpha">(b)     <span class="literal">55 + f0</span></p>&#13;
<p class="alpha">(c)     <span class="literal">80 + 7b</span></p>&#13;
<p class="alpha">(d)     <span class="literal">63 + 7b</span></p>&#13;
<p class="alpha">(e)     <span class="literal">0f + ff</span></p>&#13;
<p class="alpha">(f)     <span class="literal">80 + 80</span></p>&#13;
<p class="box-list1" id="ch3exe12">3.12     Add the following pairs of 16-bit numbers (shown in hexadecimal) and indicate whether your result is “right” or “wrong.” First treat them as unsigned values and then as signed values (stored in two’s complement):</p>&#13;
<p class="alpha">(a)     <span class="literal">1234 + edcc</span></p>&#13;
<p class="alpha">(b)     <span class="literal">1234 + fedc</span></p>&#13;
<p class="alpha">(c)     <span class="literal">8000 + 8000</span></p>&#13;
<p class="alpha">(d)     <span class="literal">0400 + ffff</span></p>&#13;
<p class="alpha">(e)     <span class="literal">07d0 + 782f</span></p>&#13;
<p class="alpha">(f)     <span class="literal">8000 + ffff</span></p>&#13;
</div>&#13;
<h3 class="h3" id="ch03lev1sec6"><strong>What You’ve Learned</strong></h3>&#13;
<p class="noindentin"><strong>Binary arithmetic</strong>   Computers perform addition and subtraction in the binary number system. Addition of two numbers may yield a result that is 1 bit wider than each of the two numbers. Subtraction of one number from another may require borrowing from 1 bit beyond the width of the two numbers.</p>&#13;
<p class="noindentin"><strong>Representing signed/unsigned</strong>   Bit patterns can be treated as representing either signed or unsigned integers. Two’s complement notation is commonly used to represent signed integers.</p>&#13;
<p class="noindentin"><strong>Carry flag</strong>   The CPU includes a 1-bit carry flag, <span class="literal">C</span>, that can show whether the result of addition or subtraction exceeds the number of bits allowed for an unsigned integer.</p>&#13;
<p class="noindentin"><strong>Overflow flag</strong>   The CPU includes a 1-bit overflow flag, <span class="literal">V</span>, that can show whether the result of addition or subtraction exceeds the number of bits allowed for a signed integer using two’s complement notation.</p>&#13;
<p class="indent">In the next chapter, you’ll learn how to perform Boolean algebra. Although it may seem a bit strange at first, once we get going, you’ll see that it’s actually easier than elementary algebra. For one thing, everything evaluates to either <span class="literal">0</span> or <span class="literal">1</span>!</p>&#13;
</div>
</div>
</body></html>