<html><head></head><body>
<h2 class="h" id="ch07"><span epub:type="pagebreak" id="page_189" class="calibre1"/><strong class="calibre2"><span class="big">7</span><br class="calibre3"/>DIAGRAMS AND ANIMATIONS</strong></h2>
<div class="bq">
<p class="center"><em class="calibre11">Tell me, Steed. Is everything to scale?</em></p>
<p class="center1">—Mrs. Peel</p>
</div>
<div class="image"><img alt="Image" src="../images/common.jpg" class="calibre6"/></div>
<p class="noindent">Diagrams are an essential form of scientific communication and education. The type of diagram treated in this chapter is distinct from the plots of data or mathematical functions we worked with in <a href="ch04.xhtml" class="calibre10">Chapter 4</a>. <em class="calibre11">Diagrams</em> in this context refers to illustrations of mathematical structures, drawings of experimental setups, flowcharts describing algorithms or processing pipelines, and similar graphical descriptions.</p>
<p class="indent">Animations now frequently accompany scientific papers reporting on simulations, as supplementary material offered online. They’re also a valuable tool in education and have a myriad of uses in scientific and mathematical communication. In this chapter, we’ll explore several Julia packages that can help you create a variety of types of diagrams and animations.<span epub:type="pagebreak" id="page_190"/></p>
<h3 class="h2" id="ch07lev1"><strong class="calibre2">Diagramming with Luxor</strong></h3>
<p class="noindent">The <span class="literal">Luxor</span> package is sophisticated and highly versatile, allowing you to create almost any type of diagram. To install it, enter <span class="codestrong1">add Luxor</span> in the package manager.</p>
<p class="indent">The package uses an imperative style to build up a picture in stages. You enter a series of commands that manipulate a global state, each command potentially adding something to the drawing. The effect of each drawing command depends on the state at the time it is entered. For example, to draw a blue circle, first set the color to blue and then enter the circle-drawing command, with arguments giving its position, size, and whether it should be “stroked” (an outline drawn) or filled. The outline or fill will use the currently set color. Each element—circles, polygons, lines, text, or any of a variety of objects—requires a separate command, and colors, styles, opacities, and other settings are set globally before each command is issued.</p>
<p class="indent">For a concrete example, let’s create a simple diagram (shown in <a href="ch07.xhtml#ch7fig1" class="calibre10">Figure 7-1</a>) of the relative sizes of the planets in the solar system, arranged in order of their distance from the Sun.</p>
<div class="image1"><img alt="Image" id="ch7fig1" src="../images/ch07fig01.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 7-1: The relative sizes of the planets</em></p>
<p class="indent"><a href="ch07.xhtml#ch7lis1" class="calibre10">Listing 7-1</a> shows the complete REPL session that creates the diagram in <a href="ch07.xhtml#ch7fig1" class="calibre10">Figure 7-1</a>.</p>
<pre class="calibre13">   julia&gt; <span class="codestrong">using \captionlst{Luxor}</span>

<span class="ent">➊</span> julia&gt; <span class="codestrong">planet_diameters = [4879 12104 12756 ;;</span>
    <span class="codestrong">3475 6792 142984 120536 51118 49528 2370];</span>

   julia&gt; <span class="codestrong">planet_names = ["Mercury", "Venus", "Earth", "Moon",</span>
    <span class="codestrong">"Mars", "Jupiter", "Saturn", "Uranus", "Neptune", "Pluto"];</span>

   julia&gt; <span class="codestrong">dimenx = 1000;</span>

   julia&gt; <span class="codestrong">dimeny =  500;</span>

<span class="ent">➋</span> julia&gt; <span class="codestrong">@png begin</span>
              <span class="codestrong">dscale = 500.0</span>
            <span class="ent">➌</span> <span class="codestrong">origin(Point(planet_diameters[1]/(2*dscale), dimeny/2))</span>
              <span class="codestrong">ledge = 0.0</span>
              <span class="codestrong">diameter = 0</span>
            <span class="ent">➍</span> <span class="codestrong">fontface("Liberation Sans")</span>
               <span class="codestrong">fontsize(32)</span>
               <span class="codestrong">for i in 1:10</span>
                   <span class="codestrong">ledge += diameter/2.0</span>
                   <span class="codestrong">name = planet_names[i]</span>
                   <span class="codestrong">diameter = planet_diameters[i]/dscale</span>
                 <span class="ent">➎</span> <span class="codestrong">ledge += diameter/2.0</span>
                    <span class="codestrong">setcolor("black")</span>
                    <span class="codestrong">setdash("solid")</span>
                    <span class="codestrong">circle(Point(ledge , 0), diameter/2.0, :stroke)</span>
                    <span class="codestrong">txtstart = Point(100*(i-1), 180 + 35*(i%2))</span>
                    <span class="codestrong">text(planet_names[i], txtstart)</span>
                    <span class="codestrong">setcolor("blue")</span>
                 <span class="ent">➏</span> <span class="codestrong">setdash("dot")</span>
                    <span class="codestrong">line(txtstart, Point(ledge, 0), :stroke)</span>
              <span class="codestrong">end</span>
       <span class="ent">➐</span> <span class="codestrong">end dimenx dimeny "planets.png"</span></pre>
<p class="list" id="ch7lis1"><span epub:type="pagebreak" id="page_191"/><em class="calibre11">Listing 7-1: Creating a diagram of the solar system using</em> <span class="codeitalic">Luxor</span></p>
<p class="indent">The program gets its planetary diameters, which are in kilometers, from a NASA website (see “Further Reading” on <a href="ch07.xhtml#fur7" class="calibre10">page 211</a>). When copying and pasting from the NASA table there, the numbers are space separated. This creates a <span class="literal">1\times10</span> array (Earth’s moon and Pluto are included), which is fine; we just need a list we can iterate over.</p>
<p class="indent">The double semicolon at the end of the line <span class="ent">➊</span> breaks the literal input of the array over two lines (this feature was added in Julia v1.7). Although spaces and double semicolons both signify concatenation along the second dimension, normally you may not mix them in a single literal array definition. The usage here is an exception just for this purpose.</p>
<p class="indent">The two variables <span class="literal">dimenx</span> and <span class="literal">dimeny</span> hold the dimensions of our diagram. Dimensions in <span class="literal">Luxor</span> are points, which are 1/72 of an inch.</p>
<p class="indent"><span class="literal">Luxor</span> supplies several macros for conveniently setting up the drawing environment. The <span class="literal">@png</span> macro <span class="ent">➋</span> initializes a PNG illustration, defines the origin of the coordinate system to be the center of the picture, and displays the result upon reaching the end of the block <span class="ent">➐</span>. After the final <span class="literal">end</span> statement, we give the dimensions of the image and its filename (you can leave this out, but probably won’t want to). The default size is 600×600, and the default filename is <em class="calibre11">luxor-drawing-</em> followed by a timestamp and the file extension. This can lead to a profusion of files on your disk as you develop your drawing code, so you probably want to specify a filename, which will get overwritten on each run. The file extension is optional and <span class="literal">Luxor</span> will supply one if you leave it out.</p>
<p class="indent">We need a scaling factor to deal with the large planetary diameters, which we assign to <span class="literal">dscale</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_192"/>The macro sets the origin of the coordinate system to the center of the diagram, which, using our variables, would be <span class="literal">(dimenx/2, dimeny/2)</span>. The code will be neater if we set the origin <span class="ent">➌</span> in the <em class="calibre11">x</em>-direction such that the left edge of the first planet starts at the left boundary.</p>
<p class="indent">I discovered that, on my system, if I don’t set a <span class="literal">fontface</span> <span class="ent">➍</span>, I get ugly bitmapped fonts in the output. This particular font may not exist on your system, so adjust as needed. If you ask for a font that <span class="literal">Luxor</span> can’t find, it will carry on, making a substitution.</p>
<p class="indent">The x-coordinate of the current circle’s center is assigned to <span class="literal">ledge</span>, which is updated twice <span class="ent">➎</span> for each planet: once to increase it by the radius of the previous planet and once by the planet about to be drawn. The result is a series of osculating circles.</p>
<p class="indent">The color is set to blue and the dash style to dot <span class="ent">➏</span> before each label is printed. As with other diagrams in this chapter, you can find color versions in the online supplement at <a href="https://julia.lee-phillips.org" class="calibre10"><em class="calibre11">https://julia.lee-phillips.org</em></a>.</p>
<p class="indent">If you run the code from <a href="ch07.xhtml#ch7lis1" class="calibre10">Listing 7-1</a> in the REPL, your default image viewing application will open a window displaying the diagram file when you run the code. The REPL will hang until you quit the application. If you run this in Pluto or Jupyter, the diagram will be embedded in the cell below the code.</p>
<p class="indent">Other options for macros are <span class="literal">@svg</span> and <span class="literal">@pdf</span>, which create files of the respective types. However, PDFs will not be embedded into notebooks.</p>
<p class="indent">In addition to lines, circles, and text, <span class="literal">Luxor</span> has commands for drawing several other shapes, and even such geometrical constructions as tangent lines to circles. (See “Further Reading” on <a href="ch07.xhtml#fur7" class="calibre10">page 211</a> for a link to the manual.)</p>
<h3 class="h2" id="ch07lev2"><strong class="calibre2">The Graphs Package</strong></h3>
<p class="noindent">With enough patience, you can use <span class="literal">Luxor</span> to create any type of diagram. However, it’s usually easier to use a specialized package for diagrams of a specific, standard type.</p>
<p class="indent">This section is about graphs in the mathematical sense and their visualization. The word <em class="calibre11">graph</em> is often used synonymously with the types of plots that were the subject of <a href="ch04.xhtml" class="calibre10">Chapter 4</a>, but to a mathematician, a graph is a set of nodes connected by edges, and that’s the type of graph we consider here. Graphs of this type are used to represent a huge variety of systems. Anytime you have a collection of objects that are connected together in a network of relationships, you have a graph. Examples include a taxonomy of plants or animals, call sites in a computer program, grammatical structures in a sentence, organizational charts, and the relationships among characters in a novel. In such a graph, the objects (parts of the organization or characters in the novel) are called <em class="calibre11">nodes</em> and the connections between nodes are called <em class="calibre11">edges</em>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_193"/>The Julia <span class="literal">Graphs</span> package contains functions for making several types of graphs. It depends upon <span class="literal">Plots</span> and <span class="literal">GraphRecipes</span> to actually draw the pictures representing the graphs. The first of these we’re familiar with from <a href="ch04.xhtml" class="calibre10">Chapter 4</a>; the second is a collection of <em class="calibre11">plotting recipes</em> that, in turn, use <span class="literal">Plots</span> to draw pictures. The recipe mechanism allows users and package authors to extend <span class="literal">Plots</span> so that it can visualize new data types or make new types of plots. To understand how these recipes work, we need to know more about the type system, so plot recipes are covered in “Plot Recipes” on <a href="ch08.xhtml#ch08lev7" class="calibre10">page 252</a>.</p>
<p class="indent">As an introduction to the <span class="literal">Graphs</span> package, we’ll build a program to create a diagram of the predator–prey relationships among 14 species living in the Chesapeake Bay in the eastern United States:</p>
<pre class="calibre13">using Plots
using Graphs
using GraphRecipes

creatures = ["Striped bass", "Atlantic croaker", "White perch",
             "Summer flounder", "Clearnose skate", "Bay anchovy",
             "Worms", "Mysids", "Amphipods", "Juvenile weakfish",
             "Sand shrimp", "Mantis shrimp", "Razor clams",
             "Juvenile Atlantic croaker"]

foodchain = SimpleDiGraph(14)</pre>
<p class="indent">First, we import the three necessary libraries (<span class="literal">Plots</span>, <span class="literal">Graphs</span>, and <span class="literal">Graph</span> <span class="literal">Recipes</span>) and create a vector of the names of the creatures. These names will become labels in the diagram and will also serve as references for the graph’s nodes.</p>
<p class="indent">The final line of the program so far creates an empty <em class="calibre11">directed graph</em> with 14 nodes (called “vertices” by <span class="literal">Graphs.jl)</span>. A directed graph is one where the edges have a direction, usually represented visually as an arrowhead. For this example, the direction of the edge will represent what creature eats what. In an <em class="calibre11">undirected graph</em>, the edges simply represent connections, with no hierarchy involved.</p>
<p class="indent">The next step is to add edges to <span class="literal">foodchain</span> representing information about the predator–prey relationships. The <span class="literal">add_edge!(foodchain, a, b)</span> function mutates the graph in its first argument by adding an edge going from node <span class="literal">a</span> to node <span class="literal">b</span>. That’s what we want, but it’s not convenient, because <span class="literal">a</span> and <span class="literal">b</span> need to be integers representing the orders of the nodes in the list. To enter these arguments, we would have to count through the list of <span class="literal">creatures</span> for each relationship. For example, to enter an edge representing the fact that striped bass eat worms, we would have to call <span class="literal">add_edge!(foodchain, 1, 7)</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_194"/>Let’s make the process more convenient by defining a dictionary and a function that will allow us to refer to the creatures by name:</p>
<pre class="calibre13">food_dict = Dict([creatures[i] =&gt; i for i in 1:14])

function ↪(predator, prey)
    add_edge!(foodchain, food_dict[predator], food_dict[prey])
end</pre>
<p class="indent">The <span class="literal">food_dict</span> dictionary simply associates each creature string with its order in the list, for easy reference. The new function allows us to add edges by naming the predator and its prey. We’re using a name for this function that can serve as an infix operator (see “Operators Are Functions Too” on <a href="ch06.xhtml#ch06lev1sec4" class="calibre10">page 159</a>). The REPL shortcut (and LaTeX command) for that character is <span class="literal">\hookrightarrow</span>.</p>
<p class="indent">With the hooked arrow function in place, we can list a set of predator–prey relationships taken from a study of the ecology of the Chesapeake Bay:</p>
<pre class="calibre13">"Striped bass" ↪ "Worms"
"Striped bass" ↪ "Amphipods"
"Striped bass" ↪ "Mysids"
"Striped bass" ↪ "Bay anchovy"
"Atlantic croaker" ↪ "Mysids"
"Atlantic croaker" ↪ "Worms"
"White perch" ↪ "Worms"
"White perch" ↪ "Amphipods"
"Summer flounder" ↪ "Bay anchovy"
"Summer flounder" ↪ "Mysids"
"Summer flounder" ↪ "Juvenile weakfish"
"Summer flounder" ↪ "Sand shrimp"
"Summer flounder" ↪ "Mantis shrimp"
"Clearnose skate" ↪ "Mantis shrimp"
"Clearnose skate" ↪ "Razor clams"
"Clearnose skate" ↪ "Juvenile Atlantic croaker"

graphplot(foodchain; names=creatures, nodeshape=:rect, fontsize=5,
          nodesize=0.14, method=:stress)</pre>
<p class="indent">The <span class="literal">add_edge!()</span> function mutates the <span class="literal">foodchain</span> graph by adding edges. The last call produces the illustration shown in <a href="ch07.xhtml#ch7fig2" class="calibre10">Figure 7-2</a>. In the diagram, the arrows point from predator to prey, reflecting the directions of the edges we defined.<span epub:type="pagebreak" id="page_195"/></p>
<div class="image1"><img alt="Image" id="ch7fig2" src="../images/ch07fig02.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 7-2: The predator–prey food net in the Chesapeake Bay</em></p>
<p class="indent">If you run this program, you will find that your picture looks somewhat different. In fact, each time you run it the diagram will be arranged differently in space, although the <em class="calibre11">structure</em> will always be the same—the same creatures being eaten by the same predators. This happens because of a random element in how the nodes and edges are arranged. In fact, I had to run the program about five times before I got a result that I liked. Some of the generated graphs were rather poor, with overlapping nodes.</p>
<p class="indent">The final argument in the call to <span class="literal">graphplot()</span>, <span class="literal">method</span>, selects an algorithm for laying out the graph: for turning the structure into a picture by deciding where to place the nodes. The <span class="literal">stress</span> algorithm does this by trying to maximize a global measure of how far the distances between nodes differ from a theoretical optimum. The random element comes in because the algorithm finds this maximum by deforming a random initial state.<span epub:type="pagebreak" id="page_196"/></p>
<h4 class="h3" id="ch07lev1sec1"><strong class="calibre2"><em class="calibre4">The Adjacency Matrix</em></strong></h4>
<p class="noindent">Internally, the list of edges established by calls to <span class="literal">add_edge!()</span> gets transformed into an <em class="calibre11">adjacency matrix</em>. We can see the adjacency matrix as shown in <a href="ch07.xhtml#ch7lis2" class="calibre10">Listing 7-2</a>.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">foodchain_matrix = adjacency_matrix(foodchain)</span>
14×14 SparseArrays.SparseMatrixCSC{Int64, Int64} with 16 stored entries:
 . . . . .  1  1  1  1 . . . . .
 . . . . . .  1  1 . . . . . .
 . . . . . .  1 .  1 . . . . .
 . . . . .  1 .  1 .  1  1  1 . .
 . . . . . . . . . . .  1  1  1
 . . . . . . . . . . . . . .
 . . . . . . . . . . . . . .
 . . . . . . . . . . . . . .
 . . . . . . . . . . . . . .
 . . . . . . . . . . . . . .
 . . . . . . . . . . . . . .
 . . . . . . . . . . . . . .
 . . . . . . . . . . . . . .
 . . . . . . . . . . . . . .</pre>
<p class="list" id="ch7lis2"><em class="calibre11">Listing 7-2: The adjacancy matrix is a sparse array.</em></p>
<p class="indent">The result is returned as a <em class="calibre11">sparse array</em>, one of a collection of data types defined in the <span class="literal">SparseArrays</span> package, which the <span class="literal">Graphs</span> package loads automatically. A sparse array behaves similarly to a normal array, but is specialized to be efficient when only a small proportion of its elements are defined. The REPL displays them as shown in <a href="ch07.xhtml#ch7lis2" class="calibre10">Listing 7-2</a>, with dots representing undefined locations.</p>
<p class="indent">The elements of an adjacency matrix are set to 1 to record the existence of edges in the graph. For example, <span class="literal">foodchain_matrix[1, 6]</span> has a 1, because there’s an edge going from node 1 to node 6 (established by <span class="literal">"Striped bass"</span>↪ <span class="literal">"Bay anchovy"</span>). The adjacency matrix encodes the structure of the graph, and therefore contains its complete definition, because a graph is identical to its structure. We can plot the graph with a call to <span class="literal">graphplot(foodchain_matrix)</span>; the remaining arguments simply supply details, such as names for labeling the nodes, for its display. If the adjacency matrix is symmetrical (<span class="literal">M[i, j]</span> <span class="literal">== M[j, i]</span>), it represents an undirected graph. Otherwise, as in the food chain example, it represents a directed graph, and <span class="literal">graphplot()</span> will draw it using arrows rather than simple lines. The adjacency matrix must have at least one nonzero element, or at least one edge defined with <span class="literal">add_edge!()</span>, before plotting a graph.</p>
<p class="indent">The package uses sparse matrices for efficiency, but, if we’re constructing an adjacency matrix directly, as in the next example, we have the option of using normal matrices. In this case, a 0 element indicates the absence of an edge and nonzero elements show where the edges are.<span epub:type="pagebreak" id="page_197"/></p>
<h4 class="h3" id="ch07lev1sec2"><strong class="calibre2"><em class="calibre4">Factor Trees</em></strong></h4>
<p class="noindent">At the risk of awakening bad memories from high school algebra class, our next example, found in <a href="ch07.xhtml#ch7lis3" class="calibre10">Listing 7-3</a>, will be a program to draw factor trees: graph diagrams showing the division of a number into ever-smaller factors, ending with its unique prime factors. It will show how to build a graph by constructing its adjacency matrix and provide an example of an undirected graph with a tree structure. Here’s the complete program that produces the factor tree.</p>
<pre class="calibre13">using Primes: factor
using Plots
using Graphs
using GraphRecipes
function factree(n)
 <span class="ent">➊</span> factors = factor(Vector, n)
    lf = length(factors)
    if lf == 1
        println("$n is prime.")
     <span class="ent">➋</span> return
    end
    names = [n; n ÷ factors[1]; factors[1]]
    for f in factors[2:end-1]
        push!(names, names[end-1] ÷ f, f)
    end
    nel = length(names)
 <span class="ent">➌</span> a = zeros(nel, nel)
    println("Prime factors: $factors")
    j = 1; i = 1
    a[1, 2] = 1
    a[1, 3] = 1
    for i in 2:2:nel-3
        a[i, i+2] = 1
        a[i, i+3] = 1
    end
    graphplot(a;
              nodeshape=:circle,
           <span class="ent">➍</span> nodesize=0.12 + log10(n) * .01,
              axis_buffer=0.3,
              curves=false,
              color=:black,
              linewidth=2,
              names=names,
              fontsize=10,
           <span class="ent">➎</span> method=:buchheim)
end</pre>
<p class="list" id="ch7lis3"><em class="calibre11">Listing 7-3: A program to create a factor tree</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_198"/>The new import, the first line of the program, gets us the <span class="literal">factor()</span> function <span class="ent">➊</span>, which returns the prime factors of its argument. The program works only for integers <span class="literal">n</span> greater than 1. The first argument supplied to <span class="literal">factor()</span> tells it to return the results in a vector, the form that we need to construct the factor tree. The default is to return the results in a special-purpose type that lists factors and multiplicities. If there is only one of those, <span class="literal">n</span> is a prime number, so we stop immediately <span class="ent">➋</span>, announcing why. The program proceeds through the list of primes, dividing and concatenating the results onto the <span class="literal">names</span> vector. We then initialize the adjacency matrix <span class="literal">a</span> <span class="ent">➌</span> and record the links between each pair of factors and their product up the tree. The final call to <span class="literal">graphplot()</span> takes the adjacency matrix as its first argument; the keyword arguments set details for the illustration. The <span class="literal">nodesize</span> argument sets the extra size of the circles beyond what is required for them to contain their labels. The algorithm for enlarging them does not quite succeed in making them grow big enough, so we add something extra proportional to the number of digits in the label <span class="ent">➍</span>. Calling <span class="literal">factree(14200)</span> produces <a href="ch07.xhtml#ch7fig3" class="calibre10">Figure 7-3</a>.</p>
<div class="image1"><img alt="Image" id="ch7fig3" src="../images/ch07fig03.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 7-3: A factor tree for the number 14,200</em></p>
<p class="indent">The package provides two layout methods for creating tree-like graphs. The <span class="literal">:tree</span> method works, but the results are a bit free-form. The <span class="literal">:buchheim</span> method <span class="ent">➎</span> produces the regular tree shown in <a href="ch07.xhtml#ch7fig3" class="calibre10">Figure 7-3</a>. Although the prime factorization is unique, the factor tree that leads to it, and thus the result of the program, may not be.</p>
<h3 class="h2" id="ch07lev3"><strong class="calibre2">Animations with Javis</strong></h3>
<p class="noindent">The widely used <span class="literal">Javis</span> package is a good choice for making almost any type of animated diagram. It’s built on top of <span class="literal">Luxor</span> (see “Diagramming with Luxor” on <a href="ch07.xhtml#ch07lev1" class="calibre10">page 190</a>), which means you can build on your knowledge of that package <span epub:type="pagebreak" id="page_199"/>to create animations. A <span class="literal">Javis</span> program creates objects from <span class="literal">Luxor</span> drawing commands and turns them into videos by means of a fairly intuitive set of calls to rotate, translate, or move them along paths, as well as by changing shape parameters in time.</p>
<h4 class="h3" id="ch07lev1sec3"><strong class="calibre2"><em class="calibre4">Closures</em></strong></h4>
<p class="noindent">To use <span class="literal">Javis</span> effectively, it helps to be familiar with a programming technique called a <em class="calibre11">closure</em>. Experienced programmers who know how to use closures can safely skip this section.</p>
<p class="indent">A closure is a function that is created and returned by another function. We’ll refer to the returned function as the <em class="calibre11">inner function</em> and the one that creates it as the <em class="calibre11">outer function</em>. Most modern languages allow the programmer to create closures, but some are more convenient for this than others. Julia, because of its lexical scoping and convenient syntax for function definition, makes closures easy and intuitive.</p>
<p class="indent">The key aspect to closures is that the inner function can access variables defined in the outer function. We say that they are <em class="calibre11">closed over</em>, hence the name. The outer function becomes a function factory, returning a function whose behavior depends on the arguments passed to the outer function, but with, potentially, a completely different function signature.</p>
<p class="indent"><a href="ch07.xhtml#ch7lis4" class="calibre10">Listing 7-4</a> shows a simple example of a closure that we’ll find a useful application for shortly.</p>
<pre class="calibre13">function power(n)
    return function(x)
        x^n
    end
end</pre>
<p class="list" id="ch7lis4"><em class="calibre11">Listing 7-4: Defining a closure</em></p>
<p class="noindent">With this definition, when we call, for example, <span class="literal">power(5)</span>, we get a function of a single variable that raises that variable to the fifth power and returns the result. In other words, if we define two functions this way:</p>
<pre class="calibre13">p = power(5)

q = x -&gt; x^5</pre>
<p class="noindent">then <span class="literal">p</span> and <span class="literal">q</span> have the same behavior:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">p(4) == q(4) == 1024</span>
true</pre>
<p class="indent">The function <span class="literal">power()</span> returns is anonymous, but we can assign it to a variable, in this case <span class="literal">p</span>, as we can any other function.</p>
<p class="indent">Now <span class="literal">power()</span> is a function factory that makes functions that raise their arguments to any desired exponent. As mentioned in “Plotting Functions” on <a href="ch04.xhtml#ch04lev1sec2" class="calibre10">page 88</a>, one version of the <span class="literal">plot()</span> function from the <span class="literal">Plots</span> package <span epub:type="pagebreak" id="page_200"/>accepted the simple names of functions of one variable to plot. We can plot such functions without mentioning variables or defining arrays.</p>
<p class="indent">It would seem that this convenience could not be exploited to plot, say, functions that depend on a parameter in addition to the independent variable, and that we would need to use named functions or the anonymous function syntax to pass such functions to <span class="literal">plot()</span>. For example, if we want to plot <span class="literal">f(x, n) = x^n</span>, we can’t just call <span class="literal">plot(f)</span>, because <span class="literal">f()</span> needs two arguments, but we could call <span class="literal">plot((x) -&gt; x^n)</span> if <span class="literal">n</span> were already defined. Closures are an alternative to passing anonymous functions in cases such as this.</p>
<p class="indent">Once we have the closure defined in <a href="ch07.xhtml#ch7lis4" class="calibre10">Listing 7-4</a>, we can make the following plotting call:</p>
<pre class="calibre13">plot([power(1), power(2), power(3)]; legend=:top)</pre>
<p class="noindent">This produces the plot in <a href="ch07.xhtml#ch7fig4" class="calibre10">Figure 7-4</a>.</p>
<div class="image1"><img alt="Image" id="ch7fig4" src="../images/ch07fig04.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 7-4: Plotting with closures</em></p>
<p class="indent">This plotting example is simply one application of closures. They are a powerful technique for generating functions that capture the state under which they are defined.</p>
<h4 class="h3" id="ch07lev1sec4"><strong class="calibre2"><em class="calibre4">Epicycle Animation</em></strong></h4>
<p class="noindent">The pattern for using <span class="literal">Javis</span> is to define functions that produce each of the objects you intend to animate, and then call a series of statements that refer to those objects and animate them, changing their positions or other properties in time.<span epub:type="pagebreak" id="page_201"/></p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">Since</em> <span class="codeitalic1">Javis</span> <em class="calibre11">is built on</em> <span class="codeitalic1">Luxor</span><em class="calibre11">, it imports</em> <span class="codeitalic1">Luxor</span> <em class="calibre11">itself and re-exports that package’s functions. The consequence is that a program that contains</em> <span class="codeitalic1">using Javis</span> <em class="calibre11">must not also contain</em> <span class="codeitalic1">using Luxor</span><em class="calibre11">, because that would lead to name conflicts. If you’ve been using</em> <span class="codeitalic1">Luxor</span> <em class="calibre11">in the REPL, you must start a new REPL before using</em> <span class="codeitalic1">Javis</span><em class="calibre11">.</em></p>
</div>
<p class="indent">The object-creating functions use one or more <span class="literal">Luxor</span> functions for circles, lines, text, or other graphical entities available through <span class="literal">Luxor</span>, and optionally return information about the object for use in the animation calls.</p>
<p class="indent">The <span class="literal">Luxor</span> documentation describes three methods for passing the object-creating functions into the animation functions. We’ll learn another method, based on closures, that’s more general and leads to neater and easier-to-read code.</p>
<p class="indent">The goal for this example is to create a program that produces animations of models of the solar system in the style of Ptolemy. This ancient cosmology put our Earth at the center of the universe and explained observations of planets as caused by their circular orbits, which themselves circled around larger orbits. These circular orbits are called <em class="calibre11">epicycles</em>; any one planet’s motion might be modeled by one or more epicycles, ending with a large circle around a point somewhat displaced from Earth by a distance called the <em class="calibre11">eccentricity</em>.</p>
<p class="indent">To build the program, we’ll start with functions that create the planets and orbits. Here’s the one for a planet:</p>
<pre class="calibre13">function planet(radius=15, color="green"; action = :fill, p=0)
    return function(video, object, frame)
        sethue(color)
        circle(p, radius, action)
        return p
    end
end</pre>
<p class="indent">This is a closure. A call to <span class="literal">planet()</span> returns a function that accepts three positional arguments and draws a circle with a radius, color, and position determined not by the arguments passed to the returned function, but by the original arguments passed to <span class="literal">planet()</span>.</p>
<p class="indent">This indirection is necessary because the <span class="literal">Javis</span> functions that do the animation expect a function as their first and only required argument. They don’t accept a shape as an argument, but a function that draws a shape. They pass the three values <span class="literal">(video, object, frame)</span> to this function: data types representing the video, the object being animated, and the integer frame number. The function can use any of them, or as in the case of the function created by <span class="literal">planet()</span>, none of them.</p>
<p class="indent">The closure returns the circle’s position. We must do this if other animation functions need to know that position, as is the case in our video.</p>
<p class="indent">The function for drawing orbits will be almost the same:</p>
<pre class="calibre13">function orbit(radius, color="orchid1"; p=O)
    return function(video, object, frame)
        sethue(color)
        circle(p, radius, :stroke)
        return p
    end
end</pre>
<p class="noindent"><span epub:type="pagebreak" id="page_202"/>Orbits will have an outline, but won’t be filled in.</p>
<p class="indent">With these two functions, we can draw animatable planets and orbits, which is most of what we need. But it would also be nice to show how the wandering of the planet around the solar system translates into changes in its observed location in the sky relative to the fixed stars as the days go by. We’ll approximate this movement by the projection of the planet’s position along the horizontal coordinate. The <span class="literal">pos()</span> function supplied by <span class="literal">Javis</span> returns an object’s position, and it has convenient <span class="literal">x</span> and <span class="literal">y</span> fields for extracting the respective coordinates.</p>
<p class="indent">The following function accepts an object and draws another circle that shares its horizontal coordinate, close to the top of the video:</p>
<pre class="calibre13">function observed_position(orbiter; radius=10, color="orangered")
    return function(video, object, frame)
        sethue(color)
     <span class="ent">➊</span> y = 0 - video.height/2 + 50
        x = pos(orbiter).x
        circle(Point(x, y), radius, :fill)
    end
end</pre>
<p class="indent">Here <span class="literal">observed_position()</span> uses the <span class="literal">video</span> argument’s <span class="literal">height</span> field <span class="ent">➊</span> automatically supplied by the animation functions.</p>
<p class="indent">We would like to draw one more object: a curve in space visualizing the path taken by the planet. We’ll record this path as a series of points in a global <span class="literal">positions</span> vector. At every frame, this function pushes the new position onto the vector and draws a series of tiny circles tracing the path:</p>
<pre class="calibre13">function track!(positions, orbiter)
    return function(video, object, frame)
        sethue("cadetblue1")
        push!(positions, pos(orbiter))
        circle.(positions, 2, :fill)
    end
end</pre>
<p class="indent">We need one more drawing function, used in nearly all <span class="literal">Javis</span> animations, for defining the background:</p>
<pre class="calibre13">function ground(args...)
    background("black")
    sethue("white")
end</pre>
<p class="indent"><span epub:type="pagebreak" id="page_203"/>This definition for <span class="literal">ground()</span> creates a drawing canvas with a black background and uses white as the default drawing color.</p>
<p class="indent">With functions for each object we want to draw, we can create the animation:</p>
<pre class="calibre13">using Javis


function epicycles(inputcycles; eccentricity=0.1, file=nothing)
    box = 200
    eccentricity *= -box
    cycles = [(box*s, f) for (s,f) in inputcycles[1:end-1]]
    R = sum(c[1] for c in cycles)
    # Some encoders require a multiple of 2:
    box_length = 1.5*(2box + R) ÷ 2 * 2
 <span class="ent">➊</span> solar_system = Video(box_length, box_length)
    positions = []
 <span class="ent">➋</span> Background(1:500, ground)
    earth = Object(planet(), Point(0, eccentricity))
    origin = Object(planet(2, "white"))
    inner_orbit = Object(orbit(box))
    for (radius, frequency) in cycles
        outer_orbit = Object(orbit(radius), Point(0, box))
        box += radius
     <span class="ent">➌</span> act!(outer_orbit, Action(anim_rotate_around(frequency * 2π, inner_orbit)))
        inner_orbit = outer_orbit
    end
    wanderer = Object(planet(6, "bisque"), Point(0, box))
    act!(wanderer, Action(anim_rotate_around(inputcycles[end] * 2π,
         inner_orbit)))
 <span class="ent">➍</span> Object(track!(positions, wanderer))
    Object(observed_position(wanderer))
    if file == nothing
     <span class="ent">➎</span> render(solar_system; liveview=true)
    else
        render(solar_system; pathname=file, framerate=30)
    end
end</pre>
<p class="indent">The <span class="literal">epicycles()</span> function accepts one required positional argument, <span class="literal">inputcycles</span>, in the form <span class="literal">[(s1, f1), (s2, f2), ..., fp]</span>. Each <span class="literal">(s, f)</span> pair gives the size <span class="literal">s</span> as a fraction of the main orbit radius of an epicycle with an orbital frequency of <span class="literal">f</span>. Frequencies here refer to the number of cycles completed during the animation. The final <span class="literal">fp</span> is the planet’s frequency.</p>
<p class="indent">After some calculations to scale the orbits according to the video’s overall size, and to adjust this size to account for the epicycles input by the user, we have the one statement <span class="ent">➊</span> that all <span class="literal">Javis</span> animations require: defining the <span class="literal">Video</span> and its dimensions.</p>
<p class="indent"><span epub:type="pagebreak" id="page_204"/>The first animation command <span class="ent">➋</span> establishes the background to be drawn for the first 500 frames. The next three animation commands are calls to <span class="literal">Object()</span>; this is the <span class="literal">Javis</span> command that places the graphical element on the background. The <span class="literal">Object()</span> function accepts a range of frames as a first argument, but uses the range supplied to the most recent <span class="literal">Background()</span> or <span class="literal">Object()</span> command as a default. <span class="literal">Javis</span> is an imperative system that maintains a state to which animation statements apply, containing the current <span class="literal">Video</span> and range of frames.</p>
<p class="indent">Next we have a loop that adds orbits for each epicycle supplied in the argument. The <span class="literal">act!()</span> function <span class="ent">➌</span> is how we create most types of motion in <span class="literal">Javis</span>. Its first argument is the object we want to animate, and the second argument is a function defining the motion. The only such motion we use in this program is <span class="literal">anim_rotate_around()</span>, which takes an angle (in radians) and the object that becomes the center of rotation. The complex, compound motions in the epicycle model are easy to construct because the object rotated around can itself be in motion.</p>
<p class="indent">The final two <span class="literal">Object()</span> calls <span class="ent">➍</span> create the path tracking the planet and the projection showing its approximate observed position. Although these are animated objects, they don’t need an <span class="literal">act!()</span> call because they’re defined with reference to other animated objects.</p>
<p class="indent">The <span class="literal">epicycles()</span> function also accepts two optional keyword arguments. The <span class="literal">eccentricity</span> gives the displacement of Earth from the center of the main orbit. If <span class="literal">file</span> is supplied, the program creates a video file and saves it there; if not, it displays the result in an interactive viewer.</p>
<p class="indent">As an example, to produce an animation with a planet that goes around once during the movie, with two epicycles going around two and three times as fast, the first with a diameter half of the orbit’s diameter, and the second with a diameter half the first’s, make the following call:</p>
<pre class="calibre13">epicycles([(0.5, 2), (0.25, 3), 1]; file="ptolemaic.mp4")</pre>
<p class="noindent">This call saves the rendered animation in an MP4 file.</p>
<p class="indent">The type of viewer depends on the coding environment. In the REPL, <span class="literal">Javis</span> opens a window with controls to step or scrub through the animation frames. In a Pluto notebook, the frames appear in a horizontal list with a scroll bar. A change to the rendering call when using a notebook, setting <span class="literal">liveview=false</span> <span class="ent">➎</span>, will embed an animated GIF directly in the notebook instead. The <span class="literal">Javis</span> package can save animations as GIFs or MP4 files; the choice is controlled with the file extension. As GIFs can become quite large, the MP4 format is a good option; however, either one requires significant time to render compared with the <span class="literal">liveview</span> option, which is remarkably fast.</p>
<p class="indent"><a href="ch07.xhtml#ch7fig5" class="calibre10">Figure 7-5</a> shows one frame from the rendered video. (See the book’s online supplement at <a href="https://julia.lee-phillips.org" class="calibre10"><em class="calibre11">https://julia.lee-phillips.org</em></a> for the full video.)<span epub:type="pagebreak" id="page_205"/></p>
<div class="image1"><img alt="Image" id="ch7fig5" src="../images/ch07fig05.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 7-5: A frame from an animation created using</em> <span class="codeitalic">Javis</span></p>
<p class="indent">We are able to create this visualization using only one type of motion, the <span class="literal">anim_rotate_around()</span> call. To make an object spin around its origin, the call is <span class="literal">anim_rotate()</span>.</p>
<p class="indent">Some of the other motions that we can create by supplying them as arguments to <span class="literal">Action()</span> include the following:</p>
<div class="bqparan">
<p class="noindentin"><span class="codestrong1">appear()</span> <strong class="calibre7">and</strong> <span class="codestrong1">disappear()</span> Accept any of the arguments <span class="literal">:fade</span>, <span class="literal">:scale</span>, and <span class="literal">:fade_line_width</span>, and make the object come into or out of existence by changing the specified property. Using <span class="literal">:draw_text</span> makes text appear with a typing effect.</p>
<p class="noindentin"><span class="codestrong1">follow_path()</span> Causes an object to follow a path given as a series of points.</p>
<p class="noindentin"><span class="codestrong1">anim_scale()</span> Shrinks or grows an object.</p>
<p class="noindentin"><span class="codestrong1">anim_translate()</span> Moves an object along a line.</p>
<p class="noindentin"><span class="codestrong1">change()</span> Changes any property of an object.<span epub:type="pagebreak" id="page_206"/></p>
</div>
<h3 class="h2" id="ch07lev4"><strong class="calibre2">Animations with Reel</strong></h3>
<p class="noindent">The <span class="literal">Reel</span> package, like <span class="literal">Javis</span>, creates animations, but it serves a different purpose. While <span class="literal">Javis</span> makes it easy to create animations by programmatically describing objects and their motions, <span class="literal">Reel</span> lets us create a video from any function that creates images depending on a parameter (typically time).</p>
<p class="indent">We use an exported function from <span class="literal">Reel</span>, called <span class="literal">roll()</span>, to which we pass an image-creating function of two positional arguments: the <span class="literal">duration</span> that we want for the video and the frames per second (<span class="literal">fps</span>). The two aforementioned positional arguments are time (<span class="literal">t</span>) and timestep (<span class="literal">dt</span>); <span class="literal">roll()</span> calculates both of these, setting <span class="literal">dt = duration/fps</span>, and passes them to the function, calling it repeatedly, each time with an updated <span class="literal">t</span>. It returns a video object that we turn into either a GIF or an MP4 file with a call to <span class="literal">write()</span>. Arranging for a function to accept <span class="literal">t</span> and <span class="literal">dt</span> and create the desired video frame is our responsibility.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">The</em> <span class="codeitalic1">Reel</span> <em class="calibre11">package is not updated frequently, and may not work properly in every computing environment. An alternative, that only creates GIFs but is simple and convenient, is built into recent versions of</em> <span class="codeitalic1">Plots</span><em class="calibre11">. See “Further Reading” on <a href="ch07.xhtml#fur7" class="calibre10">page 211</a></em> <em class="calibre11">for documentation of the</em> <span class="codeitalic1">@animate</span> <em class="calibre11">and</em> <span class="codeitalic1">@gif</span> <em class="calibre11">macros.</em></p>
</div>
<p class="indent"><a href="ch07.xhtml#ch7lis5" class="calibre10">Listing 7-5</a> calculates the displacement of one axisymmetric mode of a vibrating drumhead and creates a video visualizing the motion as a heatmap.</p>
<pre class="calibre13">   using SpecialFunctions
   using Plots
   using Reel
   R = 1.0 # Drum radius
   z2 = 5.52008 # 2nd zero of J0
   λ2 = z2/R
   c = 1
   A = 1; B = 1

   function vibe(r; t=0)
       if r &gt; R
           return 0
       else
        <span class="ent">➊</span> return (A * cos(c*λ2*t) + B * sin(c*λ2*t)) * besselj0(λ2*r)
       end
   end
   r = 0:R/100:R
   theta = 0:2π/100:2π
<span class="ent">➋</span> function drum_frame(t, dt)
       heatmap(theta, r, (theta, r) -&gt;
           vibe(r; t=t); colorbar=false, clim=(-1, 1),
           c=:curl, proj=:polar, ticks=[], size=(100, 100))
   end
   drum_video = roll(drum_frame, fps=30, duration=2)
   write("drum_video.mp4", drum_video)</pre>
<p class="list" id="ch7lis5"><span epub:type="pagebreak" id="page_207"/><em class="calibre11">Listing 7-5: Animating the vibration of a circular drum head</em></p>
<p class="indent">First we import three packages. The vibrating circular drumhead has a radial dependence described by a Bessel function, available from the <span class="literal">SpecialFunctions</span> package. We use a plotting function from <span class="literal">Plots</span> to create our movie frames, and then use <span class="literal">Reel</span> to stitch the animation together.</p>
<p class="indent">After defining a few constants for the solution, we define the <span class="literal">vibe()</span> function, which takes the radial coordinate and a keyword argument <span class="literal">t</span> and returns the solution at that time and coordinate. The Bessel function <em class="calibre11">J</em><sub class="calibre24">0</sub> from the <span class="literal">SpecialFunctions</span> package is named <span class="literal">besselj0()</span> <span class="ent">➊</span>.</p>
<p class="indent">The next two lines define the coordinate arrays for plotting. A polar coordinate system is most natural in this circular geometry: <span class="literal">r</span> is the radial coordinate and <span class="literal">theta</span> is the angular coordinate. We have to wrap <span class="ent">➋</span> the plotting function in a function of <span class="literal">t</span> and <span class="literal">dt</span> so that <span class="literal">roll()</span> can generate the animation frames. For this application, we don’t use <span class="literal">dt</span> for anything, but the function still needs to accept two arguments. The call to <span class="literal">heatmap()</span> uses the <span class="literal">:curl</span> color spectrum, which has a thin white region near 0, letting us see the nodal lines and clearly distinguishing the positive and negative regions. The <span class="literal">proj</span> argument selects the polar geometry.</p>
<p class="indent"><a href="ch07.xhtml#ch7fig6" class="calibre10">Figure 7-6</a> shows one frame from the resulting animation. (See the online supplement at <a href="https://julia.lee-phillips.org" class="calibre10"><em class="calibre11">https://julia.lee-phillips.org</em></a> for the complete video.)</p>
<div class="image1"><img alt="Image" id="ch7fig6" src="../images/ch07fig06.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 7-6: One frame from a vibrating drumhead animation</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_208"/>After we create the video with the <span class="literal">roll()</span> function, we save the result to a file using <span class="literal">write()</span>. The file extension specifies the video format; the other two choices are GIF and WEBM.</p>
<p class="indent">The <span class="literal">write()</span> function is Julia’s standard for writing data to files. The <span class="literal">Reel</span> package defines a version of it that converts the video to the requested format when it sees a <span class="literal">Reel</span> video in its second argument. <a href="ch08.xhtml" class="calibre10">Chapter 8</a> explains how this is possible and how you can make your own specialized versions of functions activated by the types of their arguments.</p>
<h3 class="h2" id="ch07lev5"><strong class="calibre2">Interactive Visualizations in Pluto</strong></h3>
<p class="noindent">The Pluto notebook (see “Pluto: A Better Notebook” on <a href="ch01.xhtml#ch01lev1sec9" class="calibre10">page 17</a>) provides an easy way to create interactive animations through its <span class="literal">@bind</span> macro. This macro binds the output of any of the standard HTML input controls to a Julia variable. When we execute a cell containing a <span class="literal">@bind</span> macro call, Pluto creates the control in the output area for the cell. When the user manipulates the control, Pluto instantly updates the value of the variable to which the control is bound. Because of the reactive nature of the notebook, any cells that depend on that value are automatically re-executed. If any of those cells produce a graph or other visualization, the graphic will change in response to the user interaction. Input controls in HTML include sliders, numerical or text input boxes, file choosers, color pickers, checkboxes, selection menus, and more.</p>
<p class="indent">We don’t need to actually write any HTML (or know anything about it) thanks to the <span class="literal">PlutoUI</span> package, which provides a convenient Julia interface to the HTML input controls. For HTML experts, however, the option to use the web’s markup language directly is supported. It’s even possible to create custom controls using JavaScript. See “Further Reading” on <a href="ch07.xhtml#fur7" class="calibre10">page 211</a> for links to more information and for <span class="literal">PlutoUI</span> documentation.</p>
<p class="indent">Let’s look at a few examples of how to use the <span class="literal">@bind</span> macro with <span class="literal">PlutoUI</span> controls. The following uses the browser’s date-picker widget:</p>
<pre class="calibre13">@bind <span class="codeitalic">some_date</span> DateField()</pre>
<p class="noindent">This command assigns the date the user selected to <span class="codeitalic1">some_date</span>, which will have Julia’s <span class="literal">Dates.DateTime</span> data type.</p>
<p class="indent">This example uses the HTML checkbox:</p>
<pre class="calibre13">@bind <span class="codeitalic">a_setting</span> CheckBox()</pre>
<p class="noindent">Here <span class="codeitalic1">a_setting</span> becomes a <span class="literal">Boolean</span>: <span class="literal">true</span> if the user clicks the box and <span class="literal">false</span> otherwise.</p>
<p class="indent">The following uses an HTML text field:</p>
<pre class="calibre13">@bind <span class="codeitalic">label</span> TextField()</pre>
<p class="noindent">This call will assign whatever the user types into a text box as a <span class="literal">String</span> to the variable <span class="codeitalic1">label</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_209"/>There are many more. All of these functions accept a <span class="literal">default</span> keyword argument, and some accept other arguments as well. For example, <span class="literal">TextField()</span> accepts an optional tuple argument; if supplied, it creates a multiline <span class="literal">textarea</span> with the number of columns and rows taken from the tuple’s first and second elements.</p>
<p class="indent">As an example of an interactive visualization, let’s return to the vibrating drumhead problem from <a href="ch07.xhtml#ch7lis5" class="calibre10">Listing 7-5</a>. The goal is to create a notebook containing a plot of the drumhead where the user can move in time by manipulating a slider.</p>
<p class="indent">We’ll make a few small changes to the code from <a href="ch07.xhtml#ch7lis5" class="calibre10">Listing 7-5</a>. First, we need one additional import, <span class="literal">using PlutoUI</span>, to be able to use the HTML widgets, and we won’t need to import <span class="literal">Reel</span>.</p>
<p class="indent">The <span class="literal">vibe()</span> function needs no changes, but let’s alter the plotting function to make a surface plot rather than a heatmap and to show the time in a title. The <span class="literal">surface()</span> function from <span class="literal">Plots</span> doesn’t understand polar coordinates, so we need to use <span class="literal">x</span> and <span class="literal">y</span> and convert manually:</p>
<pre class="calibre13">function drum_frame(t)
    surface(x, y, (x, y) -&gt;
        vibe(sqrt(x^2 + y^2); t=t); colorbar=false, clim=(-1, 1),
        c=:curl, zrange=(-1.2, 1.2), title="t = $t")
end</pre>
<p class="indent">We want the interactivity to be responsive, so we’ll sacrifice some smoothness in the plot by using a coarser gridding:</p>
<pre class="calibre13">x = -1:0.05:1
y = -1:0.05:1</pre>
<p class="noindent">We’re not making a movie, so we don’t need the last two lines of <a href="ch07.xhtml#ch7lis5" class="calibre10">Listing 7-5</a>. To make the notebook, we import <span class="literal">Pluto</span> in the REPL and execute <span class="literal">Pluto.run()</span>, which opens a new tab in the default web browser with the Pluto start page. After clicking the link to create a new notebook, we can enter all these variable and function definitions into cells. The final cell will contain the line:</p>
<pre class="calibre13">@bind t Slider(0:0.01:1.1382)</pre>
<p class="noindent">The range supplied as an argument will become the starting, step size, and ending values for the slider. The ending value is the time for one complete vibration cycle.</p>
<p class="indent">A picture in a book can’t convey the experience of using the notebook. For that, there is no substitute for trying it yourself. But <a href="ch07.xhtml#ch7fig7" class="calibre10">Figure 7-7</a> shows a screenshot of the plot and slider.</p>
<div class="image1"><span epub:type="pagebreak" id="page_210"/><img alt="Image" id="ch7fig7" src="../images/ch07fig07.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 7-7: The vibrating drumhead in a Pluto notebook</em></p>
<p class="indent">Interactive Pluto notebooks are a powerful means to create explanatory documents and educational material. The fact that they’re stored as text files makes them easy to share, at least with other Julia users.</p>
<h3 class="h2" id="ch07lev6"><strong class="calibre2">Conclusion</strong></h3>
<p class="noindent">The packages we’ve explored in this chapter make it easy to create a wide variety of diagrams and animations. This facility is a boon to the community of Julia users, as many of the scientists and engineers who form a large segment of its audience are also teachers, conference presenters, and creators of online educational materials. All of these activities are enhanced by having tools at hand to construct explanatory visualizations. The ability to create complex visualizations within Julia is important: much of the time they will require computations that we’re already performing in our Julia programs. Indeed, often they will be part of the dissemination of the results of those computations. Packages such as <span class="literal">Luxor</span> and <span class="literal">Javis</span> free us from the need to reach for external programs and from becoming mired in another “two language problem.”</p>
<p class="indent">In the next chapter, we’ll return to the language itself and learn about the type system. This is the final piece required for Julia mastery; putting it in place will unlock a new level of programming power.</p>
<div class="box">
<p class="boxtitle-d" id="fur7"><span epub:type="pagebreak" id="page_211" class="calibre1"/><strong class="calibre2">FURTHER READING</strong></p>
<ul class="calibre12">
<li class="noindent1">Videos and color images are available in the online supplement at <a href="https://julia.lee-phillips.org" class="calibre10"><em class="calibre11">https://julia.lee-phillips.org</em></a>.</li>
<li class="noindent1">The <span class="literal">Luxor</span> documentation is available at <a href="http://juliagraphics.github.io/Luxor.jl/stable/" class="calibre10"><em class="calibre11">http://juliagraphics.github.io/Luxor.jl/stable/</em></a>.</li>
<li class="noindent1">The <span class="literal">Javis</span> documentation is available at <a href="https://juliaanimators.github.io/Javis.jl/stable/" class="calibre10"><em class="calibre11">https://juliaanimators.github.io/Javis.jl/stable/</em></a>.</li>
<li class="noindent1">For <span class="literal">GraphRecipes</span> attributes, including a complete list of available layout algorithms, visit <a href="https://docs.juliaplots.org/stable/generated/graph_attributes/" class="calibre10"><em class="calibre11">https://docs.juliaplots.org/stable/generated/graph_attributes/</em></a>.</li>
<li class="noindent1">Documentation for the <span class="literal">NetworkLayout</span> package that supplies the different graph layout algorithms, where you can see interesting animations of the workings of the various layout strategies, is available at <a href="https://juliagraphs.org/NetworkLayout.jl/stable/" class="calibre10"><em class="calibre11">https://juliagraphs.org/NetworkLayout.jl/stable/</em></a>.</li>
<li class="noindent1">For details on how to use the <span class="literal">@gif</span> and <span class="literal">@animate</span> macros, visit <a href="https://docs.juliaplots.org/latest/animations/" class="calibre10"><em class="calibre11">https://docs.juliaplots.org/latest/animations/</em></a>.</li>
<li class="noindent1">A tutorial on making custom interface components for Pluto using JavaScript is available at <a href="https://cotangent.dev/how-to-make-custom-pluto-ui-components/" class="calibre10"><em class="calibre11">https://cotangent.dev/how-to-make-custom-pluto-ui-components/</em></a>.</li>
<li class="noindent1">The creator of Pluto explains how to create custom interactions using JavaScript in this video: <a href="https://www.youtube.com/watch?v=SAC_RCjyRRs" class="calibre10"><em class="calibre11">https://www.youtube.com/watch?v=SAC_RCjyRRs</em></a>.</li>
<li class="noindent1">For documentation on the functions available in <span class="literal">PlutoUI</span>, visit <a href="https://docs.juliahub.com/PlutoUI/" class="calibre10"><em class="calibre11">https://docs.juliahub.com/PlutoUI/</em></a>.<span epub:type="pagebreak" id="page_212"/></li></ul>
</div>
</body></html>