<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch22"><span epub:type="pagebreak" id="page_421"/><span class="big">22</span><br/>COORDINATE SYSTEMS AND FIELDS</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">In this chapter we’ll begin exploring Faraday and Maxwell’s electromagnetic theory, which broke from Coulomb’s particle-based ideas by introducing the notion of a field. The Faraday-Maxwell theory is the best theory we have for explaining electrical, magnetic, and optical phenomena. As a field theory, the Faraday-Maxwell theory supported the locality ideas of relativity 40 years before Einstein wrote about it, served as an inspiration for other field theories like general relativity, and became the prototype for contemporary gauge field theories of particle physics. The field idea now plays an important role in many areas of physics, such as continuum mechanics, fluid dynamics, and quantum field theory. That a field is a function is one reason why functional programming serves physics so well.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_422"/>It is possible, and elegant, to give an exposition of electromagnetic theory in four-dimensional spacetime (and functional languages like Haskell are especially well suited to the task), but we’ll follow the more common practice of using three-dimensional notation since physical insight and geometric insight into four-dimensional relativistic spacetime language take some time to acquire. Accordingly, this chapter describes coordinate systems for three-dimensional space, defines a data type for position in three-dimensional space, and introduces the idea of a <em>field</em>, which is a function whose input is a position in three-dimensional space.</p>&#13;
<p class="indent">We’ll gain a bit of insight by looking first at polar coordinates, the most common coordinates for a two-dimensional plane after Cartesian. Then, we’ll look at cylindrical and spherical coordinates, the two most common coordinate systems for three-dimensional space after Cartesian coordinates. We’ll make a new data type for positions in three-dimensional space that accommodates Cartesian, cylindrical, and spherical coordinates as well as any other coordinate system we might want to use. We’ll introduce scalar and vector fields, and data types for them, so that we have the basic mathematical framework to talk about things like charge density (a scalar field) and electric field (a vector field).</p>&#13;
<h3 class="h3" id="ch22lev1">Polar Coordinates</h3>&#13;
<p class="noindent">Polar coordinates are a way of assigning two numbers to each point in the plane so that one of the numbers is the distance from the origin to the point. Polar coordinates are a natural choice for situations with rotational symmetry about a point in the plane, although their use need not be confined to such situations. We’ll use the variables <em>s</em> and <em>ϕ</em> for polar coordinates. The names <em>s</em> and <em>ϕ</em> are from Griffiths’ electrodynamics text [<strong><a href="bib.xhtml#bib19"><span class="green">19</span></a></strong>].</p>&#13;
<p class="indent">The Cartesian coordinates <em>x</em> and <em>y</em> are related to the polar coordinates <em>s</em> and <em>ϕ</em> by the following equations:</p>&#13;
<p class="centere"><em>x</em> = <em>s</em> cos <em>ϕ</em></p>&#13;
<p class="centere"><em>y</em> = <em>s</em> sin <em>ϕ</em></p>&#13;
<p class="indent">The coordinate <em>s</em> is the distance from the origin to a point in the plane, and the coordinate <em>ϕ</em> is the angle between the x-axis and a line joining the origin to a point (see <a href="ch22.xhtml#ch22fig1">Figure 22-1</a>).</p>&#13;
<div class="imagel" id="ch22fig1"><img src="Images/423fig01.jpg" alt="Image" width="601" height="602"/></div>&#13;
<p class="figcap"><em>Figure 22-1: Polar coordinates</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_423"/>In <a href="ch22.xhtml#ch22fig1">Figure 22-1</a>, we’ve also introduced polar coordinate unit vectors. The unit vector <img class="inline" src="Images/scap.jpg" alt="Image" width="8" height="16"/> points away from the origin. (This is a well-defined direction at every point in the plane except for the origin itself.) Equivalently, the unit vector <img class="inline" src="Images/scap.jpg" alt="Image" width="8" height="16"/> points in the direction for which <em>ϕ</em> stays constant and <em>s</em> increases. Analogously, the unit vector <img class="inline" src="Images/sdcap.jpg" alt="Image" width="14" height="25"/> points in the direction for which <em>s</em> stays constant and <em>ϕ</em> increases. We can write the polar coordinate unit vectors <img class="inline" src="Images/scap.jpg" alt="Image" width="8" height="16"/> and <img class="inline" src="Images/sdcap.jpg" alt="Image" width="14" height="25"/> in terms of the Cartesian coordinate unit vectors <img class="inline" src="Images/xcap.jpg" alt="Image" width="12" height="15"/> and <img class="inline" src="Images/ycap.jpg" alt="Image" width="11" height="21"/> as follows:</p>&#13;
<div class="imagec"><img src="Images/423equ01.jpg" alt="Image" width="278" height="113"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_424"/>Unlike the Cartesian unit vectors <img class="inline" src="Images/xcap.jpg" alt="Image" width="12" height="15"/> and <img class="inline" src="Images/ycap.jpg" alt="Image" width="11" height="21"/>, the polar unit vectors <img class="inline" src="Images/scap.jpg" alt="Image" width="8" height="16"/> and <img class="inline" src="Images/sdcap.jpg" alt="Image" width="14" height="25"/> point in different directions at different points in the plane. The picture on the right of <a href="ch22.xhtml#ch22fig5">Figure 22-5</a> later in this chapter shows the unit vector <img class="inline" src="Images/sdcap.jpg" alt="Image" width="14" height="25"/> at different points in the xy-plane, and you can see how its direction changes.</p>&#13;
<p class="indent">The definition of polar coordinates in two dimensions makes it easy to define cylindrical coordinates in three dimensions, to which we now turn.</p>&#13;
<h3 class="h3" id="ch22lev2">Cylindrical Coordinates</h3>&#13;
<p class="noindent">Cylindrical coordinates are an extension of polar coordinates into three dimensions and are a natural choice of coordinates for situations with rotational and translational symmetry about some axis. We can use the cylindrical coordinates <em>s</em>, <em>ϕ</em>, and <em>z</em> to represent the location of a point in three-dimensional space, as shown in <a href="ch22.xhtml#ch22fig2">Figure 22-2</a>. The coordinate <em>s</em> is the distance from the z-axis to the point in space, the coordinate <em>ϕ</em> is the angle between the xz-plane and the plane containing the z-axis and the point, and the coordinate <em>z</em> means the same thing as in Cartesian coordinates: the distance from the xy-plane. Cylindrical coordinates are closely related to polar coordinates in that cylindrical coordinates describe the xy-plane in a polar fashion but continue to use the Cartesian z-coordinate.</p>&#13;
<div class="imagel" id="ch22fig2"><img src="Images/424fig01.jpg" alt="Image" width="434" height="423"/></div>&#13;
<p class="figcap"><em>Figure 22-2: Cylindrical coordinates</em></p>&#13;
<p class="indent">The Cartesian coordinates <em>x</em>, <em>y</em>, and <em>z</em> are related to the cylindrical coordinates <em>s</em>, <em>ϕ</em>, and <em>z</em> by the following equations:</p>&#13;
<div class="imagec"><img src="Images/424equ01.jpg" alt="Image" width="390" height="20"/></div>&#13;
<div class="imagec"><img src="Images/424equ02.jpg" alt="Image" width="390" height="21"/></div>&#13;
<div class="imagec"><img src="Images/424equ03.jpg" alt="Image" width="388" height="20"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_425"/>Also shown in <a href="ch22.xhtml#ch22fig2">Figure 22-2</a> are the cylindrical coordinate unit vectors. The unit vector <img class="inline" src="Images/scap.jpg" alt="Image" width="8" height="16"/> points away from the z-axis. (This is a well-defined direction at every point in space except for points on the z-axis.) Equivalently, the unit vector <img class="inline" src="Images/scap.jpg" alt="Image" width="8" height="16"/> points in the direction for which <em>ϕ</em> and <em>z</em> stay constant and <em>s</em> increases. The unit vector <img class="inline" src="Images/sdcap.jpg" alt="Image" width="14" height="25"/> points in the direction for which <em>s</em> and <em>z</em> stay constant and <em>ϕ</em> increases. Finally, the unit vector <img class="inline" src="Images/zcap.jpg" alt="Image" width="9" height="16"/> points in the direction for which <em>s</em> and <em>ϕ</em> stay constant and <em>z</em> increases.</p>&#13;
<p class="indent">We can write the cylindrical coordinate unit vectors <img class="inline" src="Images/scap.jpg" alt="Image" width="8" height="16"/>, <img class="inline" src="Images/sdcap.jpg" alt="Image" width="14" height="25"/>, and <img class="inline" src="Images/zcap.jpg" alt="Image" width="9" height="16"/> in terms of the Cartesian coordinate unit vectors <img class="inline" src="Images/xcap.jpg" alt="Image" width="12" height="15"/>, <img class="inline" src="Images/ycap.jpg" alt="Image" width="11" height="21"/>, and <img class="inline" src="Images/zcap.jpg" alt="Image" width="9" height="16"/> as follows:</p>&#13;
<div class="imagec"><img src="Images/425equ01.jpg" alt="Image" width="429" height="21"/></div>&#13;
<div class="imagec"><img src="Images/425equ02.jpg" alt="Image" width="434" height="26"/></div>&#13;
<div class="imagec"><img src="Images/425equ03.jpg" alt="Image" width="429" height="20"/></div>&#13;
<p class="indent">Now that we’ve talked about the system of cylindrical coordinates and shown how it’s an alternative to Cartesian coordinates for describing points in three-dimensional space, let’s discuss one more three-dimensional coordinate system.</p>&#13;
<h3 class="h3" id="ch22lev3">Spherical Coordinates</h3>&#13;
<p class="noindent">Spherical coordinates are a natural choice in situations with rotational symmetry about a point in space, but, like all of the three-dimensional coordinate systems described in this chapter, they are also a general system of coordinates capable of describing arbitrary positions in 3D space. We can use the spherical coordinates <em>r</em>, <em>θ</em>, and <em>ϕ</em> to represent the location of a point in space, as shown in <a href="ch22.xhtml#ch22fig3">Figure 22-3</a>.</p>&#13;
<div class="imagel" id="ch22fig3"><img src="Images/425fig01.jpg" alt="Image" width="434" height="423"/></div>&#13;
<p class="figcap"><em>Figure 22-3: Spherical coordinates</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_426"/>The coordinate <em>r</em> is the distance from the origin to the point in space, the coordinate <em>θ</em> is the angle between the z-axis and a line from the origin to the point, and the coordinate <em>ϕ</em> is the angle between the xz-plane and the plane containing the z-axis and the point. (The coordinate <em>ϕ</em> has the same meaning in spherical coordinates that it has in cylindrical coordinates.)</p>&#13;
<p class="indent">The Cartesian coordinates <em>x</em>, <em>y</em>, and <em>z</em> are related to the spherical coordinates <em>r</em>, <em>θ</em>, and <em>ϕ</em> by the following equations:</p>&#13;
<div class="imagec"><img src="Images/426equ01.jpg" alt="Image" width="412" height="21"/></div>&#13;
<div class="imagec"><img src="Images/426equ02.jpg" alt="Image" width="412" height="21"/></div>&#13;
<div class="imagec"><img src="Images/426equ03.jpg" alt="Image" width="411" height="20"/></div>&#13;
<p class="indent">Also shown in <a href="ch22.xhtml#ch22fig3">Figure 22-3</a> are the spherical coordinate unit vectors. The unit vector <img class="inline" src="Images/rcap.jpg" alt="Image" width="9" height="16"/> points away from the origin. (This is a well-defined direction at every point in space except for the origin itself.) Equivalently, the unit vector <img class="inline" src="Images/rcap.jpg" alt="Image" width="9" height="16"/> points in the direction for which <em>θ</em> and <em>ϕ</em> stay constant and <em>r</em> increases. The unit vector <img class="inline" src="Images/thcap.jpg" alt="Image" width="11" height="21"/> points in the direction for which <em>r</em> and <em>ϕ</em> stay constant and <em>θ</em> increases. Finally, the unit vector <img class="inline" src="Images/sdcap.jpg" alt="Image" width="14" height="25"/> points in the direction for which <em>r</em> and <em>θ</em> stay constant and <em>ϕ</em> increases.</p>&#13;
<p class="indent">To write <img class="inline" src="Images/rcap.jpg" alt="Image" width="9" height="16"/> in terms of the Cartesian unit vectors, we divide the position vector <img class="inline" src="Images/426equ04.jpg" alt="Image" width="125" height="21"/> by its magnitude <img class="inline" src="Images/426equ05.jpg" alt="Image" width="144" height="38"/>. The expression for <img class="inline" src="Images/sdcap.jpg" alt="Image" width="14" height="25"/> is the same as it was for cylindrical coordinates. An expression for <img class="inline" src="Images/thcap.jpg" alt="Image" width="11" height="21"/> can be found from <img class="inline" src="Images/426equ09.jpg" alt="Image" width="75" height="25"/>. We can write the spherical coordinate unit vectors <img class="inline" src="Images/rcap.jpg" alt="Image" width="9" height="16"/>, <img class="inline" src="Images/thcap.jpg" alt="Image" width="11" height="21"/>, and <img class="inline" src="Images/sdcap.jpg" alt="Image" width="14" height="25"/> in terms of the Cartesian coordinate unit vectors <img class="inline" src="Images/xcap.jpg" alt="Image" width="12" height="15"/>, <img class="inline" src="Images/ycap.jpg" alt="Image" width="11" height="21"/>, and <img class="inline" src="Images/zcap.jpg" alt="Image" width="9" height="16"/> as follows:</p>&#13;
<div class="imagec"><img src="Images/426equ06.jpg" alt="Image" width="604" height="65"/></div>&#13;
<div class="imagec"><img src="Images/426equ07.jpg" alt="Image" width="605" height="31"/></div>&#13;
<div class="imagec"><img src="Images/426equ08.jpg" alt="Image" width="812" height="35"/></div>&#13;
<p class="indent">Now that we’ve completed our introduction to spherical coordinates, and to all of the coordinate systems we intend to use, our next mission is to define a new type for positions in three-dimensional space that will work well with all of our three-dimensional coordinate systems. However, before we do that, let’s lay down some introductory code for this chapter.</p>&#13;
<h3 class="h3" id="ch22lev4">Introductory Code</h3>&#13;
<p class="noindent"><a href="ch22.xhtml#ch22list1">Listing 22-1</a> shows the first lines of code for the <code>CoordinateSystems</code> module we’ll develop in this chapter.</p>&#13;
<pre id="ch22list1">{-# OPTIONS -Wall #-}&#13;
&#13;
module CoordinateSystems where&#13;
&#13;
<span epub:type="pagebreak" id="page_427"/>import SimpleVec&#13;
    ( R, Vec, (^/), vec, xComp, yComp, zComp, iHat, jHat, kHat&#13;
    , magnitude, sumV, zeroV )&#13;
import Mechanics3D ( orient, v3FromVec )&#13;
import MOExamples ( Table(..), Justification(..) )&#13;
import qualified Vis as V&#13;
import SpatialMath ( V3(..) )&#13;
import Diagrams.Prelude&#13;
    ( Diagram, V2(..), PolyType(..), PolyOrientation(..), PolygonOpts(..)&#13;
    , (#), (@@), dims, p2, r2, arrowAt, position, fc, black, white&#13;
    , blend, none, lw, rotate, deg, rad, scale, polygon, sinA )&#13;
import Diagrams.Backend.Cairo ( B, renderCairo )</pre>&#13;
<p class="listing"><em>Listing 22-1: Opening lines of code for the <span class="codeitalic1">CoordinateSystems</span> module</em></p>&#13;
<p class="indent">Here, we import functions and types that we’ve previously written from the <code>SimpleVec</code>, <code>Mechanics3D</code>, and <code>MOExamples</code> modules. We’ll use the <code>Vis</code> module for visualizing scalar and vector fields, and we’ll use the <code>V3</code> type from <code>SpatialMath</code> since it’s the native vector type for the <code>Vis</code> module. The <code>Diagrams</code> <code>.Prelude</code> and <code>Diagrams.Backend.Cairo</code> modules are part of the diagrams package, which we’ll use for vector field visualization. The appendix contains information on installing the diagrams package.</p>&#13;
<h3 class="h3" id="ch22lev5">A Type for Position</h3>&#13;
<p class="noindent">We’d like to have a Haskell type to describe the position of a point in space. We’d also like to be able to specify points in three-dimensional space in Cartesian, cylindrical, or spherical coordinates, and to access previously defined positions in any of the coordinate systems, including a system different from the one used to define it.</p>&#13;
<h4 class="h4" id="ch22lev6">Defining the New Type</h4>&#13;
<p class="noindent">How can we use Haskell to describe a point in space? We have three options. Option A is to use a triple <code>(R,R,R)</code> of Cartesian coordinates. This is fine for many purposes. It has the advantage of simplicity, but it has the disadvantage that we already know we’re interested in using cylindrical and spherical coordinates, which are also triples of numbers. This puts us in the dangerous position of mistaking a Cartesian (<em>x</em>,<em>y</em>,<em>z</em>) triple for a spherical (<em>r</em>,<em>θ</em>,<em>ϕ</em>) triple. The compiler can help us avoid this mistake, but only if we make intelligent use of the type system. Option A is workable but dangerous. We can make better use of the computer to help us avoid mistakes.</p>&#13;
<p class="indent">Option B is to use the <code>Vec</code> type for position, as we did in mechanics. The <code>Vec</code> type clearly has Cartesian components, so it’s harder to get confused compared with Option A. If we run into a triple <code>(R,R,R)</code> somewhere in code we’ve previously written, the type does not tell us whether it’s a Cartesian <span epub:type="pagebreak" id="page_428"/>triple or a spherical triple. On the other hand, if we run into a <code>Vec</code>, we know it is a Cartesian triple under the hood. Option B is workable. One downside of Option B is that position is not really a vector because vectors are, by definition, things that can be added, and it doesn’t make sense to add positions. If we think of position as a vector, it is a vector from some fixed origin. But adding vectors means putting them tip-to-tail, and this isn’t really allowed for position “vectors” whose tails are fixed at the origin. The other disadvantage of using <code>Vec</code> for position (Option B) is that the Haskell type system cannot help us to distinguish position from any other <code>Vec</code> (such as velocity, acceleration, or momentum).</p>&#13;
<p class="indent">Option C is to use Haskell’s facilities to make a brand-new data type ourselves, which can’t be confused with any other data type. This is not the simplest option, but it will give us the power of working with the three coordinate systems we’re interested in, and it will give us the advantage that the compiler will not allow us to confuse position with velocity. We’ll pursue Option C.</p>&#13;
<p class="indent">We’ll construct a new type in Haskell with the <code>data</code> keyword.</p>&#13;
<pre>data Position = Cart R R R&#13;
                deriving (Show)</pre>&#13;
<p class="indent">The <code>Position</code> that appears immediately to the right of the <code>data</code> keyword is the name we give to the new type. The <code>Cart</code> that appears to the right of the equal sign is the type’s one data constructor, so named to remind us that we are storing the position information in Cartesian coordinates, regardless of the coordinate system in which any particular <code>Position</code> is defined or used.</p>&#13;
<p class="indent">With the new <code>Position</code> data type, we have a way to store three numbers that the compiler will not confuse with any other way of storing three numbers (like a <code>Vec</code>). But the real usefulness of <code>Position</code> is that we can now define three ways of <em>making</em> a <code>Position</code> (one for each coordinate system) and three ways of <em>using</em> a <code>Position</code> (again, one for each coordinate system).</p>&#13;
<h4 class="h4" id="ch22lev7">Making a Position</h4>&#13;
<p class="noindent">At the beginning of this chapter, we showed how Cartesian, cylindrical, and spherical coordinates can be used to describe a position in space. Each coordinate system uses three numbers to specify a position. A coordinate system is a function from three real numbers to space.</p>&#13;
<pre>type CoordinateSystem = (R,R,R) -&gt; Position</pre>&#13;
<p class="indent">Here are the definitions for the three coordinate systems. For Cartesian coordinates, we just stick the coordinates behind the data constructor Cart. For cylindrical coordinates (<em>s</em>,<em>ϕ</em>,<em>z</em>), we convert to Cartesian using Equations 22.1 and 22.2 and then apply the Cart constructor to the Cartesian values. For spherical coordinates (<em>r</em>,<em>θ</em>,<em>ϕ</em>), we again apply the data constructor to the converted Cartesian values using Equations 22.7, 22.8, and 22.9.</p>&#13;
<span epub:type="pagebreak" id="page_429"/>&#13;
<pre>cartesian   :: CoordinateSystem&#13;
cartesian (x,y,z)&#13;
    = Cart x y z&#13;
&#13;
cylindrical :: CoordinateSystem&#13;
cylindrical (s,phi,z)&#13;
    = Cart (s * cos phi) (s * sin phi) z&#13;
&#13;
spherical   :: CoordinateSystem&#13;
spherical (r,theta,phi)&#13;
    = Cart (r * sin theta * cos phi)&#13;
           (r * sin theta * sin phi)&#13;
           (r * cos theta)</pre>&#13;
<p class="indent">The functions cartesian, cylindrical, and spherical are our three ways of making a <code>Position</code>. Before we turn to the three ways of using a <code>Position</code>, we’ll define three helper functions that are almost the same as cartesian, cylindrical, and spherical. These three functions have the shortened names cart, cyl, and sph, and the only difference is that they take their arguments in a curried style, one right after the other, rather than as a triple. They are convenient helping functions.</p>&#13;
<pre>cart :: R  -- x coordinate&#13;
     -&gt; R  -- y coordinate&#13;
     -&gt; R  -- z coordinate&#13;
     -&gt; Position&#13;
cart = Cart&#13;
&#13;
cyl  :: R  -- s   coordinate&#13;
     -&gt; R  -- phi coordinate&#13;
     -&gt; R  -- z   coordinate&#13;
     -&gt; Position&#13;
cyl s phi z = cylindrical (s,phi,z)&#13;
&#13;
sph  :: R  -- r    coordinate&#13;
     -&gt; R  -- theta coordinate&#13;
     -&gt; R  -- phi   coordinate&#13;
     -&gt; Position&#13;
sph r theta phi = spherical (r,theta,phi)</pre>&#13;
<p class="indent">The function <code>cart</code> is a helping function to take three numbers (<em>x</em>, <em>y</em>, <em>z</em>) and form the appropriate position using Cartesian coordinates. The definition of <code>cart</code> is given in point-free style, meaning we omitted the parameters because they are identical on both sides of the equation.</p>&#13;
<p class="indent">The function <code>cyl</code> is a helping function to take three numbers (<em>s</em>, <em>ϕ</em>, <em>z</em>) and form the appropriate position using cylindrical coordinates. We just call the <span epub:type="pagebreak" id="page_430"/>function <code>cylindrical</code> to do the real work. The function <code>sph</code> is a helping function to take three numbers (<em>r</em>, <em>θ</em>, <em>ϕ</em>) and form the appropriate position using spherical coordinates.</p>&#13;
<p class="indent">Let’s use the <code>cart</code> function to define the <code>origin</code>, which is the position where all three Cartesian coordinates are 0.</p>&#13;
<pre>origin :: Position&#13;
origin = cart 0 0 0</pre>&#13;
<h4 class="h4" id="ch22lev8">Using a Position</h4>&#13;
<p class="noindent">We said earlier that we would like to be able to look at an existing <code>Position</code> in Cartesian, cylindrical, or spherical coordinates, regardless of the coordinate system used to define the position. The following three functions show how to <em>use</em> a position to obtain a triple in the desired coordinate system:</p>&#13;
<pre>cartesianCoordinates   :: Position -&gt; (R,R,R)&#13;
cartesianCoordinates   (Cart x y z) = (x,y,z)&#13;
&#13;
cylindricalCoordinates :: Position -&gt; (R,R,R)&#13;
cylindricalCoordinates (Cart x y z) = (s,phi,z)&#13;
    where&#13;
      s = sqrt(x**2 + y**2)&#13;
      phi = atan2 y x&#13;
&#13;
sphericalCoordinates   :: Position -&gt; (R,R,R)&#13;
sphericalCoordinates   (Cart x y z) = (r,theta,phi)&#13;
    where&#13;
      r = sqrt(x**2 + y**2 + z**2)&#13;
      theta = atan2 s z&#13;
      s = sqrt(x**2 + y**2)&#13;
      phi = atan2 y x</pre>&#13;
<p class="indent">The mathematical content of these three functions is merely to convert Cartesian coordinates to any of the three systems. However, the worth of these functions lies in their type. They allow us to express a <code>Position</code> in any of the three coordinate systems, giving the numerical values of the coordinates so they can be used for something. The value of the <code>Position</code> data type is that it abstracts away from a specific coordinate system, allowing us to use any coordinate system without getting confused about what a set of three numbers might mean. In practice, then, we’ll keep our <code>Position</code>s for as long as we can, converting to a particular coordinate system only when we need access to particular coordinate values.</p>&#13;
<p class="indent">In physics language, both position and displacement have the dimension of length and the SI unit of meter. The next section endeavors to clarify the relationship between position and displacement.</p>&#13;
<h3 class="h3" id="ch22lev9"><span epub:type="pagebreak" id="page_431"/>Displacement</h3>&#13;
<p class="noindent">A <em>displacement</em> is a vector that points from a source position to a target position. We have argued earlier that position in physics in not really a vector. Physicists use the term <em>displacement</em> when they want to refer to a vector with the dimension of length.</p>&#13;
<p class="indent">It is useful and natural to want a type <code>Displacement</code> for these vectors with the dimension of length. As usual, we have the choice of whether to make a brand-new type using the <code>data</code> keyword or to merely make a type synonym using the <code>type</code> keyword. The former option protects us from confusing displacement with any other vector, but at the cost of introducing a new data constructor, while the latter option is convenient but provides no such protection. We choose the latter option and make <code>Displacement</code> a type synonym for <code>Vec</code>.</p>&#13;
<pre>type Displacement = Vec</pre>&#13;
<p class="indent">The displacement function allows us to “subtract” positions (recall we cannot add positions) to get a vector.</p>&#13;
<pre>displacement :: Position  -- source position&#13;
             -&gt; Position  -- target position&#13;
             -&gt; Displacement&#13;
displacement (Cart x' y' z') (Cart x y z)&#13;
    = vec (x-x') (y-y') (z-z')</pre>&#13;
<p class="indent">Since a displacement vector points from the source position to the target position, we subtract the Cartesian source coordinates from the target coordinates.</p>&#13;
<p class="indent">The shiftPosition function allows us to add a displacement to a position to get a new position.</p>&#13;
<pre>shiftPosition :: Displacement -&gt; Position -&gt; Position&#13;
shiftPosition v (Cart x y z)&#13;
   = Cart (x + xComp v) (y + yComp v) (z + zComp v)</pre>&#13;
<p class="indent">We’ll use the <code>shiftPosition</code> function in the next chapter to define some geometric objects.</p>&#13;
<p class="indent">Having introduced coordinate systems, a type for position, and the distinction between position and displacement, we now turn to the last major idea of the chapter—that of a field.</p>&#13;
<h3 class="h3" id="ch22lev10">The Scalar Field</h3>&#13;
<p class="noindent">Some physical quantities, like volume charge density and electric potential, are best described by giving a number for each point in space. These physical quantities are called <em>scalar fields</em>. The word <em>field</em> in physics means a function of physical space or spacetime; in other words, something that can <span epub:type="pagebreak" id="page_432"/>take a different value at each point in space. (The word <em>field</em> in mathematics means something else.) A scalar field is a field in which the value assigned at each point in space is a scalar (that is, a number). Temperature is another example of a scalar field. The temperature in one place (Annville, Pennsylvania, for example) is usually different from the temperature at another place (Vero Beach, Florida, say).</p>&#13;
<p class="indent">Since a scalar field associates a number with each position in space, it makes sense to define a scalar field type to be a function from space to numbers.</p>&#13;
<pre>type ScalarField = Position -&gt; R</pre>&#13;
<p class="indent">When we’re using a coordinate system, we can define scalar fields for each of the coordinates. For example, we can have a scalar field that associates each position in space with the value of its x-coordinate.</p>&#13;
<pre>xSF :: ScalarField&#13;
xSF p = x&#13;
    where&#13;
      (x,_,_) = cartesianCoordinates p</pre>&#13;
<p class="indent">Here is the coordinate scalar field that is associated with the spherical coordinate <em>r</em>:</p>&#13;
<pre>rSF :: ScalarField&#13;
rSF p = r&#13;
    where&#13;
      (r,_,_) = sphericalCoordinates p</pre>&#13;
<p class="indent">In <a href="ch09.xhtml">Chapter 9</a>, we defined functions that extract components from a triple:</p>&#13;
<pre>fst3 :: (a,b,c) -&gt; a&#13;
fst3 (u,_,_) = u&#13;
&#13;
snd3 :: (a,b,c) -&gt; b&#13;
snd3 (_,u,_) = u&#13;
&#13;
thd3 :: (a,b,c) -&gt; c&#13;
thd3 (_,_,u) = u</pre>&#13;
<p class="indent">We can use these functions to express the y-coordinate scalar field as the scalar field associated with the second Cartesian coordinate.</p>&#13;
<pre>ySF :: ScalarField&#13;
ySF = snd3 . cartesianCoordinates</pre>&#13;
<p class="indent">We can define any of the coordinate scalar fields in this way.</p>&#13;
<p class="indent"><a href="ch22.xhtml#ch22fig4">Figure 22-4</a> shows a visualization of the scalar field <code>ySF</code> using a coordinate system in which <em>x</em> comes out of the page, <em>y</em> increases to the right, and <em>z</em> <span epub:type="pagebreak" id="page_433"/>increases upward. Associated with each position in space is its y-value, so the numbers increase to the right but do not change moving upward or out of the page. Later in the chapter, we will show how to make scalar field visualizations like that in <a href="ch22.xhtml#ch22fig4">Figure 22-4</a>.</p>&#13;
<div class="imagel" id="ch22fig4"><img src="Images/433fig01.jpg" alt="Image" width="570" height="570"/></div>&#13;
<p class="figcap"><em>Figure 22-4: A screenshot of the y-coordinate scalar field <span class="codeitalic1">ySF</span> produced with the program <span class="codeitalic1">ySF3D</span>. The mouse and keyboard can be used to zoom in or out and rotate the visualization, a standard feature of the <span class="codeitalic1">Vis</span> module.</em></p>&#13;
<p class="indent">Because charge density is a scalar field, the scalar field will play an important role in <a href="ch24.xhtml">Chapter 24</a> when we define charge distributions.</p>&#13;
<p class="indent">The second type of field used in physics, and possibly the more important, is the vector field, to which we turn next.</p>&#13;
<h3 class="h3" id="ch22lev11">The Vector Field</h3>&#13;
<p class="noindent">A <em>vector field</em> associates a vector with each point in space.</p>&#13;
<pre>type VectorField = Position -&gt; Vec</pre>&#13;
<p class="indent">In <a href="ch25.xhtml">Chapters 25</a> and <a href="ch27.xhtml">27</a>, we’ll discuss electric fields and magnetic fields, respectively, which are vector fields.</p>&#13;
<p class="indent">When we’re using a coordinate system, we can define vector fields that come from coordinates. The unit vectors used with cylindrical and spherical <span epub:type="pagebreak" id="page_434"/>coordinates, such as <img class="inline" src="Images/scap.jpg" alt="Image" width="8" height="16"/>, <img class="inline" src="Images/sdcap.jpg" alt="Image" width="14" height="25"/>, <img class="inline" src="Images/rcap.jpg" alt="Image" width="9" height="16"/>, and <img class="inline" src="Images/thcap.jpg" alt="Image" width="11" height="21"/>, are really <em>unit vector fields</em> because their directions change depending on their location in space.</p>&#13;
<p class="indent">The vector fields <img class="inline" src="Images/scap.jpg" alt="Image" width="8" height="16"/> and <img class="inline" src="Images/sdcap.jpg" alt="Image" width="14" height="25"/> are defined using Equations 22.4 and 22.5.</p>&#13;
<pre>sHat   :: VectorField&#13;
sHat   r = vec ( cos phi) (sin phi) 0&#13;
    where&#13;
      (_,phi,_) = cylindricalCoordinates r&#13;
&#13;
phiHat :: VectorField&#13;
phiHat r = vec (-sin phi) (cos phi) 0&#13;
    where&#13;
      (_,phi,_) = cylindricalCoordinates r</pre>&#13;
<p class="indent"><a href="ch22.xhtml#ch22fig5">Figure 22-5</a> shows visualizations of the vector field <code>phiHat</code>. Associated with each position in space is a vector, whose tail is located at the point in space, and whose magnitude and direction show the value of the vector at that point. The picture on the left shows the vector field in three dimensions, where <em>x</em> comes out of the page, <em>y</em> increases to the right, and <em>z</em> increases upward. The z-axis is the central axis of symmetry for the <code>phiHat</code> vector field. The picture on the right shows the vector field in the xy-plane. Since <code>phiHat</code> is a unit vector field, all of the vectors in these pictures have the same length. The pictures make clear how the unit vector field <img class="inline" src="Images/sdcap.jpg" alt="Image" width="14" height="25"/> points in different directions at different points in space. Later in the chapter I will show how to produce visualizations like this.</p>&#13;
<div class="imagel" id="ch22fig5"><img src="Images/434fig01.jpg" alt="Image" width="607" height="222"/></div>&#13;
<p class="figcap"><em>Figure 22-5: Two ways of visualizing the vector field <img class="inline" src="Images/sdcap.jpg" alt="Image" width="14" height="25"/>, or <span class="codeitalic1">phiHat</span>. The left shows a screenshot of the image produced by <span class="codeitalic1">phiHat3D</span>. The right shows an image in the xy-plane produced by <span class="codeitalic1">phiHatPNG</span>.</em></p>&#13;
<p class="indent">Here are definitions for the unit vector fields <img class="inline" src="Images/rcap.jpg" alt="Image" width="9" height="16"/> and <img class="inline" src="Images/thcap.jpg" alt="Image" width="11" height="21"/>, using Equations 22.10 and 22.11:</p>&#13;
<pre>rHat :: VectorField&#13;
rHat rv = let d = displacement origin rv&#13;
          in if d == zeroV&#13;
             then zeroV&#13;
             else d ^/ magnitude d&#13;
&#13;
<span epub:type="pagebreak" id="page_435"/>thetaHat :: VectorField&#13;
thetaHat r = vec ( cos theta * cos phi)&#13;
                 ( cos theta * sin phi)&#13;
                 (-sin theta         )&#13;
    where&#13;
      (_,theta,phi) = sphericalCoordinates r</pre>&#13;
<p class="indent">We regard <img class="inline" src="Images/icap.jpg" alt="Image" width="6" height="20"/>, <img class="inline" src="Images/jcap.jpg" alt="Image" width="9" height="26"/>, and <img class="inline" src="Images/kcap.jpg" alt="Image" width="11" height="20"/> as simple unit vectors (<code>Vec</code>s), but we define <img class="inline" src="Images/xcap.jpg" alt="Image" width="12" height="15"/>, <img class="inline" src="Images/ycap.jpg" alt="Image" width="11" height="21"/>, and <img class="inline" src="Images/zcap.jpg" alt="Image" width="9" height="16"/> as unit vector fields (<code>VectorField</code>s), analogous to <img class="inline" src="Images/scap.jpg" alt="Image" width="8" height="16"/>, <img class="inline" src="Images/sdcap.jpg" alt="Image" width="14" height="25"/>, <img class="inline" src="Images/rcap.jpg" alt="Image" width="9" height="16"/>, and <img class="inline" src="Images/thcap.jpg" alt="Image" width="11" height="21"/>.</p>&#13;
<pre>xHat :: VectorField&#13;
xHat = const iHat&#13;
&#13;
yHat :: VectorField&#13;
yHat = const jHat&#13;
&#13;
zHat :: VectorField&#13;
zHat = const kHat</pre>&#13;
<p class="indent">One important vector field that is not a unit vector field is the vector field <strong>r</strong>, which associates each position with the displacement vector from the origin to that position. We’ll give the name <code>rVF</code> to this vector field.</p>&#13;
<pre>rVF :: VectorField&#13;
rVF = displacement origin</pre>&#13;
<p class="indent">The function <code>displacement</code> takes a source <code>Position</code> and a target <code>Position</code> and returns the displacement vector from the source to the target. By omitting the target position in the definition, the function <code>rVF</code> takes a target position as input and produces a displacement vector as output, which is just the <code>VectorField</code> we want.</p>&#13;
<p class="indent"><a href="ch22.xhtml#ch22fig6">Figure 22-6</a> shows visualizations of the vector field <code>rVF</code>. Both pictures show the vector field in the xy-plane. The picture on the left places the tail of each vector at the position it is associated with, and it displays vectors with greater magnitude as arrows with longer length. The picture on the right places the center of each vector at the position it is associated with, and it displays vectors with greater magnitude as darker arrows.</p>&#13;
<div class="imagel" id="ch22fig6"><img src="Images/436fig01.jpg" alt="Image" width="630" height="312"/></div>&#13;
<p class="figcap"><em>Figure 22-6: Two ways of visualizing the vector field <strong>r</strong>, or <span class="codeitalic1">rVF</span>, in the xy-plane. The left image is produced by <span class="codeitalic1">rVFpng</span>; the right image is produced by <span class="codeitalic1">rVFGrad</span>.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_436"/>Later in the chapter, we’ll introduce functions that produce pictures, like those in <a href="ch22.xhtml#ch22fig6">Figure 22-6</a>, when given a vector field as input; however, producing pictures is only one of several things we can do with vector fields. Vector fields admit two kinds of derivatives, called <em>divergence</em> and <em>curl</em>, that express how the vectors of a vector field change in space. There are several integrals of vector fields over lines, surfaces, and volumes that are used to extract information and assert relationships among physical quantities. It is useful in physics to think of the vector field as a single mathematical entity. One of the advantages of a functional language for physics is the ease with which a vector field can be handled and written about as a single entity. This book aspires to make vector fields more accessible by presenting functions that allow you to play with vector fields.</p>&#13;
<p class="indent">Electric and magnetic fields are the most important vector fields in electromagnetic theory, although current density is also a vector field that appears in the famous Maxwell equations. We’ll discuss the electric field in <a href="ch25.xhtml">Chapter 25</a>, current density in <a href="ch26.xhtml">Chapter 26</a>, and the magnetic field in <a href="ch27.xhtml">Chapter 27</a>.</p>&#13;
<p class="indent">Scalar and vector fields can be added. The following are some functions to do that:</p>&#13;
<pre>addScalarFields :: [ScalarField] -&gt; ScalarField&#13;
addScalarFields flds r = sum  [fld r | fld &lt;- flds]&#13;
&#13;
addVectorFields :: [VectorField] -&gt; VectorField&#13;
addVectorFields flds r = sumV [fld r | fld &lt;- flds]</pre>&#13;
<p class="indent">We’ll use these functions in <a href="ch25.xhtml">Chapter 25</a> to add electric potential and electric field produced by multiple sources. For now, let’s turn to the question of how to visualize scalar and vector fields.</p>&#13;
<h3 class="h3" id="ch22lev12"><span epub:type="pagebreak" id="page_437"/>Functions for Visualizing Scalar Fields</h3>&#13;
<p class="noindent">A scalar field associates a number with each point in space. There are lots of ways to visualize a scalar field. We’ll develop two: one using Vis and one using text.</p>&#13;
<h4 class="h4" id="ch22lev13">3D Visualization</h4>&#13;
<p class="noindent">One simple way to visualize a scalar field is to ask Vis to display numbers for the values of the scalar field at a list of positions. The function <code>sf3D</code> takes a list of positions and a scalar field as input and returns the action of displaying a 3D picture on the screen.</p>&#13;
<pre>sf3D :: [Position]   -- positions to use&#13;
     -&gt; ScalarField  -- to display&#13;
     -&gt; IO ()&#13;
sf3D ps sf&#13;
    = V.display whiteBackground $ orient $&#13;
      V.VisObjects [V.Text3d (show (round $ sf p :: Int))&#13;
                    (v3FromPos p) V.Fixed9By15 V.black&#13;
                        | p &lt;- ps]</pre>&#13;
<p class="indent">We name the incoming list of positions <code>ps</code> and the incoming scalar field <code>sf</code>. We use a list comprehension to make a list of pictures, one for each position <code>p</code> in <code>ps</code>. Each picture is a piece of text showing the value of the scalar field at that position. The value <code>sf p</code> is the <code>R</code> expressing the value of the scalar field <code>sf</code> at position <code>p</code>. The value <code>round $ sf p :: Int</code> is the <code>Int</code> obtained by rounding the scalar field value. We round so that the numbers take up only a small amount of space and don’t overlap each other in the final picture. The value <code>show (round $ sf p :: Int)</code> is the <code>String</code> we give to <code>Vis</code>’s constructor <code>V.Text3d</code> to be shown on the screen. The value <code>v3FromPos p</code> is the <code>V3</code> (Vis’s native vector type) giving the position where the text should be displayed. The definition of <code>v3FromPos</code> is similar to that of <code>v3FromVec</code> from <a href="ch16.xhtml">Chapter 16</a>.</p>&#13;
<pre>v3FromPos :: Position -&gt; V3 R&#13;
v3FromPos p = V3 x y z&#13;
    where&#13;
      (x,y,z) = cartesianCoordinates p</pre>&#13;
<p class="indent">The <code>V.VisObjects</code> constructor sews the list of pictures together into a single picture, which we orient to use my favorite coordinate system with <code>orient</code> and display with the <code>V.display</code> function using a set of options called <code>whiteBackground</code>, which we’ll define next.</p>&#13;
<p class="indent">The option set <code>whiteBackground</code> differs from the option set <code>V.defaultOpts</code> only in that the background color has been set to white.</p>&#13;
<pre>whiteBackground :: V.Options&#13;
whiteBackground = V.defaultOpts {V.optBackgroundColor = Just V.white}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_438"/>This definition uses record syntax to specify that all fields of the <code>V.Options</code> data type should have the same values as those in <code>V.defaultOpts</code>, except for <code>V.optBackgroundColor</code>, which is set to white.</p>&#13;
<p class="indent">If you find you’d like to control the camera position from code, you can add options to do that. For example, the option set <code>whiteBackground'</code> sets the viewpoint to be a distance of 40 Vis units from the center.</p>&#13;
<pre>whiteBackground' :: V.Options&#13;
whiteBackground'&#13;
    = V.defaultOpts {V.optBackgroundColor = Just V.white,&#13;
                     V.optInitialCamera   = Just V.Camera0 {V.rho0   = 40.0,&#13;
                                                            V.theta0 = 45.0,&#13;
                                                            V.phi0   = 20.0}}</pre>&#13;
<p class="indent">Here is an example of how to use this scalar field visualization function for the <em>y</em> scalar field <code>ySF</code>:</p>&#13;
<pre>ySF3D :: IO ()&#13;
ySF3D = sf3D [cart x y z | x &lt;- [-6,-2..6]&#13;
                         , y &lt;- [-6,-2..6]&#13;
                         , z &lt;- [-6,-2..6]] ySF</pre>&#13;
<p class="indent"><a href="ch22.xhtml#ch22fig4">Figure 22-4</a> from earlier in this chapter shows the resulting picture. Perhaps the most useful feature of a 3D scalar field visualization like that in <a href="ch22.xhtml#ch22fig4">Figure 22-4</a> is that it helps us to develop a visual and geometric understanding of what a scalar field is by imagining a number at each point in space. Once we have this geometric idea under our belts, and we wish to look in detail at a specific scalar field, it’s often simpler and more convenient to use a 2D visualization, which we’ll describe next.</p>&#13;
<h4 class="h4" id="ch22lev14">2D Visualization</h4>&#13;
<p class="noindent">A 3D visualization of a scalar field can become unwieldy and hard to read, so it’s useful to have tools to view the scalar values on a 2D plane or surface. Our 2D visualization functions will allow the user to specify any plane or surface to focus on. We can do this by specifying how two numbers, representing horizontal and vertical position on the 2D visualization, map into three-dimensional space—in other words, by giving a function <code>(R,R) -&gt; Position</code>. The functions that follow refer locally to this function as <code>toPos</code>. The function <code>sfTable</code> allows the user to visualize a scalar field by specifying a surface on which to view the values of the scalar field.</p>&#13;
<pre>sfTable :: ((R,R) -&gt; Position)&#13;
        -&gt; [R]  -- horizontal&#13;
        -&gt; [R]  -- vertical&#13;
        -&gt; ScalarField&#13;
        -&gt; Table Int&#13;
sfTable toPos ss ts sf&#13;
    = Table RJ [[round $ sf $ toPos (s,t) | s &lt;- ss] | t &lt;- reverse ts]</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_439"/>The first input to <code>sfTable</code>, locally called <code>toPos</code>, specifies the surface of interest. If we wanted to specify the xz-plane, for example, we’d send the function <code>\(x,z) -&gt; cart x 0 z</code> in for <code>toPos</code>.</p>&#13;
<p class="indent">The second and third inputs to <code>sfTable</code>, locally called <code>ss</code> and <code>ts</code>, give the horizontal and vertical two-dimensional coordinates at which scalar values will be displayed. For a visualization of the xz-plane, the horizontal values could be x-values and vertical values could be z-values. The fourth input is the scalar field to be visualized.</p>&#13;
<p class="indent">The function works by sampling and displaying the values of the scalar field at the given points. We use the function <code>toPos</code> to produce a <code>Position</code> from an <code>(s,t)</code> pair of horizontal and vertical two-dimensional coordinates. We then apply the scalar field <code>sf</code> to this position, which is rounded so as not to take up too much space on the screen. The list of vertical coordinates is reversed so that the vertical values start at the bottom of the table and proceed to the top. We use the <code>Table</code> data type from <a href="ch20.xhtml">Chapter 20</a>.</p>&#13;
<p class="indent">Here is an example using <code>sfTable</code> to visualize the y-coordinate scalar field:</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:l CoordinateSystems</span>&#13;
[1 of 7] Compiling Newton2          ( Newton2.hs, interpreted )&#13;
[2 of 7] Compiling Mechanics1D      ( Mechanics1D.hs, interpreted )&#13;
[3 of 7] Compiling SimpleVec        ( SimpleVec.hs, interpreted )&#13;
[4 of 7] Compiling Mechanics3D      ( Mechanics3D.hs, interpreted )&#13;
[5 of 7] Compiling MultipleObjects  ( MultipleObjects.hs, interpreted )&#13;
[6 of 7] Compiling MOExamples       ( MOExamples.hs, interpreted )&#13;
[7 of 7] Compiling CoordinateSystems ( CoordinateSystems.hs, interpreted )&#13;
Ok, 7 modules loaded.&#13;
*CoordinateSystems&gt; <span class="codestrong1">sfTable (\(x,y) -&gt; cart x y 0) [-6,-2..6] [-6,-2..6] ySF</span>&#13;
  6  6  6  6&#13;
  2  2  2  2&#13;
 -2 -2 -2 -2&#13;
 -6 -6 -6 -6</pre>&#13;
<p class="indent">We can use a 2D scalar field visualization to show the temperature in a room or the electric potential in a capacitor, for example.</p>&#13;
<h3 class="h3" id="ch22lev15">Functions for Visualizing Vector Fields</h3>&#13;
<p class="noindent">A vector field associates a vector with each position in space. In this section, we’ll write three functions for visualizing a vector field: <code>vf3D</code>, <code>vfPNG</code>, and <code>vfGrad</code>.</p>&#13;
<p class="indent">These functions essentially have type <code>VectorField -&gt; IO ()</code>, meaning they take a vector field as input and do something, either displaying a picture on the screen or producing a graphics file on the hard drive.</p>&#13;
<h4 class="h4" id="ch22lev16">3D Visualization</h4>&#13;
<p class="noindent">The <code>Vis</code> module can produce a 3D visualization of a vector field. The basic idea is to choose a list of positions at which vectors will be displayed. <span epub:type="pagebreak" id="page_440"/>We use the vector field to compute the vector at each listed position and then display that vector with its tail at that position. The vector field will often have units that are different from the units of position (meters), so we need a scale factor to specify the number of vector field units that should be displayed per meter of space. Here is the code for the function <code>vf3D</code> that does this.</p>&#13;
<pre>vf3D :: R            -- scale factor, vector field units per meter&#13;
     -&gt; [Position]   -- positions to show the field&#13;
     -&gt; VectorField  -- vector field to display&#13;
     -&gt; IO ()&#13;
vf3D unitsPerMeter ps vf&#13;
    = V.display whiteBackground $ orient $&#13;
      V.VisObjects [V.Trans (v3FromPos p) $&#13;
                    visVec V.black (vf p ^/ unitsPerMeter)&#13;
                        | p &lt;- ps]</pre>&#13;
<p class="indent">The function <code>vf3D</code> takes a scale factor, a list of positions, and a vector field as input, and it produces a picture on the screen that can be enlarged and rotated with the mouse. As in <code>sf3D</code>, this function uses a list comprehension to make a list of pictures, one for each position <code>p</code> in <code>ps</code>. Each picture is a black arrow, produced by the <code>visVec</code> function defined below, representing the vector at position <code>p</code>, appropriately scaled and translated to the correct location. The <code>V.VisObjects</code> constructor sews the list of pictures together into a single picture, which is oriented to use my favorite coordinate system with <code>orient</code> and displayed with the <code>V.display</code> function using the option set <code>whiteBackground</code>, defined earlier in the chapter.</p>&#13;
<p class="indent">The <code>visVec</code> function takes a color and a vector as input and produces a picture of an arrow as output. Here is the code:</p>&#13;
<pre>visVec :: V.Color -&gt; Vec -&gt; V.VisObject R&#13;
visVec color v = let vmag = magnitude v&#13;
                 in V.Arrow (vmag,20*vmag) (v3FromVec v) color</pre>&#13;
<p class="indent">This function uses <code>Vis</code>’s <code>V.Arrow</code> constructor to make a picture of a vector. The first argument to <code>V.Arrow</code> is a pair of numbers. The first number is the requested length of the arrow, for which we choose <code>vmag</code>, the magnitude of the input vector. The second number is an aspect ratio for the desired ratio of arrow length to arrow shaft diameter. I chose <code>20*vmag</code> because I want the arrows to have a uniform shaft diameter. The shaft diameter is the arrow length <code>vmag</code> divided by the aspect ratio <code>20*vmag</code>, which is 1/20, independent of the arrow length.</p>&#13;
<p class="indent">The second argument to <code>V.Arrow</code> is a vector in <code>Vis</code>’s native <code>V3</code> type, which specifies the direction of the arrow. We send <code>v3FromVec v</code>, our input vector converted to type <code>V3</code>. The third and final argument to <code>V.Arrow</code> is a color, and we simply pass on the input color <code>visVec</code> is given.</p>&#13;
<p class="indent">The following program uses the <code>vf3D</code> function to produce a visualization of the <img class="inline" src="Images/sdcap.jpg" alt="Image" width="14" height="25"/> unit vector field, defined as <code>phiHat</code> earlier in the chapter:</p>&#13;
<pre>phiHat3D :: IO ()&#13;
phiHat3D = vf3D 1 [cyl r ph z | r  &lt;- [1,2,3]&#13;
                              , ph &lt;- [0,pi/4..2*pi]&#13;
                              , z  &lt;- [-2..2]] phiHat</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_441"/>The left side of <a href="ch22.xhtml#ch22fig5">Figure 22-5</a> from earlier in the chapter shows a screenshot of the image <code>phiHat3D</code> produces. The image on the screen is interactive and can be rotated and zoomed with the mouse.</p>&#13;
<p class="indent">Sometimes a 3D visualization of a vector field can appear cluttered, so we want tools to show a slice of a vector field in two dimensions. The right side of <a href="ch22.xhtml#ch22fig5">Figure 22-5</a> shows such a 2D visualization, and we’ll turn next to how to make this kind of picture.</p>&#13;
<h4 class="h4" id="ch22lev17">2D Visualization</h4>&#13;
<p class="noindent">How can we hope to visualize a 3D vector field in two dimensions? In general, we can’t. Even if we limit our attention to a plane in three-dimensional space, say the xy-plane, the vectors could have a z-component so that they can’t be represented in the xy-plane. Nevertheless, there are enough examples of vector fields that have planes in which the vectors point <em>in the plane</em> that 2D visualization is a worthwhile endeavor.</p>&#13;
<p class="indent">As with 2D scalar field visualization, the function we write will take an argument, locally called <code>toPos</code>, with type <code>(R,R) -&gt; Position</code>, that maps the two-dimensional coordinates we supply to 3D <code>Position</code>s. After we gather a collection of vectors at positions in the plane, we need a second function to specify how these 3D vectors are to be regarded as 2D vectors in the plane. We can do this with a function <code>Vec -&gt; (R,R)</code> that we will name with the local variable <code>fromVec</code>.</p>&#13;
<p class="indent">We could use gloss for our 2D vector field visualization, but because we may want a platform for the asynchronous animation we first explored in <a href="ch20.xhtml">Chapter 20</a>, we’ll instead pursue a graphics library called diagrams that produces PNG files that could be sewn together into an asynchronous animation. The function <code>vfPNG</code> we are about to write takes a <code>VectorField</code> as input, along with some other parameters, and produces a PNG file.</p>&#13;
<pre>vfPNG :: ((R,R) -&gt; Position)&#13;
      -&gt; (Vec -&gt; (R,R))&#13;
      -&gt; FilePath    -- file name&#13;
      -&gt; R           -- scale factor in units per meter&#13;
      -&gt; [(R,R)]     -- positions to use&#13;
      -&gt; VectorField&#13;
      -&gt; IO ()&#13;
vfPNG toPos fromVec fileName unitsPerMeter pts vf&#13;
    = let vf2d = r2 . fromVec . (^/ unitsPerMeter) . vf . toPos&#13;
          pic  = mconcat [arrowAt (p2 pt) (vf2d pt) | pt &lt;- pts]&#13;
      in renderCairo fileName (dims (V2 1024 1024)) pic</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_442"/>The function takes five items as input before the vector field we want to display. The first two items are the functions, locally named <code>toPos</code> and <code>fromVec</code>, that manage the connection between 2D and 3D vector fields. The third item is a filename for the PNG file. The fourth is a scale factor, in (vector field) units per meter, to control the length of displayed vectors. The fifth item is a list of 2D points at which we want vectors displayed. Finally, the sixth item is the vector field itself.</p>&#13;
<p class="indent">The local function <code>vf2d</code> is a composition of five functions. It takes a 2D point as input and produces a 2D vector as output, with a type that diagrams likes for the positioning of arrows. Starting with a 2D position <code>(R,R)</code>, the function <code>vf2d</code> begins by applying <code>toPos</code>, the function the user of <code>vfPNG</code> provided to transform a 2D position into a <code>Position</code>. The vector field <code>vf</code> is then applied to produce a <code>Vec</code>. This vector is scaled by the scale factor <code>unitsPerMeter</code>, after which the function <code>fromVec</code> transforms the <code>Vec</code> into a pair of real numbers representing a 2D vector. Finally, diagrams’s function <code>r2</code> transforms a pair of real numbers <code>(R,R)</code> into diagrams’s 2D vector type.</p>&#13;
<p class="indent">The local variable <code>pic</code> is for the picture to be displayed, which is made by combining a list of arrow pictures formed with a list comprehension. Each arrow picture is made with diagrams’s <code>arrowAt</code> function, which places the tail of the 2D vector in its second argument at the 2D position in its first argument. The diagrams package makes a distinction between a 2D position, formed from a pair of numbers with its <code>p2</code> function, and a 2D vector, formed from a pair of numbers with its <code>r2</code> function.</p>&#13;
<p class="indent">The last line in <code>vfPNG</code> produces the PNG file with diagrams’s <code>renderCairo</code> function, which takes a filename, a pixel size, and a picture as input.</p>&#13;
<p class="indent">If the xy-plane happens to be our plane of interest, we can write a helping function by supplying <code>vfPNG</code> with its first two arguments. The function <code>vfPNGxy</code> has these first two arguments supplied:</p>&#13;
<pre>vfPNGxy :: FilePath    -- file name&#13;
        -&gt; R           -- scale factor&#13;
        -&gt; [(R,R)]     -- positions to use&#13;
        -&gt; VectorField&#13;
        -&gt; IO ()&#13;
vfPNGxy = vfPNG (\(x,y) -&gt; cart x y 0) (\v -&gt; (xComp v, yComp v))</pre>&#13;
<p class="indent">The function that <code>vfPNG</code> locally calls <code>toPos</code> is specified here as the function that maps the pair <code>(x,y)</code> into the xy-plane. The function that <code>vfPNG</code> locally calls <code>fromVec</code> projects the 3D vector into the xy-plane.</p>&#13;
<p class="indent">The following program produces a PNG file for the vector field <img class="inline" src="Images/sdcap.jpg" alt="Image" width="14" height="25"/>, or <code>phiHat</code>, the unit vector field in cylindrical and spherical coordinates corresponding to the coordinate <em>ϕ</em>:</p>&#13;
<pre>phiHatPNG :: IO ()&#13;
phiHatPNG&#13;
    = vfPNGxy "phiHatPNG.png" 1&#13;
      [(r * cos ph, r * sin ph) | r  &lt;- [1,2]&#13;
                                , ph &lt;- [0,pi/4..2*pi]] phiHat</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_443"/>The right side of <a href="ch22.xhtml#ch22fig5">Figure 22-5</a> earlier in the chapter shows the vector field <img class="inline" src="Images/sdcap.jpg" alt="Image" width="14" height="25"/> produced by <code>phiHatPNG</code>.</p>&#13;
<p class="indent">Here is code to produce a PNG picture of the vector field <code>rVF</code> introduced earlier in the chapter:</p>&#13;
<pre>rVFpng :: IO ()&#13;
rVFpng&#13;
    = vfPNGxy "rVFpng.png" 2&#13;
      [(r * cos ph, r * sin ph) | r  &lt;- [1,2]&#13;
                                , ph &lt;- [0,pi/4..2*pi]] rVF</pre>&#13;
<p class="indent">The left side of <a href="ch22.xhtml#ch22fig6">Figure 22-6</a> earlier in the chapter shows the resulting picture.</p>&#13;
<p class="indent">Physicists use the notation <strong>r</strong> in at least three ways. It can stand for a single position vector, which we would call a <code>Vec</code>. It can stand for a position function, like what we worked with in <a href="part02.xhtml">Part II</a>, returning a position when given a time. In <a href="part02.xhtml">Part II</a>, this position function would have type <code>R -&gt; Vec</code> because position was regarded as a vector back then. Now that we have a data type for position, such a function has type <code>R -&gt; Position</code>. A third use of the symbol <strong>r</strong> is for the vector field we just introduced. This has type <code>VectorField</code>, which is a type synonym for <code>Position -&gt; Vec</code>. The type system helps clarify that these three uses of the symbol <strong>r</strong> are distinct.</p>&#13;
<p class="indent">Before we leave the topic of vector field visualization, we need to look at one more visualization method.</p>&#13;
<h4 class="h4" id="ch22lev18">Gradient Visualization</h4>&#13;
<p class="noindent">When we visualize electric and magnetic fields, which we will do a few chapters from now, the magnitudes of the vectors can change enormously over short distances. Thus, displaying the magnitude of the vector as the length of an arrow can produce a burdensome picture. An alternative is to use shading to indicate magnitude, with short fat arrows to indicate direction. I call this style of vector field visualization <em>gradient visualization</em>.</p>&#13;
<p class="indent">The function <code>vfGrad</code> we define below takes a vector field, along with some other parameters, and produces a PNG file.</p>&#13;
<pre>vfGrad :: (R -&gt; R)&#13;
       -&gt; ((R,R) -&gt; Position)&#13;
       -&gt; (Vec -&gt; (R,R))&#13;
       -&gt; FilePath&#13;
       -&gt; Int    -- n for n x n&#13;
       -&gt; VectorField&#13;
       -&gt; IO ()&#13;
vfGrad curve toPos fromVec fileName n vf&#13;
 <span class="ent">➊</span> = let step = 2 / fromIntegral n&#13;
       <span class="ent">➋</span> xs = [-1+step/2, -1+3*step/2 .. 1-step/2]&#13;
       <span class="ent">➌</span> pts = [(x, y) | x &lt;- xs, y &lt;- xs]&#13;
       <span class="ent">➍</span> array = [(pt,magRad $ fromVec $ vf $ toPos pt) | pt &lt;- pts]&#13;
       <span class="ent">➎</span> maxMag = maximum (map (fst . snd) array)&#13;
       <span class="ent">➏</span> scaledArrow m th = scale step $ arrowMagRad (curve (m/maxMag)) th&#13;
       <span class="ent">➐</span> pic = position [(p2 pt, scaledArrow m th) | (pt,(m,th)) &lt;- array]&#13;
    <span class="ent">➑</span> in renderCairo fileName (dims (V2 1024 1024)) pic</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_444"/>The first argument to <code>vfGrad</code> is a monotonic function <code>curve</code> that maps the unit interval [0,<a href="bib.xhtml#bib1">1</a>] onto itself. The purpose of this argument is to make some accommodation for the possibility that a vector field may have very large magnitudes at some positions and rather small magnitudes elsewhere. The largest magnitude vectors will be colored black and those closest to zero will be colored white. Sometimes a linear scaling results in a picture in which there are black vectors close to a source and white vectors everywhere else. In those cases, a power law such as cube root or fifth root can boost the smaller magnitudes so that a continuous transition from black to white becomes evident. We can achieve a linear scaling with the identity function <code>id</code> and a fifth root scaling with the section <code>(**0.2)</code>.</p>&#13;
<p class="indent">The next arguments, with local names <code>toPos</code> and <code>fromVec</code>, are the same as in the function <code>vfPNG</code>. However, <code>toPos</code> plays a double role in this function because <code>vfGrad</code> does not ask for a list of positions at which to show vectors. Instead, <code>vfGrad</code> displays the square from (–1, –1) to (1, 1). This square must be mapped to some square in three-dimensional space, the vectors at which will be displayed. If we wanted to see the square in the xy-plane with corners at Cartesian coordinates (–10, –10, 0) and (10, 10, 0), we would send the function <code>\(x,y) -&gt; cart (10*x) (10*y) 0</code> in for <code>toPos</code>.</p>&#13;
<p class="indent">The argument <code>fileName</code> is a filename for the PNG file. The argument <code>n</code> is an integer specifying the number of arrows to use in each direction. Sending in 20, for example, will produce an image of 20 arrows by 20 arrows. The last input <code>vf</code> is the vector field itself.</p>&#13;
<p class="indent">The function <code>vfGrad</code> consists of several local definitions that build a picture <code>pic</code> <span class="ent">➐</span>, followed by the same <code>renderCairo</code> line <span class="ent">➑</span> used in <code>vfPNG</code> to make the PNG file. The first three lines <span class="ent">➊</span> <span class="ent">➋</span> <span class="ent">➌</span> in the <code>let</code> clause serve to choose the points <code>pts</code> at which the vector field will be sampled and displayed. The next line <span class="ent">➍</span> defines <code>array</code> (type <code>[((R,R),(R,R))]</code>) as a list of pairs of points and 2D vectors. We calculate the 2D vector at <code>pt</code> by applying <code>toPos</code> to convert <code>pt</code> to a 3D <code>Position</code>, applying the vector field <code>vf</code>, then using <code>fromVec</code> to convert the 3D vector to a 2D vector, and finally applying <code>magRad</code>, defined next, to express the 2D vector in magnitude-angle form.</p>&#13;
<p class="indent">The local variable <code>maxMag</code> <span class="ent">➎</span> searches the list <code>array</code> to find the maximum magnitude of all of the vectors in the list. Vectors with this magnitude will be colored black. The local function <code>scaledArrow</code> <span class="ent">➏</span> describes how to make a picture of a single arrow from a magnitude <code>m</code> and angle <code>th</code>. It normalizes the magnitude <code>m</code> by dividing it by the maximum magnitude <code>maxMag</code>, resulting in a normalized magnitude between 0 and 1. This normalized magnitude is then scaled, or curved, by the function <code>curve</code>, a monotonic function mapping the unit interval [0,<a href="bib.xhtml#bib1">1</a>] to itself. The normalized and scaled magnitude then passes with the angle to the <code>arrowMagRad</code> function, defined next, to get a picture of the arrow. Finally, the code scales the size of the arrow based on <span epub:type="pagebreak" id="page_445"/>the number of arrows requested. We form the final picture <code>pic</code> <span class="ent">➐</span> with a list comprehension by placing each of the arrows at the appropriate position.</p>&#13;
<p class="indent">The function <code>magRad</code> converts a pair of Cartesian coordinates to polar coordinates, with the angle in radians.</p>&#13;
<pre>magRad :: (R,R) -&gt; (R,R)&#13;
magRad (x,y) = (sqrt (x*x + y*y), atan2 y x)</pre>&#13;
<p class="indent">The function <code>arrowMagRad</code> produces a picture of an arrow based on a normalized magnitude in the range 0 to 1 and an angle in radians.</p>&#13;
<pre>-- magnitude from 0 to 1&#13;
arrowMagRad :: R  -- magnitude&#13;
            -&gt; R  -- angle in radians, counterclockwise from x axis&#13;
            -&gt; Diagram B&#13;
arrowMagRad mag th&#13;
    = let r      = sinA (15 @@ deg) / sinA (60 @@ deg)&#13;
          myType = PolyPolar [120 @@ deg, 0 @@ deg, 45 @@ deg, 30 @@ deg,&#13;
                              45 @@ deg, 0 @@ deg, 120 @@ deg]&#13;
                   [1,1,r,1,1,r,1,1]&#13;
          myOpts = PolygonOpts myType NoOrient (p2 (0,0))&#13;
      in scale 0.5 $ polygon myOpts # lw none # fc (blend mag black white) #&#13;
         rotate (th @@ rad)</pre>&#13;
<p class="indent">The function defines the shape of the arrow as a polygon and chooses the color based on the normalized magnitude. A normalized magnitude of 1 results in a black arrow, 0 results in white, and numbers in between result in some shade of gray.</p>&#13;
<p class="indent">Here is an example of gradient visualization for the vector field <strong>r</strong>, or <code>rVF</code>:</p>&#13;
<pre>rVFGrad :: IO ()&#13;
rVFGrad = vfGrad id&#13;
          (\(x,y) -&gt; cart x y 0)&#13;
          (\v -&gt; (xComp v,yComp v))&#13;
          "rVFGrad.png" 20&#13;
          rVF</pre>&#13;
<p class="indent">The right side of <a href="ch22.xhtml#ch22fig6">Figure 22-6</a> earlier in the chapter shows the vector field <strong>r</strong>, or <code>rVF</code> produced by <code>rVFGrad</code>.</p>&#13;
<h3 class="h3" id="ch22lev19">Summary</h3>&#13;
<p class="noindent">This chapter introduced the idea of a field, which is a function from a position in three-dimensional space. Scalar fields and vector fields are the two most important types of field for electromagnetic theory. We introduced several ways of visualizing scalar and vector fields as well as coordinate systems for three-dimensional space, in particular for cylindrical and spherical coordinates. We then wrote a new data type for position.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_446"/>Since electromagnetic theory is geometric, the next chapter introduces data types for geometric objects like curves, surfaces, and volumes.</p>&#13;
<h3 class="h3" id="ch22lev20">Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 22.1.</strong> Show that the polar coordinate unit vectors form an orthonormal system. Orthonormal means both orthogonal (different vectors are perpendicular to each other) and normalized (each vector has length one). In other words, show that</p>&#13;
<div class="imagec"><img src="Images/446equ01.jpg" alt="Image" width="76" height="91"/></div>&#13;
<p class="noindentts"><strong>Exercise 22.2.</strong> Write <img class="inline" src="Images/xcap.jpg" alt="Image" width="12" height="15"/> and <img class="inline" src="Images/ycap.jpg" alt="Image" width="11" height="21"/> in terms of <img class="inline" src="Images/scap.jpg" alt="Image" width="8" height="16"/> and <img class="inline" src="Images/sdcap.jpg" alt="Image" width="14" height="25"/>. Your results should contain <em>s</em>, <em>ϕ</em>, <img class="inline" src="Images/scap.jpg" alt="Image" width="8" height="16"/>, and <img class="inline" src="Images/sdcap.jpg" alt="Image" width="14" height="25"/> but not <em>x</em> or <em>y</em>.</p>&#13;
<p class="noindentts"><strong>Exercise 22.3.</strong> Show that the spherical coordinate unit vectors form an orthonormal system. In other words, show that</p>&#13;
<div class="imagec"><img src="Images/446equ02.jpg" alt="Image" width="76" height="197"/></div>&#13;
<p class="noindentts"><strong>Exercise 22.4.</strong> Write <img class="inline" src="Images/xcap.jpg" alt="Image" width="12" height="15"/>, <img class="inline" src="Images/ycap.jpg" alt="Image" width="11" height="21"/>, and <img class="inline" src="Images/zcap.jpg" alt="Image" width="9" height="16"/> in terms of <img class="inline" src="Images/rcap.jpg" alt="Image" width="9" height="16"/>, <img class="inline" src="Images/thcap.jpg" alt="Image" width="11" height="21"/>, and <img class="inline" src="Images/sdcap.jpg" alt="Image" width="14" height="25"/>. Your results can contain <em>r</em>, <em>θ</em>, <em>ϕ</em>, <img class="inline" src="Images/rcap.jpg" alt="Image" width="9" height="16"/>, <img class="inline" src="Images/thcap.jpg" alt="Image" width="11" height="21"/>, and <img class="inline" src="Images/sdcap.jpg" alt="Image" width="14" height="25"/> but not <em>x</em>, <em>y</em>, or <em>z</em>.</p>&#13;
<p class="noindentts"><strong>Exercise 22.5.</strong> Define a coordinate scalar field</p>&#13;
<pre>thetaSF :: ScalarField&#13;
thetaSF = undefined</pre>&#13;
<p class="noindentts">for the <em>θ</em> coordinate in spherical coordinates.</p>&#13;
<p class="noindentts"><strong>Exercise 22.6.</strong> Use 3D visualization to make an image of the vector field <img class="inline" src="Images/thcap.jpg" alt="Image" width="11" height="21"/>, or <code>thetaHat</code>.</p>&#13;
<pre>thetaHat3D :: IO ()&#13;
thetaHat3D = undefined</pre>&#13;
<p class="noindentts"><strong>Exercise 22.7.</strong> Use the <code>vf3D</code> function to visualize the vector field <strong>r</strong>, or <code>rVF</code>. You may need to use a scale factor greater than 1 so the arrows don’t overlap each other. A larger scale factor shrinks the arrows because the scale factor is in units per meter.</p>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_447"/><strong>Exercise 22.8.</strong> Use gradient vector field visualization to make an image of the vector field <img class="inline" src="Images/thcap.jpg" alt="Image" width="11" height="21"/>, or <code>thetaHat</code>, in the xz-plane. In the first <code>undefined</code> below, you must say how to map a pair of coordinates to a <code>Position</code>, knowing that you are interested in the xz-plane. In the second <code>undefined</code>, you must say how to map a <code>Vec</code> to a pair of numbers describing the two components of the vector to be displayed.</p>&#13;
<pre>thetaHatGrad :: IO ()&#13;
thetaHatGrad = vfGrad id undefined undefined "thetaHatGrad.png" 20 thetaHat</pre>&#13;
<p class="noindentts"><strong>Exercise 22.9.</strong> Use gradient vector field visualization to make an image of the vector field <img class="inline" src="Images/sdcap.jpg" alt="Image" width="14" height="25"/>, or <code>phiHat</code>, in the xy-plane.</p>&#13;
<pre>phiHatGrad :: IO ()&#13;
phiHatGrad = undefined<span epub:type="pagebreak" id="page_448"/></pre>&#13;
</div></body></html>