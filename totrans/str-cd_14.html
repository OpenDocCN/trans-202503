<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_297"/><span class="big">11</span><br/>BEFUNGE</h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">Like Piet, Befunge is a 2D programming language. Befunge is fun, is not particularly difficult to work with, and produces some of the most aesthetically pleasing source code I’ve ever seen. I think you’ll agree by the end of this chapter.</p>&#13;
<p class="indent">Our goal is to learn and experiment with Befunge. After BF, it’s perhaps the most influential esolang, and is usually included in lists with titles like “Ten of the weirdest programming languages you’ve never heard of.” We’ll learn why Befunge exists and why it’s called Befunge. We’ll then follow our usual pattern of exploring the gist of the language with examples. We’ll conclude with a discussion. I hope this marks only the beginning of your Befunge experiments.</p>&#13;
<h3 class="h3" id="lev1sec78"><strong>Befunge-93 World Tour</strong></h3>&#13;
<p class="noindent">In 1993, the movie <em>Jurassic Park</em> brought dinosaurs to the big screen, Mulder and Scully were chasing aliens on TV, and Bill Clinton was beginning his first term as president. In 1993, a typical home computer cost about $1,800 in 2022 dollars, had around 4MB of RAM, a 16 MHz clock speed, a 20MB <span epub:type="pagebreak" id="page_298"/>hard drive, and a “high-density” 1.44MB floppy drive. And, most notably for us, in 1993, Chris Pressey gifted Befunge to the world.</p>&#13;
<p class="indent">Depending on how you view things, Befunge was the world’s first 2D programming language. One might argue that Konrad Zuse’s <em>Plankalkül</em> was the first because its source code included stacked commands, but I think Befunge’s approach is sufficiently different to claim the honor. Pressey’s intention for Befunge was to create a language that was as difficult to compile as possible. The “Befunge” name is a misspelling of “before” as typed on a BBS in the wee hours of the morning. If the term BBS is unfamiliar, it stands for “bulletin board system,” which was how early personal computer enthusiasts communicated with each other over slow modems before the internet became accessible to the general public.</p>&#13;
<p class="indent">Let’s dive into the world of Befunge to learn how it works and how to write code for it. We’ll begin by installing and building the canonical interpreter for Befunge-93, after which we’ll take it for a ride with some simple examples. Along the way, we’ll learn how to use BEdit, a Befunge-93 editor. You don’t need to use BEdit to write Befunge code—any text editor will do—but I found BEdit handy. Then again, I wrote it, so I’m biased.</p>&#13;
<h4 class="h4" id="lev2sec96"><strong><em>Building Befunge-93</em></strong></h4>&#13;
<p class="noindent">Run the following command to obtain Befunge-93 from creator Chris Pressey’s GitHub site.</p>&#13;
<pre>&gt; <span class="codestrong1">git clone https://github.com/catseye/Befunge-93.git</span></pre>&#13;
<p class="noindent">This will get you the latest version, most likely the Silver Jubilee version from 2018. That’s the version we’ll work with.</p>&#13;
<p class="indent">Building the Befunge interpreter is straightforward. However, before you build it, if you wish, I suggest making a small code change to initialize the pseudorandom number seed using <code>/dev/urandom</code> instead of using <code>time</code>, which is how it’s written. That way, if you run the interpreter many times within a second, which we’ll do later in the chapter, the pseudorandom generator will not produce the same sequence repeatedly.</p>&#13;
<p class="indent">I suggest the following steps to build <code>bef</code>, the Befunge interpreter:</p>&#13;
<pre>&gt; <span class="codestrong1">cd Befunge-93</span>&#13;
&gt; <span class="codestrong1">vi src/bef.c</span></pre>&#13;
<p class="noindent">The second command starts a text editor with <em>bef.c</em> open. If you don’t use <code>vi</code> or <code>vim</code>, make the appropriate substitution for your typical editor (then learn <code>vim</code>). Look for <code>srand</code>, which should be around line 252. Then replace</p>&#13;
<pre>srand((unsigned)time(0));</pre>&#13;
<p class="noindent">with</p>&#13;
<pre><span epub:type="pagebreak" id="page_299"/>unsigned int seed;&#13;
f = fopen("/dev/urandom","rb");&#13;
fread(&amp;seed,4,1,f);&#13;
fclose(f);&#13;
srand(seed);</pre>&#13;
<p class="noindent">Lastly, use <code>make</code> to build the interpreter.</p>&#13;
<pre>&gt; <span class="codestrong1">make</span></pre>&#13;
<p class="indent">We want the <em>bef</em> executable in the <em>bin</em> directory. I encountered no issues using <code>gcc</code> and suspect you won’t, either. Change to the <em>bin</em> directory and test the build by typing</p>&#13;
<pre>&gt; <span class="codestrong1">./bef</span>&#13;
USAGE: bef [-d] [-o] [-u] [-q] [-i] [-=] [-l] [-t]&#13;
           [-r input] [-w output] [-s stack] [-y delay] foo.bf</pre>&#13;
<p class="indent">Befunge is simple to use. We’ll explore its visual debugger, <code>-d</code>, later. You’ll probably want to use <code>-q</code> to suppress the startup message. I defined an alias:</p>&#13;
<pre>&gt; <span class="codestrong1">alias bef="bef -q"</span></pre>&#13;
<p class="noindent">Befunge is ready. Let’s see how to use it.</p>&#13;
<h4 class="h4" id="lev2sec97"><strong><em>Printing Text</em></strong></h4>&#13;
<p class="noindent">Befunge programs live on a playfield that is 80 characters across and 25 lines tall. All Befunge commands are a single character. For data, Befunge uses a stack, like Forth. Befunge even supports a few Forth primitives to manipulate the stack: <code>DUP</code>, <code>DROP</code>, and <code>SWAP</code>. Of all the esolangs we’ve explored, Befunge has the richest command set.</p>&#13;
<p class="indent">The best way to get into Befunge is to see it in action. Let’s start with <em>cow.bf</em> . First, we’ll run it:</p>&#13;
<pre>&gt; <span class="codestrong1">bef examples/cow.bf</span>&#13;
How now brown cow?</pre>&#13;
<p class="noindent">I agree, nothing too impressive. Let’s look at the code.</p>&#13;
<pre>&lt;v"How now brown cow?"0&#13;
 &gt;:v&#13;
 ^,_91+,@</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_300"/>Okay, now things are a little more interesting. What are we to make of this jumble of characters? Befunge programs, like Piet programs, run in all directions, beginning in the upper-left corner (row 0, column 0), with the instruction pointer to the right, meaning instructions are evaluated from left to right running along the row.</p>&#13;
<p class="indent">The first row of <em>cow.bf</em> is <code>&lt;v"How now brown cow?"0</code>. The first instruction is <code>&lt;</code>, which tells Befunge to change the instruction pointer to move to the left. The playfield wraps at the edges and ignores spaces. Therefore, the first instruction of <em>cow.bf</em> moves flow to the left, which wraps around, ignores spaces, and encounters <code>0</code> moving right to left. Befunge pushes digits onto the stack, so <code>0</code> pushes a 0 on the stack. The next instruction is the double quote (<code>"</code>), which begins string mode. The interpreter then pushes ASCII values of the characters onto the stack until it encounters the next double quote. Therefore, the string <code>How now brown cow?</code> is pushed on the stack in ASCII, one character at a time. However, program flow in Befunge moves right to left, so the string is pushed on the stack <em>backward</em>, starting with the question mark first and ending with <code>H</code>. But this is exactly what we want because stacks are LIFO data structures. We now have our first Befunge idiom: push strings on the stack from right to left so the string can be read in code from left to right.</p>&#13;
<p class="indent">The character after the leftmost double quote is <code>v</code>, which changes program flow to down. The very next instruction is <code>&gt;</code>, which changes the flow to the right again. Then comes <code>:</code>, which duplicates the top stack value, the ASCII code for <code>H</code>.</p>&#13;
<p class="indent">Program flow is again directed down by <code>v</code> to hit underscore (_), the first of Befunge’s two conditional commands. The _ command pops the top stack item and, if it is 0, changes program flow to the right; otherwise, it goes left. If the top stack item is 0, we want to end, as the string has been printed. Recall that the first instruction after <code>&lt;</code> in the upper left pushed 0 on the stack.</p>&#13;
<p class="indent">If the top stack item isn’t 0, the string hasn’t been entirely printed yet. Therefore, moving to the left from _ uses a comma (<code>,</code>) to print the character and change the program flow to up. Going up hits <code>&gt;</code> on the second line to start the loop again.</p>&#13;
<p class="indent">The _ command encounters the 0 initially pushed on the stack at the beginning of the program. This will direct flow to the right to execute <code>91+,@</code>. The first three commands push the digits 9 and 1 onto the stack and add the digits so the stack contains 10. Even though only single digits can be pushed onto the stack in code, the stack itself supports a signed 64-bit integer. With 10 on the stack, we hit <code>,</code> to print the top stack item as an ASCII character—in this case, a newline. To end a Befunge program, execute <code>@</code>.</p>&#13;
<p class="indent">We now understand how <em>cow.bf</em> works. With all this flowing left, right, up, and down, it would be nice to <em>see cow.bf</em> working. Thankfully, Befunge is cleverly made, and by using the <code>-d</code> command line option, we can, literally, watch program flow happen. This works best when any output is directed <span epub:type="pagebreak" id="page_301"/>to a file. Similarly, if there is input from the user, it’s best read from a file. Naturally, a static book cannot show you the flow of the program, but the following command will:</p>&#13;
<pre>&gt; <span class="codestrong1">bef -d -w ttt examples/cow.bf</span></pre>&#13;
<p class="noindent">Once you press ENTER you’ll see the source code at the top of the screen with a cursor flowing over each instruction as it is executed. You can watch the loop repeat to print each character on the stack before ending. The output is then written to the temporary file, <em>ttt</em>.</p>&#13;
<h4 class="h4" id="lev2sec98"><strong><em>Using BEdit</em></strong></h4>&#13;
<p class="noindent">How was <em>cow.bf</em> created? You could use a normal text editor, but I used <em>bedit.py</em>, a simple Befunge editor created in Python. We won’t discuss the code, but do take a look if you are curious. Note that the terminal window in which you run <em>bedit.py</em> must be at least 120 characters wide and 26 lines tall. If not, <em>bedit.py</em> will happily remind you.</p>&#13;
<p class="indent">Executing <code>python3 bedit.py examples/cow.bf</code> produces <a href="ch11.xhtml#ch011fig1">Figure 11-1</a>.</p>&#13;
<div class="image"><img id="ch011fig1" src="Images/11fig01.jpg" alt="Image" width="678" height="310"/></div>&#13;
<p class="figcap"><em>Figure 11-1: Editing</em> cow.bf</p>&#13;
<p class="indent">The editor has two panes. On the left is a pane of 80×25 characters. This is the Befunge playfield where code goes. On the right is a summary of the editor and Befunge commands for reference. To move around the code, use the arrow keys. Any character you enter will go where the cursor currently is. To make entering code easier, typing characters moves in the direction of the last arrow key. Therefore, to type from right to left, move the cursor to the left with the left arrow key and begin typing. A bit of experimentation is all it takes to get the hang of it.</p>&#13;
<p class="indent">Use CTRL-W to write the file and CTRL-E to exit, which will also write the file if it has been modified. You must supply the name of the file on the <span epub:type="pagebreak" id="page_302"/>command line, whether new or not. Pressing CTRL-H clears the current row from the cursor to the right edge. Likewise, CTRL-V clears the current column from the cursor down. That’s it; the editor is simple, but I used it to create all the examples in this chapter.</p>&#13;
<h4 class="h4" id="lev2sec99"><strong><em>Befunge Says Hello</em></strong></h4>&#13;
<p class="noindent">Before we get to genuinely interesting, or at least illustrative, Befunge programs, we must look at our obligatory example. Run <em>hello.bf</em> to see our favorite greeting. Then, bring it up in BEdit to look at the code.</p>&#13;
<pre>v&gt;v                                                                             &#13;
8-8  Print "Hello, world!"                                                      &#13;
479                                                                             &#13;
*:*                                                                             &#13;
1:,                                                                             &#13;
+-,                                                                             &#13;
:3,                                                                             &#13;
3:,                                                                             &#13;
*+,                                                                             &#13;
12,                                                                             &#13;
++,                                                                             &#13;
:*,                                                                             &#13;
83,                                                                             &#13;
+7,                                                                             &#13;
:*,                                                                             &#13;
62,                                                                             &#13;
+:,                                                                             &#13;
:+9                                                                             &#13;
3*1                                                                             &#13;
-2+                                                                             &#13;
:6,                                                                             &#13;
8:@                                                                             &#13;
+*                                                                              &#13;
84                                                                              &#13;
&gt;^</pre>&#13;
<p class="indent">This is one of the more unusual examples of “Hello, world!” we’ve yet seen. Note that anywhere the program doesn’t go is fair game for comments, like the one on the second line (line 1, counting from 0). We’ll count lines from 0 because that’s how computer people count. See if you can figure out how this version works (hint: think characters, not strings). It’s not tricky, just unusual because of Befunge’s 2D program flow. Because Befunge can’t directly push numbers larger than 9 on the stack, larger values must be calculated piece by piece.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch011tab1">Table 11-1</a> lists Befunge’s commands.</p>&#13;
<p class="tabcap" id="ch011tab1"><span epub:type="pagebreak" id="page_303"/><strong>Table 11-1:</strong> The Befunge-93 Command Set</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Command</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Description</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>0</code>–<code>9</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Push a digit</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>+-*/%</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>( a b -- a op b )</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>!</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>( a -- !a )</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">`</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>( a b -- a&gt;b )</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>&gt;&lt;^v</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Set instruction pointer direction</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>?</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Pointer to random direction</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>_</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Pop; 0 = right, else left</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>|</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Pop; 0 = down, else up</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>"</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Push string</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>:</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>( a -- a a )</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>\</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>( a b -- b a )</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>$</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>( a -- )</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>.</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Pop; print as integer</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>,</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Pop; print as char</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>#</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Skip next cell (bridge)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>p</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>( v c r -- )</code> play[r,c] = v</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>g</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>( c r -- )</code> push play[r,c]</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba"><code>&amp;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Input number; push</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba"><code>~</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Input char; push</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>@</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">Exit program</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Most commands are easy to understand, but a few, like <code>#</code>, <code>?</code>, <code>p</code>, and <code>g</code>, are less clear and are the focus of the examples that follow. Note the use of Forth-style stack effect comments where appropriate.</p>&#13;
<h3 class="h3" id="lev1sec79"><strong>Befunge in Action</strong></h3>&#13;
<p class="noindent">The Befunge-93 repository includes many examples in the <em>eg</em> directory. That said, with one exception mentioned in the discussion, we’ll roll our own examples in this chapter.</p>&#13;
<p class="indent">Specifically, we’ll explore what makes Befunge unique. Naturally, a 2D language is unusual, but I find other parts of the language even more interesting in terms of thinking about coding.</p>&#13;
<p class="indent">However, first we must explore flow control and, at the same time, how input works. Doing this leaves us well situated to explore other language features. After flow control, we’ll explore Befunge’s <code>#</code> bridge command, which might seem unnecessary at first, but it is really quite clever. After that comes <code>?</code>, Befunge’s version of a pseudorandom number generator. We close the section with <code>p</code> and <code>g</code>, which enable both data storage in program space and self-modifying code.</p>&#13;
<h4 class="h4" id="lev2sec100"><span epub:type="pagebreak" id="page_304"/><strong><em>Going with the Flow</em></strong></h4>&#13;
<p class="noindent">Flow control in Piet (<a href="ch09.xhtml#ch09">Chapter 9</a>) was accomplished by setting up barriers. Befunge makes life easier by explicitly selecting new directions through the playfield, as we saw above with <em>cow.bf</em> and <em>hello.bf</em> .</p>&#13;
<p class="indent">Let’s work through two examples to improve our understanding of flow in Befunge. The first example converts a string of binary digits to decimal. The second converts text files using DOS line endings to Unix format.</p>&#13;
<h5 class="h5" id="lev3sec33"><strong>Binary to Decimal</strong></h5>&#13;
<p class="noindent">One approach to converting a binary number to decimal is to add the binary digit, from left to right, to a running total initialized to 0, then multiply by 2. When all the digits have been processed, divide by 2 to get the final value. Division by 2 is necessary because multiplying by 2 sets up for the next digit; however, there is no next digit after the last digit is read.</p>&#13;
<p class="indent">For example, if the input is 1101<sub>2</sub>, we get the decimal equivalent as</p>&#13;
<p class="equationc">((((((((0 + 1) × 2) + 1) × 2) + 0) × 2) + 1) × 2) ÷ 2 = 13</p>&#13;
<p class="indent">We’ll use the stack to hold the running total; therefore, the first thing we need on the stack is a 0. Then, we’ll begin a loop to read a character, subtract 48 to make it a 0 or 1, add it to the running total, and then multiply by 2. When all binary digits are read, divide by 2, print the top stack item as a decimal, and exit. Simple.</p>&#13;
<p class="indent">Well, not quite. How do we know all the binary digits have been read? One of two things will happen, both of which affect the value of the input character read. If the character is a newline, ASCII 10, then we know input is complete. Also, if reading from a file, the input might be end-of-file (EOF), which Befunge reports as <em>–</em>1. Therefore, we’ll need to check for both cases.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch011list1">Listing 11-1</a> presents <em>bin2dec.bf</em> .</p>&#13;
<pre>0v          &gt;68*-+2*  v&#13;
        &gt;:1+|&#13;
 &gt;~:55+-|   &gt;$2/.55+,@&gt;&#13;
        &gt;$2/.55+,@</pre>&#13;
<p class="caption" id="ch011list1"><em>Listing 11-1: Converting binary strings to decimal</em></p>&#13;
<p class="indent">This code is fairly compact with only four lines of code. The first line begins with <code>0v</code> to push 0 on the stack and move down. The next instruction is <code>&gt;</code> to move again to the right. At this point, we want to read a binary digit and check if it’s a newline: <code>~:55+-|</code>. The first character (tilde) reads the binary digit as a character and places it on the stack. The second character (colon) duplicates the character value so we can subtract 10 from it without losing it.</p>&#13;
<p class="indent">To get 10 on the stack, we use <code>55+</code>, and we use <code>-</code> to subtract. The stack now contains the running total, which is still 0, the first character, and whatever we get from subtracting 10 from the character. If the character is a newline, the stack contains 0 and pipe (<code>|</code>) will change program flow to down, thereby executing <code>&gt;$2/.55+,@</code> to drop the extra copy of the final input character, <span epub:type="pagebreak" id="page_305"/>divide the running total by 2, print it as a number, output a newline, and exit. Notice that <code>|</code> is the down/up equivalent of _. It moves program flow down if the top stack item is 0 and moves it up otherwise.</p>&#13;
<p class="indent">If the character isn’t a newline, flow moves up from <code>|</code> to <code>&gt;:1+|</code>. This block of code checks if EOF was read by adding 1 and asking if the top stack item is 0 or not. If it is, flow goes down from the second pipe to execute the second copy of <code>&gt;$2/.55+,@</code>, thereby printing the decimal answer.</p>&#13;
<p class="indent">Lastly, if the character isn’t newline or EOF, we move to the rest of line 0, <code>&gt;68*-+2*</code>, to subtract 48, add the 0 or 1 to the running total, and multiply by 2. The final character of line 0 is <code>v</code> to direct flow to the final character of line 2, <code>&gt;</code>, which wraps back around to the beginning of line 2 to get the next input character.</p>&#13;
<p class="indent">There are several ways to run <em>bin2dec.bf</em> . We could just run it and manually type the binary number. Or we might use <code>echo</code> to send the number to <code>bef</code>. Lastly, we might use file redirection. For example:</p>&#13;
<pre>&gt; <span class="codestrong1">bef examples/bin2dec.bf</span>&#13;
<span class="codestrong1">1101</span>&#13;
13&#13;
&gt; <span class="codestrong1">echo 11010 | bef examples/bin2dec.bf</span>&#13;
26&#13;
&gt; <span class="codestrong1">bef examples/bin2dec.bf &lt;ttt</span>&#13;
52 &#13;
&gt; <span class="codestrong1">cat ttt</span>&#13;
110100</pre>&#13;
<p class="indent">To watch a trace of <em>bin2dec.bf</em> , we can use <code>ttt</code> as above, but we need to use Befunge’s command line arguments. For example:</p>&#13;
<pre>&gt; <span class="codestrong1">bef -d -r ttt -w qqq examples/bin2dec.bf</span></pre>&#13;
<p class="indent">If you watch the trace, you’ll see that the program ends when newline is read. We can see the newline explicitly with <code>xxd</code>.</p>&#13;
<pre>&gt; <span class="codestrong1">xxd ttt</span>&#13;
00000000: 3131 3031 3030 0a</pre>&#13;
<p class="noindent">However, the input file need not have a final newline. In that case, the program does not exit by the first pipe, which checks for newline, but by the second pipe, which reads EOF (that is, <em>–</em>1). The following snippet of Python creates a new input file without a final newline.</p>&#13;
<pre>with open("zzz","r") as f:&#13;
    f.write("110100")</pre>&#13;
<p class="indent">Now run <em>bef</em> with <code>-d</code> as above, substituting <code>zzz</code> for <code>ttt</code>, and watch carefully. The program ends by taking the second pipe. The moral of the story is: care is required when deciding whether the input to a Befunge program is complete.</p>&#13;
<h5 class="h5" id="lev3sec34"><span epub:type="pagebreak" id="page_306"/><strong>DOS to Unix</strong></h5>&#13;
<p class="noindent">A common issue when moving files from one computer system to another is a mismatch in end-of-line conventions. Unix systems end each line of a text file with ASCII 10. This is a linefeed and is sometimes called newline. However, Windows systems, which are built on MS-DOS, use two characters at the end of each line: ASCII 13 and ASCII 10. ASCII 13 is a carriage return. Besides being an unnecessary waste of disk space, the carriage return causes trouble with systems that expect only a linefeed. ASCII 13 is CTRL-M, so some Unix editors show an extraneous <code>^M</code> when manipulating files with DOS line endings. Thus, it would be nice to convert such files to Unix format. To complicate matters still further, older Macintosh text files use only ASCII 13 as the line ending. Thankfully, such text files are becoming rare.</p>&#13;
<p class="indent">Naturally, there are utilities to convert text file line endings, to say nothing of modern text editors that handle DOS files without trouble. But just for a moment, let’s pretend it’s still 1993 and our Amiga computer isn’t that influenced by DOS. We need a conversion utility, and we happen to have this nifty new language called Befunge to play with. Surely it can do what we want.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch011list2">Listing 11-2</a> contains <em>dos2unix.bf</em> , a program to convert text files with DOS line endings to Unix (and Amiga). Structurally, it’s rather similar to <a href="ch11.xhtml#ch011list1">Listing 11-1</a>, but there are some differences.</p>&#13;
<pre>v          &gt;       &gt;&gt;,&#13;
     &gt;:85+-|&#13;
&gt;~:1+|     &gt;$~:55+-|&#13;
     @             &gt;^</pre>&#13;
<p class="caption" id="ch011list2"><em>Listing 11-2: Converting DOS line endings to Unix</em></p>&#13;
<p class="indent">The overall flow of the program is left to right, from column 0 of line 2 on over. The first block of code, <code>~:1+|</code>, reads a character and ascertains whether it is EOF. If so, we’re done and <code>@</code> calls it a day. If not, we need to check if the character read is ASCII 13, which is precisely what <code>&gt;:85+-|</code> does. If we subtract 13 and get 0, then the character is ASCII 13. In that case, take the branch on line 2, <code>&gt;$~:55+-|</code>, which drops the extra ASCII 13, reads the next input character, and checks if it’s ASCII 10. If it is, we want to keep it, so <code>&gt;^</code> moves up to <code>&gt;&gt;,</code> to print it. If the second character read isn’t ASCII 10, we have an embedded ASCII 13, which is weird, but whatever, we’ll keep it. That’s the top branch of the second pipe on line 2. Lastly, if the pipe in line 1 does not move down, it moves up to print the input character. This is the path taken for most of the characters read.</p>&#13;
<p class="indent">Now let’s test <em>dos2unix.bf</em> . To run it with redirection, use the following commands:</p>&#13;
<pre>&gt; <span class="codestrong1">bef examples/dos2unix.bf &lt;ttt.dos &gt;ttt.unix</span>&#13;
&gt; <span class="codestrong1">xxd ttt.dos</span>&#13;
00000000: 4142 430d 0a44 4546 0d0a 4142 430d 0a44  ABC..DEF..ABC..D&#13;
00000010: 4546 0d0a                                EF..<span epub:type="pagebreak" id="page_307"/>&#13;
&gt; <span class="codestrong1">xxd ttt.unix</span>&#13;
00000000: 4142 430a 4445 460a 4142 430a 4445 460a  ABC.DEF.ABC.DEF.</pre>&#13;
<p class="noindent">The input file, <em>ttt.dos</em>, uses DOS line endings. The output of <code>xxd</code> shows the carriage return and linefeed characters as <code>0d0a</code>. The output, <em>ttt.unix</em>, has only <code>0a</code>, as it should.</p>&#13;
<p class="indent">I admit that the two examples in this section are not the most beguiling. However, they help check your understanding of how Befunge works. Writing programs is more fun than reading them, so I encourage you to give something similar a go. Perhaps a utility to take a Unix text file and spit out a DOS version? When you are ready, move on to the next section.</p>&#13;
<h4 class="h4" id="lev2sec101"><strong><em>Building Bridges</em></strong></h4>&#13;
<p class="noindent">The command that likely made the least sense at first blush when you read through <a href="ch11.xhtml#ch011tab1">Table 11-1</a> was <code>#</code> (hash mark), the bridge command. This command skips the next instruction, acting as a bridge to move over it.</p>&#13;
<p class="indent">For example, a Befunge program consisting of only <code>88*1+#.,</code> will print the letter <em>A</em> forever. The first part, <code>88*1+</code>, puts 65 on the stack. Then, <code>#</code> skips the next instruction, which is a period to print <code>65</code>, and instead hits the comma to print ASCII 65, which is <code>A</code>. That is all the text on the first line, so the instruction pointer will wrap around to repeat it, over and over (<a href="ch11.xhtml#ch011list3">Listing 11-3</a>).</p>&#13;
<pre>&lt;v"xyzzy"0&#13;
 &gt;:#v_82+,@&#13;
 ^ ,&lt;</pre>&#13;
<p class="caption" id="ch011list3"><em>Listing 11-3: One use for the bridge instruction</em></p>&#13;
<p class="noindent">The <code>#</code> skips the next instruction—why on earth would we want to do that? One reason for <code>#</code> is found in <em>bridge.bf</em> (<a href="ch11.xhtml#ch011list3">Listing 11-3</a>), which does nothing more than print the word <code>xyxxy</code>. If you hear a hollow voice saying “fool,” fear not. (And if you don’t understand that reference, fear not as well.)</p>&#13;
<p class="indent">As with the <em>cow.bf</em> example above, <em>bridge.bf</em> moves from right to left and loops to print character after character. However, in this case, consider line 1, <code>&gt;:#v_82+,@</code>. From left to right, the commands are to move right, duplicate the character at the top of the stack, and then skip the <code>v</code> command but execute the underscore (_), which moves to the right if the top stack item is 0 and moves to the left otherwise.</p>&#13;
<p class="indent">Here’s where we see the utility of bridge. If the character is 0, go right to push 10 on the stack, print the newline character, and exit. Otherwise, move left. The first instruction moving left from _ is <code>v</code>, the very instruction <code>#</code> skipped when moving from left to right.</p>&#13;
<p class="indent">Executing <code>v</code> moves down, then left, to print the character and ultimately loop around to process the next character. So the bridge command is essential in this case as it allows one set of commands when the program flows to the right while executing a different set of commands when it flows to the left. Keep this behavior in mind because we’ll see it again in the next section.</p>&#13;
<h4 class="h4" id="lev2sec102"><span epub:type="pagebreak" id="page_308"/><strong><em>Fun with Dice</em></strong></h4>&#13;
<p class="noindent">Befunge’s <code>?</code> command randomly changes the instruction pointer’s direction. It might be up, down, left, or right. Let’s have some fun with this unusual instruction. At first blush, we might think it useless: who wants a program that isn’t deterministic? Then again, random numbers are frequently used in everything from games to simulations. Can we press <code>?</code> into similar service?</p>&#13;
<p class="indent">As <code>?</code> selects a new instruction pointer direction, it seems reasonable we might use it to simulate dice. In particular, <code>?</code> selects from four possible directions, so we might simulate what gamers call a D4, which is a die with four sides instead of the usual six.</p>&#13;
<p class="indent">How can <code>?</code> help us here? Well, if we encounter <code>?</code>, there are four possible directions to go, so if we push a 1, 2, 3, or 4 depending on which direction is selected, we’ll get our four-sided die.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch011list4">Listing 11-4</a> shows one approach to simulating a four-sided die.</p>&#13;
<pre>v  &gt; v&#13;
&gt;#v?v&#13;
  1234&#13;
  &gt;&gt;&gt;&gt;.91+,@</pre>&#13;
<p class="caption" id="ch011list4"><em>Listing 11-4: Simulating a four-sided die</em></p>&#13;
<p class="indent">In this case, we move to <code>?</code> by moving down to line 1, then right. Notice the bridge instruction in line 1. When moving to the right, we want to skip the <code>v</code> instruction to reach <code>?</code>. If <code>?</code> selects to move to the left, we hit the <code>v</code> to move to line 2 and push 1 on the stack. Likewise, the other three directions away from <code>?</code> end up pushing 2, 3, or 4 before hitting line 3, which moves to the right to print the selected value.</p>&#13;
<p class="indent">If we run <em>die4.bf</em> 10,000 times, we expect each outcome value to appear with roughly equal frequency. One such experiment of 10,000 runs produced <code>[2472, 2577, 2452, 2499]</code> as the respective number of 1s, 2s, 3s, and 4s. The values are similar, so it’s fair to say our four-sided die program works.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch011list5">Listing 11-5</a> shows a first attempt at simulating a standard six-sided die.</p>&#13;
<pre>     v&#13;
v  .2?1.  v&#13;
     v&#13;
 v .4?3. v&#13;
     v&#13;
  v.6?5.v&#13;
     ^&#13;
&gt;&gt;&gt;  v  &lt;&lt;&lt;&#13;
     5&#13;
     5&#13;
     +&#13;
     ,&#13;
     @</pre>&#13;
<p class="caption" id="ch011list5"><em>Listing 11-5: Attempting to simulate a six-sided die</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_309"/>If nothing else, <a href="ch11.xhtml#ch011list5">Listing 11-5</a> is nice and symmetric. I toyed with putting it on a t-shirt. Flow moves down the center from top to bottom. When the interpreter encounters a <code>?</code>, moving back up forces flow back into <code>?</code>, leaving only three exits: to either side or down. If to the side, a number from 1 to 6 is pushed on the stack and printed, and arrows move flow to the bottom to print a newline before exiting.</p>&#13;
<p class="indent">There are six numbers, so surely this arrangement is appropriate. If you run this version 10,000 times, you might get a distribution similar to <code>[3337, 3333, 1072, 1109, 543, 606]</code>, which is not at all uniform. <a href="ch11.xhtml#ch011list5">Listing 11-5</a> can be found in <em>die6_biased.bf</em> , and as you might expect from the name, it is a loaded die that strongly favors 1s and 2s.</p>&#13;
<p class="indent">From the counts, the ratio between 1s and 2s to 3s and 4s then 5s and 6s is 6:2:1, meaning one is six times as frequent as six. If we look at the structure of <a href="ch11.xhtml#ch011list5">Listing 11-5</a>, we can calculate the probabilities associated with each outcome. The first <code>?</code> has a 1 out of 3 chance of selecting 1, 2, or moving on to other numbers. Therefore, the probability of choosing a 1 or a 2 is 1/3 + 1/3 = 2/3. That means the sum of the remaining probabilities, those for selecting 3 through 6, must total 1/3. Selecting 3 or 4 is similar to 1 or 2—there is a 1 out of 3 chance—but it’s 1 out of 3 from what is already a 1 out of 3 chance. Therefore, there is a 1 in 9 chance of selecting 3 and the same for selecting 4. The final 1 in 9 chance is split evenly between choosing 5 or 6, or 1 in 18 each.</p>&#13;
<p class="indent">If the probabilities above are correct, they must add up to 1. Let’s use Scheme to check that they do.</p>&#13;
<pre>&gt; <span class="codestrong1">racket</span>&#13;
Welcome to Racket v6.11.&#13;
&gt; <span class="codestrong1">(+ 1/3 1/3 1/9 1/9 1/18 1/18)</span>&#13;
1</pre>&#13;
<p class="noindent">Our calculations are correct. Clearly, we don’t want <a href="ch11.xhtml#ch011list5">Listing 11-5</a>, aesthetics aside. So how can we use something that selects 1 in 4 to get something that selects 1 in 6 with equal probabilities?</p>&#13;
<p class="indent">If we restrict <code>?</code> to select one of two options only, we can use each of those outputs to choose another pair, thereby changing two options into four. Do the same for each of the four, and we have eight outputs, each equally likely to be selected. We only want six of the eight, so if either of the remaining two are selected, we repeat until one of the six is chosen.</p>&#13;
<p class="indent">There are different ways to write such an algorithm. The file <em>die6.bf</em> holds one of them (see <a href="ch11.xhtml#ch011list6">Listing 11-6</a>). Take a moment to look at the code to absorb what it means. Then linger a little longer to appreciate the code’s ethereal beauty.</p>&#13;
<pre>v                    &gt;&#13;
              &gt;      ?&lt;&#13;
                     &gt;6  v   v&#13;
       &gt;      ?&lt;&#13;
                     &gt;5  v<span epub:type="pagebreak" id="page_310"/>&#13;
              &gt;      ?&lt;&#13;
                     &gt;4  v&#13;
&gt;      ?&lt;                &gt;.91+,@&#13;
                     &gt;3  ^&#13;
              &gt;      ?&lt;&#13;
                     &gt;2  ^&#13;
       &gt;      ?&lt;&#13;
                     &gt;1  ^&#13;
              &gt;      ?&lt;&#13;
^                    &gt;</pre>&#13;
<p class="caption" id="ch011list6"><em>Listing 11-6: Simulating a six-sided die with equal probabilities</em></p>&#13;
<p class="indent">The rightmost instructions push 1 through 6 on the stack. However, if flow reaches the top or bottom, it continues to the right to wrap around and move back to the beginning until one of the six desired paths is selected.</p>&#13;
<p class="indent">Running the code in <a href="ch11.xhtml#ch011list6">Listing 11-6</a> 10,000 times gives us frequencies of <code>[1678, 1638, 1705, 1660, 1637, 1682]</code>, which is exactly what we want; each outcome is now equally likely. As an exercise, see if you can come up with arrangements of <code>?</code> to simulate an 8-sided die, 12-sided die, or even 20-sided die.</p>&#13;
<h4 class="h4" id="lev2sec103"><strong><em>Wandering Around</em></strong></h4>&#13;
<p class="noindent">The file <em>brownian.bf</em> contains a program where the entire playfield is filled with <code>?</code> and nothing else. Running this program on its own is boring; it produces no output and never ends. However, running it with Befunge’s debugger is mesmerizing:</p>&#13;
<pre>&gt; <span class="codestrong1">bef -d examples/brownian.bf</span></pre>&#13;
<p class="noindent">The cursor wanders over the playfield in a way that is reminiscent of Brownian motion, the random motion of particles in some medium.</p>&#13;
<p class="indent">Before we move on, take a look at <em>zero.bf</em> . It consists of an entire playfield of <code>?</code> commands with a single period (<code>.</code>) in the middle.</p>&#13;
<p class="indent">Befunge never throws an error because of the stack. If you attempt to pop the stack when it is empty, Befunge returns 0. The print command pops the stack, so printing when the stack is empty outputs 0. If you run <em>zero.bf</em> with the debugger, you might think you’re in for a long wait to hit the one print instruction. However, if you run <em>zero.bf</em> without the debugger, your screen will quickly fill with 0s. Human perception of how fast computers operate is orders of magnitude too slow. Computers are so much quicker than we can appreciate that even a simple interpreter like Befunge randomly hits that one print command at a tremendous rate. In fact, dumping the output to the screen is slow. Direct the output to a file instead, and even my old system has Befunge printing nearly 15,000 0s per second.</p>&#13;
<p class="indent">However, it turns out my statement about Befunge not throwing stack errors is incorrect. Run this program: <code>00/.@</code>. I consider it an Easter egg.</p>&#13;
<h4 class="h4" id="lev2sec104"><span epub:type="pagebreak" id="page_311"/><strong><em>Updating the Playfield on the Fly</em></strong></h4>&#13;
<p class="noindent">Befunge programs live in the playfield and memory is restricted to the stack. Or is it? The <code>p</code> instruction lets the programmer write to the playfield as the program runs. If the altered cell happens to be part of the running program, and the value written is the ASCII code for a valid command, then Befunge will use that command. This means that Befunge allows self-modifying code, which, under normal circumstances, is taboo. But we’re working with esolangs, so what was forbidden may be permitted. Use <code>p</code> to write to the playfield and <code>g</code> to read from it.</p>&#13;
<p class="indent">Let’s explore <code>p</code> and <code>g</code> with two examples. The first converts an integer less than 65,536 (= 2<sup>16</sup>) to a four-digit hexadecimal number. The second is a simple calculator.</p>&#13;
<h5 class="h5" id="lev3sec35"><strong>What the Hex?</strong></h5>&#13;
<p class="noindent">Old-school BASIC used <code>DATA</code> and <code>READ</code> to store data in source code. These were usually instructions for small machine language routines that were <code>POKE</code>d into memory and later <code>CALL</code>ed from BASIC. We can use <code>g</code> similarly to read data from the playfield.</p>&#13;
<p class="indent">Suppose we have a number, <em>v</em>, on the stack. We’ll assume it’s positive and less than 65,536. Our task is to convert this number to four hex digits and print them. One way to do this is to split <em>v</em> in two by replacing it with <em>v</em>/256 and <em>v</em> mod 256. Then, if we do the same with the split values using 16 in place of 256, we’ll extract the four hexadecimal digit values.</p>&#13;
<p class="indent">For example, if the user enters 1234, the sequence of operations leads to</p>&#13;
<div class="imagec"><img src="Images/f0311.jpg" alt="Image" width="250" height="167"/></div>&#13;
<p class="noindent">or (0,4,13,2) = 04<em>D</em>2<sub>16</sub> = 1234.</p>&#13;
<p class="indent">Let’s put this algorithm to the test and, at the same time, use <code>p</code> and <code><em>g</em></code> because we can. The code we need is in <em>dec2hex.bf</em> and is shown in <a href="ch11.xhtml#ch011list7">Listing 11-7</a>.</p>&#13;
<pre>v    0123456789ABCDEF&#13;
&gt;&amp;:55*55+*6+/\55*55+*6+%            v&#13;
v                    p01%*28p02/*28:&lt;&#13;
&gt;:82*%30p82*/40p                    v&#13;
v                           ,g0+5g04&lt;&#13;
&gt;30g5+0g,                           v&#13;
v                           ,g0+5g02&lt;&#13;
&gt;10g5+0g,55+,@</pre>&#13;
<p class="caption" id="ch011list7"><em>Listing 11-7: Converting decimal to hex</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_312"/>The program flows in a zig-zag pattern, row by row, beginning with line 1. First, the user is asked for a number (<code>&amp;</code>), after which comes the division and modulo by 256. At the end of the line, <em>v</em>/256 and <em>v</em> mod 256 are on the stack.</p>&#13;
<p class="indent">Line 2 runs from right to left. Flipping the instructions, the interpreter executes <code>:82*/20p82*%10p</code>. Let’s break this down a bit. The first instruction duplicates the top stack item, <em>v</em> mod 256. Next, <code>82*/</code> divides the top stack item by 16, thereby calculating the second digit of the answer. To store it in the playfield, we use <code>20p</code>.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch011tab1">Table 11-1</a> says the <code>p</code> instruction expects three values on the stack: the value to store, the playfield column, and the playfield row. Therefore, <code>20p</code> stores the second digit value in row 0, column 2. The remainder of line 2 uses modulo to get the value of the first digit and places it in <code>10p</code>, row 0, column 1. Line 3, running left to right, repeats the calculation to find the values of digits 3 and 4.</p>&#13;
<p class="indent">When line 4 begins, again running right to left, we have the digit values in row 0 of the playfield. We now need to print them as ASCII characters. You’ve likely noticed the string <code>0123456789ABCDEF</code> in line 0. We’ll use this string to get the characters we need. This is the Befunge equivalent of <code>DATA</code> in BASIC or FORTRAN. The digit value serves as an index into this string.</p>&#13;
<p class="indent">Flipped, line 4 is <code>40g5+0g,</code>. The first part, <code>40g</code>, reads the value of digit 4, which is the most significant digit. To index the proper character, we must add 5, then another <code>g</code> pulls the proper character, placing its ASCII value on the stack for <code>,</code> to print. The remainder of <a href="ch11.xhtml#ch011list7">Listing 11-7</a> prints the rest of the answer and a newline and then ends.</p>&#13;
<p class="indent">Running <em>dec2hex.bf</em> shows that the program works.</p>&#13;
<pre>&gt; <span class="codestrong1">bef examples/dec2hex.bf</span>&#13;
<span class="codestrong1">1234</span>&#13;
04D2</pre>&#13;
<p class="noindent">It’s more interesting to run this example with the debugger. For example, if the temporary file <em>ttt</em> contains an integer, say 6,502, we might run the code with the following:</p>&#13;
<pre>&gt; <span class="codestrong1">bef -d -r ttt -w qqq examples/dec2hex.bf</span></pre>&#13;
<p class="noindent">While the code executes, watch the top row carefully. You’ll see four lights, er, dots appear. These are the specific digits placed in the playfield by the <code>p</code> instructions. When the program ends, the output is in another temporary file, <em>qqq</em>, which contains 1966<sub>16</sub> = 6502.</p>&#13;
<p class="indent">Using the playfield to store program data is a handy option. Using the playfield to alter program execution is the next step. Let’s see how.</p>&#13;
<h5 class="h5" id="lev3sec36"><strong>Program Transmogrification</strong></h5>&#13;
<p class="noindent">Self-modifying code, or, as I like to call it, <em>program transmogrification</em>, is seldom used and with good reason. However, Befunge supports it, and there are times it’s more handy than not. For example, a calculator program needs <span epub:type="pagebreak" id="page_313"/>to accept a number, an operator, and another number. The code is much the same regardless of the operator, as long as the operator is binary. Befunge supports five binary arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and <code>%</code>. Let’s make a simple calculator that lets users enter a single digit, the desired operator, and a second digit before calculating and printing the answer.</p>&#13;
<p class="indent">In Python, we might implement such a calculator with</p>&#13;
<pre>a = int(getch())&#13;
op= getch()&#13;
b = int(getch())&#13;
if op == "+":&#13;
    ans = a + b&#13;
elif op == "-":&#13;
    ans = a - b&#13;
elif op == "*":&#13;
    ans = a * b&#13;
elif op == "/":&#13;
    ans = a / b&#13;
elif op == "%":&#13;
    ans = a % b&#13;
print(ans)</pre>&#13;
<p class="noindent">We’re assuming the existence of a function, <code>getch</code>, that returns a single character from the keyboard.</p>&#13;
<p class="indent">The Python code would do the trick, but its highly repetitive <code>if</code> statement isn’t particularly attractive. If we know the operation is addition, the code becomes simpler.</p>&#13;
<pre>a = int(getch())&#13;
b = int(getch())&#13;
print(a+b)</pre>&#13;
<p class="noindent">If the operation is division, the code is the same; just replace <code>+</code> with <code>/</code>.</p>&#13;
<p class="indent">The key to our Befunge calculator is in the phrase, “just replace <em>X</em> with <em>Y</em>.” That is exactly what we’ll do: we’ll write the program as if the operator were always addition, but modify the program source in the playfield during program execution to use the user’s actual operator.</p>&#13;
<p class="indent">Algorithmically, then, we need to do the following:</p>&#13;
<ol>&#13;
<li class="noindent">Get a single digit character from the user and convert it to a number  on the stack.</li>&#13;
<li class="noindent">Get a single operator character from the user and place it in the  proper location in the playfield so Befunge uses it when calculating  the answer.</li>&#13;
<li class="noindent">Get a second digit from the user on the stack.</li>&#13;
<li class="noindent">Perform the operation and print the answer.</li>&#13;
</ol>&#13;
<p class="indent"><a href="ch11.xhtml#ch011list8">Listing 11-8</a> shows <em>calc.bf</em> . It’s even shorter than the description of what it does.</p>&#13;
<pre><span epub:type="pagebreak" id="page_314"/>~68*-~61p~68*-84*,88*3-,84*,v&#13;
@,+82.+                     &lt;</pre>&#13;
<p class="caption" id="ch011list8"><em>Listing 11-8: Program transmogrification in action</em></p>&#13;
<p class="indent">The first part reads a character, assumed to be a digit, and subtracts 48 to convert it to an integer. That’s <code>~68*-</code>. The program then asks for the operator, which it places in row 1, column 6 (<code>~61p</code>). If you look at row 1, column 6, you’ll see it contains a <code>+</code>, which is overwritten by the operator character the user enters—program transmogrification!</p>&#13;
<p class="indent">The rest of line 0 gets the second digit, prints a space, an equals sign, and another space. Line 1 applies the updated operation, prints the result and a newline, and exits. Let’s see <a href="ch11.xhtml#ch011list8">Listing 11-8</a> in action.</p>&#13;
<pre>&gt; <span class="codestrong1">bef examples/calc.bf</span>&#13;
<span class="codestrong1">8*5</span>&#13;
 = 40 &#13;
&gt; <span class="codestrong1">bef examples/calc.bf</span>&#13;
<span class="codestrong1">9%4</span>&#13;
 = 1 &#13;
&gt; <span class="codestrong1">bef examples/calc.bf</span>&#13;
<span class="codestrong1">2+2</span>&#13;
 = 4 &#13;
&gt; <span class="codestrong1">bef examples/calc.bf</span>&#13;
<span class="codestrong1">2-9</span>&#13;
 = -7</pre>&#13;
<p class="indent">The stated goal of Befunge was to make a language that is too hard to compile, so it makes sense to allow self-modifying code. In this particular case, especially given how Befunge works as a programming language, a bit of self-modification was the more elegant solution. Without it, <em>calc.bf</em> would have to be much larger: it would need to enable comparing the operator character with each of the five possible operators along with a different code path for each operator. This would definitely not be as elegant.</p>&#13;
<h3 class="h3" id="lev1sec80"><strong>Discussion</strong></h3>&#13;
<p class="noindent">Befunge-93 is imperative, and the stack is of arbitrary size, limited only by the computer’s RAM, so we might think it’s Turing complete. However, it isn’t. What keeps it from being Turing complete is a limitation many other languages do not have: the program <em>must</em> fit in the playfield, as that’s all the room there is. Therefore, programs cannot be arbitrarily complex and Befunge-93 is not Turing complete.</p>&#13;
<p class="indent">You may notice that in the previous paragraph, I was careful to type “Befunge-93.” A later version of Befunge, Befunge-98, removes the limitation on playfield size and therefore <em>is</em> Turing complete. However, I felt an affinity for the original, which is why we worked with it here.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_315"/>The web has many additional resources for Befunge, though not at the scale of BF or even Piet. The best resources for Befunge are <em><a href="https://esolang.org/">https://esolang.org/</a></em> and Chris Pressey’s site (<em><a href="https://git.catseye.tc/Befunge-93/">https://git.catseye.tc/Befunge-93/</a></em>). I also found this interview with Pressey interesting: <em><a href="https://esoteric.codes/blog/interview-with-chris-pressey/">https://esoteric.codes/blog/interview-with-chris-pressey/</a></em>. Befunge figures prominently. Last of all, if you’re like me, you’ll find plenty to explore and think about by examining all of Pressey’s site, including the many other programming languages he’s developed over the years (<em><a href="https://catseye.tc/">https://catseye.tc/</a></em>).</p>&#13;
<p class="indent">Befunge has been written in Befunge—see the included <em>befunge.bf</em> file. It’s from the esolang wiki. To use it, run <em>befunge.bf</em> , passing in the Befunge program you want to run from standard in. If the program has input, separate the program text from the input with a semicolon (<code>;</code>). For example:</p>&#13;
<pre>&gt; <span class="codestrong1">bef examples/befunge.bf &lt;examples/cow.bf  2&gt;/dev/null</span>&#13;
How now brown cow?</pre>&#13;
<p class="noindent">This is quite impressive and reinforces the argument that Befunge-93 would be Turing complete if there were enough program space. The <code>2&gt;</code> redirection ignores the Befunge error messages that you’ll see if you don’t use it.</p>&#13;
<p class="indent">It just happens that the Befunge interpreter in Befunge fits in the playfield. The esolang wiki does not provide authorship information for <em>befunge .bf</em> , so I’m not sure who we should thank for such a clever implementation.</p>&#13;
<p class="indent">2D programming is cute and much in line with what a “good” esolang is—something outside the box. The clever bits, to me, are seeing the utility of an instruction like <code>#</code>, the bridge instruction, and with it the recognition that programs running in multiple directions might want to do slightly different things when running left to right or right to left, even for the same line of code. Using single-digit numbers, knowing any number can be built on the stack as needed, is also quite clever.</p>&#13;
<p class="indent">Good esolangs inspire other esolangs. Befunge is no different. For example, if there is a 2D language, then why not a 3D language? Interested? If so, take a look at Suzy (<em><a href="https://github.com/gvx/suzy/">https://github.com/gvx/suzy/</a></em>). However, be aware that it hasn’t been updated for more than a decade, so use Python 2.<em>X</em> to run its examples.</p>&#13;
<p class="indent">What about other 2D languages? Befunge has inspired so many esolangs that a term has evolved just to describe them: <em>fungeoids</em>. The esolang wiki lists pages of fungeoids at <em><a href="https://esolangs.org/wiki/Category:Two-dimensional_languages">https://esolangs.org/wiki/Category:Two-dimensional_languages</a></em>. If imitation is the sincerest form of flattery, then Befunge should feel abundantly flattered, provided Befunge can feel anything, of course.</p>&#13;
<h3 class="h3" id="lev1sec81"><strong>Summary</strong></h3>&#13;
<p class="noindent">Befunge was the target of this chapter. We learned that Befunge is the first 2D programming language, has been around long enough to have a silver jubilee, and is fun to program in. We also learned that Befunge has inspired a swarm of related esolangs: the fungeoids.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_316"/>And, with that, our exploration of existing esolangs draws to a close. <a href="part01.xhtml#part01">Part I</a> of the book discussed the essentials of programming languages. <a href="part02.xhtml#part02">Part II</a> prepped us for esolangs by studying atypical programming languages, and <a href="part03.xhtml#part03">Part III</a> explored existing esolangs. Now we move to <a href="part04.xhtml#part04">Part IV</a> to implement two homegrown esolangs: Filska and Firefly.</p>&#13;
</div></body></html>