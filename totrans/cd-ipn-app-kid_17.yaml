- en: '14'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SETTING THE STAGE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Over the next several chapters, we’ll put your new skills to good use to build
    a game called *Schoolhouse Skateboarder* , where the player controls a skateboarder
    who has to jump over obstacles and collect gems.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll set up your Xcode project file, add images for the player,
    and display a schoolyard background. [Figure 14-1](text00026.html#ch14fig1) is
    a preview of how the game will look on an iPhone. Players try to survive as long
    as possible by tapping to jump over obstacles, collecting gems and scoring points
    along the way. They lose when they tip over or fall down a hole.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00270.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-1: The finished game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHERE DO I GET ART AND SOUND EFFECTS?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve already created all the art and sound effects you need to make Schoolhouse
    Skateboarder (available from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    ). You don’t need anything else to follow along. If you want to customize it,
    you can make the game your own by replacing the skateboarder image with a character
    of your choosing, or you might have someone grabbing hamburgers instead of gems.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, by the end of this book, you’ll be inspired to design your own games.
    It can be rewarding to create the entire game by yourself, including the artwork
    and sound effects. You have complete control over every aspect of *your* game.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also plenty of places on the web where you can find free game art
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://opengameart.org/](http://opengameart.org/)*** Free game art, sounds,
    and music'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  prefs: []
  type: TYPE_NORMAL
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE GAME PROJECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  prefs: []
  type: TYPE_NORMAL
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SETTING THE STAGE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Over the next several chapters, we’ll put your new skills to good use to build
    a game called *Schoolhouse Skateboarder* , where the player controls a skateboarder
    who has to jump over obstacles and collect gems.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll set up your Xcode project file, add images for the player,
    and display a schoolyard background. [Figure 14-1](text00026.html#ch14fig1) is
    a preview of how the game will look on an iPhone. Players try to survive as long
    as possible by tapping to jump over obstacles, collecting gems and scoring points
    along the way. They lose when they tip over or fall down a hole.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00270.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-1: The finished game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHERE DO I GET ART AND SOUND EFFECTS?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve already created all the art and sound effects you need to make Schoolhouse
    Skateboarder (available from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    ). You don’t need anything else to follow along. If you want to customize it,
    you can make the game your own by replacing the skateboarder image with a character
    of your choosing, or you might have someone grabbing hamburgers instead of gems.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, by the end of this book, you’ll be inspired to design your own games.
    It can be rewarding to create the entire game by yourself, including the artwork
    and sound effects. You have complete control over every aspect of *your* game.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also plenty of places on the web where you can find free game art
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://opengameart.org/](http://opengameart.org/)*** Free game art, sounds,
    and music'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  prefs: []
  type: TYPE_NORMAL
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE GAME PROJECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  prefs: []
  type: TYPE_NORMAL
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)![](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Over the next several chapters, we’ll put your new skills to good use to build
    a game called *Schoolhouse Skateboarder* , where the player controls a skateboarder
    who has to jump over obstacles and collect gems.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll set up your Xcode project file, add images for the player,
    and display a schoolyard background. [Figure 14-1](text00026.html#ch14fig1) is
    a preview of how the game will look on an iPhone. Players try to survive as long
    as possible by tapping to jump over obstacles, collecting gems and scoring points
    along the way. They lose when they tip over or fall down a hole.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00270.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-1: The finished game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHERE DO I GET ART AND SOUND EFFECTS?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve already created all the art and sound effects you need to make Schoolhouse
    Skateboarder (available from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    ). You don’t need anything else to follow along. If you want to customize it,
    you can make the game your own by replacing the skateboarder image with a character
    of your choosing, or you might have someone grabbing hamburgers instead of gems.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, by the end of this book, you’ll be inspired to design your own games.
    It can be rewarding to create the entire game by yourself, including the artwork
    and sound effects. You have complete control over every aspect of *your* game.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also plenty of places on the web where you can find free game art
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://opengameart.org/](http://opengameart.org/)*** Free game art, sounds,
    and music'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  prefs: []
  type: TYPE_NORMAL
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE GAME PROJECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  prefs: []
  type: TYPE_NORMAL
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Over the next several chapters, we’ll put your new skills to good use to build
    a game called *Schoolhouse Skateboarder* , where the player controls a skateboarder
    who has to jump over obstacles and collect gems.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll set up your Xcode project file, add images for the player,
    and display a schoolyard background. [Figure 14-1](text00026.html#ch14fig1) is
    a preview of how the game will look on an iPhone. Players try to survive as long
    as possible by tapping to jump over obstacles, collecting gems and scoring points
    along the way. They lose when they tip over or fall down a hole.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00270.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-1: The finished game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHERE DO I GET ART AND SOUND EFFECTS?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve already created all the art and sound effects you need to make Schoolhouse
    Skateboarder (available from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    ). You don’t need anything else to follow along. If you want to customize it,
    you can make the game your own by replacing the skateboarder image with a character
    of your choosing, or you might have someone grabbing hamburgers instead of gems.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, by the end of this book, you’ll be inspired to design your own games.
    It can be rewarding to create the entire game by yourself, including the artwork
    and sound effects. You have complete control over every aspect of *your* game.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also plenty of places on the web where you can find free game art
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://opengameart.org/](http://opengameart.org/)*** Free game art, sounds,
    and music'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  prefs: []
  type: TYPE_NORMAL
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE GAME PROJECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  prefs: []
  type: TYPE_NORMAL
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll set up your Xcode project file, add images for the player,
    and display a schoolyard background. [Figure 14-1](text00026.html#ch14fig1) is
    a preview of how the game will look on an iPhone. Players try to survive as long
    as possible by tapping to jump over obstacles, collecting gems and scoring points
    along the way. They lose when they tip over or fall down a hole.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00270.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-1: The finished game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHERE DO I GET ART AND SOUND EFFECTS?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve already created all the art and sound effects you need to make Schoolhouse
    Skateboarder (available from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    ). You don’t need anything else to follow along. If you want to customize it,
    you can make the game your own by replacing the skateboarder image with a character
    of your choosing, or you might have someone grabbing hamburgers instead of gems.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, by the end of this book, you’ll be inspired to design your own games.
    It can be rewarding to create the entire game by yourself, including the artwork
    and sound effects. You have complete control over every aspect of *your* game.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also plenty of places on the web where you can find free game art
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://opengameart.org/](http://opengameart.org/)*** Free game art, sounds,
    and music'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  prefs: []
  type: TYPE_NORMAL
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE GAME PROJECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  prefs: []
  type: TYPE_NORMAL
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)![](Image00270.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-1: The finished game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHERE DO I GET ART AND SOUND EFFECTS?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve already created all the art and sound effects you need to make Schoolhouse
    Skateboarder (available from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    ). You don’t need anything else to follow along. If you want to customize it,
    you can make the game your own by replacing the skateboarder image with a character
    of your choosing, or you might have someone grabbing hamburgers instead of gems.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, by the end of this book, you’ll be inspired to design your own games.
    It can be rewarding to create the entire game by yourself, including the artwork
    and sound effects. You have complete control over every aspect of *your* game.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also plenty of places on the web where you can find free game art
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://opengameart.org/](http://opengameart.org/)*** Free game art, sounds,
    and music'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  prefs: []
  type: TYPE_NORMAL
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE GAME PROJECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  prefs: []
  type: TYPE_NORMAL
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-1: The finished game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WHERE DO I GET ART AND SOUND EFFECTS?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve already created all the art and sound effects you need to make Schoolhouse
    Skateboarder (available from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    ). You don’t need anything else to follow along. If you want to customize it,
    you can make the game your own by replacing the skateboarder image with a character
    of your choosing, or you might have someone grabbing hamburgers instead of gems.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, by the end of this book, you’ll be inspired to design your own games.
    It can be rewarding to create the entire game by yourself, including the artwork
    and sound effects. You have complete control over every aspect of *your* game.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also plenty of places on the web where you can find free game art
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://opengameart.org/](http://opengameart.org/)*** Free game art, sounds,
    and music'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  prefs: []
  type: TYPE_NORMAL
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE GAME PROJECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  prefs: []
  type: TYPE_NORMAL
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**WHERE DO I GET ART AND SOUND EFFECTS?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve already created all the art and sound effects you need to make Schoolhouse
    Skateboarder (available from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    ). You don’t need anything else to follow along. If you want to customize it,
    you can make the game your own by replacing the skateboarder image with a character
    of your choosing, or you might have someone grabbing hamburgers instead of gems.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, by the end of this book, you’ll be inspired to design your own games.
    It can be rewarding to create the entire game by yourself, including the artwork
    and sound effects. You have complete control over every aspect of *your* game.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also plenty of places on the web where you can find free game art
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://opengameart.org/](http://opengameart.org/)*** Free game art, sounds,
    and music'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  prefs: []
  type: TYPE_NORMAL
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE GAME PROJECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  prefs: []
  type: TYPE_NORMAL
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We’ve already created all the art and sound effects you need to make Schoolhouse
    Skateboarder (available from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    ). You don’t need anything else to follow along. If you want to customize it,
    you can make the game your own by replacing the skateboarder image with a character
    of your choosing, or you might have someone grabbing hamburgers instead of gems.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, by the end of this book, you’ll be inspired to design your own games.
    It can be rewarding to create the entire game by yourself, including the artwork
    and sound effects. You have complete control over every aspect of *your* game.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also plenty of places on the web where you can find free game art
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://opengameart.org/](http://opengameart.org/)*** Free game art, sounds,
    and music'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  prefs: []
  type: TYPE_NORMAL
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE GAME PROJECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  prefs: []
  type: TYPE_NORMAL
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hopefully, by the end of this book, you’ll be inspired to design your own games.
    It can be rewarding to create the entire game by yourself, including the artwork
    and sound effects. You have complete control over every aspect of *your* game.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also plenty of places on the web where you can find free game art
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://opengameart.org/](http://opengameart.org/)*** Free game art, sounds,
    and music'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  prefs: []
  type: TYPE_NORMAL
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE GAME PROJECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  prefs: []
  type: TYPE_NORMAL
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are also plenty of places on the web where you can find free game art
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://opengameart.org/](http://opengameart.org/)*** Free game art, sounds,
    and music'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  prefs: []
  type: TYPE_NORMAL
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE GAME PROJECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  prefs: []
  type: TYPE_NORMAL
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '***[http://opengameart.org/](http://opengameart.org/)*** Free game art, sounds,
    and music'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  prefs: []
  type: TYPE_NORMAL
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE GAME PROJECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  prefs: []
  type: TYPE_NORMAL
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '***[http://freetems.net/](http://freetems.net/)*** Free game art and music'
  prefs: []
  type: TYPE_NORMAL
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  prefs: []
  type: TYPE_NORMAL
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE GAME PROJECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  prefs: []
  type: TYPE_NORMAL
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '***[http://www.bfxr.net/](http://www.bfxr.net/)*** Free retro game sound creation
    tool'
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  prefs: []
  type: TYPE_NORMAL
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE GAME PROJECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  prefs: []
  type: TYPE_NORMAL
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**MAKING GAMES WITH XCODE’S SPRITEKIT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  prefs: []
  type: TYPE_NORMAL
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE GAME PROJECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  prefs: []
  type: TYPE_NORMAL
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SpriteKit is iOS’s built-in game engine for making two-dimensional, or 2D, games.
    A *game engine* is a set of tools that lets you quickly and easily make animations,
    use audio and sound effects, create a menu system, and more. Programmers use game
    engines so they can focus on what’s truly important—making the game fun.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  prefs: []
  type: TYPE_NORMAL
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE GAME PROJECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  prefs: []
  type: TYPE_NORMAL
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Typically, a game consists of many sprites. A *sprite* is a 2D image used in
    a game. Sprites can be full-screen images that provide the backdrop for the game,
    or they can be smaller images that move around and do things. Background sprites
    set the stage. For example, in a space shooter game, the background sprites might
    show a space scene with stars and planets, and there would be smaller sprites
    for the player’s spaceship, enemy ships, bullets, asteroids, and power-ups.
  prefs: []
  type: TYPE_NORMAL
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE GAME PROJECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  prefs: []
  type: TYPE_NORMAL
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As far as game engines go, SpriteKit is top notch. Tasks that would take many
    lines of code in other game engines can be accomplished with just a line or two
    in SpriteKit, and it’s fun to use!
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE GAME PROJECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  prefs: []
  type: TYPE_NORMAL
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)![](Image00271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE GAME PROJECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  prefs: []
  type: TYPE_NORMAL
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*iOS also has a 3D game engine called SceneKit, but since we’re building a
    2D game, we’ll stick with SpriteKit.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**CREATING THE GAME PROJECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  prefs: []
  type: TYPE_NORMAL
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**CREATING THE GAME PROJECT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  prefs: []
  type: TYPE_NORMAL
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first thing we need to do is create a new SpriteKit project for our game.
    Open Xcode and select **File** ▸ **New** ▸ **Project…** . In the project template
    dialog, select **iOS** , choose the **Game** template, and then click **Next**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  prefs: []
  type: TYPE_NORMAL
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, name your project SchoolhouseSkateboarder in the Product Name field. Choose
    **SpriteKit** as the Game Technology. Since our game will run only on iPhones
    (and iPod touches), select **iPhone** as the Devices setting. Then click **Next**
    to create your game project.
  prefs: []
  type: TYPE_NORMAL
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Without changing a thing, you can run this project and you’ll see a black screen
    with a label that says *Hello, World!* . Each time you click your mouse anywhere
    in the simulator, a spinning box will appear on the screen (see [Figure 14-2](text00026.html#ch14fig2)
    ), and the label will shrink for a second. If the label appears sideways, you
    can rotate the simulator window by selecting **Hardware** ▸ **Rotate Left** from
    the simulator’s menu.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Whenever you make a new project using the Game template, Xcode adds this simple
    interaction so you can make sure everything’s working.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)![](Image00272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Running the project created by the Game template before making
    any changes*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since we don’t want a giant *Hello, World!* label in our game, let’s remove
    that first. That label exists in the *scene editor* , a tool used to visually
    design a SpriteKit scene, similar to the way storyboards are used to design UIKit
    views. You can drag objects into the scene editor, move them around, and change
    their size, color, and other properties. This can be a useful tool, but it has
    many limitations compared to what can be done in code. Therefore, apart from removing
    the *Hello, World!* label, we won’t be using the scene editor for Schoolhouse
    Skateboarder. To open the scene editor, click the file named *GameScene.sks* in
    the Project navigator. Once it loads, you should see a black scene with the *Hello,
    World!* label. Click the label, and then press DELETE . See [Figure 14-3](text00026.html#ch14fig3)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)![](Image00273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Deleting the Game template’s* Hello, World! *label*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we’ve created the project and removed the *Hello, World!* label, we
    can get down to business—the business of fun, that is!
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**ADDING IMAGES**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First, you’ll want to add all of the images to your project as assets. (An asset
    is just a thing in your game, such as a sprite or a sound effect.)
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Download the ZIP file from *[https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)*
    . Once the download is complete, you’ll have a folder named *ch14-images* inside
    your *Downloads* folder with all the image files you need.
  prefs: []
  type: TYPE_NORMAL
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To add the image files to your project, you’ll need to drag them from Finder
    into Xcode and drop them into an asset catalog. (An asset catalog is a special
    type of folder in an Xcode project that holds and organizes project resources
    such as image files and icons.) It is helpful for images because it groups together
    related image files. Once the files are in the asset catalog, you can use them
    anywhere in your code by referring to their filenames. The Game template we used
    comes with one asset catalog already, called *Assets.xcassets* , which is the
    catalog we’ll use.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)![](Image00274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click *Assets.xcassets* in the Project navigator. You should see the existing
    assets, AppIcon, and spaceship image. You can delete the spaceship image, since
    we won’t be using it. Click it and then press DELETE .
  prefs: []
  type: TYPE_NORMAL
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now open Finder and navigate to the folder where the image files were downloaded.
    Press ⌘ -A to select them all. Once they’re highlighted, drag them into the Xcode
    asset catalog, as shown in [Figure 14-4](text00026.html#ch14fig4) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)![](Image00275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Adding the image files to your project’s asset catalog*'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You might have noticed that all of the image files are *.png* files. *PNG* stands
    for *Portable Network Graphics* , and it is the most common image file type used
    in iOS applications because it has the smallest file size for the best quality
    image. You could use *.jpg* files, but *.png* files are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**THE SCENERY: DISPLAYING A BACKGROUND IMAGE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that you’ve added all the images to the project, let’s write some code to
    display the background image in our app.
  prefs: []
  type: TYPE_NORMAL
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you created a new project using the Game template, some helpful code was
    automatically added to your project. Click the file named *GameScene.swift* in
    the Project navigator. You should see a bunch of code already there. This code
    is there for two reasons. First, it gives you an example of how to create a shape
    (the spinning box) and how to perform an action (making the box spin). Second,
    it lets you immediately run a new project and make sure that everything is set
    up properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, we’re going to remove most of that code and add our own code.
    Go ahead and delete everything in *GameScene.swift* , except for the declaration
    of the didMove(to:) function and the update(_:) function, so that it looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameScene.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Most of the logic in our game will be in the GameScene class. Think of a scene
    as one view or screen in your app. The GameScene class will manage everything
    that happens within the scene—how the sprites should be displayed, how the player
    will interact with the game, and how scoring will happen. Complex games may have
    many separate scenes—for example, a title scene, a menu scene, a game scene, and
    a settings scene. Our game will have just one scene: the game scene.'
  prefs: []
  type: TYPE_NORMAL
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Scene classes will usually have setup functions (stuff that happens once), a
    game loop or update functions (stuff that happens over and over again during the
    game), and user interaction functions (stuff that happens only when the user taps
    or swipes).
  prefs: []
  type: TYPE_NORMAL
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The setup function didMove(to:) is called when your game first starts. It’s
    great for code that sets up the scene, such as the code that adds the initial
    sprites or sets the player’s score and lives. It’s similar to the viewDidLoad()
    method that you used to set up the date picker in the AddBirthdayViewController
    in [Chapter 10](text00021.html#ch10) , and it’s called just once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we add the background image to the scene, we have to set the anchorPoint
    of the scene. Add this line of code to the didMove(to:) method (the gray lines
    indicate some of the existing code, for placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)![](Image00276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scene’s anchor point determines how sprites will be positioned in
    the scene. When you pin a piece of paper to a corkboard with a pushpin, the pushpin
    is the anchor point. The piece of paper will be positioned where you put the pushpin,
    and if the paper rotates, it will rotate around the pushpin. This is exactly how
    the anchorPoint property works with sprites and scenes in SpriteKit. The Game
    template’s GameScene has its anchor point in the middle of the scene, but we want
    the anchor point to be in the lower left of the scene, so we set it to CGPoint.zero
    , or (0, 0). For some games, such as a space shooter, it’s better to have the
    anchor point in the middle of the scene. But for our game, where the ground is
    on the bottom of the screen, moving the anchor point to the lower left will make
    it easier to work with. See [Figure 14-5](text00026.html#ch14fig5) for an illustration
    of various anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)![](Image00277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Various locations of anchor points ranging from (0, 0) to (1,
    1)*'
  prefs: []
  type: TYPE_NORMAL
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In our scene, when we place a sprite at an x-position of 0, it will be at the
    left edge of the screen. And when we place a sprite at a y-position of 0, it will
    be at the bottom edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*We’ll be building each code file for the projects step-by-step. The final
    versions are available from* [https://www.nostarch.com/iphoneappsforkids/](https://www.nostarch.com/iphoneappsforkids/)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**ANCHOR POINTS FOR SPRITES**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the anchor point of a sprite, changing how that sprite gets
    positioned and how it rotates. See [Figure 14-6](text00026.html#ch14fig6) for
    an example of rotating a sprite with different anchor points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The anchor point of a sprite determines how it will rotate.*'
  prefs: []
  type: TYPE_NORMAL
- en: Sprites normally have their anchor point in the center. We won’t be changing
    any sprite anchor points, so we will always position sprites using their center
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, to load our background image, add the following lines of code to the didMove(to:)
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let’s walk through the five lines of code we just added. The line at ➊ creates
    a sprite called background , using either the *[background@2x.png](mailto:background@2x.png)*
    file or the *[background@3x.png](mailto:background@3x.png)* file. Both files were
    added to the asset catalog earlier and Xcode will choose the right file automatically.
    You simply have to refer to it in code as "background" or "background.png" . To
    understand how Xcode picks the right file, see “[Sizing Images for Different Screen
    Resolutions](text00026.html#ch14lev1sec7) ” on [page 213](text00026.html#page_213)
    . Note that the variable name does not have to match the image name—you can use
    whatever you want for the variable name. The image name, however, must match a
    file that you added to an asset catalog in your project. SKSpriteNode is the sprite
    class in SpriteKit, so when we create a sprite in our game, we’ll be creating
    an SKSpriteNode , as we did here.
  prefs: []
  type: TYPE_NORMAL
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The lines at ➋ and ➌ create the constants xMid and yMid , which will represent
    the middle position of the screen. frame is a property of GameScene —it’s a CGRect
    (a rectangle) that represents the entire screen. Every scene and sprite has a
    frame that describes where it is on the screen. A frame has an x-position, a y-position,
    a width, and a height (see [Figure 14-7](text00026.html#ch14fig7) ). The midX
    property gives us the middle x-position of the screen’s frame, and midY gives
    us the middle y-position.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)![](Image00279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: A frame describes the position and size of a sprite.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➍ sets the position of our background image to the middle of the
    screen by creating a CGPoint using xMid and yMid and assigning it to the sprite’s
    position property.
  prefs: []
  type: TYPE_NORMAL
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A CGPoint is a struct that holds two CGFloat values, which represent x- and
    y-coordinates. When you’re dealing with screen coordinates, you typically use
    CGFloat as the data type instead of Float or Double . A single CGPoint can hold
    two values, one for *x* and one for *y* , which makes it convenient for dealing
    with screen coordinates in a 2D game where everything is positioned using both
    x- and y-positions.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Anything that begins with* CG *comes from the* Core Graphics framework*, an
    Apple framework used for graphics. You’ll notice this kind of naming system a
    lot in Swift—the first two or three letters of a class or struct often tell you
    what that object is used for or where it comes from. For example, all the SpriteKit
    classes, such as* SKSpriteNode *, start with* SK *.*'
  prefs: []
  type: TYPE_NORMAL
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line at ➎ adds the background image to the scene by calling the function
    addChild(_:) . This sprite is now a *child* of the scene, which means it is attached
    to this scene. For instance, if the scene grows, shrinks, or goes away, this child
    sprite will, too. In a SpriteKit game, the scene is always the parent object,
    and every sprite is added as a child of that scene or as a child of another sprite.
    Whenever you add a sprite, it’s important to think about what that sprite’s parent
    should be. For example, the skater sprite is a child of the scene, but if we wanted
    to add interchangeable hats onto the skater, we would use a hat sprite that is
    a child of the skater sprite. That way, whenever the skater jumped, the hat would
    stay on the skater, and we wouldn’t have to also move the hat separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**HOW IT WILL BE PLAYED: SCREEN ORIENTATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It takes more work to create a game that runs in both portrait and landscape
    modes, so it’s often best to decide which orientation is best for your game and
    just pick that one. Since our game is an action game that scrolls horizontally,
    landscape orientation (where the device is on its side, as shown in [Figure 14-8](text00026.html#ch14fig8)
    ) makes the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)![](Image00280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: How our game looks in portrait versus landscape orientation*'
  prefs: []
  type: TYPE_NORMAL
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Try running the project now, using the iPhone 7 simulator, and you’ll notice
    it may default to portrait orientation. Let’s change the project settings so the
    game runs only in landscape. Go to the Project navigator and click the **SchoolhouseSkateboarder**
    project—it’s at the top of the Project navigator with a blue icon next to it,
    as you can see in [Figure 14-9](text00026.html#ch14fig9) .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)![](Image00281.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)![](Image00282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Access the project settings by clicking the project entry in
    the Project navigator.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Figure 14-10](text00026.html#ch14fig10) , you can see a list of projects
    and targets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)![](Image00283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Uncheck the Portrait option, leaving both Landscape orientation
    options checked.*'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you don’t see the list of Projects and Targets on your screen, click the
    square icon in the upper-left corner of the window, as shown in [Figure 14-10](text00026.html#ch14fig10)
    . This list will appear and the icon will turn blue to indicate that the list
    area is now being shown. Make sure the **SchoolhouseSkateboarder** target is selected.
    Now find the **Portrait** checkbox and uncheck it. Leave the Landscape orientation
    options checked.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Run the game again, and you’ll see it launches in landscape orientation. We’re
    getting closer, but the background image doesn’t yet fill the screen. We’ll see
    how to fix this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With the game now running in landscape orientation, you need to make sure that
    your simulator is also in landscape orientation. To rotate it, select **Hardware**
    ▸ **Rotate Right** from the simulator’s menu, as shown in [Figure 14-11](text00026.html#ch14fig11)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)![](Image00284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Rotating the simulator orientation to match the game*'
  prefs: []
  type: TYPE_NORMAL
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**SIZING IMAGES FOR DIFFERENT SCREEN RESOLUTIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before we dive into the code, we should decide which devices and screen resolutions
    we’ll support. The more devices you support, the more you’ll have to deal with
    different screen sizes, which means you need to do extra work to ensure the artwork
    assets you create will display properly on each device. Games tend to require
    more effort in this area than UIKit-based apps like our Birthday Tracker because
    game artwork will look stretched out if you just scale it up or down. To avoid
    that problem, you’ll have to work with a different set of images for each device
    you want to support.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)![](Image00285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xcode has a system for naming image files to help you tell which images are
    for which devices. For example, suppose you wanted to add an image of a skater
    to your game, and you had a skater image file that was 100 pixels wide and 100
    pixels tall (100×100). You would name that image *skater.png* . You’d also need
    to create an image named *[skater@2x.png](mailto:skater@2x.png)* that is 200×200
    pixels, and another image named *[skater@3x.png](mailto:skater@3x.png)* that is
    300×300 pixels. These three files should be the same image in three different
    sizes. If the game is run on an iPhone 4, the *@2x* file will automatically be
    used thanks to the handy *@2x* suffix. If the game runs on an iPhone 6 Plus, the
    *@3x* file will automatically be used. In your code, you can just refer to the
    file as skater , and as long as you’ve correctly named the images in your project,
    Xcode will display the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For Schoolhouse Skateboarder, we’ll support everything from the iPhone 4 on.
    That means we’ll need to support the following four screen resolutions: 960×640,
    1136×640, 1334×750, and 1920×1080.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the images we’re using have a suffix, such as* @2x *or* @3x*. An image
    without a suffix, such as* skater.png*, is considered to be a 1x image. You only
    need to include 1x-sized images for older devices that have a non-retina display,
    such as an iPhone 3GS or a first-generation iPad mini. Therefore, all of our image
    files will have the* @2x *or* @3x *suffix.*'
  prefs: []
  type: TYPE_NORMAL
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our background image files are named *[background@2x.png](mailto:background@2x.png)*
    and *[background@3x.png](mailto:background@3x.png)* . If you look at the *Assets.xcassets*
    asset catalog, you’ll notice that Xcode grouped these two images together. If
    you drag images at the same time into an Xcode asset catalog, Xcode automatically
    recognizes that they are different sizes of the same image because of how they
    are named and groups them together. See [Figure 14-12](text00026.html#ch14fig12)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)![](Image00286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Images with multiple sizes are grouped together in the asset
    catalog.*'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have one last bit of prep to take care of before moving on from the background
    image. You may have noticed that when you run the game using the iPhone 7 simulator,
    the background image doesn’t fill the entire screen, as shown in [Figure 14-13](text00026.html#ch14fig13)
    . This is because of the way the Game template handles sizing a game scene. The
    game scene’s size will be set based on the settings in the *GameScene.sks* scene
    editor file that was included in our project. We won’t be using the scene editor
    in this project, so we need to add code in order to make sure our scenes are sized
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)![](Image00287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: The background image doesn’t fill the entire screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click the *GameViewController.swift* file in the Project navigator and find
    the viewDidLoad() method. Add the following lines of code that set the scene’s
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*GameViewController.swift*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code in the viewDidLoad() method creates an instance of the GameScene class
    and displays it. Since the GameScene is the main scene of our game, we want it
    to always fill the entire screen. The code that we added here determines the size
    (width and height) of the view being displayed, and sets the size of the new scene
    so that it fills the entire view.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Run the project again. The background image should fill the entire screen now.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you started making the Schoolhouse Skateboarder game and learned
    about SpriteKit. You learned how to create a game project in Xcode and import
    assets, such as images, into the project. You also learned about supporting various
    device screen resolutions through standard file naming practices and about how
    to pick what image types you’ll need in a game. Finally, you created and displayed
    a background image sprite.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we’ve set up a SpriteKit game project with the resources we need and
    tackled the questions of screen orientation and resolution, it’s time to program
    some action. In [Chapter 15](text00027.html#ch15) , we’ll add our hero and the
    ground that she skates on, make everything move, and let the player tap on the
    screen to make her jump.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00288.jpg)![](Image00288.jpg)'
  prefs: []
  type: TYPE_IMG
