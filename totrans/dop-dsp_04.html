<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="25" id="Page_25"/>3</span><br/>
<span class="ChapterTitle">Using Ansible to Configure SSH</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro"><em>SSH</em> is a protocol and tool that provides command line access to a remote host from your own machine. If you are managing a remote host or a fleet of remote hosts, the most common way to access them is over SSH. Most servers are likely to be headless, so the easiest way to access them is from a terminal. Since SSH opens access to a host, misconfiguration or default installations can lead to unauthorized access. As with a lot of Linux services out of the box, the default security settings are adequate for most cases, but you will want to know how to increase security and then automate it. As an engineer, you should understand the steps required to lock down SSH on a host or hosts.</p>
<p><span epub:type="pagebreak" title="26" id="Page_26"/>In this chapter, you’ll learn how to use Ansible to secure SSH access to your VM. You’ll do this by disabling password access over SSH, requiring public key authentication over SSH, and enabling two-factor authentication (2FA) over SSH for your user <em>bender</em>. You’ll use a combination of some familiar Ansible modules, and you’ll be introduced to some new ones. By the end of this chapter, you’ll have a better understanding of how to enforce strict access to SSH and the automation steps required to do so. </p>
<h2 id="h1-502482c03-0001">Understanding and Activating Public Key Authentication</h2>
<p class="BodyFirst">Most Linux distributions use passwords to authenticate over SSH by default. Although this is okay for many setups, you should beef up security by adding another option: <em>public key authentication</em><em>.</em> This method uses a key pair, consisting of a public key file and a private key file, to confirm your identity. Public key authentication is considered best practice for authenticating users over SSH because potential attackers who want to hijack a user’s identity need both a copy of a user’s private key and the passphrase to unlock it.</p>
<p>When you create an SSH session with a key, the remote host encrypts a <em>challenge</em> with your public key and<em> </em>sends the challenge back to you. Because you are in possession of the private key, you can decode the message and send back a response to the remote server. If the server can validate the response, it will know you are in possession of the private key and will thus confirm your identity. To learn more about the key exchange and SSH, visit <a href="https://www.ssh.com/academy/ssh/" class="LinkURL">https://www.ssh.com/academy/ssh/</a>. </p>
<h3 id="h2-502482c03-0001">Generating a Public Key Pair</h3>
<p class="BodyFirst">To generate a key pair, you’ll use the <code>ssh-keygen</code> command line tool. This tool, usually installed on Unix hosts by default as part of the <code>ssh</code> package, generates and manages authentication key pairs for SSH. There’s a good chance you already have a public key pair on your local host, but for this book, let’s create a new key pair so you don’t interfere with it. You’ll also add a passphrase to the private key. A <em>passphrase</em> is like a password, but it’s usually longer (more like a group of unrelated words than a complex stream of characters). You add it so that if your private key ever fell into the wrong hands, the bad actors would need to have your passphrase to unlock it and spoof your identity. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The following instructions are for Linux and macOS only. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>In a terminal on your local host, enter the following command to generate a new key pair:</p>
<pre><code>$ <b>ssh-keygen -t rsa -f ~/.ssh/dftd -C dftd</b>
Generating public/private rsa key pair.
Enter passphrase (empty for no passphrase): <var class="bold">&lt;passphrase&gt;</var>
<span epub:type="pagebreak" title="27" id="Page_27"/>Enter same passphrase again: <var class="bold">&lt;passphrase&gt;</var>
Your identification has been saved in /Users/bradleyd/.ssh/dftd.
Your public key has been saved in /Users/bradleyd/.ssh/dftd.pub.</code></pre>
<p>You first instruct <code>ssh-keygen</code> to create an <code>rsa</code> key pair that has a name of <code>dftd</code> (DevOps for the Desperate). If you do not specify a name, it defaults to <em>id_rsa</em>, which might override your existing local key. The <code>-C</code> flag adds a human-readable comment to the end of the key that can help identify what the key is for. Here, it’s also set to <code>dftd</code>. During execution, the command should prompt you to secure your key by adding a passphrase. Enter a strong passphrase to protect the key. Also remember to always keep your passphrase safe, because if you lose it, your key will become forever locked and you will never be able to use it for authentication again.</p>
<p>After you confirm the passphrase, the private key and public key files are created under your local <em>~./ssh/</em> directory. </p>
<h3 id="h2-502482c03-0002">Using Ansible to Get Your Public Key on the VM</h3>
<p class="BodyFirst">Each user’s home folder on the VM has a file called <em>authorized_keys</em><em>.</em> This file contains a list of public keys the SSH server can use to authenticate that user. You’ll use this file to authenticate <em>bender</em> when accessing the VM over SSH. To do this, you need to copy the local public key you just created in the previous section (<em>/Users/bradleyd/.ssh/dftd.pub, </em>in my case) and append the contents of that file to the <em>/home/bender/.ssh/authorized_keys</em> file on the VM.</p>
<p>To copy the file’s content, you’ll use a provided Ansible task. This task and all the other tasks related to this chapter are located in the cloned repository under the <em>ansible/chapter3/</em> directory. </p>
<p>Open the <em>authorized_keys.yml</em> file in your favorite editor to review the Ansible task. The first thing you should notice is that this file has only one task. It should look like this:</p>
<pre><code>- name: Set authorized key file from local user
  authorized_key:
    user: bender
    state: present
    key: "{{ lookup('file', lookup('env','HOME') + '/.ssh/dftd.pub') }}"</code></pre>
<p>First, set the <code>name</code> of the task to identify its intent. Use the Ansible <code>authorized_key</code> module to copy your public key from the local host over to <em>bender</em> on the VM. The <code>authorized_key</code> module is quite simple and requires that you set only the <code>user</code> and <code>key</code> parameters. In this example, it copies the local public key you made earlier into <code>bender</code>’s <em>/home/bender/.ssh/authorized_keys</em> file. Set the <code>state</code> to <code>present</code>, as you want to add the key and not remove it. </p>
<p>To get the contents of the local public key, you’ll use Ansible’s evaluation expansion operators (<code>{{</code> <code>}}</code>) and a built-in Ansible function called <code>lookup</code><em>. </em>The <code>lookup</code> function retrieves information from outside resources, based on the plug-in specified as its first argument. In this example, <code>lookup</code> uses the <code>file</code> plug-in to read the contents of the <em>~/.ssh/dftd.pub</em> public key file. The full path to this public key file is constructed with the <code/><span epub:type="pagebreak" title="28" id="Page_28"/>lookup <code>env</code> plug-in and string concatenation denoted by the <em>+ </em>sign. The final result should look similar to this if you’re on a Mac: <em>/Users/bradleyd/.ssh/dftd.pub</em>. If you are on Linux, it should like similar to this: <em>/home/bradleyd/.ssh/dftd.pub</em>. The file path will be different, depending on your OS and username.</p>
<h2 id="h1-502482c03-0002">Adding Two-Factor Authentication</h2>
<p class="BodyFirst">Security is built in layers. The more layers you have, the harder it is for an intruder to gain access. The next layer of security to add is <em>two-factor authentication (2FA</em><em>)</em>, which validates a user’s identity by using credentials and something that the user has, like a phone or device. The main goal of 2FA is to make it harder for someone to spoof your identity if your password or key is compromised.</p>
<p>Two-factor authentication relies on your providing two out of these three things: <em>something you know</em>, <em>something you have</em>, and <em>something you are</em>. Here are some examples of each:</p>
<ol class="none">
<li>Something you know: password or pin</li>
<li>Something you have: phone or hardware authentication device, such as a YubiKey</li>
<li>Something you are: fingerprint or voice</li>
</ol>
<p>For this example, you’ll use a <em>time-based one-time password (TOTP)</em> to satisfy the “something you have” portion, along with your public key for access. You’ll use the <code>Google Authenticator</code> package to configure your VM to use TOTP tokens for logging in. These TOTP tokens are usually generated from an application like <code>oathtool</code> (<a href="https://www.nongnu.org/oath-toolkit/" class="LinkURL">https://www.nongnu.org/oath-toolkit/</a>) and are valid for only a short period of time. I have taken the liberty of creating 10 TOTP tokens that Ansible will use for you, but I will also show you how to use <code>oathtool</code> (more on this later).</p>
<p>To enforce 2FA on your VM, you’ll use some provided Ansible tasks to install another PAM module, configure the SSH server, and enable 2FA. To review the provided tasks, first open the <em>two_factor.yml</em> file in your editor. (All the Ansible files for this chapter are located in the <em>ansible/chapter3/</em> directory.) This file has seven tasks, and each task has a specific job to enable 2FA. The tasks are named as follows:</p>
<ol class="decimal">
<li value="1">Install the <code>libpam-google-authenticator</code> package.</li>
<li value="2">Copy over preconfigured <code>GoogleAuthenticator</code> config.</li>
<li value="3">Disable password authentication for SSH.</li>
<li value="4">Configure PAM to use <code>GoogleAuthenticator</code> for SSH logins.</li>
<li value="5">Set <code>ChallengeResponseAuthentication </code>to <code>Yes</code>.</li>
<li value="6">Set Authentication Methods for <em>bender</em>, <em>vagrant</em>, and <em>ubuntu</em>.</li>
<li value="7">Insert an additional line here that reads: Restart SSH Server.</li>
</ol>
<p>We’ll look at each of these tasks in the following sections.</p>
<h3 id="h2-502482c03-0003"><span epub:type="pagebreak" title="29" id="Page_29"/>Installing Google Authenticator</h3>
<p class="BodyFirst"><code>Google Authenticator</code> is a PAM module that allows you to enforce 2FA over SSH. This module is located in the Ubuntu software repository under the name <code>libpam-google-authenticator</code>. The package contains all the necessary files to enable <code>Google Authenticator</code>. With the <em>two_factor.yml</em> file still open, find the first task at the top. It should look like this:</p>
<pre><code>- name: Install the libpam-google-authenticator package
  apt:
    name: "libpam-google-authenticator"
    update_cache: yes
    state: present</code></pre>
<p>The <code>name</code> on the first line identifies the task’s intent (installing a package). You’ll use Ansible’s <code>apt</code> module to install the OS package. The <code>apt</code> module also requires the following <code>name</code> parameter to be set, and in this example, it is set to the package name <code>libpam-google-authenticator</code>. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">note</span></h2>
<p> 	I chose to use the <code>apt</code> module because it’s the default on Ubuntu, and it updates the OS’s package manager cache before installing the <code>libpam</code><code>-google-authenticator</code><em> </em>package. The <em>package cache</em> is like a list of software titles that the OS knows about. If the package manager cache is stale, <code>apt</code> may not know how to find the package and the task may fail. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Finally, as before, set the <code>state</code> to <code>present</code> since you want to install the package and not remove it. Most Ansible modules have the <code>state</code> set to <code>present</code> as a default, but you are most likely not the only person using these tasks. Letting the other engineers know your intent leaves little room for doubt or error, so even though you could omit this step, it’s always better to be explicit.</p>
<h3 id="h2-502482c03-0004">Configuring Google Authenticator</h3>
<p class="BodyFirst">To configure <code>Google Authenticator</code> for a user, you typically would run the <code>google-authenticator</code> command that was installed from the <code>libpam-google-authenticator</code> package. This application creates a configuration file named <em>.google_authenticator</em> in the user’s <em>home/</em> directory by default. The configuration file consists of a Base32 key (secret); configuration options, such as token reuse and time to live; and 10 emergency recovery tokens. To keep the focus on provisioning, I’ve created the <em>google_authenticator</em> configuration file for you in the <em>chapter3/ </em>directory. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">WARNING</span></h2>
<p>	Do not use this file in the real world, as the secret key and tokens are not so secret. Instead, keep these values safe by storing them in Ansible Vault or another product like HashiCorp’s vault (<a href="https://www.vaultproject.io/" class="LinkURL">https://www.vaultproject.io/</a>). You can also add the <code>no_log</code><code>: True</code> option to any task that might write sensitive information to the provision log.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Since the goal is to automate, you’ll use an Ansible task to copy this configuration file over to the VM. If you’re tempted to think, “It would be easier just to run the command by hand,” remember that in most cases you’ll <span epub:type="pagebreak" title="30" id="Page_30"/>be managing many hosts. Doing that by hand would be tedious and make you error prone.</p>
<p> With the <em>two_factor.yml</em> file still open, locate the task on line 7 of the file that looks like this:</p>
<pre><code>- name: Copy over preconfigured GoogleAuthenticator config
  copy:
    src: ../ansible/chapter3/google_authenticator
    dest: /home/bender/.google_authenticator
    owner: bender
    group: bender
    mode: 0600</code></pre>
<p>As always, the <code>name</code> of the task describes its intent (copy a file). The Ansible <code>copy</code> module copies the configuration file from your local host to the VM. Use the <code>copy</code> module when you need to copy a file from a source to a destination. (The source can be either local or remote.) The <code>copy</code> module requires you to set the <code>src</code> and <code>dest</code> parameters. In this case, the <code>src</code> field is set to the local <em>google_authenticator</em> file in the cloned repository (<a href="https://github.com/bradleyd/devops_for_the_desperate/" class="LinkURL">https://github.com/bradleyd/devops_for_the_desperate/</a>). Notice the two dots (<code>..</code>) in the beginning of the source (<em>src</em>) file. These dots indicate that the file is located one directory up from the current <em>vagrant/</em> directory, where the <code>ansible</code> command is run. Without these dots, the <code>ansible-playbook</code> command would not be able to find the <em>ansible/</em> directory where the file is located. The <code>dest</code> parameter is set to the file named <em>/home/bender/.google_authenticator </em>on the VM. The file permission, or <code>mode</code>, is set to read and write (<code>0600</code>), so only the owner of the file, <em>bender</em>, can read and write to it. </p>
<p>To learn more about <code>Google Authenticator</code>, visit <a href="https://github.com/google/google-authenticator/wiki/" class="LinkURL">https://github.com/google/google-authenticator/wiki/</a><em>.</em></p>
<h3 id="h2-502482c03-0005">Configuring PAM for Google Authenticator</h3>
<p class="BodyFirst">As mentioned in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>, PAM controls a lot of authorization and authentication methods in Linux. To be able to use <code>Google Authenticator</code> over SSH, you need to modify the SSH PAM configuration file, which is very similar to what you did in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>. To add <code>Google Authenticator</code> to PAM, you’ll need to make changes to the module file located at <em>/etc/pam.d/sshd</em>. This file controls how PAM interacts with the SSH server (more on that later).</p>
<p>You’ll use two provided Ansible tasks that disable password prompts over SSH and tell PAM where it can find the <code>Google Authenticator</code> file (<em>pam_google_authenticator.so</em>). Remember, you want to force users to use public key authentication in lieu of passwords. This change will also make it harder for attackers to brute-force SSH with a password since you will not allow it. </p>
<p>With the <em>two_factor.yml</em> file still open, locate the first of the two tasks that configure PAM (on line 15). It should look like this:</p>
<pre><code>- name: Disable password authentication for SSH
  lineinfile:
    dest: "/etc/pam.d/sshd"
    regex: "@include common-auth"
    line: "#@include common-auth"</code></pre>
<p><span epub:type="pagebreak" title="31" id="Page_31"/>This task disables <code>password</code> prompts for SSH via the PAM module. To edit the PAM <em>sshd</em> file, this task uses the familiar Ansible <code>lineinfile</code> module, which locates the <code>common-auth</code> line with a regular expression (<code>regex</code>) and comments it out with a <em>#</em> sign. In this case, the regular expression searches for the full <code>common-auth</code> line. By commenting out that line, SSH <code>password</code> prompts for users are disabled when logging in over SSH.</p>
<p>The second task that will configure PAM, located on line 21, should look like this: </p>
<pre><code>- name: Configure PAM to use GoogleAuthenticator for SSH logins
  lineinfile:
    dest: "/etc/pam.d/sshd"
    line: "auth required pam_google_authenticator.so nullok"</code></pre>
<p>This task tells PAM about the <code>Google Authenticator</code> module. It uses the Ansible <code>lineinfile</code> module again to edit the PAM <em>sshd</em> file. This time, you just want to add the <code>auth</code> line to the bottom of the PAM file, which lets PAM know it should use <code>Google Authenticator</code> as an authentication mechanism. The <code>nullok</code> option at the end of the line tells PAM that this authentication method is optional, which allows you to avoid locking out users until they have successfully configured 2FA. In a production environment, you should remove the <code>nullok</code> option once all users have enabled 2FA. </p>
<h3 id="h2-502482c03-0006">Configuring the SSH Server</h3>
<p class="BodyFirst">The SSH server manages all the SSH connections from the clients and enforces specific rules governing those connections. The SSH server will require some changes to expect a 2FA response, since that’s not a default configuration. </p>
<p>First, you’ll want to use Ansible to enable a keyboard response prompt when authenticating over SSH. The option to set is called <code>ChallengeResponseAuthentication</code>, and it’s needed so users can enter the two-factor verification code when logging in. </p>
<p>The second change Ansible will make is to set the SSH users’ <code>AuthenticationMethods</code>, which enable the SSH server to enforce specific ways for users to authenticate themselves. For this example, you’ll set the <code>AuthenticationMethods</code> for <em>bender</em> to be <code>publickey</code> and <code>keyboard-interactive</code>. This will force <em>bender</em> to need a public key and a TOTP token to log in. You’ll also set the <em>vagrant</em> and <em>ubuntu</em> users’ <code>AuthenticationMethods</code> only to <code>publickey</code> to log in, so you’ll still have users that can access the VM if anything goes wrong with 2FA.</p>
<p>With the <em>two_factor.yml</em> file still open, let’s review the two tasks that modify the VM’s SSH server. The first of these tasks, on line 26, should look like this:</p>
<pre><code>- name: Set ChallengeResponseAuthentication to Yes
  lineinfile:
    dest: "/etc/ssh/sshd_config"
    regexp: "^ChallengeResponseAuthentication (yes|no)"
    line: "ChallengeResponseAuthentication yes"
    state: present</code></pre>
<p><span epub:type="pagebreak" title="32" id="Page_32"/>The task sets the <code>ChallengeResponseAuthentication</code> to <code>yes</code>. It uses the <code>lineinfile</code> module again to change a line in the VM’s SSH server config file. It locates the line using a regular expression that searches for the <code>ChallengeResponseAuthentication</code> option at the beginning of a line that is set to <code>yes</code> or <code>no</code>. Once it finds the line, it sets the line to <code>ChallengeResponseAuthentication</code><code> yes</code> to enable keyboard interactivity for 2FA.</p>
<p>The last task in the file that configures the SSH server should look like this:</p>
<pre><code>- name: Set Authentication Methods for bender, vagrant, and ubuntu
  blockinfile:
    path: "/etc/ssh/sshd_config"
    block: |
      Match User "ubuntu,vagrant"
          AuthenticationMethods publickey
      Match User "bender,!vagrant,!ubuntu"
          AuthenticationMethods publickey,keyboard-interactive
    state: present
  notify: "Restart SSH Server"</code></pre>
<p>This task sets the authentication methods for users using the <code>blockinfile</code> module. Similar to <code>lineinfile</code>, <code>blockinfile</code> can manipulate a block of text. This is useful when you need to change multiple lines at once and preserve indentation inside a file. The <code>blockinfile</code> module requires that the <code>path</code> parameter be set. In this case, the <code>path</code> of the file to edit is <em>/etc/ssh/sshd_config</em>. The pipe character (<code>|</code>) is YAML notation for introducing a multiline string: the block of text, where the task uses an SSH server configuration option called <code>Match</code> that allows you to apply certain criteria to specific users. In this example, you want to allow the <em>ubuntu</em> and <em>vagrant</em> users to use <code>publickey</code> authentication only when logging in over SSH. Then you want to set the authentication methods for <em>bender</em> to be <code>publickey</code> and <code>keyboard-interactive</code>, to enforce 2FA. Finally, this example sets a <code>notify</code> action to <code>"Restart SSH Server"</code> on this task. (I’ll discuss the <code>notify</code> option next.)</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The <em>sshd_config</em> file includes options to disable password prompts and PAM. You want to leave these options commented out, or not used, as you want to funnel all your authentication through PAM to keep with system defaults for accounting and sessions.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-502482c03-0007">Restarting the SSH Server with a Handler</h3>
<p class="BodyFirst">Editing the configuration file is not enough; the SSH server requires a restart for all the changes to take effect. To make that happen, you’ll use the <code>notify</code> Ansible option that triggers a <code>handler</code> to perform a single task. A <code>handler</code> is just like any other task, but it’s executed only once and has a globally unique name across the whole playbook. </p>
<p><span epub:type="pagebreak" title="33" id="Page_33"/>The last Ansible task in <em>two_factor.yml</em> activates a <code>handler</code> that restarts the SSH server for you. Open the <em>handlers/restart_ssh.yml</em> file found in the <em>ansible/</em> directory. It should look like this:</p>
<pre><code>- name: Restart SSH Server
  service:
    name: sshd
    state: restarted</code></pre>
<p>This <code>handler</code>’s <code>name</code> is set to <code>Restart SSH Server</code>. This <code>name</code> matches the <code>notify</code> value from the previous task (<code>Set Authentication Methods for bender</code>, <code>vagrant, and ubuntu</code>). This is not an accident. The values must match exactly to be triggered. The <code>service</code> module restarts the SSH server. This module requires the <code>name</code> parameter, which is <code>sshd</code> in this case, to be set. Finally, this task sets the <code>state</code> to <code>restarted</code>. If, for some reason, the SSH server does not restart, the task will fail.</p>
<p>You’re now finished with the Ansible tasks, so it’s safe to close all the open files. </p>
<h2 id="h1-502482c03-0003">Provisioning the VM</h2>
<p class="BodyFirst">To provision the VM with all the tasks described thus far, you’ll need to uncomment them in the playbook. You’ll follow essentially the same process that you followed in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>, but this time around, you’ll need to uncomment two tasks and a <code>handler</code>. Open the <em>site.yml</em> file in your editor and locate the task for authorized keys, which should look like this:</p>
<pre><code><b>#- </b><b>import_tasks</b><b>: chapter3/</b><b>authorized_keys.yml</b></code></pre>
<p>Remove the <code>#</code> symbol to uncomment it. </p>
<p>Next, find the task for 2FA:</p>
<pre><code><b>#- </b><b>import_tasks</b><b>: chapter3/</b><b>two_factor.yml</b><b> </b></code></pre>
<p>Remove the <code>#</code> symbol to uncomment that line as well. </p>
<p>Next, find the <code>handler</code> section that’s located below all the tasks. The <code>handler</code> to restart the SSH server should look like this:</p>
<pre><code><b>#- </b><b>import_tasks</b><b>: handlers/</b><b>restart_ssh.yml</b></code></pre>
<p>Remove the <code>#</code> symbol at the beginning of the line to uncomment it.</p>
<p>The playbook should now look like this:</p>
<pre><code>- name: Provision VM
  hosts: all
  become: yes
  become_method: sudo
  remote_user: ubuntu
  tasks:
    - import_tasks: chapter2/pam_pwquality.yml
<span epub:type="pagebreak" title="34" id="Page_34"/>    - import_tasks: chapter2/user_and_group.yml
    <b>- import_tasks: chapter3/authorized_keys.yml</b>
<b>    - import_tasks: chapter3/two_factor.yml</b>
  <var>--snip--</var>
  handlers:
<b>    - import_tasks: handlers/restart_ssh.yml</b></code></pre>
<p>Here, the changes to the playbook for Chapter 3 are added on to the changes from <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>. As mentioned previously, the playbook is a collection of tasks that will perform specific actions on a host or group of hosts to enforce a specified state.</p>
<p>Now, you’ll automate the configuration of the VM using Vagrant. Navigate to the <em>vagrant/</em> directory, and once there, enter the following command:</p>
<pre><code>$ <b>vagrant</b> <b>provision</b>
<var>--snip--</var>
PLAY RECAP *********************************************************************
default    : ok=16   changed=9   unreachable=0   failed=0   skipped=0   rescued=0   ignored=0</code></pre>
<p>Notice that the total task count has increased to <code>16</code> since the last provision. You have also changed a total of <code>9</code> things on the VM. Here’s a summary of the things that changed:</p>
<ul>
<li>Seven new tasks from Chapter 3</li>
<li>One task that updates the empty file from the previous chapter</li>
<li>One <code>handler</code></li>
</ul>
<p>Once again, make sure no actions failed before you continue. The values from the provision output will vary, depending on how many times you run the <code>provision</code> command in this chapter. This is because Ansible is working hard to make sure your environment is consistent, and it doesn’t do extra work that is not needed. As mentioned earlier, Ansible is idempotent, meaning it can be executed several times and each execution completes with the same end state you would expect from the initial execution. </p>
<h2 id="h1-502482c03-0004">Testing SSH Access</h2>
<p class="BodyFirst">With the VM successfully provisioned, you should test <em>bender</em>’s access over SSH. To test public key and 2FA over SSH, you’ll need the private key you created earlier and one of the emergency tokens from the <em>google_authenticator</em> file in the repository. The private key should be located in your local SSH directory. On my Mac, it’s in <em>/Users/bradleyd/.ssh/dftd</em>. The emergency tokens are the 10 eight-digit numbers located at the bottom of the <em>ansible/chapter3/google_authenticator</em><em> </em>file. Choose the first one.</p>
<p>To <code>ssh</code> in to the VM as <em>bender</em>, open a terminal on your local host and enter the following command: </p>
<pre><code>$ <b>ssh</b> <span class="CodeAnnotation" aria-label="annotation1">1</span><b>-i ~/.ssh/dftd</b> <b>-p 2222 </b><span class="CodeAnnotation" aria-label="annotation2">2</span><b>bender@localhost</b>
Enter passphrase for key /Users/bradleyd/.ssh/dftd: <var class="bold">&lt;passphrase&gt;</var>
<span epub:type="pagebreak" title="35" id="Page_35"/>Verification code: <var class="bold">&lt;76338876&gt;</var>
<var>--snip--</var>
bender@dftd:~$</code></pre>
<p>In the <code>ssh</code> command, you set the identity file to your private key <span class="CodeAnnotation" aria-label="annotation1">1</span> for authentication and set the remote SSH port to <code>2222</code>. The default SSH port is 22, but Vagrant listens on a different SSH port to avoid conflicts on your local host. You also set the login user to <em>bender</em> and the SSH host to <code>localhost</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>. </p>
<p>The output indicates you should have been prompted twice during this login session: once to enter the passphrase to unlock your private key, and a second time to enter a 2FA verification code. After satisfying both prompts, you should be successfully logged in to the VM as <em>bender</em>.</p>
<p>If, for some reason, you weren’t prompted for a TOTP token or for the private key passphrase, stop and check for errors. You can log in to the VM as the <em>vagrant</em> user and inspect the logs. A good place to start looking for errors is in either <em>/var/log/auth.log</em> or <em>/var/log/syslog</em><em> </em>on the VM. Common errors include the SSH server not restarting cleanly and one of the configuration files having a syntax issue.</p>
<p>Each of the 10 tokens provided is for one-time use. Every time you successfully use one, it’s removed from the <em>/home/bender/.google_authenticator</em> file. If, for some reason, you burn through all the tokens, run the <code class="bold">vagrant provision</code> command again to replace the file and replenish the tokens. Another option is to use a TOTP application like <code>oathtool</code> and generate a time-based one-time token by using the Base32 secret at the top of the <em>/home/bender/.google_authenticator</em> file. You can install <code>oathtool</code> with Ubuntu’s package manager by using the <code class="bold">apt install oathtool</code> command. Every time you need a token, you can use the following command:</p>
<pre><code>$ <b>oathtool --totp --base32 "QLIUWM4UVD7E5SI6PPVZ2EGRFU"</b>
097903</code></pre>
<p>Here, you pass <code>oathtool</code> your Base32 secret in the double quotes and set the flags <code>--totp</code> and <code>--base32</code> to generate the token. In this result, the token <code>097903</code> is generated and can be used when prompted for a verification code. Feel free to use this method or the provided tokens when logging in.</p>
<h2 id="h1-502482c03-0005">Summary</h2>
<p class="BodyFirst">In this chapter, you secured the VM by disabling password logins, requiring public key authentication, and enforcing 2FA for <em>bender</em>. Automating these simple steps improves your host’s security, whether it’s local or on someone else’s computer in the cloud. As with the previous chapters, these automation tasks are a part of a foundational base that you can employ with all your hosts. In the next chapter, you’ll use more Ansible tasks to control user access by enabling security policies.</p>
</section>
</body></html>