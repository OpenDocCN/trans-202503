- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User Environments
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: This book’s primary focus is on the parts of the Linux system that normally
    underlie server processes and interactive user sessions. But eventually, the system
    and the user have to meet somewhere. Startup files play an important role at this
    point, because they set defaults for the shell and other interactive programs.
    They determine how the system behaves when a user logs in.
  prefs: []
  type: TYPE_NORMAL
- en: Most users don’t pay close attention to their startup files, touching them only
    when they want to add something for convenience, such as an alias. Over time,
    the files become cluttered with unnecessary environment variables and tests that
    can lead to annoying (or quite serious) problems.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve had your Linux machine for a while, you might have noticed that your
    home directory accumulates a bafflingly large array of startup files over time.
    These are sometimes called *dot files* because they nearly always start with a
    dot (*.*), excluding them from the default display of `ls` and most file managers.
    Many of these are automatically created when you first run a program, and you’ll
    never need to change them. This chapter primarily covers shell startup files,
    which are the ones you’re most likely to modify or rewrite from scratch. Let’s
    first look at how much care you need to take when working on these files.
  prefs: []
  type: TYPE_NORMAL
- en: 13.1 Guidelines for Creating Startup Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When designing startup files, keep the user in mind. If you’re the only user
    on a machine, you don’t have much to worry about, because any errors affect only
    you and they’re easy enough to fix. However, if you’re creating startup files
    meant to be the defaults for all new users on a machine or network, or if you
    think that someone might copy your files for use on a different machine, this
    process becomes considerably more critical. If you make an error in a startup
    file and distribute it to 10 users, you might end up fixing this error 10 times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep two essential goals in mind when creating startup files for other users:'
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity Keep the number of startup files small, and keep the files as short
    and simple as possible so that they’re easy to modify but hard to break. Each
    item in a startup file is just one more thing that can break.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Readability Use extensive comments in files so that the users get a good picture
    of what each part of a file does.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 13.2 When to Alter Startup Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before making a change to a startup file, ask yourself whether you really should
    be making it. Here are some good reasons for changing startup files:'
  prefs: []
  type: TYPE_NORMAL
- en: You want to change the default prompt.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to accommodate some critical locally installed software. (Consider
    using wrapper scripts first, though.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your existing startup files are broken.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If everything in your Linux distribution works, be careful. Sometimes the default
    startup files interact with other files in */etc*.
  prefs: []
  type: TYPE_NORMAL
- en: That said, you probably wouldn’t be reading this chapter if you weren’t interested
    in changing the defaults, so let’s examine what’s important.
  prefs: []
  type: TYPE_NORMAL
- en: 13.3 Shell Startup File Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What goes into a shell startup file? Some things might seem obvious, such as
    the command path and a prompt setting. But what exactly *should* be in the path,
    and what does a reasonable prompt look like? And how much is too much to put in
    a startup file?
  prefs: []
  type: TYPE_NORMAL
- en: This section discusses the essentials of a shell startup file—from the command
    path, prompt, and aliases through the permissions mask.
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.1  The Command Path
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most important part of any shell startup file is the command path. The
    path should cover the directories that contain every application of interest to
    a regular user. At the very least, the path should contain these components, in
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This order ensures that you can override standard default programs with site-specific
    variants located in */usr/local*.
  prefs: []
  type: TYPE_NORMAL
- en: Most Linux distributions install executables for nearly all packaged user software
    in */usr/bin*. Some are occasional differences that have crept in over the years,
    such as putting games in */usr/games* and graphical applications in a separate
    location, so check your system’s defaults first. And make sure that every general-use
    program on the system is available through one of the directories just listed.
    If not, your system is probably getting out of control. Don’t change the default
    path in your user environment to accommodate every new software installation directory.
    A cheap way to accommodate separate installation directories is to use symbolic
    links in */usr/local/bin*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many users create a *bin* directory of their own to store shell scripts and
    programs, so you may want to add this to the front of the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re interested in systems utilities (such as `sysctl`, `fdisk`, and `lsmod`),
    add the *sbin* directories to your path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 13.3.2  The Manual Page Path
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The traditional manual page path was determined by the `MANPATH` environment
    variable, but you shouldn’t set it because doing so overrides the system defaults
    in */etc/manpath.config*.
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.3  The Prompt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Experienced users tend to avoid long, complicated, useless prompts. In comparison,
    many administrators and distributions drag everything into a default prompt. Even
    many shell default prompts are cluttered or otherwise mostly useless. For example,
    the default `bash` prompt contains the shell name and version number. Your choice
    should reflect your users’ needs; place the current working directory, hostname,
    and username in the prompt if it really helps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Above all, avoid characters that mean something significant to the shell, such
    as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple prompt setting for `bash` ends with the customary `$` (the traditional
    `csh` prompt ends with `%`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `\u` is an expression that the shell evaluates to the current username
    (see the PROMPTING section of the bash(1) manual page). Other popular expressions
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\h` The hostname (the short form, without domain names).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`\!` The history number.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`\w` The current directory. Because this can become long, you can limit the
    display to just the final component by using `\W` instead.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`\$` `$` if running as a user account; `#` if root.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 13.3.4  Aliases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Among the stickier points of contemporary user environments is the role of
    *aliases*, a shell feature that substitutes one string for another before executing
    a command. Aliases can be efficient shortcuts that save some typing. However,
    they have several drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: It can be tricky to manipulate arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are confusing; a shell’s built-in `which` command can tell you if something
    is an alias, but it won’t tell you where it was defined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are frowned upon in subshells and noninteractive shells; they aren’t passed
    onto child shells.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One classic mistake when defining an alias is to add extra arguments to an existing
    command—for example, aliasing `ls` to `ls -F`. At best, this can make it difficult
    to remove the `-F` argument when you don’t want it. At worst, it can have severe
    consequences for the user who does not understand that they’re not using the default
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Given these disadvantages, you should probably avoid aliases whenever possible;
    it’s easier to write a shell function or an entirely new shell script. A computer
    can start and execute shells so quickly that the difference between an alias and
    an entirely new command should be unnoticeable.
  prefs: []
  type: TYPE_NORMAL
- en: That said, aliases do come in handy when you wish to alter a part of the shell’s
    environment. You can’t change an environment variable with a shell script, because
    scripts run as subshells. (But you can instead define shell functions to perform
    this task.)
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.5  The Permissions Mask
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As described in Chapter 2, a shell’s built-in `umask` (permissions mask) facility
    sets your default permissions. Include the `umask` command in one of your startup
    files to make certain that any program you run creates files with your desired
    permissions. There are two reasonable choices:'
  prefs: []
  type: TYPE_NORMAL
- en: '`077` This mask is the most restrictive permissions mask; it doesn’t give any
    other users access to new files and directories. This is often appropriate on
    a multi-user system where you don’t want other users to look at any of your files.
    However, when set as the default, this mask can sometimes lead to problems when
    your users want to share files but don’t understand how to set permissions correctly.
    (Inexperienced users have a tendency to set files to a world-writable mode.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`022` This mask gives other users read access to new files and directories.
    This can be a good choice on a single-user system because many daemons that run
    as pseudo-users won’t be able to see files and directories created with the more
    restrictive `077` umask.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 13.4 Startup File Order and Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you know what to put into shell startup files, it’s time to see some
    specific examples. Surprisingly, one of the most difficult and confusing parts
    of creating startup files is determining which of several possible startup files
    to use. This section covers the two most popular Unix shells: `bash` and `tcsh`.'
  prefs: []
  type: TYPE_NORMAL
- en: 13.4.1  The bash Shell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In `bash`, you can choose from the startup filenames *.bash_profile*, *.profile*,
    *.bash_login*, and *.bashrc*. Which one is appropriate for your command path,
    manual page path, prompt, aliases, and permissions mask? The answer is that you
    should have a *.bashrc* file accompanied by a *.bash_profile* symbolic link pointing
    to *.bashrc* because there are a few different kinds of `bash` shell instance
    types.
  prefs: []
  type: TYPE_NORMAL
- en: The two main shell instance types are interactive and noninteractive, but we’re
    interested only in interactive shells, because noninteractive shells (such as
    those that run shell scripts) usually don’t read any startup files. Interactive
    shells are those you use to run commands from a terminal, such as the ones you’ve
    seen in this book, and they can be classified as *login* or *non-login*.
  prefs: []
  type: TYPE_NORMAL
- en: Login Shells
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Traditionally, a login shell is what you get when you first log in to a system
    with the terminal using a program such as */bin/login*. Logging in remotely with
    SSH also gives you a login shell. The basic idea is that the login shell is an
    initial shell. You can tell if a shell is a login shell by running `echo $0`;
    if the first character is a `-`, the shell’s a login shell.
  prefs: []
  type: TYPE_NORMAL
- en: When `bash` runs as a login shell, it runs */etc/profile*. Then it looks for
    a user’s *.bash_profile*, *.bash_login*, and *.profile* files, running only the
    first one that it sees.
  prefs: []
  type: TYPE_NORMAL
- en: As strange as it sounds, it’s possible to run a noninteractive shell as a login
    shell to force it to run startup files. To do so, start the shell with the `-l`
    or `--login` option.
  prefs: []
  type: TYPE_NORMAL
- en: Non-Login Shells
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A non-login shell is an additional shell that you run after you log in. It’s
    simply any interactive shell that’s not a login shell. Windowing system terminal
    programs (`xterm`, GNOME Terminal, and so on) start non-login shells unless you
    specifically ask for a login shell.
  prefs: []
  type: TYPE_NORMAL
- en: Upon starting up as a non-login shell, `bash` runs */etc/bash.bashrc* and then
    runs the user’s *.bashrc*.
  prefs: []
  type: TYPE_NORMAL
- en: The Consequences of Two Kinds of Shells
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The reasoning behind the two different startup files is that in the old days,
    users logged in through a traditional terminal with a login shell, and then started
    non-login subshells with windowing systems or the `screen` program. For the non-login
    subshells, it was deemed a waste to repeatedly set the user environment and run
    a bunch of programs that had already been run. With login shells, you could run
    fancy startup commands in a file such as *.bash_profile*, leaving only aliases
    and other “lightweight” things to your *.bashrc*.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, most desktop users log in through a graphical display manager (you’ll
    learn more about these in the next chapter). Most of these start with one noninteractive
    login shell in order to preserve the login versus non-login model. When they do
    not, you need to set up your entire environment (path, manual path, and so on)
    in your *.bashrc*, or you’ll never see any of your environment in your terminal
    window shells. However, you *also* need a *.bash_profile* if you ever want to
    log in on the console or remotely, because those login shells don’t ever bother
    with *.bashrc*.
  prefs: []
  type: TYPE_NORMAL
- en: Example .bashrc
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In order to satisfy both non-login and login shells, how would you create a
    *.bashrc* that can also be used as your *.bash_profile*? Here’s one very elementary
    (yet perfectly sufficient) example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this startup file, the path has `$HOME/bin` at the front so that executables
    there take precedence over the system versions. If you need the system executables,
    add `/sbin` and `/usr/sbin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As described earlier, you can share this *.bashrc* file with *.bash_profile*
    via a symbolic link, or you can make the relationship even clearer by creating
    *.bash_profile* as this one-liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Checking for Login and Interactive Shells
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With a *.bashrc* matching your *.bash_profile*, you don’t normally run extra
    commands for login shells. However, if you want to define different actions for
    login and non-login shells, you can add the following test to your *.bashrc*,
    which checks the shell’s `$-` variable for an `i` character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 13.4.2  The tcsh Shell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The standard `csh` on virtually all Linux systems is `tcsh`, an enhanced C shell
    that popularized features such as command-line editing and multimode filename
    and command completion. Even if you don’t use `tcsh` as the default new user shell
    (`bash` should be the default), you should still provide `tcsh` startup files
    in case your users happen to come across `tcsh`.
  prefs: []
  type: TYPE_NORMAL
- en: You don’t have to worry about the difference between login shells and non-login
    shells in `tcsh`. Upon startup, `tcsh` looks for a *.tcshrc* file. Failing this,
    it looks for the `csh` shell’s *.cshrc* startup file. The reason for this order
    is that you can use the *.tcshrc* file for `tcsh` extensions that don’t work in
    `csh`. You should probably stick to using the traditional *.cshrc* instead of
    *.tcshrc*; it’s highly unlikely that anyone will ever use your startup files with
    `csh`. And if a user actually does come across `csh` on some other system, your
    *.cshrc* will work.
  prefs: []
  type: TYPE_NORMAL
- en: Example .cshrc
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here is a sample *.cshrc* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 13.5 Default User Settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best way to write startup files and choose defaults for new users is to
    experiment with a new test user on the system. Create the test user with an empty
    home directory and refrain from copying your own startup files to the test user’s
    directory. Write the new startup files from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: When you think you have a working setup, log in as the new test user in all
    possible ways (on the console, remotely, and so on). Make sure that you test as
    many things as possible, including the windowing system operation and manual pages.
    When you’re happy with the test user, create a second test user, copying the startup
    files from the first test user. If everything still works, you now have a new
    set of startup files that you can distribute to new users.
  prefs: []
  type: TYPE_NORMAL
- en: This section outlines reasonable defaults for new users.
  prefs: []
  type: TYPE_NORMAL
- en: 13.5.1  Shell Defaults
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The default shell for any new user on a Linux system should be `bash` because:'
  prefs: []
  type: TYPE_NORMAL
- en: Users interact with the same shell that they use to write shell scripts. (For
    many reasons, which I won’t expand upon here, `csh` is a notoriously bad scripting
    tool—don’t even think about it.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bash` is the default on Linux distributions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bash` uses the GNU readline library to accept input, and therefore its interface
    is identical to that of many other tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bash` gives you fine, easy-to-understand control over I/O redirection and
    file handles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, many seasoned Unix wizards use a shell such as `csh` or `tcsh` simply
    because it’s what they’re most familiar with, and they can’t bear to switch. Of
    course, you can choose any shell you like, but choose `bash` if you don’t have
    any preference, and use `bash` as the default shell for any new user on the system.
    (Users can change their shell with the `chsh` command to suit their individual
    preference.)
  prefs: []
  type: TYPE_NORMAL
- en: 13.5.2  Editor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On traditional systems, the default editor is `vi` or `emacs`. These are the
    only editors virtually guaranteed to exist (or at least be available) on nearly
    any Unix system, which means they’ll cause the least trouble in the long run for
    a new user. However, Linux distributions often configure `nano` to be the default
    editor, because it’s easier for beginners to use.
  prefs: []
  type: TYPE_NORMAL
- en: As with shell startup files, avoid large default editor startup files. A little
    `set` `showmatch` in the *.exrc* startup file (to have `vi` show matching parentheses)
    never hurt anyone, but steer clear of anything that significantly changes the
    editor’s behavior or appearance, such as the `showmode` feature, auto-indentation,
    and wrap margins.
  prefs: []
  type: TYPE_NORMAL
- en: 13.5.3  Pager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The pager is a program, such as `less`, that shows text one page at a time.
    It’s perfectly reasonable to set the default `PAGER` environment variable to `less`.
  prefs: []
  type: TYPE_NORMAL
- en: 13.6 Startup File Pitfalls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Avoid these pitfalls in startup files:'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t put any kind of graphical command in a shell startup file. Not all shells
    run in graphical environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t set the `DISPLAY` environment variable in a shell startup file. We haven’t
    looked at graphical environments yet, but this can cause your graphical session
    to misbehave.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t set the terminal type in a shell startup file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t skimp on descriptive comments in default startup files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t run commands in a startup file that print to the standard output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never set `LD_LIBRARY_PATH` in a shell startup file (see Section 15.1.3).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.7 Further Startup Topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because this book deals only with the underlying Linux system, we won’t cover
    windowing environment startup files. This is a large issue indeed, because the
    display manager that logs you in to a modern Linux system has its own set of startup
    files, such as *.xsession*, *.xinitrc*, and the endless combinations of GNOME-
    and KDE-related items.
  prefs: []
  type: TYPE_NORMAL
- en: The windowing choices may seem bewildering, and there is no one common way to
    start a windowing environment in Linux. The next chapter describes some of the
    many possibilities. However, when you determine what your system does, you might
    get a little carried away with the files that relate to your graphical environment.
    That’s fine, but don’t carry it over to new users. The same tenet of keeping things
    simple in shell startup files works wonders for GUI startup files, too. In fact,
    you probably don’t need to change your GUI startup files at all.
  prefs: []
  type: TYPE_NORMAL
