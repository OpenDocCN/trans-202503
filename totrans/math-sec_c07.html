<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 7: Using Geometry to Improve Security Practices</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:1ff3c234-c763-4a12-a0c7-4ddf7c732e40" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_127" title="127"/>7</span><br/>
<span class="ChapterTitle">Using Geometry to Improve Security Practices</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">When you think about modern security, geometry might not immediately come to mind. However, using computer algorithms to solve classic geometric problems such as line length, shape area, and object intersections allows you to analyze spatial relationships, which in turn can inform your security practices. This field is known as <em>computational geometry. </em></p>
<p>In the next few chapters, we’ll apply geometry to problems that relate data to the physical world using geometric rules. In <span class="xref" itemid="xref_target_Chapter 8"><a href="c08.xhtml">Chapter 8</a></span>, we’ll use the properties of shapes to locate an imaginary perpetrator using cell phone data and MapBox Maps through a process you’ve probably heard of: location triangulation. Then, in <span class="xref" itemid="xref_target_Chapter 9"><a href="c09.xhtml">Chapter 9</a></span>, we’ll put on our resource planning <span epub:type="pagebreak" id="Page_128" title="128"/>hats and look at the distribution of emergency services (like fire stations) using one of my favorite geometric algorithms, Voronoi tessellation. Finally, in <span class="xref" itemid="xref_target_Chapter 10"><a href="c10.xhtml">Chapter 10</a></span>, we’ll explore using geometry for facial recognition.</p>
<p>But first, we need to cover computational geometry more generally. We’ll begin this chapter by going over the essential theory with Python examples. We’ll use a Python library called Shapely, which abstracts away a lot of common tasks such as defining shapes and checking if two shapes touch or overlap at any points.</p>
<h2 id="h1-502567c07-0001">Describing Shapes</h2>
<p class="BodyFirst">Geometry is one of those areas of mathematics that is relatively intuitive for human brains. If I showed you a shape and asked you to label it as a square, triangle, or circle, you wouldn’t even have to consciously think about the definition of the shape; you’d simply “know” the matching name. Encoding geometric intuition into computers has proven less straightforward. Before we can discuss how to analyze shapes, then, we need a way to describe the shapes in a data format our programs can digest. Then we need to define a series of mathematical checks for each type of shape we want to be able to identify. Luckily, most of the heavy lifting has already been done for us in Python’s Shapely library. In this section, we’ll use Shapely to define some of the key shapes we’ll need to understand for the upcoming projects to make sense. We’ll start with the very basic building blocks of shapes: points and lines. From there we can build increasingly complex shape representations, combine shapes to form 2D models, and look at some of the interesting analysis functions Shapely provides.</p>
<h3 id="h2-502567c07-0001">Points and Lines</h3>
<p class="BodyFirst">We start with an empty universe represented as a 2D Cartesian plane. Only two types of object exist in this world: a point and a line segment. A <em>point</em> denotes an exact place on the plane using the common (<em>x</em>, <em>y</em>) coordinate system. A <em>line segment</em> is a part of an infinitely long line; it is bounded by, and contains every point on the line between, two distinct end points. In theory there are an infinite number of points between the two end points; in practice, the number of distinct points is limited by the floating-point precision of the platform or programming language. Python supports 17 decimal places of precision, which will be more than enough for our tasks. </p>
<p>In Shapely, you define a point by telling the library what the point’s associated <em>x</em> and <em>y</em> values should be, as in <a href="#listing7-1" id="listinganchor7-1">Listing 7-1</a>.</p>
<pre><code>from shapely.geometry import Point
point_a = Point(2.0, 4.0)
point_b = Point(0.0, 0.0)</code></pre>
<p class="CodeListingCaption"><a id="listing7-1">Listing 7-1</a>: Defining a point in Shapely</p>
<p><span epub:type="pagebreak" id="Page_129" title="129"/>This code creates two <code>Point</code> objects on our Cartesian plane: <code>point_a</code> at (2.0, 4.0) and <code>point_b</code> at (0.0, 0.0). </p>
<p>To create a line segment, we can call the <code>LineString</code> class in Shapely and pass in the starting point (<em>x</em>, <em>y</em>) and the end point (<em>x</em>, <em>y</em>). We can pass in either tuples or <code>Point</code> objects. <a href="#listing7-2" id="listinganchor7-2">Listing 7-2</a> shows how to create a <code>LineString</code> object from scratch or from the two previously created points.</p>
<pre><code>from shapely.geometry import LineString
line = LineString([(2.0, 4.0), (0.0, 0.0)])
line2 = LineString([point_a, point_b])</code></pre>
<p class="CodeListingCaption"><a id="listing7-2">Listing 7-2</a>: Creating a <code>LineString</code> from <code>Point</code> objects</p>
<p>The two line segments defined in <a href="#listing7-2">Listing 7-2</a> are identical from the library’s perspective, so you’re free to use whichever syntax suits your code best. If you plan to reuse the same points throughout your application, creating the <code>Point</code> objects first makes the code cleaner and easier to understand.</p>
<p>Points and line segments are the most basic building blocks of shapes. Let’s look at how we can combine them to define more complex shapes known as polygons.</p>
<h3 id="h2-502567c07-0002">Polygons</h3>
<p class="BodyFirst">By combining points and line segments in various configurations, we can build polygons like squares, stars, and even a very close approximation of circles. In geometry, a polygon<em> P </em>is a plane figure that is described by a finite number of points connected by line segments that form a closed chain. A <em>closed chain</em> means that the first and last point in the sequence are always the same, so the series of line segments always ends by connecting back to the origin. Line segments used in constructing <em>P</em> may be referred to as <em>edges</em>, <em>sides</em>, and <em>faces</em> interchangeably. The points along the boundary of <em>P</em> are often referred to as the <em>vertices</em> (singular <em>vertex</em>) of the shape. <a href="#listing7-3" id="listinganchor7-3">Listing 7-3</a> shows how to create a polygon with the Shapely library. </p>
<pre><code>from shapely.geometry import Polygon
poly_a = Polygon([(0, 0), (10, 0), (7, 5), (3, 5)])
poly_b = Polygon([point_a, point_b, (10, 0), point_a])</code></pre>
<p class="CodeListingCaption"><a id="listing7-3">Listing 7-3</a>: Creating a <code>Polygon</code> from <code>Point</code> objects</p>
<p>First, we import the <code>Polygon</code> class, which allows us to define polygons similar to how we defined <code>LineString</code> objects in <a href="#listing7-2">Listing 7-2</a>. The major difference with the <code>Polygon</code> class is that Shapely creates an additional point to close the shape boundary if it isn’t explicitly defined (as with <code>poly_a</code>). The second object, <code>poly_b</code>, shows how you can mix <code>Point</code> objects and hardcoded values when defining a polygon’s perimeter. It also demonstrates how to explicitly close a polygon by including a final point that matches the initial <span epub:type="pagebreak" id="Page_130" title="130"/>point in the perimeter. Remember: whenever possible, explicit is better than implicit.</p>
<p>A <em>regular</em> polygon is one where all angles and sides are equal. Any polygon that doesn’t satisfy this criteria (which is the majority of them) is considered <em>irregular</em>. A <em>simple</em> polygon has only one boundary, which doesn’t intersect itself at any point. A <em>complex</em> polygon has one or more edges that intersect, making the shape twist across itself. Many rules about simple polygons don’t work for complex polygons, so we’ll avoid them. </p>
<p>Polygons can be very complex shapes with hundreds of edges and vertices, but all possible polygons can be classified into one of two categories. A <em>convex</em> polygon is one where all its interior angles are less than 180 degrees. All the vertices of the polygon will point outward, away from the interior of the shape. A <em>concave</em> polygon is any polygon that does not satisfy the convex definition. A simple rule of thumb is that if you can travel counterclockwise around the entire perimeter of the shape using only left turns, then the shape is convex. If you ever have to veer right to get to the next vertex, then the shape is concave. <a href="#figure7-1" id="figureanchor7-1">Figure 7-1</a> illustrates the difference.</p>
<figure>
<img alt="" class="" src="image_fi/502567c07/f07001.png"/>
<figcaption><p><a id="figure7-1">Figure 7-1</a>: Concave vs. convex shapes</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate <a href="#figure7-1">Figure 7-1</a> is in the 11th cell of the <em>Computational_Geometry.ipynb</em> notebook. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The shape on the left has two points where the perimeter moves toward the interior (1, 1) and (0.8, 1). If you were walking around the perimeter of this shape counterclockwise, you’d have to turn right when you reached either of these points. The shape on the right has no vertices that point inward. You could indeed walk counterclockwise around the whole shape using only left turns, so it is convex. </p>
<p>Similar to how you can combine points and line segments to make basic shapes, you can combine a simple polygon and a special object called a <em>linear ring</em> polygon (<em>ring</em> or <em>hole</em> for short) to create voids in the interior. <a href="#figure7-2" id="figureanchor7-2">Figure 7-2</a> shows the result of combining a simple polygon with a ring.</p>
<span epub:type="pagebreak" id="Page_131" title="131"/><figure>
<img alt="" class="" src="image_fi/502567c07/f07002.png"/>
<figcaption><p><a id="figure7-2">Figure 7-2</a>: Comparing polygon types</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate <a href="#figure7-2">Figure 7-2</a> is in the 12th cell of the <em>Computational_Geometry.ipynb</em> notebook. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>A ring polygon <em>rph</em> (the leftmost image of <a href="#figure7-2">Figure 7-2</a>) is a hollow shape with no solid region. It’s composed entirely of the points and line segments that fall along its defining border, the thick black outline in the image. </p>
<p>A simple polygon <em>P</em> (the middle image) is a solid plane region that contains all the points within its boundaries as well as all the points along the defining perimeter, shown by the black shape in the middle.</p>
<p>The polygon with a hole (the right image) combines the ring polygon on the left with the simple polygon in the middle. To combine the two, we subtract the points in the ring from the set of points in <em>P</em> (<em>P</em>2 = <em>P</em>1 ∉ <em>rph</em>). The points that fall within the ring shape are excluded from the geometry of the overall polygon. </p>
<p><a href="#listing7-4" id="listinganchor7-4">Listing 7-4</a> shows how we can construct the three different classes of polygon in the figure.</p>
<pre><code>from shapely.geometry import Polygon, LinearRing
poly_a = Polygon([(0, 0), (10, 0), (7, 5), (3, 5)])
poly_hole = LinearRing([(2, 2), (8, 2), (5, 3), (4, 3)])
rbus_b_holed = Polygon(poly_a, [poly_hole])</code></pre>
<p class="CodeListingCaption"><a id="listing7-4">Listing 7-4</a>: Creating a polygon with a hole in Shapely</p>
<p>We define the main polygon, <code>poly_a</code>, the same as in <a href="#listing7-3">Listing 7-3</a>, using its bounding vertices. To define the ring polygon, <code>poly_hole</code>, we create a <code>LinearRing</code> object by passing in the vertices defining its perimeter. We create the final polygon by combining the two shapes into a new <code>Polygon</code> object. The <code>poly_hole</code> object is passed inside a list to support multiple holes in the same polygon. Holes may not cross each other or the exterior of the polygon; they can touch only at a single point. Shapely doesn’t prevent you from creating invalid features, but it will raise exceptions when you try to operate on them.</p>
<p><span epub:type="pagebreak" id="Page_132" title="132"/>By combining individual points, line segments, polygons, and holes, we can begin to model the physical space around us with enough accuracy to be useful. We can use complex polygons to define the bounds of a space and use holes inside the complex polygons to denote areas people can’t travel due to obstructions. We’ll dive into this more in the “<span class="xref" itemid="xref_target_ScenarioPlanning Security for a Concert"><a href="#h1-502567c07-0002">Scenario: Planning Security for a Concert</a></span>” section, but first let’s cover some best practices to help your code run smoothly.</p>
<h3 id="h2-502567c07-0003">Vertex Order</h3>
<p class="BodyFirst">When you create a shape, the order of the vertices matters. The standard practice is to pass the vertices in counterclockwise order (<code>ccw</code> in Shapely) around the perimeter. Having points in a known order makes several operations—like checking if a point falls inside a shape or if a polygon is convex—considerably faster to compute. Shapely has a couple of functions to help with this. In <a href="#listing7-5" id="listinganchor7-5">Listing 7-5</a> we check if an object is in counterclockwise orientation and, if not, translate its point order so that it is.</p>
<pre><code>ring = LinearRing([(0,0), (1,1), (1,0)])
print(ring.is_ccw)
new_ring = LinearRing(list(ring.coords)[::-1])
print(new_ring.is_ccw)</code></pre>
<p class="CodeListingCaption"><a id="listing7-5">Listing 7-5</a>: Checking and fixing the order of vertices</p>
<p>We start by creating a <code>LinearRing</code> object. You can prove to yourself on a piece of graph paper that the order of the vertices, from left to right, forms a clockwise description of a triangle. We can use Shapely to check if the vertices are in counterclockwise order by printing the Boolean attribute <code>is_ccw</code>, which will be <code>False</code>. To translate the list into counterclockwise order, we use a Python list inversion (<code>[::-1]</code>), which adds the coordinates in reverse order to a new list, then assigns the newly reordered list to a new <code>LinearRing</code> object called <code>new_ring</code>. Printing <code>is_ccw</code> on <code>new_ring</code> will now return <code>True</code>, confirming the new ordering is indeed counterclockwise.</p>
<p>Now that you can describe shapes in a way the computer can work with, let’s look at some common operations you’ll repeatedly use when geometrically analyzing security problems. In the next section we’ll cover useful algorithms for finding areas, determining overlaps and intersections, and calculating perimeter lengths for irregular shapes.</p>
<h2 id="h1-502567c07-0002">Scenario: Planning Security for a Concert</h2>
<p class="BodyFirst">The best way to get acquainted with computational geometry theory is to apply it in a scenario, so imagine you’re asked to plan the security for a concert being held at a local park. You need to decide how many security <span epub:type="pagebreak" id="Page_133" title="133"/>personnel to assign to the event and where they’ll be positioned, and you need to provide the event coordinators with recommendations for safe attendance capacity. <a href="#figure7-3" id="figureanchor7-3">Figure 7-3</a> shows the park layout from an overhead view. </p>
<figure>
<img alt="" class="" src="image_fi/502567c07/f07003.png"/>
<figcaption><p><a id="figure7-3">Figure 7-3</a>: The park as a polygon with holes</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate <a href="#figure7-3">Figure 7-3</a> is in the 13th cell of the <em>Computational_Geometry.ipynb</em> notebook.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The outline of the polygon represents a tall fence around the park. The small square near the bottom of the park is an information booth that can’t be accessed by attendees, so we subtract it from the usable area. The rectangle near the top of the park is the stage, which also can’t be accessed by attendees, so we remove it as well. The remaining gray area is the part of the park that’s accessible to attendees. We’ll calculate this area and then use the result to figure out the number of attendees that can safely and comfortably attend the event. </p>
<h3 id="h2-502567c07-0004">Calculating Safe Occupancy Limits</h3>
<p class="BodyFirst">To find the area of irregular shapes like the park, first we must decompose the shape into a set of simple shapes, like triangles, and then sum the area of each composite shape. The act of decomposing a shape like this is known as <em>tessellation</em>, and involves overlaying a plane using one or more geometric shapes, called <em>tiles</em>, with no overlaps and no gaps. <a href="#figure7-4" id="figureanchor7-4">Figure 7-4</a> shows two approaches to triangular tessellation for the park space. </p>
<span epub:type="pagebreak" id="Page_134" title="134"/><figure>
<img alt="" class="" src="image_fi/502567c07/f07004.png"/>
<figcaption><p><a id="figure7-4">Figure 7-4</a>: A triangular tessellation of a simple polygon and a polygon with holes</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate the two plots in <a href="#figure7-4">Figure 7-4</a> is in the 16th cell of the <em>Computational_Geometry.ipynb</em> notebook.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The simple approach on the left tessellates the base polygon and temporarily ignores the holes. You calculate the total area of this shape and then subtract the areas for the two restricted zones. I used this method by hand back in my early days. The approach on the right tessellates the complex shape with holes included using Shapely’s <code>triangulate</code> function (not to be confused with location triangulation, which we’ll cover in <span class="xref" itemid="xref_target_Chapter 8"><a href="c08.xhtml">Chapter 8</a></span>). We can find the area by summing the <em>n</em> areas of each gray triangle:</p>
<figure class="graphic equation">
<img alt="" class="" src="image_fi/502567c07/m07001.png"/></figure>

<p>Here <em>P</em><sub>Δ[</sub><sub><em>i</em></sub><sub>]</sub><em>B</em> and <em>P</em><sub>Δ[</sub><sub><em>i</em></sub><sub>]</sub><em>H</em> are the base and height measurements, respectively, for the <em>i</em>th triangle in <em>P</em><sub>Δ</sub>.</p>
<p>Luckily, we don’t have to worry about manual tessellation just to find the area of the complex shape. The Shapely library automatically handles all of this under the hood when you create a shape. <a href="#listing7-6" id="listinganchor7-6">Listing 7-6</a> shows how to create the park shape and calculate the usable area for attendees.</p>
<pre><code>park = Polygon([(0,0), (4.5,0.5), (9,3), (14,7), (12,9), (5,9)])
info_booth = LinearRing([(4,2), (5,2), (5,3), (4,3)])
stage = LinearRing([(6,7), (9,7), (9,8), (6,8)])
event_shape = Polygon(list(park.exterior.coords), [info_booth, stage])
event_area = event_shape.area*10
print (f"{event_area} m^2 usable area")</code></pre>
<p class="CodeListingCaption"><a id="listing7-6">Listing 7-6</a>: Creating the complex park shape and calculating the area</p>
<p><span epub:type="pagebreak" id="Page_135" title="135"/>We start by creating the outermost <code>Polygon</code> to represent the bounds of the event space. We then create a <code>LinearRing</code> object for both the stage and information booth. Next, we create the complex polygon representing the shape of the usable space in the venue. The library provides an <code>area</code> attribute for polygons that respects any holes we passed in during creation. </p>
<p>When you’re dealing with really big shapes like the park, it’s common practice to apply a scaling factor—that is, to shrink the whole shape by some known constant to make the numbers easier to work with. In Figures 7-3 and 7-4, one unit is equal to 10 meters, or a scaling factor of 0.1, so multiplying the <code>event_shape.area</code> by 10 adjusts the result for the scaling applied to the map. The output of the <code>print</code> statement is:</p>
<pre><code>635.00 m^2 usable area</code></pre>
<p>Now that we know the usable area, we can calculate the number of attendees that can safely fill it. <a href="#listing7-7" id="listinganchor7-7">Listing 7-7</a> shows how to convert the area result to attendee count by dividing the usable area by the amount of space we aim to provide each attendee.</p>
<pre><code>import math
safe_capacity = int(math.floor(event_area / 0.75)) # 8ft sq
max_capacity = int(math.floor(event_area / 0.37))  # 4ft sq
print("Comfortable capacity: %d people" % safe_capacity)
print("Maximum safe capacity: %d people" % max_capacity)</code></pre>
<p class="CodeListingCaption"><a id="listing7-7">Listing 7-7</a>: Calculating capacity based on usable area</p>
<p>Years ago, I settled on 0.75 square meters—a little over 8 square feet—per person for events with a mixture of seated and standing attendees. (I later discovered others had reached roughly the same numbers for similar scenarios.) We multiply the <code>event_area</code> by 0.75 to find the number of people that can comfortably attend the event with room for some people to sit on a blanket and others to walk around. To find the maximum number of people that can safely stand in an area, we can cut the spacing roughly in half to 0.37 square meters, or about 4 square feet per person. Now, we can multiply the event area by 0.37 to find the “standing room only” capacity of the venue, <code>max_capacity</code>. This tight spacing would be like standing in a crowded hallway: you’re not quite bumping into other people yet, but almost. The output from the code should be:</p>
<pre><code>Comfortable capacity: 846 people
Maximum safe capacity: 1716 people</code></pre>
<p>To estimate the number of security personnel for the event, we’ll round the 846 attendees up to 900. From experience, I use a ratio of 60:1 attendees to security, which in this case means 900 / 60 = 15. However, 900 includes everyone that will be in the event area, including security personnel, so in a real scenario you actually want to round in the other direction and recommend a max comfortable capacity of 830 attendees while estimating the security detail for the higher crowd number, 900. </p>
<p><span epub:type="pagebreak" id="Page_136" title="136"/>After applying this formula to some real venues, you’ll notice your comfortable numbers are usually lower than those recommended by safety codes issued from the fire department, which is intentional. The fire department numbers are concerned with the number of people that can safely evacuate in the event of an emergency and have nothing to do with crowd security or comfort. You’ll also find that event coordinators will settle somewhere between the number you suggest and the number the fire department will allow (hence rounding up in planning for personnel and rounding down when recommending attendance).</p>
<h3 id="h2-502567c07-0005">Determining Placement of Security Personnel</h3>
<p class="BodyFirst">Now that we know how many security personnel we need, let’s address where to place them. We’ll use tessellation combined with another common operation known as <em>centroid location</em>, which finds the point that’s equidistant from all of the perimeter vertices of a polygon (that is, the <em>centroid</em>). The centroid of a convex object always lies inside the object’s area. A concave object might have a centroid that is outside the area, but since we’re tessellating the shape first, each resulting triangle will be convex and the centroid will be located within the perimeter.</p>
<p>The centroid of <em>P</em> = [(<em>x</em>0, <em>y</em>0), (<em>x</em>1, <em>y</em>1), . . . , (<em>xn – </em>1, <em>yn</em> – 1)] is the point C(<em>x</em>, <em>y</em>), where</p>
<figure class="graphic equation">
<img alt="" class="" src="image_fi/502567c07/m07002.png"/></figure>

<p class="BodyContinued">The term <em>A</em> is the signed area of <em>P</em>, which is calculated using the <em>shoelace algorithm</em>:</p>
<figure class="graphic equation">
<img alt="" class="" src="image_fi/502567c07/m07003.png"/></figure>

<p>The points in <em>P</em> need to be in sequential order along the perimeter for this to work. If the order of the vertices is counterclockwise, the area will be a negative value; otherwise, it will be positive. In either case the absolute value of <em>C</em><sub>(</sub><sub><em>x,y</em></sub><sub>)</sub> will be correct. We can use this information to place each of the 15 security personnel in the centroid location of the triangle with the largest area that hasn’t been assigned a guard yet. <a href="#listing7-8" id="listinganchor7-8">Listing 7-8</a> shows how to achieve this. </p>
<pre><code>from shapely.ops import triangulate
tess = triangulate(event_shape)
area_dict = {i: tess[i].area for i in range(len(tess))}
sort_areas = sorted(area_dict.items(), key=lambda x: x[1], reverse=True)
sec_points = [tess[t[0]].centroid.coords[0] for t in sort_areas[:15]]</code></pre>
<p class="CodeListingCaption"><a id="listing7-8">Listing 7-8</a>: A centroid-based personnel dispersion algorithm</p>
<p>We start by triangulating the <code>event_shape</code> object from <a href="#listing7-6">Listing 7-6</a> using the <code>triangulate</code> function. The result is a set of <code>Polygon</code> objects representing <span epub:type="pagebreak" id="Page_137" title="137"/>the triangles making up the shape (denoted as <em>P</em><sub>Δ</sub>). We then use a dictionary comprehension to create a sortable list of triangle index and corresponding area. We use the <code>sorted</code> function to sort the <code>area_dict</code> by value. Using descending order with <code>reverse=True</code> allows us to use the coordinates for the centroid of the first 15 triangles to estimate a good dispersion of security personnel. <a href="#figure7-5" id="figureanchor7-5">Figure 7-5</a> shows the resulting placement plan. </p>
<figure>
<img alt="" class="" src="image_fi/502567c07/f07005.png"/>
<figcaption><p><a id="figure7-5">Figure 7-5</a>: The centroid placement for security personnel</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate <a href="#figure7-5">Figure 7-5</a> is in the 19th cell of the <em>Computational_Geometry.ipynb</em> notebook.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The triangulation is identical to the one shown in <a href="#figure7-4">Figure 7-4</a>. The gray plus symbols are the centroids for each of the selected triangles. As you can see, the result of this fairly basic algorithm is pretty good. Regardless of where you’re standing in the venue, you’re never far from one or more security stations. Using a dispersion method like this ensures that security can respond quickly regardless of where they’re needed. The one problem is the fact that it placed a guard in one of the unusable parts of the venue, right on stage! We’ll see how to improve this algorithm and fix the placement of that guard in the “<span class="xref" itemid="xref_target_Improving Guard Placement"><a href="#h2-502567c07-0007">Improving Guard Placement</a></span>” section, but for the moment, let’s look at another useful piece of analysis that will help us plan and schedule walking patrols.</p>
<h3 id="h2-502567c07-0006">Estimating Guard Patrol Timing</h3>
<p class="BodyFirst">Perimeter length is a great way to estimate timing for patrols. For simplicity, let’s assume the guards patrolling the perimeter of the event don’t count against the 15 guards we already placed. We could assign the misplaced guard position to patrol, but that would change the ratio of security to attendees in the venue (albeit only slightly). For now, let’s pretend we have another two guards positioned along the perimeter so they don’t count toward attendance. One is located at a stationary point (say, at a primary <span epub:type="pagebreak" id="Page_138" title="138"/>access point like a gate) and another is walking around the perimeter. For safety, the patrol guard should have scheduled check-in times with the stationary guard. The question is how long a normal patrol should take. This is where perimeter length comes in handy. For a polygon, the length of its perimeter is the sum of the lengths of the individual line segments it comprises. To figure out how long the walk should take around the park, we can divide the outer perimeter’s length by the guard’s estimated walking speed. <a href="#listing7-9" id="listinganchor7-9">Listing 7-9</a> shows how to compute this time.</p>
<pre><code>perimeter_len = event_shape.exterior.length*10
walk_time = perimeter_len / (1.1 * 60)
print ("%.2f meter perimeter" % perimeter_len)
print ("%.2f minutes" % walk_time)</code></pre>
<p class="CodeListingCaption"><a id="listing7-9">Listing 7-9</a>: Computing guard patrol times</p>
<p>The exterior <code>length</code> attribute of a complex shape like the <code>event_shape</code> object is a <code>LinearRing</code> object representing the outermost points of the figure. To get the actual distance around the fence, we multiply the <code>LinearRing</code>’s length property by the scaling factor. Next we need an estimate for the guard’s speed. According to Wikipedia, the average human walking speed at crosswalks is about 1.4 meters per second (m/s), or about 3.1 miles per hour (mph). We can assume our security will be walking a bit slower than this (they’re observing the area as they patrol, after all). We set the rate variable to 1.1 m/s or about 2.5 mph. To get the per-minute rate, we multiply the m/s rate by 60. Then, we calculate the <code>walk_time</code> with time = distance / rate. The result from <a href="#listing7-9">Listing 7-9</a> should be:</p>
<pre><code>362.03 meter perimeter
5.49 minutes</code></pre>
<p>We can use this information to justify a policy that the patrol guard should check in at a given place along the perimeter every 5.49 minutes. In practice, you’d want to contact the patrol person if you didn’t receive a check-in within 6 minutes or so.</p>
<h3 id="h2-502567c07-0007">Improving Guard Placement</h3>
<p class="BodyFirst">Now let’s improve our guard placement from <a href="#listing7-8">Listing 7-8</a> by adding the concept of <em>co-location</em>, when two objects occupy the same space on the Cartesian plane. With co-location, we’ll be able to determine when a guard has been placed in an unusable part of the venue. Shapely provides functions—such as <code>contains</code>, <code>intersects</code>, <code>overlaps</code>, <code>touches</code>, and <code>distance</code>—to check relationships between geometric objects. Each function takes in a second object as a parameter and answers the question its name suggests. For example, <code>contains</code> checks if object B resides completely within the interior of object A. The result will be <code>True</code> if no points of B are on the exterior of A and at least one point of the interior of B lies within the interior of A. There’s an inverse relationship function, <code>within</code>, such that <code>A.contains(B) = B.within(A)</code>. The Shapely documentation contains very good explanations of each function.</p>
<p><span epub:type="pagebreak" id="Page_139" title="139"/><a href="#listing7-10" id="listinganchor7-10">Listing 7-10</a> extends the code from <a href="#listing7-8">Listing 7-8</a> so that it doesn’t place the guard station on the stage. </p>
<pre><code>finalized = []
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> s2 = Polygon(stage)
i2 = Polygon(info_booth)
for guard_station in sec_points:
    i = 0
    new_station = Point(guard_station)
    while any([
      <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> (s2.contains(new_station)),
        (i2.contains(new_station))
    ]):
        <var>--snip--</var>
      <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> new_area = sort_areas[15+i]
        i += 1
        poss = tess[new_area[0]].centroid.coords[0]
        if poss not in sec_points:
            new_station = poss
            new_station = Point(poss)
    finalized.append(list(new_station.coords[0]))</code></pre>
<p class="CodeListingCaption"><a id="listing7-10">Listing 7-10</a>: Reassigning guard stations from unusable areas</p>
<p>Because <code>LinearRing</code> objects are hollow, they don’t actually contain the points within their bounds, so first we need to change the <code>stage</code> and <code>info_booth</code> objects to <code>Polygon</code> objects <span aria-label="annotation1" class="CodeAnnotation">❶</span>. A polygon is assumed to be filled, so any point within its bounds will return <code>True</code> when we call the <code>contains</code> function <span aria-label="annotation2" class="CodeAnnotation">❷</span>. By looping over each set of coordinates in the <code>sec_list</code>, we can cast them to <code>Points</code> and check if the stage or information booth polygons contain that point. If so, we can reassign it to one of the other unoccupied triangles by starting at the 16th triangle (index 15) and assigning the guard station to the new position <span aria-label="annotation3" class="CodeAnnotation">❸</span>. We repeat the process of assigning the guard to a new position and checking if that position is contained by one of the unusable areas until we find a usable triangle. <a href="#figure7-6" id="figureanchor7-6">Figure 7-6</a> shows the result of running the improved code.</p>
<figure>
<img alt="" class="" src="image_fi/502567c07/f07006.png"/>
<figcaption><p><a id="figure7-6">Figure 7-6</a>: The improved security placement results</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" id="Page_140" title="140"/><h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate <a href="#figure7-6">Figure 7-6</a> is in the 21st cell of the <em>Computational_Geometry.ipynb</em> notebook. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>When you compare <a href="#figure7-6">Figure 7-6</a> with <a href="#figure7-5">Figure 7-5</a>, you can see the guard station got moved from the stage area to the area below the information booth, which was previously empty. This change places all 15 guards in usable areas of the venue, making sure to assign guards to the largest unprotected sections first. By combining this information with the attendance recommendation and the scheduled patrol routes, we have a good start on an event security plan. We can take this basic recommendation and further refine it with our knowledge of the venue, the event taking place, and so on, to produce a fully formed security strategy that should include contingency plans for more security personnel and attendee overflow areas.</p>
<h2 id="h1-502567c07-0003">Summary</h2>
<p class="BodyFirst">The power of computational geometry for security lies in the ability to encode physical features in a way machines can interpret: as points, line segments, and polygons. Once you encode the features, you can calculate the area, centroid location, perimeter length, and object relationships to analyze security problems. You’ve already seen how you can use geometry to describe a physical space like a park and place security personnel effectively. You’ve also seen how shapes can be combined to make more complex representations using hole objects. Finally, we covered some other common functions that you’ll encounter often in practice. There are many more functions available in the Shapely library, but the ones presented in this chapter represent a majority of the work you’ll need to perform when analyzing problems geometrically. </p>
<p>As you’ll see over the next three chapters, we can combine these operations to create other very interesting security tools. There’s still plenty of research to dive into on your own. Geometry has a long history in the security industry, and many research questions can be restated such that you can apply geometric algorithms to them. Of course, none of this even touches on geometry in cryptography, which is its own beast and needs a book of its own. If you’re interested in this field, though, check out the paper “Geometric Cryptography: Identification by Angle Trisection.”<sup class="endnote"><a href="b01.xhtml#c07-endnote-001" id="c07-noteref-001">1</a></sup> If you’re interested in how you can apply geometric algorithms to privacy issues, you’ll want to research the field of privacy-preserving computational geometry.</p>
<p>Let’s continue our exploration of computational geometry with the topic of geographic location data. In the next chapter, we’ll combine MapBox and OpenCellID data to triangulate the location of a cell phone.</p>
</section>
</body>
</html>