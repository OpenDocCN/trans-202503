<html><head></head><body>
<h2 class="h2c" id="ch01"><span epub:type="pagebreak" id="page_3"/><span class="big1"><strong>1</strong></span><br/><strong>SCANNING MEMORY USING CHEAT ENGINE</strong></h2>&#13;
<div class="image"><img src="../images/common.jpg" alt="image"/></div>&#13;
<p class="noindent">The best game hackers in the world spend years personalizing expansive arsenals with custom-built tools. Such potent toolkits enable these hackers to seamlessly analyze games, effortlessly prototype hacks, and effectively develop bots. At the core, however, each unique kit is built from the same four-piece powerhouse: a memory scanner, an assembler-level debugger, a process monitor, and a hex editor.</p>&#13;
<p class="indent">Memory scanning is the gateway to game hacking, and this chapter will teach you about Cheat Engine, a powerful memory scanner that searches a game’s operating memory (which lives in RAM) for values like the player’s level, health, or in-game money. First, I’ll focus on basic memory scanning, memory modification, and pointer scanning. Following that, we’ll dive into Cheat Engine’s powerful embedded Lua scripting engine.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_4"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You can grab Cheat Engine from</em> <a href="http://www.cheatengine.org/">http://www.cheatengine.org/</a><em>. Pay attention when running the installer because it will try to install some toolbars and other bloatware. You can disable those options if you wish.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec7"><strong>Why Memory Scanners Are Important</strong></h3>&#13;
<p class="noindent">Knowing a game’s state is paramount to interacting with the game intelligently, but unlike humans, software can’t determine the state of a game simply by looking at what’s on the screen. Fortunately, underneath all of the stimuli produced by a game, a computer’s memory contains a purely numeric representation of that game’s state—and programs can understand numbers easily. Hackers use memory scanners to find those values in memory, and then in their programs, they read the memory in these locations to understand the game’s state.</p>&#13;
<p class="indent">For example, a program that heals players when they fall below 500 health needs to know how to do two things: track a player’s current health and cast a healing spell. The former requires access to the game’s state, while the latter might only require a button to be pressed. Given the location where a player’s health is stored and the way to read a game’s memory, the program would look something like this pseudocode:</p>&#13;
<p class="programs">// do this in some loop<br/>health = readMemory(game, HEALTH_LOCATION)<br/>if (health &lt; 500)<br/>    pressButton(HEAL_BUTTON)</p>&#13;
<p class="indent">A memory scanner allows you to find <span class="literal">HEALTH_LOCATION</span> so that your software can query it for you later.</p>&#13;
<h3 class="h3" id="ch00lev1sec8"><strong>Basic Memory Scanning</strong></h3>&#13;
<p class="noindent">The memory scanner is the most basic, yet most important, tool for the aspiring game hacker. As in any program, all data in the memory of a game resides at an absolute location called a <em>memory address</em>. If you think of the memory as a very large byte array, a memory address is an index pointing to a value in that array. When a memory scanner is told to find some value <em>x</em> (called a <em>scan value</em>, because it’s the value you’re scanning for) in a game’s memory, the scanner loops through the byte array looking for any value equal to <em>x</em>. Every time it finds a matching value, it adds the index of the match to a result list.</p>&#13;
<p class="indent">Due to the sheer size of a game’s memory, however, the value of <em>x</em> can appear in hundreds of locations. Imagine that <em>x</em> is the player’s health, which is currently 500. Our <em>x</em> uniquely holds <span class="literal">500</span>, but <span class="literal">500</span> is not uniquely held by <em>x</em>, so a scan for <em>x</em> returns all variables with a value of <span class="literal">500</span>. Any addresses not related to <em>x</em> are ultimately clutter; they share a value of <span class="literal">500</span> with <em>x</em> only by <span epub:type="pagebreak" id="page_5"/>chance. To filter out these unwanted values, the memory scanner allows you to rescan the result list, removing addresses that no longer hold the same value as <em>x</em>, whether <em>x</em> is still <span class="literal">500</span> or has changed.</p>&#13;
<p class="indent">For these rescans to be effective, the overall state of the game must have significant <em>entropy</em>—a measure of disorder. You increase entropy by changing the in-game environment, often by moving around, killing creatures, or switching characters. As entropy increases, unrelated addresses are less likely to continue to arbitrarily hold the same value, and given enough entropy, a few rescans should filter out all false positives and leave you with the true address of <em>x</em>.</p>&#13;
<h3 class="h3" id="ch00lev1sec9"><strong>Cheat Engine’s Memory Scanner</strong></h3>&#13;
<p class="noindent">This section gives you a tour of Cheat Engine’s memory-scanning options, which will help you track down the addresses of game state values in memory. I’ll give you a chance to try the scanner out in “<a href="ch01.xhtml#ch01sb01">Basic Memory Editing</a>” on <a href="ch01.xhtml#page_11">page 11</a>; for now, open Cheat Engine and have a look around. The memory scanner is tightly encapsulated in its main window, as shown in <a href="ch01.xhtml#ch1fig1">Figure 1-1</a>.</p>&#13;
<div class="image"><img src="../images/f01-01.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch1fig1"/><em>Figure 1-1: Cheat Engine main screen</em></p>&#13;
<p class="indent">To begin scanning a game’s memory, click the Attach icon <span class="ent">➊</span> to attach to a process and then enter the scan value (referred to as <em>x</em> in our conceptual scanner) you want to locate <span class="ent">➌</span>. By attaching to a process, we’re telling <span epub:type="pagebreak" id="page_6"/>Cheat Engine to prepare to operate on it; in this case, that operation is a scan. It helps to also tell Cheat Engine what kind of scan to run, as I’ll discuss next.</p>&#13;
<h4 class="h4" id="ch00lev1sec10"><strong><em>Scan Types</em></strong></h4>&#13;
<p class="noindentb">Cheat Engine allows you to select two different scan directives, called Scan Type and Value Type <span class="ent">➍</span>. Scan Type tells the scanner how to compare your scan value with the memory being scanned using one of the following scan types:</p>&#13;
<p class="noindenth"><strong>Exact Value</strong> Returns addresses pointing to values equal to the scan value. Choose this option if the value you are looking for won’t change during the scan; health, mana, and level typically fall into this category.</p>&#13;
<p class="noindenth"><strong>Bigger Than</strong> Returns addresses pointing to values greater than the scan value. This option is useful when the value you’re searching for is steadily increasing, which often happens with timers.</p>&#13;
<p class="noindenth"><strong>Smaller Than</strong> Returns addresses pointing to values smaller than the scan value. Like Bigger Than, this option is useful for finding timers (in this case, ones that count down rather than up).</p>&#13;
<p class="noindenth"><strong>Value Between</strong> Returns addresses pointing to values within a scan value range. This option combines Bigger Than and Smaller Than, displaying a secondary scan value box that allows you to input a much smaller range of values.</p>&#13;
<p class="noindenth"><strong>Unknown Initial Value</strong> Returns all addresses in a program’s memory, allowing rescans to examine the entire address range relative to their initial values. This option is useful for finding item or creature types, since you won’t always know the internal values the game developers used to represent these objects.</p>&#13;
<p class="indentt">The Value Type directive tells the Cheat Engine scanner what type of variable it’s searching for.</p>&#13;
<h4 class="h4" id="ch00lev1sec11"><strong><em>Running Your First Scan</em></strong></h4>&#13;
<p class="noindent">Once the two scan directives are set, click <strong>First Scan</strong> <span class="ent">➋</span> to run an initial scan for values, and the scanner will populate the results list <span class="ent">➎</span>. Any green addresses in this list are <em>static</em>, meaning that they should remain persistent across program restarts. Addresses listed in black reside in <em>dynamically allocated memory</em>, memory that is allocated at runtime.</p>&#13;
<p class="indent">When the results list is first populated, it shows the address and real-time value of each result. Each rescan will also show the value of each result during the previous scan. (Any real-time values displayed are updated at an interval that you can set in Edit <span class="ent">▸</span> Settings <span class="ent">▸</span>General Settings <span class="ent">▸</span>Update interval.)</p>&#13;
<h4 class="h4" id="ch00lev1sec12"><span epub:type="pagebreak" id="page_7"/><strong><em>Next Scans</em></strong></h4>&#13;
<p class="noindentb">Once the results list is populated, the scanner enables the Next Scan <span class="ent">➋</span> button, which offers six new scan types. These additional scan types allow you to compare the addresses in the results list to their values in the previous scan, which will help you narrow down which address holds the game state value you’re scanning for. They are as follows:</p>&#13;
<p class="noindenth"><strong>Increased Value</strong> Returns addresses pointing to values that have increased. This complements the Bigger Than scan type by keeping the same minimum value and removing any address whose value has decreased.</p>&#13;
<p class="noindenth"><strong>Increased Value By</strong> Returns addresses pointing to values that have increased by a defined amount. This scan type usually returns far fewer false positives, but you can use it only when you know exactly how much a value has increased.</p>&#13;
<p class="noindenth"><strong>Decreased Value</strong> This option is the opposite of Increased Value.</p>&#13;
<p class="noindenth"><strong>Decreased Value By</strong> This option is the opposite of Increased Value By.</p>&#13;
<p class="noindenth"><strong>Changed Value</strong> Returns addresses pointing to values that have changed. This type is useful when you know a value will mutate, but you’re unsure how.</p>&#13;
<p class="noindenth"><strong>Unchanged Value</strong> Returns addresses pointing to values that haven’t changed. This can help you eliminate false positives, since you can easily create a large amount of entropy while ensuring the desired value stays the same.</p>&#13;
<p class="indentt">You’ll usually need to use multiple scan types in order to narrow down a large result list and find the correct address. Eliminating false positives is often a matter of properly creating entropy (as described in “<a href="ch01.xhtml#ch00lev1sec8">Basic Memory Scanning</a>” on <a href="ch01.xhtml#page_4">page 4</a>), tactically changing your scan directives, bravely pressing Next Scan, and then repeating the process until you have a single remaining address.</p>&#13;
<h4 class="h4" id="ch00lev1sec13"><strong><em>When You Can’t Get a Single Result</em></strong></h4>&#13;
<p class="noindent">Sometimes it is impossible to pinpoint a single result in Cheat Engine, in which case you must determine the correct address through experimentation. For example, if you’re looking for your character’s health and can’t narrow it down to fewer than five addresses, you could try modifying the value of each address (as discussed in “<a href="ch01.xhtml#ch00lev1sec16">Manual Modification with Cheat Engine</a>” on <a href="ch01.xhtml#page_8">page 8</a>) until you see the health display change or the other values automatically change to the one you set.</p>&#13;
<h4 class="h4" id="ch00lev1sec14"><strong><em>Cheat Tables</em></strong></h4>&#13;
<p class="noindent">Once you’ve found the correct address, you can double-click it to add it to the <em>cheat table pane</em> <span class="ent">➏</span>; addresses in the cheat table pane can be modified, watched, and saved to cheat table files for future use.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_8"/>For each address in the cheat table pane, you can add a description by double-clicking the Description column, and you can add a color by right-clicking and selecting Change Color. You can also display the values of each address in hexadecimal or decimal format by right-clicking and selecting Show as hexadecimal or Show as decimal, respectively. Lastly, you can change the data type of each value by double-clicking the Type column, or you can change the value itself by double-clicking the Value column.</p>&#13;
<p class="indent">Since the main purpose of the cheat table pane is to allow a game hacker to neatly track addresses, it can be dynamically saved and loaded. Go to <strong>File</strong> <span class="ent">▸</span> <strong>Save</strong> or <strong>File</strong> <span class="ent">▸</span><strong>Save As</strong> to save the current cheat table pane to a <em>.ct</em> document file containing each address with its value type, description, display color, and display format. To load the saved <em>.ct</em> documents, go to <strong>File</strong> <span class="ent">▸</span><strong>Load</strong>. (You’ll find many ready-made cheat tables for popular games at <em><a href="http://cheatengine.org/tables.php">http://cheatengine.org/tables.php</a></em>.)</p>&#13;
<p class="indent">Now that I’ve described how to scan for a game state value, I’ll discuss how you can change that value when you know where it lives in memory.</p>&#13;
<h3 class="h3" id="ch00lev1sec15"><strong>Memory Modification in Games</strong></h3>&#13;
<p class="noindent">Bots cheat a game system by modifying memory values in the game’s state in order to give you lots of in-game money, modify your character’s health, change your character’s position, and so on. In most online games, a character’s vitals (such as health, mana, skills, and position) are held in memory but are controlled by the game server and relayed to your local game client over the Internet, so modifying such values during online play is merely cosmetic and doesn’t affect the actual values. (Any useful memory modification to an online game requires a much more advanced hack that’s beyond Cheat Engine’s capabilities.) In local games with no remote server, however, you can manipulate all of these values at will.</p>&#13;
<h4 class="h4" id="ch00lev1sec16"><strong><em>Manual Modification with Cheat Engine</em></strong></h4>&#13;
<p class="noindent">We’ll use Cheat Engine to understand how the memory modification magic works.</p>&#13;
<p class="indent">To modify memory manually, do the following:</p>&#13;
<ol>&#13;
<li><p class="noindent">Attach Cheat Engine to a game.</p></li>&#13;
<li><p class="noindent">Either scan for the address you wish to modify or load a cheat table that contains it.</p></li>&#13;
<li><p class="noindent">Double-click on the Value column for the address to open an input prompt where you can enter a new value.</p></li>&#13;
<li><p class="noindent">If you want to make sure the new value can’t be overwritten, select the box under the Active column to <em>freeze</em> the address, which will make Cheat Engine keep writing the same value back to it every time it changes.</p></li>&#13;
</ol>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_9"/>This method works wonders for quick-and-dirty hacks, but constantly changing values by hand is cumbersome; an automated solution would be much more appealing.</p>&#13;
<h4 class="h4" id="ch00lev1sec17"><strong><em>Trainer Generator</em></strong></h4>&#13;
<p class="noindent">Cheat Engine’s trainer generator allows you to automate the whole memory modification process without writing any code.</p>&#13;
<p class="indent">To create a <em>trainer</em> (a simple bot that binds memory modification actions to keyboard hotkeys), go to <strong>File</strong> <span class="ent">▸</span> <strong>Create generic trainer Lua script from table</strong>. This opens a Trainer generator dialog similar to the one shown in <a href="ch01.xhtml#ch1fig2">Figure 1-2</a>.</p>&#13;
<div class="image"><img src="../images/f01-02.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch1fig2"/><em>Figure 1-2: Cheat Engine Trainer generator dialog</em></p>&#13;
<p class="indentb">There are a number of fields to modify here:</p>&#13;
<p class="noindenth"><strong>Processname</strong> The name of the executable the trainer should attach to. This is the name shown in the process list when you attach with Cheat Engine, and it should be autofilled with the name of the process Cheat Engine is attached to.</p>&#13;
<p class="noindenth"><strong>Popup trainer on keypress</strong> Optionally enables a hotkey—which you set by entering a key combination in the box below the checkbox—to display the trainer’s main window.</p>&#13;
<p class="noindenth"><strong>Title</strong> The name of your trainer, which will be displayed on its interface. This is optional.</p>&#13;
<p class="noindenth"><strong>About text</strong> The description of your trainer, to be displayed on the interface; this is also optional.</p>&#13;
<p class="noindenth"><strong>Freeze interval (in milliseconds)</strong> The interval during which a freeze operation overwrites the value. You should generally leave this at 250, as lower intervals can sap resources and higher values may be too slow.</p>&#13;
<p class="indentt"><span epub:type="pagebreak" id="page_10"/>Once these values are configured, click <strong>Add Hotkey</strong> to set up a key sequence to activate your trainer. You will be prompted to select a value from your cheat table. Enter a value, and you will be taken to a Set/Change hotkey screen similar to <a href="ch01.xhtml#ch1fig3">Figure 1-3</a>.</p>&#13;
<div class="image"><img src="../images/f01-03.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch1fig3"/><em>Figure 1-3: Cheat Engine Set/Change hotkey screen</em></p>&#13;
<p class="indentb">On this screen, place your cursor in the box labeled Type the keys you want to set the hotkey to <span class="ent">➊</span> and enter the desired key combination. Next, choose the desired action from the drop-down menu <span class="ent">➋</span>; your options should appear in the following order:</p>&#13;
<p class="noindenth"><strong>Toggle freeze</strong> Toggles the freeze state of the address.</p>&#13;
<p class="noindenth"><strong>Toggle freeze and allow increase</strong> Toggles the freeze state of the address but allows the value to increase. Any time the value decreases, the trainer overwrites it with its previous value. Increased values will not be overwritten.</p>&#13;
<p class="noindenth"><strong>Toggle freeze and allow decrease</strong> Does the opposite of Toggle freeze and allow increase.</p>&#13;
<p class="noindenth"><strong>Freeze</strong> Sets the address to frozen if it’s not frozen already.</p>&#13;
<p class="noindenth"><strong>Unfreeze</strong> Unfreezes the address if it’s frozen.</p>&#13;
<p class="noindenth"><strong>Set value to</strong> Sets the value to whatever you specify in the value box <span class="ent">➌</span>.</p>&#13;
<p class="noindenth"><strong>Decrease value with</strong> Decreases the value by the amount you specify in the value box <span class="ent">➌</span>.</p>&#13;
<p class="noindenth"><strong>Increase value with</strong> Does the opposite of Decrease value with.</p>&#13;
<p class="indentt">Finally, you can set a description for the action <span class="ent">➍</span>. Click <strong>Apply</strong>, then <strong>OK</strong>, and your action will appear in the list on the Trainer generator screen. At this point, Cheat Engine runs the trainer in the background, and you can simply press the hotkeys you configured to execute the memory actions.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_11"/>To save your trainer to a portable executable, click <strong>Generate trainer</strong>. Running this executable after the game is launched will attach your trainer to the game so you can use it without starting Cheat Engine.</p>&#13;
<p class="indent">Now that you know your way around Cheat Engine’s memory scanner and trainer generator, try modifying some memory yourself.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart" id="ch01sb01"><strong>BASIC MEMORY EDITING</strong></p>&#13;
<p class="noindent">Download the files for this book from <em><a href="https://www.nostarch.com/gamehacking/">https://www.nostarch.com/gamehacking/</a></em>, and run the file <em>BasicMemory.exe</em>. Next, start up Cheat Engine and attach to the binary. Then, using only Cheat Engine, find the addresses for the x- and y-coordinates of the gray ball. (Hint: Use the 4 Bytes value type.)</p>&#13;
<p class="indent">Once you’ve found the values, modify them to place the ball on top of the black square. The game will let you know once you’ve succeeded by displaying the text “Good job!” (Hint: Each time the ball is moved, its position—stored as a 4-byte integer—in that plane is changed by 1. Also, try to look only for static [green] results.)</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec18"><strong>Pointer Scanning</strong></h3>&#13;
<p class="noindent">As I’ve mentioned, online games often store values in dynamically allocated memory. While addresses that reference dynamic memory are useless to us in and of themselves, some static address will always point to another address, which in turn points to another, and so on, until the tail of the chain points to the dynamic memory we’re interested in. Cheat Engine can locate these chains using a method called <em>pointer scanning</em>.</p>&#13;
<p class="indent">In this section, I’ll introduce you to pointer chains and then describe how pointer scanning works in Cheat Engine. When you have a good grasp of the user interface, you can get some hands-on experience in “<a href="ch01.xhtml#ch00lev1sec18">Pointer Scanning</a>” on <a href="ch01.xhtml#page_18">page 18</a>.</p>&#13;
<h4 class="h4" id="ch00lev1sec19"><strong><em>Pointer Chains</em></strong></h4>&#13;
<p class="noindent">The chain of offsets I’ve just described is called a <em>pointer chain</em> and looks like this:</p>&#13;
<p class="programs">list&lt;int&gt; chain = {<span class="codeitalic">start</span>, <span class="codeitalic">offset1</span>, <span class="codeitalic">offset2</span>[<span class="codeitalic">, ...</span>]}</p>&#13;
<p class="indent">The first value in this pointer chain (<span class="literal">start</span>) is called a <em>memory pointer</em>. It’s an address that starts the chain. The remaining values (<span class="literal">offset1</span>, <span class="literal">offset2</span>, and so on) make up the route to the desired value, called a <em>pointer path</em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_12"/>This pseudocode shows how a pointer chain might be read:</p>&#13;
<p class="programs">   int readPointerChain(chain) {<br/><span class="ent">➊</span>      ret = read(chain[0])<br/>       for i = 1, chain.len - 1, 1 {<br/>           offset = chain[i]<br/>           ret = read(ret + offset)<br/>       }<br/>       return ret<br/>   }</p>&#13;
<p class="indent">This code creates the function <span class="literal">readPointerPath()</span>, which takes a pointer chain called <span class="literal">chain</span> as a parameter. The function <span class="literal">readPointerPath()</span> treats the pointer path in <span class="literal">chain</span> as a list of memory offsets from the address <span class="literal">ret</span>, which is initially set to the memory pointer at <span class="ent">➊</span>. It then loops through these offsets, updating the value of <span class="literal">ret</span> to the result of <span class="literal">read(ret + offset)</span> on each iteration and returning <span class="literal">ret</span> once it’s finished. This pseudocode shows what <span class="literal">readPointerPath()</span> looks like when the loop is unrolled:</p>&#13;
<p class="programs">list&lt;int&gt; chain = {0xDEADBEEF, 0xAB, 0x10, 0xCC}<br/>value = readPointerPath(chain)<br/>// the function call unrolls to this<br/>ret = read(0xDEADBEEF) //chain[0]<br/>ret = read(ret + 0xAB)<br/>ret = read(ret + 0x10)<br/>ret = read(ret + 0xCC)<br/>int value = ret</p>&#13;
<p class="indent">The function ultimately calls <span class="literal">read</span> four times, on four different addresses—one for each element in <span class="literal">chain</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Many game hackers prefer to code their chain reads in place, instead of encapsulating them in functions like</em> <span class="literal"><span class="codeitalic">readPointerPath()</span></span>.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev1sec20"><strong><em>Pointer Scanning Basics</em></strong></h4>&#13;
<p class="noindent">Pointer chains exist because every chunk of dynamically allocated memory must have a corresponding static address that the game’s code can use to reference it. Game hackers can access these chunks by locating the pointer chains that reference them. Because of their multitier structure, however, pointer chains cannot be located through the linear approach that memory scanners use, so game hackers have devised new ways to find them.</p>&#13;
<p class="indent">From a reverse engineering perspective, you could locate and analyze the assembly code in order to deduce what pointer path it used to access the value, but doing so is very time-consuming and requires advanced tools. <em>Pointer scanners</em> solve this problem by using brute-force to recursively iterate over every possible pointer chain until they find one that resolves to the target memory address.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_13"/>The <a href="ch01.xhtml#ch1exe1">Listing 1-1</a> pseudocode should give you a general idea of how a pointer scanner works.</p>&#13;
<p class="programs">   list&lt;int&gt; pointerScan(target, maxAdd, maxDepth) {<br/><span class="ent">➊</span>    for address = BASE, 0x7FFFFFF, 4 {<br/>           ret = rScan(address, target, maxAdd, maxDepth, 1)<br/>           if (ret.len &gt; 0) {<br/>               ret.pushFront(address)<br/>               return ret<br/>           }<br/>      }<br/>      return {}<br/>   }<br/>   list&lt;int&gt; rScan(address, target, maxAdd, maxDepth, curDepth) {<br/><span class="ent">➋</span>      for offset = 0, maxAdd, 4 {<br/>            value = read(address + offset)<br/><span class="ent">➌</span>          if (value == target)<br/>                return list&lt;int&gt;(offset)<br/>        }<br/><span class="ent">➍</span>      if (curDepth &lt; maxDepth) {<br/>            curDepth++<br/><span class="ent">➎</span>          for offset = 0, maxAdd, 4 {<br/>                ret = rScan(address + offset, target, maxAdd, maxDepth, curDepth) <br/><span class="ent">➏</span>              if (ret.len &gt; 0) {<br/>                    ret.pushFront(offset)<br/><span class="ent">➐</span>                  return ret<br/>                }<br/>            }<br/>        }<br/>        return {}<br/>   }</p>&#13;
<p class="listt"><a id="ch1exe1"/><em>Listing 1-1: Pseudocode for a pointer scanner</em></p>&#13;
<p class="indent">This code creates the functions <span class="literal">pointerScan()</span> and <span class="literal">rScan()</span>.</p>&#13;
<h5 class="h5" id="ch00lev1sec21"><strong>pointerScan()</strong></h5>&#13;
<p class="noindent">The <span class="literal">pointerScan()</span> function is the entry point to the scan. It takes the parameters <span class="literal">target</span> (the dynamic memory address to find), <span class="literal">maxAdd</span> (the maximum value of any offset), and <span class="literal">maxDepth</span> (the maximum length of the pointer path). It then loops through every 4-byte aligned address <span class="ent">➊</span> in the game, calling <span class="literal">rScan()</span> with the parameters <span class="literal">address</span> (the address in the current iteration), <span class="literal">target</span>, <span class="literal">maxAdd</span>, <span class="literal">maxDepth</span>, and <span class="literal">curDepth</span> (the depth of the path, which is always 1 in this case).</p>&#13;
<h5 class="h5" id="ch00lev1sec22"><strong>rScan()</strong></h5>&#13;
<p class="noindent">The <span class="literal">rScan()</span> function reads memory from every 4-byte aligned offset between <span class="literal">0</span> and <span class="literal">maxAdd</span> <span class="ent">➋</span>, and returns if a result is equal to <span class="literal">target</span> <span class="ent">➌</span>. If <span class="literal">rScan()</span> doesn’t return in the first loop and the recursion is not too deep <span class="ent">➍</span>, it increments <span class="literal">curDepth</span> and again loops over each offset <span class="ent">➎</span>, calling itself for each iteration.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_14"/>If a self call returns a partial pointer path <span class="ent">➏</span>, <span class="literal">rScan()</span> will prepend the current offset to the path and return up the recursion chain <span class="ent">➐</span> until it reaches <span class="literal">pointerScan()</span>. When a call to <span class="literal">rScan()</span> from <span class="literal">pointerScan()</span> returns a pointer path, <span class="literal">pointerScan()</span> pushes the current address to the front of the path and returns it as a complete chain.</p>&#13;
<h4 class="h4" id="ch00lev1sec23"><strong><em>Pointer Scanning with Cheat Engine</em></strong></h4>&#13;
<p class="noindent">The previous example showed the basic process of pointer scanning, but the implementation I’ve shown is primitive. Aside from being insanely slow to execute, it would generate countless false positives. Cheat Engine’s pointer scanner uses a number of advanced interpolations to speed up the scan and make it more accurate, and in this section, I’ll introduce you to the smorgasbord of available scanning options.</p>&#13;
<p class="indent">To initiate a pointer scan in Cheat Engine, right-click on a dynamic memory address in your cheat table and click <strong>Pointer scan for this address</strong>. When you initiate a pointer scan, Cheat Engine will ask you where to store the scan results as a <em>.ptr</em> file. Once you enter a location, a Pointerscanner scanoptions dialog similar to the one shown in <a href="ch01.xhtml#ch1fig4">Figure 1-4</a> will appear.</p>&#13;
<div class="image"><img src="../images/f01-04.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch1fig4"/><em>Figure 1-4: Cheat Engine Pointerscanner scanoptions dialog</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_15"/>The Address to find input field at the top displays your dynamic memory address. Now carefully select from among Cheat Engine’s many scan options.</p>&#13;
<h5 class="h5" id="ch00lev1sec24"><strong>Key Options</strong></h5>&#13;
<p class="noindent">Several of Cheat Engine’s scan options typically retain their default values. Those options are as follows:</p>&#13;
<p class="noindenth"><strong>Addresses must be 32-bits aligned</strong> Tells Cheat Engine to scan only addresses that are multiples of 4, which greatly increases the scan speed. As you’ll learn in <a href="ch04.xhtml#ch04">Chapter 4</a>, compilers align data so that most addresses will be multiples of 4 anyway by default. You’ll rarely need to disable this option.</p>&#13;
<p class="noindenth"><strong>Only find paths with a static address</strong> Speeds up the scan by preventing Cheat Engine from searching paths with a dynamic start pointer. This option should <em>always</em> be enabled because scanning for a path starting at another dynamic address can be counterproductive.</p>&#13;
<p class="noindenth"><strong>Don’t include pointers with read-only nodes</strong> Should also always be enabled. Dynamically allocated memory that stores volatile data should never be read-only.</p>&#13;
<p class="noindenth"><strong>Stop traversing a path when a static has been found</strong> Terminates the scan when it finds a pointer path with a static start address. This should be enabled to reduce false positives and speed up the scan.</p>&#13;
<p class="noindenth"><strong>Pointer path may only be inside this region</strong> Can typically be left as is. The other options available to you compensate for this large range by intelligently narrowing the scope of the scan.</p>&#13;
<p class="noindenth"><strong>First element of pointerstruct must point to module</strong> Tells Cheat Engine not to search heap chunks in which virtual function tables are not found, under the assumption that the game was coded using object orientation. While this setting can immensely speed up scans, it’s highly unreliable and you should almost always leave it disabled.</p>&#13;
<p class="noindenth"><strong>No looping pointers</strong> Invalidates any paths that point to themselves, weeding out inefficient paths but slightly slowing down the scan. This should usually be enabled.</p>&#13;
<p class="noindenth"><strong>Max level</strong> Determines the maximum length of the pointer path. (Remember the <span class="literal">maxDepth</span> variable in the example code in <a href="ch01.xhtml#ch1exe1">Listing 1-1</a>?) This should be kept around 6 or 7.</p>&#13;
<p class="indent">Of course, there will be times when you’ll need to change these options from the settings described. For example, failing to obtain reliable results with the No looping pointers or Max level settings typically means that the value you’re looking for exists in a dynamic data structure, like a linked list, binary tree, or vector. Another example is the Stop traversing a path when a static has been found option, which in rare cases can prevent you from getting reliable results.</p>&#13;
<h5 class="h5" id="ch00lev1sec25"><span epub:type="pagebreak" id="page_16"/><strong>Situational Options</strong></h5>&#13;
<p class="noindent">Unlike the previous options, your settings for the remaining ones will depend on your situation. Here’s how to determine the best configuration for each:</p>&#13;
<p class="noindenth"><strong>Improve pointerscan with gathered heap data</strong> Allows Cheat Engine to use the heap allocation record to determine offset limits, effectively speeding up the scan by weeding out many false positives. If you run into a game using a custom memory allocator (which is becoming increasingly common), this option can actually do the exact opposite of what it’s meant to do. You can leave this setting enabled in initial scans, but it should be the first to go when you’re unable to find reliable paths.</p>&#13;
<p class="noindenth"><strong>Only allow static and heap addresses in the path</strong> Invalidates all paths that can’t be optimized with heap data, making this approach even more aggressive.</p>&#13;
<p class="noindenth"><strong>Max different offsets per node</strong> Limits the number of same-value pointers the scanner checks. That is, if <em>n</em> different addresses point to <span class="literal">0x0BADF00D</span>, this option tells Cheat Engine to consider only the first <em>m</em> addresses. This can be extremely helpful when you’re unable to narrow down your result set. In other cases, you may want to disable it, as it will miss many valid paths.</p>&#13;
<p class="noindenth"><strong>Allow stack addresses of the first thread(s) to be handled as static</strong> Scans the call stacks of oldest <em>m</em> threads in the game, considering the first <em>n</em> bytes in each one. This allows Cheat Engine to scan the parameters and local variables of functions in the game’s call chain (the goal being to find variables used by the game’s main loop). The paths found with this option can be both highly volatile and extremely useful; I use it only when I fail to find heap addresses.</p>&#13;
<p class="noindenth"><strong>Stack addresses as only static address</strong> Takes the previous option even further by allowing only stack addresses in pointer paths.</p>&#13;
<p class="noindenth"><strong>Pointers must end with specific offsets</strong> Can be useful if you know the offset(s) at the end of a valid path. This option will allow you to specify those offsets (starting with the last offset at the top), greatly reducing the scope of the scan.</p>&#13;
<p class="noindenth"><strong>Nr of threads scanning</strong> Determines how many threads the scanner will use. A number equal to the number of cores in your processor often works best. A drop-down menu with options allows you to specify the priority for each thread. Idle is best if you want your scan to go very slowly, Normal is what you should use for most scans, and Time critical is useful for lengthy scans but will render your computer useless for the scan duration.</p>&#13;
<p class="noindenth"><strong>Maximum offset value</strong> Determines the maximum value of each offset in the path. (Remember the <span class="literal">maxAdd</span> variable in <a href="ch01.xhtml#ch1exe1">Listing 1-1</a>?) I typically start with a low value, increasing it only if my scan fails; <span class="literal">128</span> is a good starting value. Keep in mind that this value is mostly ignored if you’re using the heap optimization options.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_17"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>What if both Only allow static and heap addresses in the path and Stack addresses as only static address are enabled? Will the scan come up empty? Seems like a fun, albeit useless, experiment.</em></p>&#13;
</div>&#13;
<p class="indent">Once you have defined your scan options, click <strong>OK</strong> to start a pointer scan. When the scan completes, a results window will appear with the list of pointer chains found. This list often has thousands of results, containing both real chains and false positives.</p>&#13;
<h4 class="h4" id="ch00lev1sec26"><strong><em>Pointer Rescanning</em></strong></h4>&#13;
<p class="noindent">The pointer scanner has a rescan feature that can help you eliminate false positives. To begin, press <small>CTRL</small>-R from the results window to open the Rescan pointerlist dialog, as shown in <a href="ch01.xhtml#ch1fig5">Figure 1-5</a>.</p>&#13;
<div class="image"><img src="../images/f01-05.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch1fig5"/><em>Figure 1-5: Cheat Engine Rescan pointerlist dialog</em></p>&#13;
<p class="indent">There are two main options to consider when you tell Cheat Engine to rescan:</p>&#13;
<p class="noindenth"><strong>Only filter out invalid pointers</strong> If you check this box <span class="ent">➊</span>, the rescan will discard only pointer chains that point to invalid memory, which helps if your initial result set is very large. Disable this to filter out paths that don’t resolve to a specific address or value (as shown in the figure).</p>&#13;
<p class="noindenth"><strong>Repeat rescan until stopped</strong> If you check this box <span class="ent">➋</span>, the rescan will execute in a continuous loop. Ideally, you should enable this setting and let rescan run while you create a large amount of memory entropy.</p>&#13;
<p class="indentt">For the initial rescan, enable both <strong>Only filter out invalid pointers</strong> and <strong>Repeat rescan until stopped</strong>, and then press <strong>OK</strong> to initiate the rescan. The rescan window will go away, and a Stop rescan loop button will appear in the results window. The result list will be constantly rescanned until you click Stop rescan loop, but spend a few minutes creating memory entropy before doing so.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_18"/>In rare cases, rescanning using a rescan loop may still leave you with a large list of possible paths. When this happens, you may need to restart the game, find the address that holds your value (it may have changed!), and use the rescan feature on this address to further narrow results. In this scan, leave <strong>Only filter out invalid pointers</strong> unchecked and enter the <em>new</em> address in the <strong>Address to find</strong> field.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you had to close the results window, you can reopen it and load the result list by going to the main Cheat Engine window and pressing the Memory View button below the results pane. This should bring up a memory dump window. When the window appears, press <small>CTRL</small>-P to open the pointer scan results list. Then press <small>CTRL</small>-O to open the</em> .ptr <em>file where you saved the pointer scan.</em></p>&#13;
</div>&#13;
<p class="indent">If your results still aren’t narrow enough, try running the same scan across system restarts or even on different systems. If this still yields a large result set, each result can safely be considered static because more than one pointer chain can resolve to the same address.</p>&#13;
<p class="indent">Once you’ve narrowed down your result set, double-click on a usable pointer chain to add it to your cheat table. If you have a handful of seemingly usable chains, grab the one with the fewest offsets. If you find multiple chains with identical offsets that start with the same pointer but diverge after a certain point, your data may be stored in a dynamic data structure.</p>&#13;
<p class="indent">That’s all there is to pointer scanning in Cheat Engine. Try it yourself!</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><strong>POINTER SCANNING</strong></p>&#13;
<p class="noindent">Go to <em><a href="https://www.nostarch.com/gamehacking/">https://www.nostarch.com/gamehacking/</a></em> and download <em>MemoryPointers.exe</em>. Unlike the last task, which required you to win only once, this one requires that you win 50 times in 10 seconds. Upon each win, the memory addresses for the x- and y-coordinates will change, meaning you will be able to freeze the value only if you have found a proper pointer path. Start this exercise the same way as the previous one, but once you’ve found the addresses, use the Pointer scan feature to locate pointer paths to them. Then, place the ball on top of the black square, freeze the value in place, and press <small>TAB</small> to begin the test. Just as before, the game will let you know once you’ve won. (Hint: Try setting the maximum level to <span class="literal">5</span> and the maximum offset value to <span class="literal">512</span>. Also, play with the options to allow stack addresses, terminate the scan when a static is found, and improve the pointer scan with heap data. See which combination of options gives the best results.)</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec27"><strong>Lua Scripting Environment</strong></h3>&#13;
<p class="noindent">Historically, bot developers rarely used Cheat Engine to update their addresses when a game released a patch because it was much easier to do so in OllyDbg. This made Cheat Engine useless to game hackers other <span epub:type="pagebreak" id="page_19"/>than for initial research and development—that is, until a powerful Lua-based embedded scripting engine was implemented around Cheat Engine’s robust scanning environment. While this engine was created to enable the development of simple bots within Cheat Engine, professional game hackers found they could also use it to easily write complex scripts to automatically locate addresses across different versions of a game’s binary—a task that might otherwise take hours.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You’ll find more detail about the Cheat Engine Lua scripting engine on the wiki at</em> <a href="http://wiki.cheatengine.org/">http://wiki.cheatengine.org/</a>.</p>&#13;
</div>&#13;
<p class="indent">To start using the Lua engine, press <small>CTRL-ALT</small>-L from the main Cheat Engine window. Once the window opens, write your script in the text area and click <strong>Execute script</strong> to run it. Save a script with <small>CTRL</small>-S and open a saved script with <small>CTRL</small>-O.</p>&#13;
<p class="indent">The scripting engine has hundreds of functions and infinite use cases, so I’ll give you just a glimpse of its abilities by breaking down two scripts. Every game is different and every game hacker writes scripts to accomplish unique goals, so these scripts are only useful for demonstrating concepts.</p>&#13;
<h4 class="h4" id="ch00lev1sec28"><strong><em>Searching for Assembly Patterns</em></strong></h4>&#13;
<p class="noindent">This first script locates functions that compose outgoing packets and sends them to the game server. It works by searching a game’s assembly code for functions that contain a certain code sequence.</p>&#13;
<p class="programs"><span class="ent">➊</span> BASEADDRESS = getAddress("Game.exe")<br/><span class="ent">➋</span> function LocatePacketCreation(packetType)<br/><span class="ent">➌</span>     for address = BASEADDRESS, (BASEADDRESS + 0x2ffffff) do<br/>           local push = readBytes(address, 1, false)<br/>           local type = readInteger(address + 1)<br/>           local call = readInteger(address + 5)<br/><span class="ent">➍</span>         if (push == 0x68 and type == packetType and call == 0xE8) then<br/>               return address<br/>           end<br/>       end<br/>       return 0<br/>   end<br/>   FUNCTIONHEADER = { 0xCC, 0x55, 0x8B, 0xEC, 0x6A }<br/><span class="ent">➎</span> function LocateFunctionHead(checkAddress)<br/>       if (checkAddress == 0) then return 0 end <br/><span class="ent">➏</span>     for address = checkAddress, (checkAddress - 0x1fff), -1 do<br/>           local match = true<br/>           local checkheader = readBytes(address, #FUNCTIONHEADER, true)<br/><span class="ent">➐</span>         for i, v in ipairs(FUNCTIONHEADER) do<br/>               if (v ~= checkheader[i]) then<br/>                   match = false<br/>                   break<br/>               end<br/>           end<br/><span class="ent">➑</span>         if (match) then return address + 1 end<br/>       end<br/>       return 0<br/>   end<br/><br/><span class="ent">➒</span> local funcAddress = LocateFunctionHead(LocatePacketCreation(0x64))<br/>   if (funcAddress ~= 0) then<br/>       print(string.format("0x%x",funcAddress))<br/>   else<br/>       print("Not found!")<br/>   end</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_20"/>The code begins by getting the base address of the module that Cheat Engine is attached to <span class="ent">➊</span>. Once it has the base address, the function <span class="literal">LocatePacketCreation()</span> is defined <span class="ent">➋</span>. This function loops through the first <span class="literal">0x2FFFFFF</span> bytes of memory in the game <span class="ent">➌</span>, searching for a sequence that represents this x86 assembler code:</p>&#13;
<p class="programs">PUSH type   ; Data is: 0x68 [4byte type]<br/>CALL offset ; Data is: 0xE8 [4byte offset]</p>&#13;
<p class="indent">The function checks that the type is equal to <span class="literal">packetType</span>, but it doesn’t care what the function offset is <span class="ent">➍</span>. Once this sequence is found, the function returns.</p>&#13;
<p class="indent">Next, the <span class="literal">LocateFunctionHead()</span> function is defined <span class="ent">➎</span>. The function backtracks up to 0x1FFF bytes from a given address <span class="ent">➏</span>, and at each address, it checks for a stub of assembler code <span class="ent">➐</span> that looks something like this:</p>&#13;
<p class="programs">INT3         ; 0xCC<br/>PUSH EBP     ; 0x55<br/>MOV EBP, ESP ; 0x8B 0xEC<br/>PUSH [-1]    ; 0x6A 0xFF</p>&#13;
<p class="indent">This stub will be present at the beginning of every function, because it’s part of the function prologue that sets up the function’s stack frame. Once it finds the code, the function will return the address of the stub plus 1 <span class="ent">➑</span> (the first byte, <span class="literal">0xCC</span>, is padding).</p>&#13;
<p class="indent">To tie these steps together, the <span class="literal">LocatePacketCreation()</span> function is called with the <span class="literal">packetType</span> that I’m looking for (arbitrarily <span class="literal">0x64</span>) and the resulting address is passed into the <span class="literal">LocateFunctionHead()</span> function <span class="ent">➒</span>. This effectively locates the first function that pushes <span class="literal">packetType</span> into a function call and stores its address in <span class="literal">funcAddress</span>. This stub shows the result:</p>&#13;
<p class="programs">INT3          ; LocateFunctionHead back-tracked to here<br/>PUSH EBP      ;   and returned this address<br/>MOV EBP, ESP<br/>PUSH [-1]<br/>--<span class="codeitalic">snip</span>--<br/>PUSH [0x64]   ; LocatePacketCreation returned this address<br/>CALL [something]</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_21"/>This 35-line script can automatically locate 15 different functions in under a minute.</p>&#13;
<h4 class="h4" id="ch00lev1sec29"><strong><em>Searching for Strings</em></strong></h4>&#13;
<p class="noindent">This next Lua script scans a game’s memory for text strings. It works much as the Cheat Engine’s memory scanner does when you use the string value type.</p>&#13;
<p class="programs">   BASEADDRESS = getAddress("Game.exe")<br/><span class="ent">➊</span> function findString(str)<br/>       local len = string.len(str)<br/><span class="ent">➋</span>     local chunkSize = 4096<br/><span class="ent">➌</span>     local chunkStep = chunkSize - len<br/>       print("Found '" .. str .. "' at:")<br/><span class="ent">➍</span>     for address = BASEADDRESS, (BASEADDRESS + 0x2ffffff), chunkStep do<br/>           local chunk = readBytes(address, chunkSize, true)<br/>            if (not chunk) then break end<br/><span class="ent">➎</span>         for c = 0, chunkSize-len do <br/><span class="ent">➏</span>             checkForString(address , chunk, c, str, len)<br/>           end<br/>       end<br/>   end<br/>   function checkForString(address, chunk, start, str, len)<br/>       for i = 1, len do<br/>           if (chunk[start+i] ~= string.byte(str, i)) then<br/>               return false<br/>           end<br/>       end<br/><span class="ent">➐</span>     print(string.format("\t0x%x", address + start))<br/>   end<br/><br/><span class="ent">➑</span> findString("hello")<br/><span class="ent">➒</span> findString("world")</p>&#13;
<p class="indent">After getting the base address, the <span class="literal">findString()</span> function is defined <span class="ent">➊</span>, which takes a string, <span class="literal">str</span>, as a parameter. This function loops through the game’s memory <span class="ent">➍</span> in 4,096-byte-long chunks <span class="ent">➋</span>. The chunks are scanned sequentially, each one starting <span class="literal">len</span> (the length of <span class="literal">str</span>) bytes before the end of the previous one <span class="ent">➌</span> to prevent missing a string that begins on one chunk and ends on another.</p>&#13;
<p class="indent">As <span class="literal">findString()</span> reads each chunk, it iterates over every byte until the overlap point in the chunk <span class="ent">➎</span>, passing each subchunk into the <span class="literal">checkForString()</span> function <span class="ent">➏</span>. If <span class="literal">checkForString()</span> matches the subchunk to <span class="literal">str</span>, it prints the address of that subchunk to the console <span class="ent">➐</span>.</p>&#13;
<p class="indent">Lastly, to find all addresses that reference the strings <span class="literal">"hello"</span> and <span class="literal">"world"</span>, the functions <span class="literal">findString("hello")</span> <span class="ent">➑</span> and <span class="literal">findString("world")</span> <span class="ent">➒</span> are called. By using this code to search for embedded debug strings and pairing it with the previous code to locate function headers, I’m able to find a large number of internal functions within a game in mere seconds.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><span epub:type="pagebreak" id="page_22"/><strong>OPTIMIZING MEMORY CODE</strong></p>&#13;
<p class="noindent">Due to the high overhead of memory reading, optimization is extremely important when you’re writing code that performs memory reads. In the previous code snippet, notice that the function <span class="literal">findString()</span> does not use the Lua engine’s builtin <span class="literal">readString()</span> function. Instead, it reads big chunks of memory and searches them for the desired string. Let’s break down the numbers.</p>&#13;
<p class="indent">A scan using <span class="literal">readString()</span> would try to read a string of <span class="literal">len</span> bytes at every possible memory address. This means it would read, at most, <span class="literal">(0x2FFFFFF * len + len)</span> bytes. However, <span class="literal">findString()</span> reads chunks of 4,096 bytes and scans them locally for matching strings. This means it would read, at most, <span class="literal">(0x2FFFFFF + 4096 + (0x2FFFFFF / (4096 - 10)) * len)</span> bytes. When searching for a string with a length of 10, the number of bytes that each method would read is 503,316,480 and 50,458,923, respectively.</p>&#13;
<p class="indent">Not only does <span class="literal">findString()</span> read an order of magnitude less data, it also invokes far fewer memory reads. Reading in chunks of 4,096 bytes would require a total of <span class="literal">(0x2FFFFFF / (4096 - len))</span> reads. Compare that to a scan using <span class="literal">readString()</span>, which would need <span class="literal">0x2FFFFFF</span> reads. The scan that uses <span class="literal">findString()</span> is a huge improvement because invoking a read is much more expensive than increasing the size of data being read. (Note that I chose 4,096 arbitrarily. I keep the chunk relatively small because reading memory can be time-consuming, and it might be wasteful to read four pages at a time just to find the string in the first.)</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec30"><strong>Closing Thoughts</strong></h3>&#13;
<p class="noindent">By this point, you should have a basic understanding of Cheat Engine and how it works. Cheat Engine is a very important tool in your kit, and I encourage you to get some hands-on experience with it by following “<a href="ch01.xhtml#ch01sb01">Basic Memory Editing</a>” on <a href="ch01.xhtml#page_11">page 11</a> and “<a href="ch01.xhtml#ch00lev1sec18">Pointer Scanning</a>” on <a href="ch01.xhtml#page_18">page 18</a> and playing around with it on your own.</p>&#13;
</body></html>