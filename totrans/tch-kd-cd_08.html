<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Timers and Animation: What Would Disney Do?"><div class="titlepage"><div><div><h1 class="title"><a id="timers_and_animation_what_would_disney_d"/>Chapter 8. Timers and Animation: What Would Disney Do?</h1></div></div></div><p><a id="iddle1056" class="indexterm"/>One way that I learned to program in my teens was by programming short games and animations, and then changing the code to do something new. I was amazed that I could immediately see my code make graphics appear on the screen, and I think you’ll enjoy it as much as I did.</p><p><a id="iddle1076" class="indexterm"/><a id="iddle1686" class="indexterm"/><a id="iddle1687" class="indexterm"/>Games and animations have several things in common. First, they’re fun! Second, they both involve drawing graphics on the screen and changing those graphics over time to give the illusion of motion. We’ve been able to draw graphics from the beginning of this book, but the Turtle library is too slow to use for a lot of animation or moving objects. In this chapter, we’re going to install and work with a new module, <span class="emphasis"><em>Pygame</em></span>, that lets us draw, animate, and even create arcade-style games using the skills you’ve picked up so far.</p><div class="sect1" title="Getting All GUI with Pygame"><div class="titlepage"><div><div><h1 class="title"><a id="getting_all_gui_with_pygame"/>Getting All GUI with Pygame</h1></div></div></div><p>A <span class="emphasis"><em>graphical user interface</em></span> (<span class="emphasis"><em>GUI</em></span>, sometimes pronounced “gooey”) includes all the buttons, icons, menus, and windows that you see on your computer screen; it’s how you interact with a computer. When you drag and drop a file or click an icon to open a program, you’re enjoying a GUI. In games, when you press keys, move your mouse, or click, the only reason you can expect anything to happen (like running, jumping, rotating your view, and so on) is because a programmer set up the GUI.</p><p>Like the Turtle library, Pygame is very visual, perfect for GUIs for games, animations, and more. It’s portable to just about every operating system, from Windows to Mac to Linux and beyond, so the games and programs you create in Pygame can run on pretty much any computer. <a class="xref" href="ch08.html#pygame_is_freecomma_and_so_are_the_tutor" title="Figure 8-1. Pygame is free, and so are the tutorials and sample games on its website.">Figure 8-1</a> shows the Pygame website, where you’ll go to download Pygame.</p><div class="figure"><a id="pygame_is_freecomma_and_so_are_the_tutor"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00102"/><img src="httpatomoreillycomsourcenostarchimages2188975.png.jpg" alt="Pygame is free, and so are the tutorials and sample games on its website."/></div></div><p class="title">Figure 8-1. Pygame is free, and so are the tutorials and sample games on its website.</p></div><p><a id="iddle1259" class="indexterm"/><a id="iddle1703" class="indexterm"/><a id="iddle1719" class="indexterm"/><a id="iddle1870" class="indexterm"/><a id="iddle1871" class="indexterm"/>To get started, install the <code class="literal">pygame</code> module by downloading the installer from the Downloads page at <span class="emphasis"><em><a class="ulink" href="http://www.pygame.org/">http://www.pygame.org/</a></em></span>. For Windows, you’ll probably want to download <span class="emphasis"><em>pygame-1.9.1 .win32-py3.1.msi</em></span>, but see Appendix B for help if you have any trouble. For Mac and Linux, the installation is more involved; see Appendix B or go to <span class="emphasis"><em><a class="ulink" href="http://www.nostarch.com/teachkids/">http://www.nostarch.com/teachkids/</a></em></span> for step-by-step instructions.</p><p>You can check that Pygame installed with no errors by entering the following into the Python shell:</p><a id="pro_id00119"/><pre class="programlisting"><span class="brown">&gt;&gt;&gt;</span> <span class="orange">import</span> pygame</pre><p>If you get a regular <code class="literal">&gt;&gt;&gt;</code> prompt in response, you know that Python was able to find the <code class="literal">pygame</code> module without error and the Pygame library is ready to use.</p><div class="sect2" title="Drawing a Dot with Pygame"><div class="titlepage"><div><div><h2 class="title"><a id="drawing_a_dot_with_pygame"/>Drawing a Dot with Pygame</h2></div></div></div><p>Once you have Pygame installed, you can run a short sample program to draw a dot on the screen, like the one in <a class="xref" href="ch08.html#showdotdotpy_program_at_work" title="Figure 8-2. The ShowDot.py program at work">Figure 8-2</a>.</p><div class="figure"><a id="showdotdotpy_program_at_work"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00103"/><img src="httpatomoreillycomsourcenostarchimages2188977.png.jpg" alt="The ShowDot.py program at work"/></div></div><p class="title">Figure 8-2. The <span class="emphasis"><em>ShowDot.py</em></span> program at work</p></div><p><a id="iddle1395" class="indexterm"/><a id="iddle1437" class="indexterm"/><a id="iddle1443" class="indexterm"/><a id="iddle1488" class="indexterm"/><a id="iddle1702" class="indexterm"/><a id="iddle1713" class="indexterm"/><a id="iddle1810" class="indexterm"/><a id="iddle1849" class="indexterm"/><a id="iddle1950" class="indexterm"/>Type the following in a new IDLE window or download it from <span class="emphasis"><em><a class="ulink" href="http://www.nostarch.com/teachkids/">http://www.nostarch.com/teachkids/</a></em></span>:</p><div class="sect3" title="ShowDot.py"><div class="titlepage"><div><div><h3 class="title"><a id="showdotdotpy"/>ShowDot.py</h3></div></div></div><a id="pro_id00120"/><pre class="programlisting">  <span class="orange">import</span> pygame

➊ pygame.init()
➋ screen = pygame.display.set_mode([800,600])

➌ keep_going = <span class="orange">True</span>
➍ GREEN = (0,255,0)    <span class="red"># RGB color triplet for GREEN</span>
   radius = 50

➎ <span class="orange">while</span> keep_going:
➏     <span class="orange">for</span> event <span class="orange">in</span> pygame.event.get():
➐         <span class="orange">if</span> event.type == pygame.QUIT:
               keep_going = <span class="orange">False</span>
➑     pygame.draw.circle(screen, GREEN, (100,100), radius)
➒     pygame.display.update()

➓ pygame.quit()</pre><p>Let’s step through this program line by line. First, we import the <code class="literal">pygame</code> module to gain access to its features. At ➊, we <a class="firstterm" href="apd.html#gloss01_027"><em class="firstterm">initialize</em></a> Pygame, or set it up for use. The command <code class="literal">pygame.init()</code> will need to be called every time you want to use Pygame, and it always comes after the <code class="literal">import pygame</code> command and before any other Pygame functions.</p><p>At ➋, <code class="literal">pygame.display.set_mode([800,600])</code> creates a display window 800 pixels wide by 600 pixels tall. We store it in a variable called <code class="literal">screen</code>. In Pygame, windows and graphics are called <span class="emphasis"><em>surfaces</em></span>, and the display surface <code class="literal">screen</code> is the main window where all of our other graphics will be drawn.</p><p>At ➌, you might recognize our looping variable, <code class="literal">keep_going</code>: we used this in our <span class="emphasis"><em>HighCard.py</em></span> and <span class="emphasis"><em>FiveDice.py</em></span> game loops in <a class="xref" href="ch06.html" title="Chapter 6. Random Fun and Games: Go Ahead, Take a Chance!">Chapter 6</a> as a Boolean flag to tell our program to keep playing. Here in our Pygame example, we use a game loop to continue drawing the graphics screen until the user closes the window.</p><p>At ➍, we set up two variables, <code class="literal">GREEN</code> and <code class="literal">radius</code>, for use in drawing our circle. The <code class="literal">GREEN</code> variable is set to the RGB triplet value <code class="literal">(0,255,0)</code>, a bright green. (<a class="firstterm" href="apd.html#gloss01_043"><em class="firstterm">RGB</em></a>, or <span class="emphasis"><em>Red Green Blue</em></span>, is one of many ways to specify a color. To pick a color, you choose three numbers, each between 0 and 255. The first number determines <a id="iddle1145" class="indexterm"/><a id="iddle1229" class="indexterm"/><a id="iddle1332" class="indexterm"/><a id="iddle1536" class="indexterm"/><a id="iddle1551" class="indexterm"/><a id="iddle1717" class="indexterm"/><a id="iddle1735" class="indexterm"/><a id="iddle2009" class="indexterm"/><a id="iddle2048" class="indexterm"/>how much red is in your color, the second number is the amount of green, and the third is blue. We picked 255 as our value for green and 0 for red and blue, so our RGB color is all green and no red or blue.) Our variable <code class="literal">GREEN</code> is a constant. We sometimes write <a class="firstterm" href="apd.html#gloss01_015"><em class="firstterm">constants</em></a>—variables we don’t intend to change—in all caps. Since the color should stay the same throughout our program, we’ve used all caps for <code class="literal">GREEN</code>. We set the <code class="literal">radius</code> variable equal to 50 pixels, for a circle 100 pixels in diameter.</p><p>The <code class="literal">while</code> loop at ➎ is our game loop, and it will keep running the Pygame window until the user chooses to exit. The <code class="literal">for</code> loop at ➏ is where we handle all the interactive events that the user can trigger in our program. In this simple example, the only event we’re checking for is whether the user clicked the red X to close the window and exit the program ➐. If so, <code class="literal">keep_going</code> gets set to <code class="literal">False</code> and our game loop ends.</p><div class="informalfigure"><a id="med_id00104a"/><div class="mediaobject"><a id="med_id00104"/><img src="httpatomoreillycomsourcenostarchimages2188979.png.jpg" alt="image with no caption"/></div></div><p>At ➑, we draw a green circle with a radius of 50 on the <code class="literal">screen</code> window at position <code class="literal">(100,100)</code>: right 100 and down 100 pixels from the upper-left corner of the window (see <a class="xref" href="ch08.html#whatapostrophes_new_in_pygame" title="What’s New in Pygame">What’s New in Pygame</a> for more information on how Pygame’s coordinate system is different from Turtle’s). We’re using <code class="literal">pygame.draw</code>, a Pygame module for drawing shapes like circles, rectangles, and line segments. We pass four arguments to the <code class="literal">pygame.draw.circle()</code> function: the surface on which we want to draw the circle (<code class="literal">screen</code>), the color for our circle (<code class="literal">GREEN</code>), the coordinates of its center point, and the radius. The <code class="literal">update()</code> function at ➒ tells Pygame to refresh the screen with the drawing changes.</p><p>Finally, when the user exits the game loop, the <code class="literal">pygame.quit()</code> command at ➓ clears the <code class="literal">pygame</code> module (it undoes all the setup from ➊) and closes the <code class="literal">screen</code> window so that the program can exit normally.</p><p><a id="iddle1636" class="indexterm"/><a id="iddle1688" class="indexterm"/><a id="iddle1714" class="indexterm"/><a id="iddle1982" class="indexterm"/><a id="iddle2064" class="indexterm"/><a id="iddle2076" class="indexterm"/>You should see an image like the one in <a class="xref" href="ch08.html#showdotdotpy_program_at_work" title="Figure 8-2. The ShowDot.py program at work">Figure 8-2</a> when you run <span class="emphasis"><em>ShowDot.py</em></span>. Take some time to play around with this dot program—create a different RGB color triplet, draw the dot in a different location on the screen, or draw a second dot. You’ll begin to see the power and ease of drawing graphics with Pygame, and you’ll have fun along the way.</p><p>This first program contains the foundation that we’ll build on to create more complex graphics, animation, and, eventually, games.</p></div></div><div class="sect2" title="What’s New in Pygame"><div class="titlepage"><div><div><h2 class="title"><a id="whatapostrophes_new_in_pygame"/>What’s New in Pygame</h2></div></div></div><p>Before we dive deeper into the exciting world of Pygame, it’s worth noting some important differences between Pygame and our old friend turtle graphics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>We have a new coordinate system, as shown in <a class="xref" href="ch08.html#pygame_uses_a_window-oriented_coordinate" title="Figure 8-3. Pygame uses a window-oriented coordinate system.">Figure 8-3</a>. Back in turtle graphics, the origin was at the center of the screen, and <span class="emphasis"><em>y</em></span> got larger as we went up the screen. Pygame uses a more common window-oriented coordinate system (we see this in many other GUI programming languages, including Java, C++, and more). The <span class="emphasis"><em>upper-left corner</em></span> of a window in Pygame is the origin, (0, 0). The x-coordinate values still increase as you move to the right (but there are no negative x-coordinate values, as they would be off the screen to the left); y-coordinate values increase as you move down (and negative y-coordinate values would be off the top of the window).</p><div class="figure"><a id="pygame_uses_a_window-oriented_coordinate"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00105"/><img src="httpatomoreillycomsourcenostarchimages2188981.png.jpg" alt="Pygame uses a window-oriented coordinate system."/></div></div><p class="title">Figure 8-3. Pygame uses a window-oriented coordinate system.</p></div></li><li class="listitem"><p><a id="iddle1303" class="indexterm"/><a id="iddle1359" class="indexterm"/><a id="iddle1376" class="indexterm"/><a id="iddle1692" class="indexterm"/><a id="iddle1694" class="indexterm"/><a id="iddle1709" class="indexterm"/><a id="iddle1873" class="indexterm"/><a id="iddle1874" class="indexterm"/>The game loop is always used in Pygame. In our earlier programs, we used a loop only if we wanted to keep playing or go back and do something again, but Pygame requires the game loop to keep updating the screen and handling events (even if the only event we handle is closing the window).</p></li><li class="listitem"><p>We handle events in Pygame by calling <code class="literal">pygame.event.get()</code> to fetch a list of events that the user has performed. These events could be mouse clicks, key presses, or even window events like the user closing the window. We use a <code class="literal">for</code> loop to handle everything in this list of events from <code class="literal">pygame.event.get()</code>. In our turtle programs, we used callback functions to handle events. In Pygame, we can still create functions and call them in our event handler code, but we can process events just using <code class="literal">if</code> statements for those events that we care to listen for.</p></li></ul></div><p>These differences make Pygame a new way of solving problems, and that’s what we’re always looking for! The more tools we have, the more problems we can solve.</p></div><div class="sect2" title="The Parts of a Game"><div class="titlepage"><div><div><h2 class="title"><a id="parts_of_a_game"/>The Parts of a Game</h2></div></div></div><p>In this section, we’ll change our <span class="emphasis"><em>ShowDot.py</em></span> program to display a smiley face image instead of a green circle, as shown in <a class="xref" href="ch08.html#showpicdotpy_draws_the_image_crazysmiled" title="Figure 8-4. ShowPic.py draws the image CrazySmile.bmp on the screen.">Figure 8-4</a>.</p><div class="figure"><a id="showpicdotpy_draws_the_image_crazysmiled"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00106"/><img src="httpatomoreillycomsourcenostarchimages2188983.png.jpg" alt="ShowPic.py draws the image CrazySmile.bmp on the screen."/></div></div><p class="title">Figure 8-4. <span class="emphasis"><em>ShowPic.py</em></span> draws the image <span class="emphasis"><em>CrazySmile.bmp</em></span> on the screen.</p></div><p><a id="iddle1074" class="indexterm"/><a id="iddle1111" class="indexterm"/><a id="iddle1166" class="indexterm"/><a id="iddle1294" class="indexterm"/><a id="iddle1360" class="indexterm"/><a id="iddle1438" class="indexterm"/><a id="iddle1489" class="indexterm"/><a id="iddle1522" class="indexterm"/><a id="iddle1720" class="indexterm"/>As we build our <span class="emphasis"><em>ShowPic.py</em></span> program, we’ll learn about the three main parts of a game or animation in Pygame. First, there’s the setup, where we import modules we need, create our screen, and initialize some important variables. Then comes the game loop, which handles events, draws graphics, and updates the display. This game loop is a <code class="literal">while</code> loop that keeps running as long as the user doesn’t quit the game. Finally, we need a way to end the program when the user quits the game.</p><div class="sect3" title="Setting Up"><div class="titlepage"><div><div><h3 class="title"><a id="setting_up"/>Setting Up</h3></div></div></div><p>First, download the smiley face image and save it in the same folder as your Python programs. Go to <span class="emphasis"><em><a class="ulink" href="http://www.nostarch.com/teachkids/">http://www.nostarch.com/teachkids/</a></em></span> to find the source code downloads and save the image <span class="emphasis"><em>CrazySmile.bmp</em></span> to the folder where you’ve been saving your <span class="emphasis"><em>.py</em></span> files. It doesn’t really matter where you keep your <span class="emphasis"><em>.py</em></span> files; just make sure to save the BMP (short for <span class="emphasis"><em>bitmap</em></span>, a common image file format) image file to the same location.</p><p>Next, let’s take care of the setup:</p><a id="pro_id00121"/><pre class="programlisting">   <span class="orange">import</span> pygame       <span class="red"># Setup</span>
   pygame.init()
   screen = pygame.display.set_mode([800,600])
   keep_going = <span class="orange">True</span>
➊ pic = pygame.image.load(<span class="green">"CrazySmile.bmp"</span>)</pre><p>As always, we import the <code class="literal">pygame</code> module and then initialize using the <code class="literal">pygame.init()</code> function. Next, we set up our <code class="literal">screen</code> to be a new Pygame window 800×600 pixels in size. We create our Boolean flag <code class="literal">keep_going</code> to control our game loop and set it equal to <code class="literal">True</code>. Finally, we do something new: at ➊, we use <code class="literal">pygame.image.load()</code>, which loads an image from a file. We create a variable for our image file and load <span class="emphasis"><em>CrazySmile.bmp</em></span>, which we’ll refer to as <code class="literal">pic</code> in our program.</p></div><div class="sect3" title="Creating a Game Loop"><div class="titlepage"><div><div><h3 class="title"><a id="creating_a_game_loop"/>Creating a Game Loop</h3></div></div></div><p>At this point, we haven’t drawn anything, but we’ve set up Pygame and loaded an image. The game loop is where we’ll actually display the smiley face image on the screen. It’s also where we’ll handle events from the user. Let’s start by handling one important event: the user choosing to quit the game.</p><a id="pro_id00122"/><pre class="programlisting">   <span class="orange">while</span> keep_going:    <span class="red"># Game loop</span>
       <span class="orange">for</span> event <span class="orange">in</span> pygame.event.get():
➊         <span class="orange">if</span> event.type == pygame.QUIT:
               keep_going = <span class="orange">False</span></pre><p><a id="iddle1107" class="indexterm"/><a id="iddle1146" class="indexterm"/><a id="iddle1293" class="indexterm"/><a id="iddle1718" class="indexterm"/><a id="iddle1733" class="indexterm"/>Our game loop will keep running as long as <code class="literal">keep_going</code> is <code class="literal">True</code>. Inside the loop, we immediately check for events from the user. In advanced games, the user can trigger a lot of events at the same time, like pressing the down arrow on the keyboard while moving the mouse left and scrolling the mouse wheel.</p><p>In this simple program, the only event we’re listening for is whether the user clicked the close window button to quit the program. We check for this at ➊. If the user triggered the <code class="literal">pygame.QUIT</code> event by trying to close the window, we want to tell our game loop to exit. We do this by setting <code class="literal">keep_going</code> to <code class="literal">False</code>.</p><p>We still need to draw our picture to the screen and update the drawing window to make sure everything appears on the screen, so we’ll add these two final lines to our game loop:</p><a id="pro_id00123"/><pre class="programlisting">screen.blit(pic, (100,100))
pygame.display.update()</pre><p>The <code class="literal">blit()</code> method draws <code class="literal">pic</code>, the image that we’ve loaded from disk (our smiley face), onto our display surface, <code class="literal">screen</code>. We’ll use <code class="literal">blit()</code> when we want to copy pixels from one surface (like the image we loaded from disk) onto another (like the drawing window). Here, we need to use <code class="literal">blit()</code> because the <code class="literal">pygame.image.load()</code> function works differently than the <code class="literal">pygame.draw.circle()</code> function we used earlier to draw our green dot. All <code class="literal">pygame.draw</code> functions accept a surface as an argument, so by passing <code class="literal">screen</code> to <code class="literal">pygame.draw.circle()</code>, we were able to have <code class="literal">pygame.draw.circle()</code> draw to our display window. But <code class="literal">pygame.image.load()</code> doesn’t take a surface as an argument; instead, it automatically creates a new, separate surface for your image. The image won’t appear on the original drawing screen unless you use <code class="literal">blit()</code>.</p><div class="informalfigure"><a id="med_id00107a"/><div class="mediaobject"><a id="med_id00107"/><img src="httpatomoreillycomsourcenostarchimages2188985.png.jpg" alt="image with no caption"/></div></div><p><a id="iddle1693" class="indexterm"/><a id="iddle1736" class="indexterm"/><a id="iddle2010" class="indexterm"/>In this case, we’ve told <code class="literal">blit()</code> that we want to draw <code class="literal">pic</code> at the location <code class="literal">(100,100)</code>, or right 100 pixels and down 100 pixels from the upper-left corner of the screen (in Pygame’s coordinate system, the origin is the upper-left corner; see <a class="xref" href="ch08.html#pygame_uses_a_window-oriented_coordinate" title="Figure 8-3. Pygame uses a window-oriented coordinate system.">Figure 8-3</a>).</p><p>The final line of our game loop is the call to <code class="literal">pygame.display.update()</code>. This command tells Pygame to show the drawing window with all the changes that have been made during this pass through the loop. That includes our smiley face. When <code class="literal">update()</code> runs, the window will be updated to show all the changes to our <code class="literal">screen</code> surface.</p><p>So far, we’ve taken care of our setup code, and we have a game loop with an event handler that listens for the user hitting the close window button. If the user clicks the close window button, the program updates the display and exits the loop. Next, we’ll take care of ending the program.</p></div><div class="sect3" title="Exiting the Program"><div class="titlepage"><div><div><h3 class="title"><a id="exiting_the_program"/>Exiting the Program</h3></div></div></div><p>The last section of our code will exit the program once the user has chosen to quit the game loop:</p><a id="pro_id00124"/><pre class="programlisting">pygame.quit()      <span class="red"># Exit</span></pre><p>If you leave this line out of your programs, the display window will stay open even after the user tries to close it. Calling <code class="literal">pygame.quit()</code> closes the display window and frees up the memory that was storing our image, <code class="literal">pic</code>.</p></div><div class="sect3" title="Putting It All Together"><div class="titlepage"><div><div><h3 class="title"><a id="putting_it_all_together-id00017"/>Putting It All Together</h3></div></div></div><p>Put it all together, and you’ll see our <span class="emphasis"><em>CrazySmile.bmp</em></span> image file— as long as you’ve saved the image in the same directory as your <span class="emphasis"><em>ShowPic.py</em></span> program file. Here’s the full listing:</p><div class="sect4" title="ShowPic.py"><div class="titlepage"><div><div><h4 class="title"><a id="showpicdotpy"/>ShowPic.py</h4></div></div></div><a id="pro_id00125"/><pre class="programlisting"><span class="orange">import</span> pygame        <span class="red"># Setup</span>
pygame.init()
screen = pygame.display.set_mode([800,600])
keep_going = <span class="orange">True</span>
pic = pygame.image.load(<span class="green">"CrazySmile.bmp"</span>)
<span class="orange">while</span> keep_going:    <span class="red"># Game loop</span>
    <span class="orange">for</span> event <span class="orange">in</span> pygame.event.get():
        <span class="orange">if</span> event.type == pygame.QUIT:
            keep_going = <span class="orange">False</span>
    screen.blit(pic, (100,100))
    pygame.display.update()

pygame.quit()        <span class="red"># Exit</span></pre><p><a id="iddle1073" class="indexterm"/><a id="iddle1338" class="indexterm"/>When you click the close window button, the display window should close.</p><p>This code has all the basic components we’ll build on to make our programs even more interactive. In the rest of this chapter and in <a class="xref" href="ch09.html" title="Chapter 9. User Interaction: Get into the Game">Chapter 9</a>, we’ll add code to our game loop to respond to different events (for example, making images on the screen move when the user moves the mouse). Now let’s see how to create a program that draws an animated bouncing ball!</p></div></div></div></div><div class="sect1" title="Timing It Just Right: Move and Bounce"><div class="titlepage"><div><div><h1 class="title"><a id="timing_it_just_right_move_and_bounce"/>Timing It Just Right: Move and Bounce</h1></div></div></div><p>We already have the skills needed to create animation, or the illusion of motion, by making one small change to our <span class="emphasis"><em>ShowPic.py</em></span> app. Instead of showing the smiley face image at a fixed location every time through the game loop, what if we change that location slightly every frame? By <a class="firstterm" href="apd.html#gloss01_022"><em class="firstterm">frame</em></a>, I mean each pass through the game loop. The term comes from one way people make animations: they draw thousands of individual pictures, making each picture slightly different from the one before it. One picture is considered one frame. The animators then put all the pictures together on a strip of film and run the film through a projector. When the pictures are shown one after another very quickly, it looks like the characters in the pictures are moving.</p><div class="informalfigure"><a id="med_id00108a"/><div class="mediaobject"><a id="med_id00108"/><img src="httpatomoreillycomsourcenostarchimages2188987.png.jpg" alt="image with no caption"/></div></div><p>With a computer, we can create the same effect by drawing a picture on the screen, clearing the screen, moving the picture slightly, and then drawing it again. The effect will look a bit like <a class="xref" href="ch08.html#in_this_first_attempt_at_animationcomma" title="Figure 8-5. In this first attempt at animation, our smiley image will streak off the screen.">Figure 8-5</a>.</p><div class="figure"><a id="in_this_first_attempt_at_animationcomma"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00109"/><img src="httpatomoreillycomsourcenostarchimages2188989.png.jpg" alt="In this first attempt at animation, our smiley image will streak off the screen."/></div></div><p class="title">Figure 8-5. In this first attempt at animation, our smiley image will streak off the screen.</p></div><p><a id="iddle1075" class="indexterm"/><a id="iddle1340" class="indexterm"/><a id="iddle1580" class="indexterm"/><a id="iddle1650" class="indexterm"/><a id="iddle1655" class="indexterm"/><a id="iddle1891" class="indexterm"/>We still call each drawing a <span class="emphasis"><em>frame</em></span>, and the speed of our animation is how many <a class="firstterm" href="apd.html#gloss01_023"><em class="firstterm">frames per second (fps)</em></a> we draw. A video game might run 60–120 frames per second, like high-definition television. Older, standard-definition TVs in the United States run at 30 fps, and many film projectors run at 24 fps (newer high-definition digital projectors can run at 60 fps or higher).</p><p>If you’ve ever made or seen a flip-book animation (in which you draw on the corners of pages in a notebook and then flip through them to create a mini-cartoon), you’ve seen that the illusion of motion can be created at many different frame rates. We’ll aim for a rate around 60 fps, fast enough to create smooth animations.</p><div class="sect2" title="Moving a Smiley"><div class="titlepage"><div><div><h2 class="title"><a id="moving_a_smiley"/>Moving a Smiley</h2></div></div></div><p>We can create simple motion in our <code class="literal">while</code> loop by drawing the smiley face image at different locations over time. In other words, in our game loop, we just need to update the (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) location of the picture and then draw it at that new location each time through the loop.</p><p>We’ll add two variables to <span class="emphasis"><em>ShowPic.py</em></span>: <code class="literal">picx</code> and <code class="literal">picy</code>, for the x- and y-coordinates of the image on the screen. We’ll add these at the end of the setup portion of our program and then save the <a id="iddle1002" class="indexterm"/><a id="iddle1046" class="indexterm"/>new version of the program as <span class="emphasis"><em>SmileyMove.py</em></span> (the final version is shown in <a class="xref" href="ch08.html#smileymovedotpy" title="SmileyMove.py">SmileyMove.py</a>).</p><a id="pro_id00126"/><pre class="programlisting">   <span class="orange">import</span> pygame       <span class="red"># Setup</span>
   pygame.init()
➊ screen = pygame.display.set_mode([600,600])
   keep_going = <span class="orange">True</span>
   pic = pygame.image.load(<span class="green">"CrazySmile.bmp"</span>)
➋ colorkey = pic.get_at((0,0))
➌ pic.set_colorkey(colorkey)
   picx = 0
   picy = 0</pre><div class="note" title="Note"><h3 class="title"><a id="ch08note01"/>Note</h3><p><span class="emphasis"><em>The lines at</em></span> ➋ <span class="emphasis"><em>and</em></span> ➌ <span class="emphasis"><em>are an optional fix for a minor issue. If the</em></span> CrazySmile.bmp <span class="emphasis"><em>image looks like it has square black corners on your screen, you can include these two lines to make sure those corners look transparent.</em></span></p></div><p>Notice that we’ve also changed our window screen to 600×600 pixels to make the window square at ➊. The game loop will begin the same way it did in <span class="emphasis"><em>ShowPic.py</em></span>, but we’ll add code to change the <code class="literal">picx</code> and <code class="literal">picy</code> variables by 1 pixel every time the loop runs:</p><a id="pro_id00127"/><pre class="programlisting"><span class="orange">while</span> keep_going:    <span class="red"># Game loop</span>
    <span class="orange">for</span> event <span class="orange">in</span> pygame.event.get():
        <span class="orange">if</span> event.type == pygame.QUIT:
            keep_going = <span class="orange">False</span>

    picx += 1        <span class="red"># Move the picture</span>
    picy += 1</pre><p>The <code class="literal">+=</code> operator adds something to the variable on the left side (<code class="literal">picx</code> and <code class="literal">picy</code>), so with <code class="literal">+= 1</code>, we’ve told the computer we want to change the x- and y-coordinates of the picture, <code class="literal">(picx, picy)</code>, by 1 pixel every time through the loop.</p><p>Finally, we need to copy the image onto the screen at the new location, update the display, and tell our program what to do to exit:</p><a id="pro_id00128"/><pre class="programlisting">    screen.blit(pic, (picx, picy))
    pygame.display.update()
pygame.quit()        <span class="red"># Exit</span></pre><p>If you run those lines, you’ll see our image take off! In fact, you’ll have to look fast because it will move right off the screen.</p><p><a id="iddle1106" class="indexterm"/><a id="iddle1108" class="indexterm"/><a id="iddle1167" class="indexterm"/><a id="iddle1230" class="indexterm"/><a id="iddle1316" class="indexterm"/><a id="iddle1811" class="indexterm"/>Look back at <a class="xref" href="ch08.html#in_this_first_attempt_at_animationcomma" title="Figure 8-5. In this first attempt at animation, our smiley image will streak off the screen.">Figure 8-5</a> for a glimpse of the smiley image before it slides out of view.</p><p>This first version may leave streaks of pixels on the display even when the smiley image has left the drawing window. We can make the animation cleaner by clearing the screen between each frame. The streaking lines we’re seeing behind our smiley are the upper-left pixels of the smiley image; every time we move down and over each frame to draw a new version of our image and update the display, we’re leaving behind a few stray pixels from the last picture.</p><p>We can fix this by adding a <code class="literal">screen.fill()</code> command to our drawing loop. The <code class="literal">screen.fill()</code> command takes a color as an argument, so we need to tell it what color we’d like to use to fill the drawing screen. Let’s add a variable for <code class="literal">BLACK</code> (using all uppercase for <code class="literal">BLACK</code> to show that it’s a constant) and set it equal to black’s RGB color triplet, <code class="literal">(0,0,0)</code>. We’ll fill the screen surface with black pixels, effectively clearing it off, before we draw each new, moved copy of our animated image.</p><p>Add this line to your setup right after <code class="literal">picy = 0</code> to create the black background fill color:</p><a id="pro_id00129"/><pre class="programlisting">BLACK = (0,0,0)</pre><p>And add this line right before the <code class="literal">screen.blit()</code> that draws our <code class="literal">pic</code> image on the screen:</p><a id="pro_id00130"/><pre class="programlisting">screen.fill(BLACK)</pre><p>Our smiley face still speeds off the screen, but this time we’re not leaving a trail of pixels behind our moving image. By filling the screen with black pixels, we’ve created the effect of “erasing” the old image from the screen every frame, before we draw the new image at the new location. This creates the illusion of smoother animation. On a relatively fast computer, though, our smiley flies off the screen way too fast. To change this, we need a new tool: a timer or clock that can keep us at a steady, predictable rate of frames per second.</p></div><div class="sect2" title="Animating a Smiley with the Clock Class"><div class="titlepage"><div><div><h2 class="title"><a id="animating_a_smiley_with_the_clock_class"/>Animating a Smiley with the Clock Class</h2></div></div></div><p>The final piece to make our <span class="emphasis"><em>SmileyMove.py</em></span> app behave like an animation we might see in a game or movie is to limit the number <a id="iddle1153" class="indexterm"/><a id="iddle1690" class="indexterm"/><a id="iddle1807" class="indexterm"/><a id="iddle1964" class="indexterm"/>of frames per second our program draws. Currently, we’re moving the smiley image only 1 pixel down and 1 pixel to the right each time through the game loop, but our computer can draw this simple scene so fast that it can produce hundreds of frames per second, causing our smiley to fly off the screen in an instant.</p><div class="informalfigure"><a id="med_id00110a"/><div class="mediaobject"><a id="med_id00110"/><img src="httpatomoreillycomsourcenostarchimages2188991.png.jpg" alt="image with no caption"/></div></div><p>Smooth animation is possible with 30 to 60 frames of animation per second, so we don’t need the hundreds of frames zooming past us every second.</p><p>Pygame has a tool that can help us control the speed of our animation: the <code class="literal">Clock</code> class. A <a class="firstterm" href="apd.html#gloss01_010"><em class="firstterm">class</em></a> is like a template that can be used to create <a class="firstterm" href="apd.html#gloss01_035"><em class="firstterm">objects</em></a> of a certain type, with functions and values that help those objects behave in a certain way. Think of a class as being like a cookie cutter and objects as the cookies: when we want to create cookies of a certain shape, we build a cookie cutter that can be reused anytime we want another cookie of the same shape. In the same way that functions help us package reusable code together, classes allow us to package data and functions into a reusable template that we can use to create objects for future programs.</p><p>We can add an object of the <code class="literal">Clock</code> class to our program setup with this line:</p><a id="pro_id00131"/><pre class="programlisting">timer = pygame.time.Clock()</pre><p>This creates a variable called <code class="literal">timer</code> linked to a <code class="literal">Clock</code> object. This <code class="literal">timer</code> will allow us to gently pause each time through the game loop and wait just long enough to make sure we’re not drawing more than a certain number of frames per second.</p><p>Adding the following line to our game loop will keep the frame rate at 60 fps by telling our <code class="literal">Clock</code> named <code class="literal">timer</code> to “tick” just 60 times per second:</p><a id="pro_id00132"/><pre class="programlisting">timer.tick(60)</pre><p>The following code, <span class="emphasis"><em>SmileyMove.py</em></span>, shows the whole app put together. It gives us a smooth, steady animated smiley face slowly gliding off the lower right of the screen.</p><div class="sect3" title="SmileyMove.py"><div class="titlepage"><div><div><h3 class="title"><a id="smileymovedotpy"/>SmileyMove.py</h3></div></div></div><a id="pro_id00133"/><pre class="programlisting"><span class="orange">import</span> pygame                <span class="red"># Setup</span>
pygame.init()
screen = pygame.display.set_mode([600,600])
keep_going = <span class="orange">True</span>
pic = pygame.image.load(<span class="green">"CrazySmile.bmp"</span>)
colorkey = pic.get_at((0,0))
pic.set_colorkey(colorkey)
picx = 0
picy = 0
BLACK = (0,0,0)
timer = pygame.time.Clock()  <span class="red"># Timer for animation</span>

<span class="orange">while</span> keep_going:            <span class="red"># Game loop</span>
    <span class="orange">for</span> event <span class="orange">in</span> pygame.event.get():
        <span class="orange">if</span> event.type == pygame.QUIT:
            keep_going = <span class="orange">False</span>

    picx += 1                <span class="red"># Move the picture</span>
    picy += 1

    screen.fill(BLACK)       <span class="red"># Clear screen</span>
    screen.blit(pic, (picx,picy))
    pygame.display.update()
    timer.tick(60)           <span class="red"># Limit to 60 frames per second</span>

pygame.quit()                <span class="red"># Exit</span></pre><p><a id="iddle1059" class="indexterm"/><a id="iddle1120" class="indexterm"/><a id="iddle1881" class="indexterm"/><a id="iddle1962" class="indexterm"/>The remaining problem is that the smiley still goes all the way off the screen in a few seconds. That’s not very entertaining. Let’s change our program to keep the smiley face on the screen, bouncing from corner to corner.</p></div></div><div class="sect2" title="Bouncing a Smiley Off a Wall"><div class="titlepage"><div><div><h2 class="title"><a id="bouncing_a_smiley_off_a_wall"/>Bouncing a Smiley Off a Wall</h2></div></div></div><p>We’ve added motion from one frame to the next by changing the position of the image we were drawing on each pass through our game loop. We saw how to regulate the speed of that animation by adding a <code class="literal">Clock</code> object and telling it how many times per second to <code class="literal">tick()</code>. In this section, we’ll see how to keep our smiley on the screen. The effect will look a bit like <a class="xref" href="ch08.html#our_goal_is_to_keep_the_smiley_quotation" title="Figure 8-6. Our goal is to keep the smiley “bouncing” between the corners of the screen.">Figure 8-6</a>, with the smiley appearing to bounce back and forth between two corners of the drawing window.</p><div class="figure"><a id="our_goal_is_to_keep_the_smiley_quotation"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00111"/><img src="httpatomoreillycomsourcenostarchimages2188993.png.jpg" alt="Our goal is to keep the smiley “bouncing” between the corners of the screen."/></div></div><p class="title">Figure 8-6. Our goal is to keep the smiley “bouncing” between the corners of the screen.</p></div><p><a id="iddle1061" class="indexterm"/><a id="iddle1063" class="indexterm"/><a id="iddle1122" class="indexterm"/><a id="iddle1172" class="indexterm"/><a id="iddle1882" class="indexterm"/>The reason our image ran off the screen before is that we didn’t set <span class="emphasis"><em>boundaries</em></span>, or limits, for our animation. Everything we draw on the screen is <span class="emphasis"><em>virtual</em></span>—meaning it doesn’t exist in the real world—so things don’t really bump into one another. If we want the virtual objects on our screen to interact, we have to create those interactions with programming logic.</p><div class="sect3" title="Hitting the Wall"><div class="titlepage"><div><div><h3 class="title"><a id="hitting_the_wall"/>Hitting the Wall</h3></div></div></div><p>When I say that we want the smiley face to “bounce” off the edge of the screen, what I mean is that when the smiley comes to the edge of the screen, we want to change the direction it’s moving so that it looks like it bounces off the solid edge of the screen. To do this, we need to test whether the <code class="literal">(picx,picy)</code> location of the smiley has reached the imaginary boundary at the edge of the screen. We call this logic <a class="firstterm" href="apd.html#gloss01_012"><em class="firstterm">collision detection</em></a> because we’re trying to <span class="emphasis"><em>detect</em></span>, or notice, when a <span class="emphasis"><em>collision</em></span> occurs, like the smiley face image “hitting” the edge of the drawing window.</p><p>We know that we can test for conditions using an <code class="literal">if</code> statement, so we could see if our image is touching, or <span class="emphasis"><em>colliding</em></span> with, the right side of the screen by checking whether <code class="literal">picx</code> is greater than some value.</p><p><a id="iddle1651" class="indexterm"/><a id="iddle1656" class="indexterm"/><a id="iddle1850" class="indexterm"/><a id="iddle1883" class="indexterm"/>Let’s figure out what that value might be. We know our screen is 600 pixels wide because we created our screen with <code class="literal">pygame.display.set_mode([600,600])</code>. We could use 600 as our boundary, but the smiley face would still go off the edge of the screen because the coordinate pair <code class="literal">(picx,picy)</code> is the location of the top-left pixel of our smiley face image.</p><p>To find our logical boundary—that is, the virtual line that <code class="literal">picx</code> has to reach for our smiley face to look like it has hit the right edge of the <code class="literal">screen</code> window—we need to know how wide our picture is. Because we know <code class="literal">picx</code> is the top-left corner of the image and it continues to the right, we can just add the width of our picture to <code class="literal">picx</code>, and when that sum equals 600, we’ll know that the right edge of the image is touching the right edge of the window.</p><p>One way to find the width of our image is by looking at the properties of the file. In Windows, right-click the <span class="emphasis"><em>CrazySmile.bmp</em></span> file, select the Properties menu item, and then click the Details tab. On a Mac, click the <span class="emphasis"><em>CrazySmile.bmp</em></span> file to select it, press <span class="inlinemediaobject"><a id="inline_id00005"/><img src="httpatomoreillycomsourcenostarchimages2188973.png.jpg" alt=""/></span> -I to get the file info window, and then click More Info. You’ll see the width and height of the picture, as shown in <a class="xref" href="ch08.html#to_determine_our_virtual_boundaries_so_o" title="Figure 8-7. To determine our virtual boundaries so our smiley face can bounce off them, we need to know the width of our image file.">Figure 8-7</a>.</p><div class="figure"><a id="to_determine_our_virtual_boundaries_so_o"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00112"/><img src="httpatomoreillycomsourcenostarchimages2188995.png.jpg" alt="To determine our virtual boundaries so our smiley face can bounce off them, we need to know the width of our image file."/></div></div><p class="title">Figure 8-7. To determine our virtual boundaries so our smiley face can bounce off them, we need to know the width of our image file.</p></div><p><a id="iddle1378" class="indexterm"/><a id="iddle1386" class="indexterm"/><a id="iddle1652" class="indexterm"/><a id="iddle1657" class="indexterm"/><a id="iddle1695" class="indexterm"/><a id="iddle1698" class="indexterm"/>Our <span class="emphasis"><em>CrazySmile.bmp</em></span> file measures 100 pixels across (and 100 pixels down). So if our <code class="literal">screen</code> is currently 600 pixels wide and the <code class="literal">pic</code> image needs 100 pixels to display the full image, our <code class="literal">picx</code> has to stay left of 500 pixels in the x-direction. <a class="xref" href="ch08.html#calculating_a_bounce_against_the_right_s" title="Figure 8-8. Calculating a bounce against the right side of the window">Figure 8-8</a> shows these measurements.</p><div class="figure"><a id="calculating_a_bounce_against_the_right_s"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00113"/><img src="httpatomoreillycomsourcenostarchimages2188997.png.jpg" alt="Calculating a bounce against the right side of the window"/></div></div><p class="title">Figure 8-8. Calculating a bounce against the right side of the window</p></div><p>But what if we change our image file or want to handle images of different widths and heights? Fortunately, Pygame has a convenient function in the <code class="literal">pygame.image</code> class that our picture variable <code class="literal">pic</code> uses. The function <code class="literal">pic.get_width()</code> returns the width in pixels of the image stored in the <code class="literal">pygame.image</code> variable <code class="literal">pic</code>. We can use this function instead of hardcoding our program to handle only an image that measures 100 pixels wide. Similarly, <code class="literal">pic.get_height()</code> gives us the height in pixels of the image stored in <code class="literal">pic</code>.</p><p>We can test whether the image <code class="literal">pic</code> is going off the right side of the screen with a statement like this:</p><a id="pro_id00134"/><pre class="programlisting"><span class="orange">if</span> picx + pic.get_width() &gt; 600:</pre><p>In other words, if the starting x-coordinate of the picture, plus the picture’s width, is greater than the width of the screen, we’ll know we’ve gone off the right edge of the screen, and we can change the image’s direction of motion.</p><div class="informalfigure"><a id="med_id00114a"/><div class="mediaobject"><a id="med_id00114"/><img src="httpatomoreillycomsourcenostarchimages2188999.png.jpg" alt="image with no caption"/></div></div></div><div class="sect3" title="Changing Direction"><div class="titlepage"><div><div><h3 class="title"><a id="changing_direction"/>Changing Direction</h3></div></div></div><p><a id="iddle1057" class="indexterm"/><a id="iddle1060" class="indexterm"/><a id="iddle1118" class="indexterm"/><a id="iddle1121" class="indexterm"/><a id="iddle1653" class="indexterm"/><a id="iddle1658" class="indexterm"/><a id="iddle1909" class="indexterm"/>“Bouncing” off the edge of the screen means going in the opposite direction after hitting that edge. The direction our image is moving is controlled by the updates to <code class="literal">picx</code> and <code class="literal">picy</code>. In our old <span class="emphasis"><em>SmileyMove.py</em></span>, we just added 1 pixel to <code class="literal">picx</code> and <code class="literal">picy</code> every time through the <code class="literal">while</code> loop with these lines:</p><a id="pro_id00135"/><pre class="programlisting">picx += 1
picy += 1</pre><p>However, these lines kept our image moving right and down 1 pixel every time; there was no “bounce,” or changing direction, because we never changed the number added to <code class="literal">picx</code> and <code class="literal">picy</code>. Those two lines mean we’re guaranteed to move right and down at a speed of 1 pixel per frame, every frame, even after the smiley has left the screen.</p><div class="informalfigure"><a id="med_id00115a"/><div class="mediaobject"><a id="med_id00115"/><img src="httpatomoreillycomsourcenostarchimages2189001.png.jpg" alt="image with no caption"/></div></div><p>Instead, we can change the constant value <code class="literal">1</code> to a variable that will represent the <span class="emphasis"><em>speed</em></span>, or number of pixels the image should move each frame. Speed is the amount of movement in a period of time. For example, a car that moves a lot in a short time is moving at a <span class="emphasis"><em>high speed</em></span>. A snail that barely moves in the same period of time is moving at a <span class="emphasis"><em>low speed</em></span>. We can define a variable called <code class="literal">speed</code> in the setup portion of our program for the amount of movement in pixels that we want for each frame:</p><a id="pro_id00136"/><pre class="programlisting">speed = 5</pre><p><a id="iddle1064" class="indexterm"/><a id="iddle1173" class="indexterm"/><a id="iddle1387" class="indexterm"/><a id="iddle1699" class="indexterm"/>Then, all we have to do in our game loop is change <code class="literal">picx</code> and <code class="literal">picy</code> by this new speed amount (instead of the constant amount <code class="literal">1</code>) every time through the loop:</p><a id="pro_id00137"/><pre class="programlisting">picx += speed
picy += speed</pre><p>One pixel per frame seemed a bit too slow at 60 frames per second in <span class="emphasis"><em>SmileyMove.py</em></span>, so I’ve increased the speed to 5 to make it move faster. But we’re still not bouncing off the right edge of the screen; we just move off the screen quickly again, because the <code class="literal">speed</code> variable doesn’t change when we hit the edge of the screen.</p><p>We can solve that final problem by adding our collision detection logic—that is, our test to see if we’ve hit the imaginary boundary at the left or right edges of the screen:</p><a id="pro_id00138"/><pre class="programlisting"><span class="orange">if</span> picx &lt;= 0 <span class="orange">or</span> picx + pic.get_width() &gt;= 600:
    speed = -speed</pre><p>First, we’re checking both the left and right boundaries of the screen by seeing if <code class="literal">picx</code> is trying to draw at a negative x-coordinate value (off the left of the screen where <code class="literal">x &lt; 0</code>) or if <code class="literal">picx + pic.get_ width()</code> totals more than the 600-pixel width of the screen (meaning the picture’s starting x-coordinate plus its width have gone off the right edge of the screen). If either of these happens, we know we’ve gone too far and we need to change the direction we’re going in.</p><p>Notice the trick we’re using if either of those boundary tests evaluates to <code class="literal">True</code>. By setting <code class="literal">speed = -speed</code>, we’re changing the <span class="emphasis"><em>direction</em></span> of the movement in our <code class="literal">while</code> loop by multiplying <code class="literal">speed</code> by –1, or by making it the negative of itself. Think of it this way: if we keep looping with <code class="literal">speed</code> equal to <code class="literal">5</code> until our <code class="literal">picx</code> plus the image’s width hits the right edge of the screen at 600 pixels (<code class="literal">picx + pic.get_width() &gt;= 600</code>), setting <code class="literal">speed = -speed</code> will change <code class="literal">speed</code> from <code class="literal">5</code> to <code class="literal">-5</code> (negative five). Then, whenever our <code class="literal">picx</code> and <code class="literal">picy</code> change in the next pass through the loop, we’ll add <code class="literal">-5</code> to our location. This is the same as <span class="emphasis"><em>subtracting</em></span> 5 from <code class="literal">picx</code> and <code class="literal">picy</code>, or moving <span class="emphasis"><em>left and up</em></span> on our screen. If this works, our smiley face will now bounce off the lower-right corner of the screen and start traveling <span class="emphasis"><em>backward</em></span>, back up to (0, 0) at the upper-left corner of the screen.</p><p>But that’s not all! Because our <code class="literal">if</code> statement is also checking for the left screen boundary (<code class="literal">picx &lt;= 0</code>), when our smiley face looks like it has hit the left side of the screen, it will change <code class="literal">speed</code> to <code class="literal">-speed</code> again. If <code class="literal">speed</code> is <code class="literal">-5</code>, this will change it to <code class="literal">-(-5)</code>, or <code class="literal">+5</code>. So if our negative <code class="literal">speed</code> variable was causing us to move to the left and up 5 pixels every frame, once we hit <code class="literal">picx &lt;= 0</code> at the left edge of the screen, <code class="literal">speed = -speed</code> will turn <code class="literal">speed</code> back to positive <code class="literal">5</code>, and the smiley image will start moving to the <span class="emphasis"><em>right and down</em></span> again, in the positive x- and y-directions.</p></div><div class="sect3" title="Putting It All Together"><div class="titlepage"><div><div><h3 class="title"><a id="putting_it_all_together-id00018"/>Putting It All Together</h3></div></div></div><p>Try version 1.0 of our app, <span class="emphasis"><em>SmileyBounce1.py</em></span>, to see the smiley face bounce from the upper-left corner of the window to the lower-right corner and back again, never leaving the drawing screen.</p><div class="sect4" title="SmileyBounce1.py"><div class="titlepage"><div><div><h4 class="title"><a id="smileybounce1dotpy"/>SmileyBounce1.py</h4></div></div></div><a id="pro_id00139"/><pre class="programlisting"><span class="orange">import</span> pygame       <span class="red"># Setup</span>
pygame.init()
screen = pygame.display.set_mode([600,600])
keep_going = <span class="orange">True</span>
pic = pygame.image.load(<span class="green">"CrazySmile.bmp"</span>)
colorkey = pic.get_at((0,0))
pic.set_colorkey(colorkey)
picx = 0
picy = 0
BLACK = (0,0,0)
timer = pygame.time.Clock()
speed = 5

<span class="orange">while</span> keep_going:    <span class="red"># Game loop</span>
    <span class="orange">for</span> event <span class="orange">in</span> pygame.event.get():
         <span class="orange">if</span> event.type == pygame.QUIT:
            keep_going = <span class="orange">False</span>
    picx += speed
    picy += speed

    <span class="orange">if</span> picx &lt;= 0 <span class="orange">or</span> picx + pic.get_width() &gt;= 600:
        speed = -speed

    screen.fill(BLACK)
    screen.blit(pic, (picx,picy))
    pygame.display.update()
    timer.tick(60)

pygame.quit()       <span class="red"># Exit</span></pre><p><a id="iddle1058" class="indexterm"/><a id="iddle1119" class="indexterm"/><a id="iddle1654" class="indexterm"/><a id="iddle1659" class="indexterm"/><a id="iddle1851" class="indexterm"/><a id="iddle1884" class="indexterm"/>With this first version of the program, we have created what looks like a smoothly animated smiley face bouncing back and forth between two corners of a square drawing window. We are able to achieve this effect precisely because the window is a perfect square, 600×600 pixels in size, and because we always change our <code class="literal">picx</code> and <code class="literal">picy</code> values by the same amount (<code class="literal">speed</code>)—our smiley face travels only on the diagonal line where <span class="emphasis"><em>x</em></span> = <span class="emphasis"><em>y</em></span>. By keeping our image on this simple path, we only have to check whether <code class="literal">picx</code> goes past the boundary values at the left and right edges of the screen.</p><p>What if we want to bounce off all four edges (top, bottom, left, and right) of the screen, in a window that isn’t a perfect square— say, 800×600? We’ll need to add some logic to check our <code class="literal">picy</code> variable to see if it passes an upper or lower boundary (the top or bottom of the screen), and we’ll need to keep track of horizontal and vertical speed separately. We’ll do that next.</p></div></div></div><div class="sect2" title="Bouncing a Smiley Off Four Walls"><div class="titlepage"><div><div><h2 class="title"><a id="bouncing_a_smiley_off_four_walls"/>Bouncing a Smiley Off Four Walls</h2></div></div></div><p>In <span class="emphasis"><em>SmileyBounce1.py</em></span>, we kept the horizontal (left-right) and vertical (up-down) motion locked so that whenever the image was moving right, it was also moving down, and when it was moving left, it was also moving up. This worked well for our square window because the width and height of the screen were the same. Let’s build on that example to create a bouncing animation that rebounds realistically off all four sides of the drawing window. We’ll make the window 800×600 pixels in size with <code class="literal">screen = pygame.display.set_mode([800,600])</code> to make the animation more interesting.</p><div class="sect3" title="Horizontal and Vertical Speed"><div class="titlepage"><div><div><h3 class="title"><a id="horizontal_and_vertical_speed"/>Horizontal and Vertical Speed</h3></div></div></div><p>First, let’s separate the horizontal and vertical components of the speed. In other words, let’s create one speed variable, <code class="literal">speedx</code>, for the <span class="emphasis"><em>horizontal</em></span> speed (how fast the image is moving to the right or left), and another speed variable, <code class="literal">speedy</code>, for the <span class="emphasis"><em>vertical</em></span> speed (how fast the image is moving down or up). We can accomplish this by changing the <code class="literal">speed = 5</code> entry in the setup section of our app to initialize a <code class="literal">speedx</code> and <code class="literal">speedy</code> as follows:</p><a id="pro_id00140"/><pre class="programlisting">speedx = 5
speedy = 5</pre><p><a id="iddle1062" class="indexterm"/><a id="iddle1065" class="indexterm"/><a id="iddle1123" class="indexterm"/><a id="iddle1174" class="indexterm"/>We can then modify our image position updates in the game loop:</p><a id="pro_id00141"/><pre class="programlisting">picx += speedx
picy += speedy</pre><p>We change <code class="literal">picx</code> (the horizontal or x-position) by <code class="literal">speedx</code> (the horizontal speed) and <code class="literal">picy</code> (the vertical or y-position) by <code class="literal">speedy</code> (the vertical speed).</p></div><div class="sect3" title="Hitting Four Walls"><div class="titlepage"><div><div><h3 class="title"><a id="hitting_four_walls"/>Hitting Four Walls</h3></div></div></div><p>The last part to figure out is the boundary collision detection for each of the four edges of the screen (top and bottom in addition to right and left). First, let’s modify the left and right boundaries to match the new screen size (800 pixels wide) and to use the new horizontal speed <code class="literal">speedx</code>:</p><a id="pro_id00142"/><pre class="programlisting"><span class="orange">if</span> picx &lt;= 0 <span class="orange">or</span> picx + pic.get_width() &gt;= 800:
    speedx = -speedx</pre><p>Notice that our left-edge-boundary case remains the same at <code class="literal">picx &lt;= 0</code>, because 0 is still the left boundary value when <code class="literal">picx</code> is at the left of the screen. This time, though, our right-edge-boundary case has changed to <code class="literal">picx + pic.get_width() &gt;= 800</code>, because our screen is now 800 pixels wide, and our image still starts at <code class="literal">picx</code> and then draws its full width to the right. So when <code class="literal">picx + pic.get_width()</code> equals <code class="literal">800</code>, our smiley face looks like it is touching the right side of the drawing window.</p><p>We slightly changed the action that our left and right boundaries trigger, from <code class="literal">speed = -speed</code> to <code class="literal">speedx = -speedx</code>. We now have two components of our speed, and <code class="literal">speedx</code> will control the left and right directions and speeds (negative values of <code class="literal">speedx</code> will move the smiley face left; positive values will move it right). So when the smiley hits the right edge of the screen, we turn <code class="literal">speedx</code> negative to make the image go back toward the left, and when it hits the left edge of the screen, we turn <code class="literal">speedx</code> back to a positive value to rebound the image to the right.</p><div class="informalfigure"><a id="med_id00116a"/><div class="mediaobject"><a id="med_id00116"/><img src="httpatomoreillycomsourcenostarchimages2189003.png.jpg" alt="image with no caption"/></div></div><p><a id="iddle1379" class="indexterm"/><a id="iddle1696" class="indexterm"/>Let’s do the same thing with <code class="literal">picy</code>:</p><a id="pro_id00143"/><pre class="programlisting"><span class="orange">if</span> picy &lt;= 0 <span class="orange">or</span> picy + pic.get_height() &gt;= 600:
    speedy = -speedy</pre><p>To test whether our smiley has hit the top edge of the screen, we use <code class="literal">picy &lt;= 0</code>, which is similar to <code class="literal">picx &lt;= 0</code> for the left edge. To figure out whether our smiley has hit the bottom edge of the screen, we need to know both the height of the drawing window (600 pixels) and the height of the image (<code class="literal">pic.get_height()</code>), and we need to see if the top of our image, <code class="literal">picy</code>, plus the image’s height, <code class="literal">pic.get_height()</code>, totals more than the height of our screen, 600 pixels.</p><p>If <code class="literal">picy</code> goes outside these top and bottom boundaries, we need to change the direction of the vertical speed (<code class="literal">speedy = -speedy</code>). This makes the smiley face look like it’s bouncing off the bottom edge of the window and heading back up, or bouncing off the top and heading back down.</p></div><div class="sect3" title="Putting It All Together"><div class="titlepage"><div><div><h3 class="title"><a id="putting_it_all_together-id00019"/>Putting It All Together</h3></div></div></div><p>When we put the whole program together in <span class="emphasis"><em>SmileyBounce2.py</em></span>, we get a convincing bouncing ball that is able to rebound off all four edges of the screen for as long as we run the app.</p><div class="sect4" title="SmileyBounce2.py"><div class="titlepage"><div><div><h4 class="title"><a id="smileybounce2dotpy"/>SmileyBounce2.py</h4></div></div></div><a id="pro_id00144"/><pre class="programlisting"><span class="orange">import</span> pygame        <span class="red"># Setup</span>
pygame.init()
screen = pygame.display.set_mode([800,600])
keep_going = <span class="orange">True</span>
pic = pygame.image.load(<span class="green">"CrazySmile.bmp"</span>)
colorkey = pic.get_at((0,0))
pic.set_colorkey(colorkey)
picx = 0
picy = 0
BLACK = (0,0,0)
timer = pygame.time.Clock()
speedx = 5
speedy = 5

<span class="orange">while</span> keep_going:    <span class="red"># Game loop</span>
    <span class="orange">for</span> event <span class="orange">in</span> pygame.event.get():
        <span class="orange">if</span> event.type == pygame.QUIT:
            keep_going = <span class="orange">False</span>
    picx += speedx
    picy += speedy

    <span class="orange">if</span> picx &lt;= 0 <span class="orange">or</span> picx + pic.get_width() &gt;= 800:
        speedx = -speedx
    <span class="orange">if</span> picy &lt;= 0 <span class="orange">or</span> picy + pic.get_height() &gt;= 600:
        speedy = -speedy

    screen.fill(BLACK)
    screen.blit(pic, (picx, picy))
    pygame.display.update()
    timer.tick(60)

pygame.quit()        <span class="red"># Exit</span></pre><p><a id="iddle1066" class="indexterm"/><a id="iddle1175" class="indexterm"/>The rebounds look realistic. If the smiley is coming toward the bottom edge at a 45-degree angle down and to the right, it bounces off at a 45-degree angle up and to the right. You can experiment with different values of <code class="literal">speedx</code> and <code class="literal">speedy</code> (say, <code class="literal">3</code> and <code class="literal">5</code>, or <code class="literal">7</code> and <code class="literal">4</code>) to see the angles change for every bounce.</p><p>Just for fun, you can comment out the line <code class="literal">screen.fill(BLACK)</code> in <span class="emphasis"><em>SmileyBounce2.py</em></span> to see the path traveled by our smiley face as it bounces off each edge of the screen. When you <span class="emphasis"><em>comment out</em></span> a line, you turn it into a comment by putting a hash mark at the beginning, as follows:</p><a id="pro_id00145"/><pre class="programlisting"><span class="red"># screen.fill(BLACK)</span></pre><p>This tells the program to ignore the instruction on that line. Now the screen is not erased after each smiley face is drawn, and you’ll see a pattern created by the trail your animation is leaving behind, like in <a class="xref" href="ch08.html#if_we_comment_out_the_line_that_clears_o" title="Figure 8-9. If we comment out the line that clears our screen after each frame, our smiley face leaves a bouncing trail behind in a cool pattern.">Figure 8-9</a>. Because each new smiley is drawn over the previous one, the result looks like cool, retro 3-D screensaver artwork as it draws.</p><p>Our collision-detection logic has allowed us to create the illusion of a solid smiley face bouncing off all four edges of a solid drawing screen. This is an improvement over our original version, which let the smiley slide off into oblivion. When we create games that allow the user to interact with pieces on the screen, and that allow those pieces to look as if they’re interacting with one another—like in Tetris, for example—we’re using the same kind of collision detection and boundary checking that we built here.</p><div class="figure"><a id="if_we_comment_out_the_line_that_clears_o"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00117"/><img src="httpatomoreillycomsourcenostarchimages2189005.png.jpg" alt="If we comment out the line that clears our screen after each frame, our smiley face leaves a bouncing trail behind in a cool pattern."/></div></div><p class="title">Figure 8-9. If we comment out the line that clears our screen after each frame, our smiley face leaves a bouncing trail behind in a cool pattern.</p></div></div></div></div></div><div class="sect1" title="What You Learned"><div class="titlepage"><div><div><h1 class="title"><a id="what_you_learned-id00020"/>What You Learned</h1></div></div></div><p><a id="iddle1885" class="indexterm"/>In this chapter, you learned how to create the illusion of motion, what we call <a class="firstterm" href="apd.html#gloss01_002"><em class="firstterm">animation</em></a>, by drawing images in different locations on the screen over time. We saw how the Pygame module can make programming a game or animation much quicker, since it has hundreds of functions that can make almost everything in a game app easier, from drawing images to creating timer-based animation— even checking for collisions. We installed Pygame on our computer so we could use its features to create fun apps of our own.</p><p>You learned about the structure of a game or app that we might build in Pygame, with a setup section; a game loop that handles events, updates and draws graphics, and then updates the display; and finally an exit section.</p><p>We started our Pygame programming by drawing a simple green dot on the screen at a chosen location, but we quickly moved on to drawing a picture from an image file on disk, saved in the same folder as our program, to our display screen. You learned that Pygame has a different coordinate system from the Turtle library, with the origin (0, 0) in the upper-left corner of the screen and positive y-coordinate values as we move down.</p><p>You learned how to create animation by drawing objects on the screen, clearing the screen, and then drawing the objects in a slightly different location. We saw that the <code class="literal">pygame.time.Clock()</code> object could make our animations steadier by limiting the number of times our animation draws each second, which is called the <span class="emphasis"><em>frames per second</em></span>, or <span class="emphasis"><em>fps</em></span>.</p><p>We built our own collision detection to check for objects “hitting” the edge of the screen, and then we added the logic to make objects look like they’re bouncing back by changing the direction of their speed or velocity variables (by multiplying them by –1).</p><p>Programming the cool apps in this chapter has given us the skills to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Install and use the <code class="literal">pygame</code> module in our own Python programs.</p></li><li class="listitem"><p>Explain the structure of a Pygame app, including the setup, game loop, and exit.</p></li><li class="listitem"><p>Build a game loop that handles events, updates and draws graphics, and updates the display.</p></li><li class="listitem"><p>Draw shapes to the screen using <code class="literal">pygame.draw</code> functions.</p></li><li class="listitem"><p>Load images from disk with <code class="literal">pygame.image.load()</code>.</p></li><li class="listitem"><p>Draw images and objects to the screen with the <code class="literal">blit()</code> function.</p></li><li class="listitem"><p>Create animations by drawing objects to the screen repeatedly in different locations.</p></li><li class="listitem"><p>Make animations smooth, clean, and predictable using a <code class="literal">pygame.time.Clock()</code> timer’s <code class="literal">tick()</code> function to limit the number of frames per second in our animations.</p></li><li class="listitem"><p>Check for collision detection by building the <code class="literal">if</code> logic to check for boundary cases, like a graphic hitting the edge of the screen.</p></li><li class="listitem"><p>Control the horizontal and vertical speeds of moving objects on the screen by changing the amount of movement in the x- and y-directions from one frame to the next.</p></li></ul></div><div class="sidebar"><a id="programming_challenges-id00021"/><p class="title">Programming Challenges</p><p><a id="iddle1245" class="indexterm"/><a id="iddle1745" class="indexterm"/><a id="iddle1812" class="indexterm"/><a id="iddle1872" class="indexterm"/>Here are three challenge problems to extend the skills you developed in this chapter. For sample answers, go to <span class="emphasis"><em><a class="ulink" href="http://www.nostarch.com/teachkids/">http://www.nostarch.com/teachkids/</a></em></span>.</p><p><span class="strong"><strong><span class="orange">#1: A COLOR-CHANGING DOT</span></strong></span></p><p>Let’s explore RGB color triplets further. We worked with some RGB colors in this chapter; remember, green was <code class="literal">(0,255,0)</code>, black was <code class="literal">(0,0,0)</code>, and so on. At <span class="emphasis"><em><a class="ulink" href="http://colorschemer.com/online/">http://colorschemer.com/online/</a></em></span>, enter different red, green, and blue values from 0 to 255 to see the colors you can create by combining different amounts of red, green, and blue light from your screen’s pixels. Start by choosing your own color triplet to use in the <span class="emphasis"><em>ShowDot.py</em></span> program. Then modify the program to draw the dot larger or smaller and at different locations on the screen. Finally, try creating a random RGB color triplet using <code class="literal">random.randint(0,255)</code> for each of the three color components (remember to <code class="literal">import random</code> at the top of your program) so that the dot changes colors every time it draws on the screen. The effect will be a color-changing dot. Call your new creation <span class="emphasis"><em>DiscoDot.py</em></span>.</p><p><span class="strong"><strong><span class="orange">#2: 100 RANDOM DOTS</span></strong></span></p><p>As a second challenge, let’s replace the single dot with 100 dots in random colors, sizes, and locations. To do this, let’s set up three arrays capable of storing 100 values each for the colors, locations, and sizes:</p><a id="pro_id00146"/><pre class="programlisting"><span class="red"># Colors, locations, sizes arrays for 100 random dots</span>
colors = [0]*100
locations = [0]*100
sizes = [0]*100</pre><p>Then, fill those three arrays with random color triplets, location pairs, and size/radius values for 100 random dots:</p><a id="pro_id00147"/><pre class="programlisting"><span class="orange">import</span> random
<span class="red"># Store random values in colors, locations, sizes</span>
<span class="orange">for</span> n <span class="orange">in</span> <span class="violet">range</span>(100):
    colors[n] = (random.randint(0,255),random.randint(0,255),
                 random.randint(0,255))
    locations[n] = (random.randint(0,800),
                    random.randint(0,600))
    sizes[n] = random.randint(10, 100)</pre><p><a id="iddle1746" class="indexterm"/>Finally, instead of drawing one dot in our <code class="literal">while</code> loop, add a <code class="literal">for</code> loop to draw the 100 random dots by using the <code class="literal">colors</code>, <code class="literal">locations</code>, and <code class="literal">sizes</code> arrays:</p><a id="pro_id00148"/><pre class="programlisting"><span class="orange">for</span> n <span class="orange">in</span> <span class="violet">range</span>(100):
    pygame.draw.circle(screen, colors[n], locations[n],
                       sizes[n])</pre><p>Call your new creation <span class="emphasis"><em>RandomDots.py</em></span>. The final app should look something like <a class="xref" href="ch08.html#advanced_version_of_our_dot_programcomma" title="Figure 8-10. An advanced version of our dot program, RandomDots.py, gives us 100 dots of random color, location, and size.">Figure 8-10</a> when complete.</p><div class="figure"><a id="advanced_version_of_our_dot_programcomma"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00118"/><img src="httpatomoreillycomsourcenostarchimages2189007.png.jpg" alt="An advanced version of our dot program, RandomDots.py, gives us 100 dots of random color, location, and size."/></div></div><p class="title">Figure 8-10. An advanced version of our dot program, <span class="emphasis"><em>RandomDots.py</em></span>, gives us 100 dots of random color, location, and size.</p></div><p><a id="iddle1740" class="indexterm"/><span class="strong"><strong><span class="orange">#3: RAINING DOTS</span></strong></span></p><p>Finally, let’s take <span class="emphasis"><em>RandomDots.py</em></span> one step further by programming the dots to “rain” off the bottom and right sides of the screen and reappear along the top and left. You’ve learned in this chapter that we create animation by changing the location of an object over time. We have the location of each dot in an array called <code class="literal">locations</code>, so if we change each dot’s x- and y-coordinates, we can animate our dots. Change the <code class="literal">for</code> loop from <span class="emphasis"><em>RandomDots.py</em></span> to calculate a new x- and y-coordinates for each dot based on the previous value, like this:</p><a id="pro_id00149"/><pre class="programlisting"><span class="orange">for</span> n <span class="orange">in</span> <span class="violet">range</span>(100):
    pygame.draw.circle(screen, colors[n], locations[n],
                       sizes[n])
    new_x = locations[n][0] + 1
    new_y = locations[n][1] + 1
    locations[n] = (new_x, new_y)</pre><p>This change calculates new x- and y-coordinates (<code class="literal">new_x</code> and <code class="literal">new_y</code>) for each dot every pass through the game loop, but it lets the dots fall off the right and bottom edges of the screen. Let’s fix this by checking whether each dot’s <code class="literal">new_x</code> or <code class="literal">new_y</code> is beyond the right or bottom edges of the screen and, if so, move the dot back up or back to the left before we store the new location:</p><a id="pro_id00150"/><pre class="programlisting"><span class="orange">if</span> new_x &gt; 800:
    new_x -= 800
<span class="orange">if</span> new_y &gt; 600:
    new_y -= 600
locations[n] = (new_x, new_y)</pre><p>The combined effect of these changes will be a steady flow of random dots “raining” down and to the right, disappearing off the bottom right of the screen and popping back up on the top or left edge. Four frames in this sequence are shown in <a class="xref" href="ch08.html#four_frames_showing_100_random_dots_as_t" title="Figure 8-11. Four frames showing 100 random dots as they move right and down across the screen">Figure 8-11</a>; you can follow groups of dots as they move down and to the right across the three images.</p><p>Save your new app as <span class="emphasis"><em>RainingDots.py</em></span>.</p><div class="figure"><a id="four_frames_showing_100_random_dots_as_t"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00119"/><img src="httpatomoreillycomsourcenostarchimages2189009.png.jpg" alt="Four frames showing 100 random dots as they move right and down across the screen"/></div></div><p class="title">Figure 8-11. Four frames showing 100 random dots as they move right and down across the screen</p></div></div></div></div></body></html>