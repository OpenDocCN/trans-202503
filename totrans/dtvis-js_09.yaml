- en: 'Chapter 9. Building Data-Driven Web Applications: Part 1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far we’ve had a chance to see many of the tools and libraries for creating
    individual JavaScript visualizations, but we’ve considered them only in the context
    of a traditional web page. Today, of course, the Web is much more than traditional
    web pages. Especially on desktop computers, websites are effectively full-featured
    software applications. (Even on mobile devices many “apps” are really just websites
    enclosed in a thin wrapper.) When a web application is structured around data,
    there’s a good chance it can benefit from data visualizations. That’s exactly
    what we’ll consider in this final project: how to integrate data visualization
    into a true web application.'
  prefs: []
  type: TYPE_NORMAL
- en: The sections that follow will walk through the development of an example application
    driven by data. The source of the data will be Nike’s Nike+ (*[http://nikeplus.com/](http://nikeplus.com/)*)
    service for runners. Nike sells many products and applications that let runners
    track their activities and save the results for analysis and review. In this chapter
    and the next, we’ll build a web application to retrieve that data from Nike and
    present it to a user. Nike, of course, has its own web app for viewing Nike+ data,
    and that app is far superior to the simple example here. We’re certainly not trying
    to compete with Nike; rather, we’re just using the Nike+ service to structure
    our example.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**This sample project is based on the version of the interface at the time
    of this writing. There may have been changes to the interface since then.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike most other chapters, this chapter won’t include multiple independent
    examples. Instead, it will walk through the main stages in the development and
    testing of a single data-driven application. We’ll see how to build up the basic
    structure and functionality of the web application. This includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to structure a web application using a framework or library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to organize an application into models and views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to incorporate visualizations in views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 10](ch10.html "Chapter 10. Building Data-Driven Web Applications:
    Part 2"), we’ll focus on some of the finer details by dealing with several quirks
    of the Nike+ interface and adding some finishing touches to round out the single-page
    application.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**To use the Nike+ data in an actual product, you must register your application
    with Nike and get the necessary credentials and security keys. That process also
    grants you access to the full documentation for the service, which is not publicly
    available. Since we’re not building a real application in this example, we won’t
    cover that step. We will, however, base the application on the Nike+ API, which
    is documented publicly on Nike’s developer website (***[https://developer.nike.com/index.html](https://developer.nike.com/index.html)***).
    Because the example doesn’t include the credentials and security keys, it won’t
    be able to access the real Nike+ service. The book’s source code, however, does
    include actual Nike+ data that can be used to emulate the Nike+ service for testing
    and development.**'
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks and Libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we’re using JavaScript to add data visualizations to traditional web pages,
    we don’t have to worry too much about organizing and structuring our JavaScript.
    After all, it’s often a relatively small amount of code, especially compared to
    the HTML markup and CSS styles that are also part of the page. With web applications,
    however, the code can grow to be more extensive and more complex. To help keep
    our code organized and manageable, we’ll take advantage of a JavaScript application
    library, also called a *framework*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Select an Application Library'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Deciding to use an application library might be easier than deciding which one
    to use. The number of these libraries has exploded in the past few years; there
    are now over 30 high-quality libraries from which to choose. A good place to see
    all the alternatives is TodoMVC (*[http://todomvc.com/](http://todomvc.com/)*),
    which shows how to implement a simple to-do application in each library.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an important question to ask that can help you narrow down the choices:
    is an application library a *pure library* or an *application framework*? Those
    terms are often used interchangeably, but there is a significant distinction.
    A pure library functions like jQuery or other libraries we’ve used throughout
    this book. It provides a set of tools for our application, and we can use as many—or
    as few—of those tools as we like. An application framework, on the other hand,
    dictates exactly how the application should work. The code that we write must
    follow the strictures and conventions of the framework. Fundamentally, the difference
    is about control. With a pure library, our code is in control and the library
    is at our disposal. With a framework, the framework code is in control, and we
    simply add the code that makes our application unique.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main advantage of a pure library is flexibility. Our code is in control
    of the application, and we have full latitude to structure the application to
    our own requirements. That’s not always a good thing, however. The constraints
    of a framework can protect us from making poor design decisions. Some of the world’s
    best JavaScript developers are responsible for the popular frameworks, and they’ve
    put a lot of thought into what makes a good web application. There’s another benefit
    to frameworks: because the framework assumes more responsibility for the application,
    there’s generally less code we’re required to write.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting this distinction between frameworks and pure libraries, but
    almost any web application can be built effectively with either. Both approaches
    provide the organization and structure necessary for a high-quality application.
    For our example, we’ll use the Backbone.js (*[http://backbonejs.org/](http://backbonejs.org/)*)
    library. It is by far the most popular of the pure (nonframework) libraries, and
    it’s used by dozens of the largest sites on the Web. The general approach that
    we’ll follow, however (including tools such as Yeoman), works well with almost
    any popular application library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Install Development Tools'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you start building your first real web application, deciding how to begin
    can be a bit intimidating. One tool that can be a big help at this stage is Yeoman
    (*[http://yeoman.io/](http://yeoman.io/)*), which describes itself as “The Web’s
    Scaffolding Tool for Modern Webapps.” That’s a pretty accurate description. Yeoman
    can define and initialize a project structure for a large number of different
    web application frameworks, including Backbone.js. As we’ll see, it also sets
    up and configures most of the other tools we’ll need during the application’s
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can use Yeoman, we must first install Node.js (*[http://nodejs.org/](http://nodejs.org/)*).
    Node.js is a powerful application development platform all by itself, but we won’t
    need to worry about the details here. It is, however, the application platform
    required by many modern web development tools like Yeoman. To install Node.js,
    follow the instructions on its website (*[http://nodejs.org/](http://nodejs.org/)*).
  prefs: []
  type: TYPE_NORMAL
- en: With Node.js installed, we can install the main Yeoman application as well as
    everything necessary to create a Backbone.js application (*[https://github.com/yeoman/generator-backbone/](https://github.com/yeoman/generator-backbone/)*)
    with one command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can execute this command in the Terminal app (on Mac OS X) or from the Windows
    command prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Define a New Project'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The development tools we just installed will make it easy to create a new web
    app project. First, with the following commands, we create a new folder (named
    *running*) for our application and then `cd` (change directory) into that folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: From within that new folder, executing the command `yo backbone` will initialize
    the project structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As part of the initialization, Yeoman will ask for permission to send diagnostic
    information (mainly which frameworks and features our app uses) back to the Yeoman
    developers. It will then give us a choice to add a few more tools to the app.
    For our example, we’ll skip any of the suggested options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Yeoman will then do its magic, creating several subfolders, installing extra
    tools and applications, and setting up reasonable defaults. As you watch all the
    pages and pages of installation information scroll by in your window, you can
    be glad that Yeoman is doing all this work for you. When Yeoman finishes, you’ll
    have a project structure like the one shown in [Figure 9-1](ch09.html#yeoman_creates_a_default_project_structu
    "Figure 9-1. Yeoman creates a default project structure for a web application.").
    It may not look exactly like the figure here, since web applications may have
    changed since this text was written, but rest assured that it will follow the
    best practices and conventions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Yeoman creates a default project structure for a web application.](figs/web/09fig01.png.jpg)Figure 9-1. Yeoman
    creates a default project structure for a web application.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll spend more time with most of these files and folders in the sections that
    follow, but here’s a quick overview of the project that Yeoman has set up for
    us.
  prefs: []
  type: TYPE_NORMAL
- en: '**app/**. The folder that will contain all the code for our app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**bower.json**. A file that keeps track of all the third-party libraries our
    app uses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**gruntfile.js**. A file that controls how to test and build our app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**node_modules/**. A folder that contains the tools used to build and test
    our app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**package.json**. A file that identifies the tools used to build and test our
    app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**test/**. A folder that will contain the code we’ll write to test our app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point Yeoman has set up a complete web app (albeit one that doesn’t
    do anything). You can execute the command `grunt serve` from the command prompt
    to see it in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `grunt` command runs one of the tools that’s part of the Yeoman package.
    When passed the `serve` option, it cleans up the application folder, starts a
    web server to host the application, launches a web browser, and navigates to the
    skeleton app. You’ll see something like [Figure 9-2](ch09.html#default_yeoman_web_application_runs_in_t
    "Figure 9-2. The default Yeoman web application runs in the browser.") in your
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![The default Yeoman web application runs in the browser.](figs/web/09fig02.png.jpg)Figure 9-2. The
    default Yeoman web application runs in the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! Our web app, as basic as it is, is now running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Add Our Unique Dependencies'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yeoman sets up sensible defaults and tools for a new app, but our app needs
    a few JavaScript libraries that aren’t part of those defaults, such as Leaflet
    for maps and Flot for charts. The Moment.js (*[http://momentjs.com/](http://momentjs.com/)*)
    library for dealing with dates and times will also come in handy, as will the
    Underscore.string (*[http://epeli.github.io/underscore.string/](http://epeli.github.io/underscore.string/)*)
    library. We can add these libraries to our project with some simple commands.
    The `--save` option tells the bower tool (which is part of the Yeoman package)
    to remember that our project depends on these libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Perhaps you’ve already begun to appreciate how tools like Yeoman make development
    easier. The simple commands shown here save us from having to find the libraries
    on the Web, download the appropriate files, copy them to the right place in our
    project, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Even more importantly, Yeoman (technically, the bower tool) automatically takes
    care of any additional libraries on which these libraries depend. The Flot library,
    for example, requires jQuery. When Yeoman installs Flot, it will also check and
    make sure that jQuery is installed in the project. In our case, it is because
    Backbone.js depends on it, but if jQuery weren’t already installed, Yeoman would
    automatically find it and install it as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'For most libraries, bower can completely install all the necessary components
    and files. In the case of Leaflet, however, we need to perform a few extra steps.
    Change directory to the *leaflet* folder within *app/bower_components*. From there,
    run two commands to install the unique tools that Leaflet requires:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Executing the command `jake` will then run all of Leaflet’s tests and, provided
    they pass, create a Leaflet.js library for our app.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'All that’s left to do is add the other libraries into our HTML files. That’s
    easy enough. The main page for our app is *index.html* in the *app* folder. There’s
    already a block of code that includes jQuery, Underscore.js, and Backbone.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We can add our new libraries after Backbone.js.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Leaflet, as we saw in [Chapter 6](ch06.html "Chapter 6. Visualizing Geographic
    Data"), also requires its own style sheet. We add that to the top of *index.html*
    just before *main.css*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve set up the structure of our app and installed the necessary libraries,
    it’s time to start development.
  prefs: []
  type: TYPE_NORMAL
- en: Models and Views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many application libraries available for web apps, and each has its
    quirks, but most of the libraries agree on the key principles that should guide
    an app’s architecture. Perhaps the most fundamental of those principles is separating
    *models* from *views.* The code that keeps track of the core data for the app
    (the models) should be separate from the code that presents that data to the user
    (the views). Enforcing this separation makes it easier to update and modify either.
    If you want to present your data in a table instead of a chart, you can do that
    without any changes to the models. And if you need to change your data source
    from a local file to a REST API, you can do that without any changes to the views.
    We’ve been employing this principle in an informal way throughout the book. In
    all of the examples, we’ve isolated the steps required to obtain and format our
    data from the steps we used to visualize it. Using an application library like
    Backbone.js gives us the tools to manage models and views more explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Define the Application’s Models'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our running app is designed to work with Nike+, which provides details about
    runs—training runs, interval workouts, trail runs, races, and so on. The data
    set we want consists of nothing but runs, so our app’s core model is, naturally,
    a run.
  prefs: []
  type: TYPE_NORMAL
- en: The Yeoman tool makes it very easy to define a model for our app. A simple command
    defines a new model and creates the JavaScript files and scaffolding for that
    model.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'That command creates two new files: *run.js* in the *app/scripts/models/* folder
    and *run.spec.js* in the *test/* folder. Let’s take a look at the file Yeoman
    created for our model. It’s quite short.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'At ➊ is a comment that lists the global variables our model requires. In this
    case there are only two: `Running` (that’s our app) and `Backbone`. Next, at ➋,
    this file creates a `.Models` property of the `Running` object unless that property
    already exists.'
  prefs: []
  type: TYPE_NORMAL
- en: When the browser encounters this line, it will check to see if `Running.Models`
    exists. If it does, then `Running.Models` won’t be `false`, and the browser never
    has to consider the second clause of the logical *or* (`||`). The statement simply
    assigns `Running.Models` to itself, so it has no practical effect. If `Running.Models`
    does not exist, however, then it evaluates to `false`, and the browser will continue
    to the second clause, where it assigns an empty object (`{}`) to `Running.Models`.
    Ultimately, this statement makes sure that the object `Running.Models` exists.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code in the file is enclosed within an *immediately invoked
    function expression.* If you haven’t seen this pattern before, it may look a little
    strange.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If we rewrite the block as a single line, though, it might be easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The statement defines a JavaScript function with a function expression, `function
    () { /* ... */ }`, and then, with the concluding `()`, it calls (technically *invokes*)
    that newly created function. All we’re really doing, therefore, is putting our
    code inside a function and calling that function. You’ll see this pattern a lot
    in professional JavaScript because it protects a block of code from interfering
    with other code blocks in the application.
  prefs: []
  type: TYPE_NORMAL
- en: When you define a variable in JavaScript, it is a *global* variable, available
    everywhere in the code. As a consequence, if two different sections of code try
    to define the same global variable, those definitions will clash. This interaction
    can cause bugs that are very hard to find, as code in one section inadvertently
    interferes with code in a completely different section. To prevent this problem,
    we can avoid using global variables, and the easiest way to do that in JavaScript
    is to define our variables inside a function. That’s the purpose of an immediately
    invoked function expression. It makes sure that any variables our code defines
    are *local* to the function rather than global, and it prevents our code blocks
    from interfering with one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Implement the Model'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our application really only needs this one model, and it’s already complete!
    That’s right: the scaffolding that Yeoman has set up for us is a complete and
    functioning model for a run. In fact, if it weren’t for some quirks in Nike’s
    REST API, we wouldn’t have to touch the model code at all. We’ll address those
    quirks in [Chapter 10](ch10.html "Chapter 10. Building Data-Driven Web Applications:
    Part 2").'
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to the next step, though, let’s look at what we can do with
    our newly created model. To do that we’ll make a temporary addition to the model
    code. We won’t use the following code in the final app; it’s only meant to show
    off what our model can already do.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s add the URL to retrieve details about a run (Nike+ uses the more
    general term *activity*). From the Nike+ documentation, we find that this URL
    is *[https://api.nike.com/v1/me/sport/activities/<activityId>](https://api.nike.com/v1/me/sport/activities/<activityId>)*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The final part of the URL depends on the specific activity, so here we add only
    the general part of the URL to our model (➊).
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine that we want to get the details for a specific run from the Nike+
    service. The run in question has a unique identifier of `2126456911`. If the Nike+
    API followed typical conventions, we could create a variable representing that
    run, *and get all its data*, with the hypothetical two statements that follow.
    (We’ll consider the quirks of the actual Nike+ interface in Step 7 of [Connecting
    with the Nike+ Service](ch10.html#connecting_with_the_nikeplus_service "Connecting
    with the Nike+ Service").)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Since many APIs *do* follow typical conventions, it’s worth spending some time
    understanding how that code works. The first statement creates a new instance
    of the Run model and specifies its identifier. The second statement tells Backbone
    to retrieve the model’s data from the server. Backbone will take care of all the
    communication with Nike+, including error handling, time-outs, parsing the response,
    and so on. Once the fetch completes, detailed information from that run will be
    available from the model. If we provide a callback function, we could output some
    of the details. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output in the browser’s console would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Not bad for a few simple lines of code! The code in this step, though, is really
    just a detour. Our application won’t use individual models in this way. Instead,
    we’ll use an even more powerful Backbone.js feature: collections.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Define the Application’s Collections'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The model we created is designed to capture the data for a single run. Our users,
    however, aren’t interested in just a single run. They’d like to see all of their
    runs—dozens, hundreds, possibly thousands of them. We can handle all of these
    runs with a *collection*, or group of models. The collection is one of the core
    concepts of Backbone.js, and it will be a big help for our app. Let’s define a
    collection for all of the user’s runs.
  prefs: []
  type: TYPE_NORMAL
- en: Yeoman makes it easy to define and set up scaffolding for our collection. We
    execute the single command `yo backbone:collection runs` from the command line.
    (Yes, we’re being very original and calling our collection of runs, well, *runs*.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Yeoman does the same thing for collections as it did for models: it creates
    an implementation file (*runs.js* in the *app/scripts/collections/* folder) and
    a test file. For now, let’s take a look at *runs.js*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This file is even simpler than our model; the default collection has only a
    single property to indicate what type of model the collection contains. Unfortunately,
    Yeoman isn’t smart enough to handle plurals, so it assumes the name of the model
    is the same as the name of the collection. That’s not true for our app, as our
    model is Run (singular) and the collection is Runs (plural). While we’re removing
    that *s*, we can also add a property to specify the REST API for the collection.
    That’s a URL from the Nike+ service.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With those two small changes, we’re ready to take advantage of our new collection
    (aside from handling a few quirks with the Nike+ API; we’ll ignore that complication
    for now and address it later). All we need to do is create a new instance of the
    Runs collection and then fetch its data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That’s all it takes to build a collection containing the user’s runs. Backbone.js
    creates a model for each and retrieves the model’s data from the server. Even
    better, those run models are stored in a true Underscore.js collection, which
    gives us access to many powerful methods to manipulate and search through the
    collection. Suppose, for example, we want to find the total distance for all of
    a user’s runs. That’s tailor-made for the Underscore.js `reduce()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: That code could tell us, for example, that the user has logged a total of 3,358
    kilometers with Nike+.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**As you may have noticed, we’re taking advantage of many utilities from Underscore.js
    in our Backbone.js application. That is not a coincidence. Jeremy Ashkenas is
    the lead developer for both projects.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Define the Application’s Main View'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have all the running data for a user, it’s time to present that
    data. We’ll do that with Backbone.js *views.* To keep our example simple, we’ll
    consider only two ways to show the running data. First we’ll display a table listing
    summary information about each run. Then, if the user clicks on a table row, we’ll
    show details about that specific run, including any visualizations. The main view
    of our application will be the summary table, so let’s focus on that first.
  prefs: []
  type: TYPE_NORMAL
- en: A Backbone.js view is responsible for presenting data to the user, and that
    data may be maintained in a collection or a model. For the main page of our app,
    we want to show summary information for all of a user’s runs. That view, therefore,
    is a view of the entire collection. We’ll call the view *Summary.*
  prefs: []
  type: TYPE_NORMAL
- en: The bulk of the table for this Summary view will be a series of table rows,
    where each row presents summary data about an individual run. That means we can
    simply create a view of a single Run model presented as a table row, and design
    our main Summary view to be made up (mostly) of many SummaryRow views. We can
    once again rely on Yeoman to set up the scaffolding for both of those types of
    views.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The scaffolding that Yeoman sets up is pretty much the same for each view; only
    the name varies. Here’s what a Summary view looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The overall structure of the file is the same as our model and our collection,
    but there’s a bit more going on in the view itself. Let’s step through the view’s
    properties one at a time. The first property is `template`. That’s where we define
    the exact HTML markup for the view, and we’ll look at this in more detail in the
    next step.
  prefs: []
  type: TYPE_NORMAL
- en: The `tagName` property defines the HTML tag that our view will use as its parent.
    Yeoman defaults it to a generic `<div>`, but we know that in our case, it will
    be a `<table>`. We’ll change that in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: The `id` and `className` properties specify HTML `id` attributes or `class`
    values to add to the main container (in our case, the `<table>`). We could, for
    example, base some CSS styles on these values. For our example, we’re not considering
    styles, so we can leave both properties blank or delete them entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the `events` property. This property identifies user events (such as
    mouse clicks) that are relevant for the view. In the case of the Summary view,
    there are no events, so we can leave the object empty or simply delete it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last two properties, `initialize()` and `render()`, are both methods. Before
    we consider those, let’s see the Summary view after we make the tweaks just mentioned.
    Now that we’ve omitted the properties we won’t be using, we’re down to just the
    `template` and `tagName` properties, plus the `initialize()` and `render()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s look inside the last two methods, starting with `initialize()`. That
    method has a single statement (other than the `return` statement that we just
    added). By calling `listenTo()`, it tells Backbone.js that the view wants to listen
    for events. The first parameter, `this.collection`, specifies the event target,
    so the statement says that the view wants to listen to events affecting the collection.
    The second parameter specifies the type of events. In this case, the view wants
    to know whenever the collection changes. The final parameter is the function Backbone.js
    should call when the event occurs. Every time the Runs collection changes, we
    want Backbone.js to call the view’s `render()` method. That makes sense, because
    whenever the Runs collection changes, whatever we were displaying on the page
    is now out of date. To make it current, our view should refresh its contents.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the real work of a view takes place in its `render()` method. After
    all, this is the code that actually creates the HTML markup for the web page.
    Yeoman has gotten us started with a template, but in the case of a collection
    view, that’s not enough. The template takes care of the HTML for the collection
    as a whole, but it doesn’t handle the models that are part of the collection.
    For the individual runs, we can use the `each()` function from Underscore.js to
    iterate through the collection and render each run.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the following code, we’ve also added a `return this;` statement
    to each method. In a bit we’ll take advantage of this addition to *chain* together
    calls to multiple methods in a single, concise statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have to write the `renderRun()` method that handles each individual
    run. Here’s what we want that function to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new SummaryRow view for the run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Render that SummaryRow view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Append the resulting HTML to the `<tbody>` in the Summary view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code to implement those steps is straightforward, but it’s helpful to take
    each step one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new SummaryRow view: `new SummaryRow({model: run})`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Render that SummaryRow view: `.render()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Append the result: `this.$("tbody").append();`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we put the steps together, we have the `renderRun()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Most of the changes we made to the Summary view are also appropriate for the
    SummaryRow view, although we don’t need to add anything to the `render()` method.
    Here’s our first implementation of the SummaryRow. Note that we’ve set the `tagName`
    property to `"tr"` because we want each run model presented as a table row.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now we have all the JavaScript code we need to show the main summary view for
    our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: Define the Main View Templates'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far we’ve developed the JavaScript code to manipulate our Summary and SummaryRow
    views. That code doesn’t generate the actual HTML markup, though. For that task
    we rely on *templates*. Templates are skeletal HTML markup with placeholders for
    individual values. Confining HTML markup to templates helps keep our JavaScript
    code clean, well structured, and easy to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Just as there are many popular JavaScript application libraries, there are also
    many template languages. Our application doesn’t require any fancy template functionality,
    however, so we’ll stick with the default template process that Yeoman has set
    up for us. That process relies on a JST tool (*[https://github.com/gruntjs/grunt-contrib-jst/](https://github.com/gruntjs/grunt-contrib-jst/)*)
    to process templates, and the tool uses the Underscore.js template language (*[http://underscorejs.org/#template/](http://underscorejs.org/#template/)*).
    It’s easy to see how this works through an example, so let’s dive in.
  prefs: []
  type: TYPE_NORMAL
- en: The first template we’ll tackle is the template for a SummaryRow. In our view,
    we’ve already established that the SummaryRow is a `<tr>` element, so the template
    needs to supply only the content that lives within that `<tr>`. We’ll get that
    content from the associated Run model, which, in turn, comes from the Nike+ service.
    Here’s an example activity that Nike+ could return.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: For a first implementation, let’s show the time of the run, as well as its duration,
    distance, and calories. Our table row, therefore, will have four cells, with each
    cell holding one of these values. We can find the template, *summaryRow.ejs*,
    in the *app/scripts/templates* folder. By default, Yeoman sets it to a simple
    paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Let’s replace that with four table cells.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As placeholders for the cells’ content, we can use model attributes enclosed
    in special `<%=` and `%>` delimiters. The full SummaryRow template is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The other template we need to supply is the Summary template. Since we’ve already
    set the view’s main tag to be a `<table>`, this template should specify the content
    within that `<table>`: a table header row plus an empty `<tbody>` element (whose
    individual rows will come from the Run models).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’re finally ready to construct the main view for our runs. The steps
    are quite straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Runs collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fetch the data for that collection from the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Summary view for the collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Render the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s the JavaScript code for those four steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can access the constructed `<table>` as the `el` (short for *element*) property
    of the view. It will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When we insert that markup in the page, our users can see a simple summary table
    listing their runs, as shown in [Figure 9-3](ch09.html#simple_table_with_a_summary_of_run_infor
    "Figure 9-3. A simple table with a summary of run information").
  prefs: []
  type: TYPE_NORMAL
- en: '![A simple table with a summary of run information](figs/web/09fig03.png.jpg)Figure 9-3. A
    simple table with a summary of run information'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 6: Refine the Main View'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’re starting to get somewhere, though the table contents could use some
    tweaking. After all, does the last digit in a run of 16.068001 kilometers really
    matter? Since Nike+ determines the attributes of our Run model, it might seem
    like we have no control over the values passed to our template. Fortunately, that’s
    not the case. If we look at the SummaryView’s `render()` method, we can see how
    the template gets its values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The template values come from a JavaScript object that we’re creating directly
    from the model. Backbone.js provided the `toJSON()` method, which returns a JavaScript
    object corresponding to the model’s attributes. We can actually pass any JavaScript
    object to the template, even one we create ourselves within the `render()` method.
    Let’s rewrite that method to provide a more user-friendly Summary view. We’ll
    take the model’s attributes one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: First is the date of the run. A date of “2013-04-09T10:54:33Z” isn’t very readable
    for average users, and it’s probably not even in their time zone. Working with
    dates and times is actually quite tricky, but the excellent Moment.js library
    (*[http://momentjs.com/](http://momentjs.com/)*) can handle all of the complexity.
    Since we added that library to our app in an earlier section, we can take advantage
    of it now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**In the interest of brevity, we’re cheating a little with the preceding code
    because it converts the UTC timestamp to the local time zone of the browser. It
    would probably be more correct to convert it to the time zone for the run, which
    Nike+ provides in the data.**'
  prefs: []
  type: TYPE_NORMAL
- en: Next up is the run’s duration. It’s doubtful that we need to show the fractions
    of seconds that Nike+ includes, so let’s simply drop them from the attribute.
    (It would be more precise to round up or down, but assuming our users are not
    Olympic athletes in training, a second here or there won’t matter. Besides, Nike+
    seems to always record these subsecond durations as “.000” anyway.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `distance` property can also use some adjustment. In addition to rounding
    it to a reasonable number of decimal places, we can convert from kilometers to
    miles for our US users. A single statement takes care of both.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `calories` property is fine as it is, so we’ll just copy it into our temporary
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if you’re an avid runner, you might have noticed that there’s an important
    value missing from the Nike+ attributes: the average pace for the run in minutes
    per mile. We have the data to calculate it, so let’s add that as well.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a new object to pass to the template.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We’ll also need to modify both templates to match the new markup. Here’s the
    updated template for SummaryRows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: And here’s the Summary template with the additional column for Pace.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a much-improved summary table for our users, shown in [Figure 9-4](ch09.html#improved_summary_table_with_cleaner-look
    "Figure 9-4. An improved summary table with cleaner-looking data").
  prefs: []
  type: TYPE_NORMAL
- en: '![An improved summary table with cleaner-looking data](figs/web/09fig04.png.jpg)Figure 9-4. An
    improved summary table with cleaner-looking data'
  prefs: []
  type: TYPE_NORMAL
- en: Views for Visualizations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve seen how to use Backbone.js views to separate data from its presentation,
    we can consider how to use the same approach for data visualizations. When the
    presentation is simple HTML markup—as in the previous section’s tables—it’s easy
    to use templates to view a model. But templates aren’t sophisticated enough to
    handle data visualizations, so we’ll need to modify our approach for those.
  prefs: []
  type: TYPE_NORMAL
- en: The data from the Nike+ service offers lots of opportunity for visualizations.
    Each run, for example, may include a record of the user’s heart rate, instantaneous
    pace, and cumulative distance, recorded every 10 seconds. Runs may also include
    the user’s GPS coordinates captured every second. That type of data lends itself
    to both charts and maps, and in this section, we’ll add both to our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Define the Additional Views'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we did in the previous section, we’ll rely on Yeoman to create the scaffolding
    for our additional views. One view, which we’ll call *Details*, will act as the
    overall view for the details of an individual run. Within that view, we’ll create
    three additional views, each showing a different aspect of the run. We can think
    of these views in a hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: '****Details****. A detailed view of a single run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****Properties****. The full set of properties associated with the run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****Chart****. Charts showing performance during the run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****Map****. A map of the run’s route'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To start the development of these views, we return to the command line and execute
    four Yeoman commands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 2: Implement the Details View'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Details view is really nothing more than a container for its three children,
    so its implementation is about as easy as it gets. We create a new view for each
    of the children, render the view, and add the resulting markup to the Details.
    Here is the complete code for this view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the previous views we’ve created, this view doesn’t have an `initialize()`
    method. That’s because the Details view doesn’t have to listen for changes to
    the model, so there’s nothing to do during initialization. In other words, the
    Details view itself doesn’t actually depend on any of the properties of the Run
    model. (The child views, on the other hand, depend greatly on those properties.)
  prefs: []
  type: TYPE_NORMAL
- en: The `render()` method itself first clears out any existing content from its
    element. This line makes it safe to call the `render()` method multiple times.
    The next three statements create each of the child views. Notice that all of the
    child views have the same model, which is the model for the Details view as well.
    This capability is the power of the model/view architecture; one data object—in
    our case, a run—can be presented in many different ways. While the `render()`
    method creates each of these child views, it also calls their `render()` methods,
    and it appends the resulting content (their `el` properties) into its own `el`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Implement the Properties View'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the Properties view, we want to show all of the properties that Nike+ has
    associated with the run. Those properties are determined by the data returned
    by the Nike+ service; here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: That data can certainly benefit from a bit of cleanup to make it more user-friendly.
    To do that we’ll take advantage of the Underscore.string library we added to the
    project before. We can make sure that library is available by “mixing it into”
    the main Underscore.js library. We’ll do that right at the start of the JavaScript
    file for the Properties view.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we’ve also added the global variable for Underscore.js (`_`) to
    the initial comment in the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most straightforward way to present this information in HTML is with a
    description list (`<dl>`). Each property can be an individual item in the list,
    with a description term (`<dt>`) holding the property name and the description
    data (`<dd>`) its value. To implement this, we set the `tagName` property of the
    view to be `"dl"`, and we create a generic list item template. Here’s the start
    of our Properties view code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: And here’s the simple template that the view will use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: A quick glance at the Nike+ data shows that it contains nested objects. The
    `metricSummary` property of the main object is itself an object. We need a function
    that will iterate through all the properties in the input object, building the
    HTML markup as it does. A recursive function can be particularly effective here,
    since it can call itself whenever it reaches another nested object. Next, we add
    an `obj2Html()` method to our view. At its core, this method will use the Underscore.js
    `reduce()` function, which is well suited to the task at hand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As we process each property, the first thing we can do is improve the key name.
    For example, we’d like to replace `startTime` with `Start Time`. That’s where
    Underscore.string comes in. Its `humanize()` function turns camelCase into separate
    words, and its `titleize()` function ensures that each word begins with an uppercase
    letter. We’ll use chaining to perform both operations in one statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Now we can consider the value. If it is an array, we’ll replace it with a string
    that shows the array length.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Next we check to see if the value is an object. If it is, then we’ll call the
    `obj2Html()` method recursively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: For other types, we convert the value to a string, format it a bit with Underscore.string,
    and make use of our template.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: There are a few other minor improvements we can make to the presentation, which
    you can find in the book’s source code. The last piece of the view is implementing
    the `render()` method. In that method, we use `toJSON()` to get an object corresponding
    to the Run model, and then we start the `obj2Html()` recursion with that object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The result is a complete picture of the properties of the run, shown in [Figure 9-5](ch09.html#completed_properties_view_shows_all_of_t
    "Figure 9-5. The completed Properties view shows all of the data associated with
    a run.").
  prefs: []
  type: TYPE_NORMAL
- en: '![The completed Properties view shows all of the data associated with a run.](figs/web/09fig05.png.jpg)Figure 9-5. The
    completed Properties view shows all of the data associated with a run.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Implement the Map View'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To show users maps of their runs, we rely on the Leaflet library from [Chapter 6](ch06.html
    "Chapter 6. Visualizing Geographic Data"). Using the library will require some
    small modifications to the normal Backbone.js view implementation, but, as we’ll
    see, those same modifications will come in handy for other views as well. Leaflet
    builds its maps in a containing element in the page (typically a `<div>`), and
    that containing element must have an `id` attribute so that Leaflet can find it.
    Backbone.js will take care of adding that `id` if we include an `id` property
    in the view. That’s easy enough.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'With `<div id="map"></div>` available in the page’s markup, we can create a
    Leaflet map with the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We might be tempted to do that directly in the view’s `render()` method, but
    there’s a problem with that approach. Adding (and removing) elements in a web
    page requires a lot of computation by the browser. When JavaScript code does that
    frequently, the performance of the page can suffer significantly. To reduce this
    problem, Backbone.js tries to minimize the number of times it adds (or removes)
    elements, and one way to do that is to add many elements at once rather than adding
    each element independently. It employs that approach when it implements a view’s
    `render()` method. Before adding any elements to the page, it lets the view finish
    constructing its entire markup; only then does it add that markup to the page.
  prefs: []
  type: TYPE_NORMAL
- en: The problem here is that when `render()` is called the first time, there won’t
    (yet) be a `<div id="map"></div>` anywhere in the page. If we call Leaflet, it
    won’t be able to find the container for its map, and it will generate an error.
    What we need to do is defer the part of `render()` that draws the map until after
    Backbone.js has added the map container to the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Underscore.js has a utility function called `defer()` to do just
    that. Instead of drawing the map directly in the `render()` method, we’ll create
    a separate method. Then, in the `render()` method, we’ll defer execution of that
    new method. Here’s what the code to do that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we’re actually using a couple of Underscore.js functions in
    our `render()` method. In addition to `defer()`, we also take advantage of `bind()`.
    The latter function ensures that the `this` value when `drawMap()` is eventually
    called is the same as the `this` value within the view.
  prefs: []
  type: TYPE_NORMAL
- en: There’s one change we can make to further improve this implementation. Although
    there won’t be a `<div id="map"></div>` in the page when `render()` is first called,
    that element will exist in subsequent calls to `render()`. In those cases, we
    don’t need to defer the execution of `drawMap()`. That leads to the following
    code for our `render()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'As long as we’re making optimizations, let’s also change the `initialize()`
    method slightly. The default method that Yeoman creates is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: For the Map view, however, we don’t really care if any property of the Run model
    changes. The only property the view needs is `gps`, so we can tell Backbone. js
    to bother us only if that specific property changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be wondering, “Why would the `gps` property of the Run model ever
    change?” I’ll get to that when I cover the quirks of the Nike+ REST API in [Chapter 10](ch10.html
    "Chapter 10. Building Data-Driven Web Applications: Part 2").'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the preliminaries out of the way, we can implement the `drawMap()` function,
    which turns out to be a very easy implementation. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the model has a `gps` property and there are waypoints associated
    with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If an old map exists, remove it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the GPS coordinates from the waypoints array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a path using those coordinates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a map that contains that path, and draw the path on the map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the map tiles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resulting code is a straightforward implementation of those steps.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the code, we’re storing a reference to the Leaflet map object
    as a property of the view. From within the view, we can access that object using
    `this.map`.
  prefs: []
  type: TYPE_NORMAL
- en: The result is a nice map of the run’s route, shown in [Figure 9-6](ch09.html#map_view_shows_the_route_of_a_run
    "Figure 9-6. A map view shows the route of a run.").
  prefs: []
  type: TYPE_NORMAL
- en: '![A map view shows the route of a run.](figs/web/09fig06.png.jpg)Figure 9-6. A
    map view shows the route of a run.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: Implement the Charts View'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last remaining view that we need to implement is the Charts view, where
    we want to show pace, heart rate, and elevation during the run. This view is the
    most complex, but nearly all of the code is identical to the example in [Tracking
    Data Values](ch02.html#tracking_data_values "Tracking Data Values"), so there’s
    no need to repeat it here.
  prefs: []
  type: TYPE_NORMAL
- en: You can see the interactive result in [Figure 9-7](ch09.html#alternative_view_shows_charts_of_the_run
    "Figure 9-7. An alternative view shows charts of the run.").
  prefs: []
  type: TYPE_NORMAL
- en: '![An alternative view shows charts of the run.](figs/web/09fig07.png.jpg)Figure 9-7. An
    alternative view shows charts of the run.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for the book includes the complete implementation. If you’re
    looking in detail at that implementation, there a few points to note:'
  prefs: []
  type: TYPE_NORMAL
- en: Just as with Leaflet and the map container, Flot expects a container for its
    chart to be present in the web page. We can use the same `defer` trick to prevent
    Flot errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nike+ returns at least four types of charts as metrics: distance, heart rate,
    speed, and GPS signal strength. We really only care about the first two. At first,
    it might seem easiest to calculate pace from speed, but speed isn’t present in
    all activities. Distance, however, is present, and we can derive pace from distance
    and time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If GPS waypoint data is available, we can also graph elevation, but that data
    is in a separate attribute of the model (not the `metrics` attribute).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As of this writing, there’s a bit of a bug in Nike’s response for GPS data.
    It claims that the measurements are on the same time scale as the other metrics
    (every 10 seconds), but in fact the GPS measurements are reported on different
    intervals. To work around this bug, we ignore the reported interval and calculate
    one ourselves. Also, we want to normalize the elevation graph to the same time
    scale as all the others. Doing that will give us the additional benefit of averaging
    the GPS elevation data; averaging is useful here because GPS elevation measurements
    aren’t generally very accurate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summing Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we’ve starting building an entire web application based on
    data and data visualizations. To help organize and coordinate our application,
    we based it on the Backbone.js library, and we relied on the Yeoman tool to create
    the application’s scaffolding and boilerplate code and templates. Backbone.js
    lets us separate our application into models and views so that the code responsible
    for managing the data doesn’t have to worry about how that data is presented (and
    vice versa).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll enable our application to communicate with the Nike+
    interface, and we’ll add some finishing touches to improve user interaction with
    the page.
  prefs: []
  type: TYPE_NORMAL
