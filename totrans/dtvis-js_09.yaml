- en: 'Chapter 9. Building Data-Driven Web Applications: Part 1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章：构建数据驱动的网页应用：第一部分
- en: 'So far we’ve had a chance to see many of the tools and libraries for creating
    individual JavaScript visualizations, but we’ve considered them only in the context
    of a traditional web page. Today, of course, the Web is much more than traditional
    web pages. Especially on desktop computers, websites are effectively full-featured
    software applications. (Even on mobile devices many “apps” are really just websites
    enclosed in a thin wrapper.) When a web application is structured around data,
    there’s a good chance it can benefit from data visualizations. That’s exactly
    what we’ll consider in this final project: how to integrate data visualization
    into a true web application.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有机会了解了许多用于创建独立JavaScript可视化的工具和库，但我们仅在传统网页的上下文中考虑了它们。当然，今天的Web已经不再仅仅是传统网页，尤其在桌面计算机上，网站实际上是功能齐全的软件应用。（即便在移动设备上，许多“应用”实际上也是封装在一个薄外壳中的网站。）当一个网页应用围绕数据进行结构化时，它很可能可以从数据可视化中受益。正是我们将在这个最终项目中考虑的内容：如何将数据可视化集成到真正的网页应用中。
- en: The sections that follow will walk through the development of an example application
    driven by data. The source of the data will be Nike’s Nike+ (*[http://nikeplus.com/](http://nikeplus.com/)*)
    service for runners. Nike sells many products and applications that let runners
    track their activities and save the results for analysis and review. In this chapter
    and the next, we’ll build a web application to retrieve that data from Nike and
    present it to a user. Nike, of course, has its own web app for viewing Nike+ data,
    and that app is far superior to the simple example here. We’re certainly not trying
    to compete with Nike; rather, we’re just using the Nike+ service to structure
    our example.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将逐步讲解如何开发一个由数据驱动的示例应用。数据的来源将是Nike的Nike+（*[http://nikeplus.com/](http://nikeplus.com/)）*
    跑步者服务。Nike销售许多产品和应用，允许跑步者跟踪他们的活动，并保存结果以供分析和回顾。在本章及下一章中，我们将构建一个网页应用，从Nike获取数据并呈现给用户。当然，Nike也有自己的网页应用来查看Nike+数据，而那个应用远远优于我们这里的简单示例。我们并不是要与Nike竞争；我们只是利用Nike+服务来构建我们的示例。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**This sample project is based on the version of the interface at the time
    of this writing. There may have been changes to the interface since then.**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**本示例项目基于本文撰写时的接口版本。此后接口可能已发生变化。**'
- en: 'Unlike most other chapters, this chapter won’t include multiple independent
    examples. Instead, it will walk through the main stages in the development and
    testing of a single data-driven application. We’ll see how to build up the basic
    structure and functionality of the web application. This includes the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他章节不同，本章不会包括多个独立的示例。相反，本章将通过开发和测试单个数据驱动应用的主要阶段来进行讲解。我们将看到如何构建网页应用的基本结构和功能。这包括以下内容：
- en: How to structure a web application using a framework or library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用框架或库来构建一个网页应用
- en: How to organize an application into models and views
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将一个应用程序组织为模型和视图
- en: How to incorporate visualizations in views
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在视图中嵌入可视化内容
- en: 'In [Chapter 10](ch10.html "Chapter 10. Building Data-Driven Web Applications:
    Part 2"), we’ll focus on some of the finer details by dealing with several quirks
    of the Nike+ interface and adding some finishing touches to round out the single-page
    application.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](ch10.html "第10章：构建数据驱动的网页应用：第二部分")中，我们将专注于一些更细微的细节，处理Nike+界面的一些特殊情况，并为单页面应用添加一些完善的细节。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**To use the Nike+ data in an actual product, you must register your application
    with Nike and get the necessary credentials and security keys. That process also
    grants you access to the full documentation for the service, which is not publicly
    available. Since we’re not building a real application in this example, we won’t
    cover that step. We will, however, base the application on the Nike+ API, which
    is documented publicly on Nike’s developer website (***[https://developer.nike.com/index.html](https://developer.nike.com/index.html)***).
    Because the example doesn’t include the credentials and security keys, it won’t
    be able to access the real Nike+ service. The book’s source code, however, does
    include actual Nike+ data that can be used to emulate the Nike+ service for testing
    and development.**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**要在实际产品中使用Nike+数据，你必须向Nike注册你的应用并获取必要的凭证和安全密钥。这个过程还会让你访问该服务的完整文档，而这些文档并未公开。由于我们在这个示例中并未构建一个真实的应用，因此我们不会涉及这一步。然而，我们将基于Nike+
    API来构建应用，该API在Nike的开发者网站上有公开文档（***[https://developer.nike.com/index.html](https://developer.nike.com/index.html)***）。由于示例中没有包括凭证和安全密钥，它将无法访问真实的Nike+服务。然而，本书的源代码中确实包含了实际的Nike+数据，可以用于模拟Nike+服务进行测试和开发。**'
- en: Frameworks and Libraries
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架与库
- en: If we’re using JavaScript to add data visualizations to traditional web pages,
    we don’t have to worry too much about organizing and structuring our JavaScript.
    After all, it’s often a relatively small amount of code, especially compared to
    the HTML markup and CSS styles that are also part of the page. With web applications,
    however, the code can grow to be more extensive and more complex. To help keep
    our code organized and manageable, we’ll take advantage of a JavaScript application
    library, also called a *framework*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用JavaScript为传统网页添加数据可视化，我们不需要太担心如何组织和结构化我们的JavaScript。毕竟，它通常是一小段代码，尤其是与HTML标记和CSS样式相比，这些内容也是页面的一部分。然而，对于Web应用，代码可能会变得更加庞大和复杂。为了帮助保持代码的组织性和可管理性，我们将利用JavaScript应用库，也称为*框架*。
- en: 'Step 1: Select an Application Library'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步：选择一个应用库
- en: Deciding to use an application library might be easier than deciding which one
    to use. The number of these libraries has exploded in the past few years; there
    are now over 30 high-quality libraries from which to choose. A good place to see
    all the alternatives is TodoMVC (*[http://todomvc.com/](http://todomvc.com/)*),
    which shows how to implement a simple to-do application in each library.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 决定使用哪个应用库可能比决定使用哪一个更容易。在过去几年里，这些库的数量激增；现在有超过30个高质量的库可以选择。一个查看所有替代品的好地方是TodoMVC
    (*[http://todomvc.com/](http://todomvc.com/)*)，它展示了如何在每个库中实现一个简单的待办事项应用。
- en: 'There is an important question to ask that can help you narrow down the choices:
    is an application library a *pure library* or an *application framework*? Those
    terms are often used interchangeably, but there is a significant distinction.
    A pure library functions like jQuery or other libraries we’ve used throughout
    this book. It provides a set of tools for our application, and we can use as many—or
    as few—of those tools as we like. An application framework, on the other hand,
    dictates exactly how the application should work. The code that we write must
    follow the strictures and conventions of the framework. Fundamentally, the difference
    is about control. With a pure library, our code is in control and the library
    is at our disposal. With a framework, the framework code is in control, and we
    simply add the code that makes our application unique.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的问题需要问，这个问题可以帮助你缩小选择范围：一个应用库是*纯库*还是*应用框架*？这两个术语经常互换使用，但实际上有很大的区别。纯库的功能类似于jQuery或本书中我们使用过的其他库。它为我们的应用提供了一组工具，我们可以根据需要使用其中的任意多或任意少的工具。另一方面，应用框架则严格规定了应用的工作方式。我们编写的代码必须遵循框架的结构和约定。根本上，这种区别在于控制权。使用纯库时，我们的代码掌控一切，库只是我们的工具；而使用框架时，框架的代码掌控一切，我们仅仅是添加使应用独特的代码。
- en: 'The main advantage of a pure library is flexibility. Our code is in control
    of the application, and we have full latitude to structure the application to
    our own requirements. That’s not always a good thing, however. The constraints
    of a framework can protect us from making poor design decisions. Some of the world’s
    best JavaScript developers are responsible for the popular frameworks, and they’ve
    put a lot of thought into what makes a good web application. There’s another benefit
    to frameworks: because the framework assumes more responsibility for the application,
    there’s generally less code we’re required to write.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 纯库的主要优势是灵活性。我们的代码控制着应用程序，我们有充分的自由来根据自己的需求结构化应用程序。然而，这并不总是好事。框架的约束可以保护我们避免做出不良的设计决策。世界上一些最顶尖的JavaScript开发人员负责着流行的框架，他们在设计一个好的网页应用程序方面做了大量的思考。框架还有一个好处：因为框架承担了更多的应用程序责任，通常我们需要编写的代码较少。
- en: It’s worth noting this distinction between frameworks and pure libraries, but
    almost any web application can be built effectively with either. Both approaches
    provide the organization and structure necessary for a high-quality application.
    For our example, we’ll use the Backbone.js (*[http://backbonejs.org/](http://backbonejs.org/)*)
    library. It is by far the most popular of the pure (nonframework) libraries, and
    it’s used by dozens of the largest sites on the Web. The general approach that
    we’ll follow, however (including tools such as Yeoman), works well with almost
    any popular application library.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，框架与纯库之间的区别，但几乎任何网页应用程序都可以通过两者中的任何一种有效构建。两种方法都提供了构建高质量应用程序所需的组织和结构。对于我们的示例，我们将使用Backbone.js
    (*[http://backbonejs.org/](http://backbonejs.org/)*) 库。它迄今为止是最受欢迎的纯（非框架）库，并且被数十个最大的网页站点使用。然而，我们将遵循的一般方法（包括工具如Yeoman）适用于几乎所有流行的应用程序库。
- en: 'Step 2: Install Development Tools'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤2：安装开发工具
- en: When you start building your first real web application, deciding how to begin
    can be a bit intimidating. One tool that can be a big help at this stage is Yeoman
    (*[http://yeoman.io/](http://yeoman.io/)*), which describes itself as “The Web’s
    Scaffolding Tool for Modern Webapps.” That’s a pretty accurate description. Yeoman
    can define and initialize a project structure for a large number of different
    web application frameworks, including Backbone.js. As we’ll see, it also sets
    up and configures most of the other tools we’ll need during the application’s
    development.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始构建第一个真正的网页应用程序时，决定从哪里开始可能会有些让人畏惧。在这个阶段，一个很有帮助的工具是Yeoman (*[http://yeoman.io/](http://yeoman.io/)*)，它自称为“现代网页应用的搭建工具”。这个描述相当准确。Yeoman可以为大量不同的网页应用框架（包括Backbone.js）定义并初始化项目结构。正如我们所见，它还设置并配置了在应用程序开发过程中需要的其他大部分工具。
- en: Before we can use Yeoman, we must first install Node.js (*[http://nodejs.org/](http://nodejs.org/)*).
    Node.js is a powerful application development platform all by itself, but we won’t
    need to worry about the details here. It is, however, the application platform
    required by many modern web development tools like Yeoman. To install Node.js,
    follow the instructions on its website (*[http://nodejs.org/](http://nodejs.org/)*).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能使用Yeoman之前，必须先安装Node.js (*[http://nodejs.org/](http://nodejs.org/)*)。Node.js本身是一个强大的应用程序开发平台，但在这里我们不需要关心其细节。然而，它是许多现代网页开发工具（如Yeoman）所要求的应用平台。要安装Node.js，请按照其网站上的说明进行操作
    (*[http://nodejs.org/](http://nodejs.org/)*).
- en: With Node.js installed, we can install the main Yeoman application as well as
    everything necessary to create a Backbone.js application (*[https://github.com/yeoman/generator-backbone/](https://github.com/yeoman/generator-backbone/)*)
    with one command.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了Node.js后，我们可以使用一个命令安装主要的Yeoman应用程序以及创建Backbone.js应用程序所需的一切 (*[https://github.com/yeoman/generator-backbone/](https://github.com/yeoman/generator-backbone/)*)
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can execute this command in the Terminal app (on Mac OS X) or from the Windows
    command prompt.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在终端应用程序（在Mac OS X上）或Windows命令提示符下执行此命令。
- en: 'Step 3: Define a New Project'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤3：定义新项目
- en: The development tools we just installed will make it easy to create a new web
    app project. First, with the following commands, we create a new folder (named
    *running*) for our application and then `cd` (change directory) into that folder.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚安装的开发工具将使创建一个新的网页应用项目变得容易。首先，通过以下命令，我们为我们的应用创建一个新的文件夹（命名为*running*），然后使用`cd`（更改目录）进入该文件夹。
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From within that new folder, executing the command `yo backbone` will initialize
    the project structure.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在该新文件夹中，执行命令`yo backbone`将初始化项目结构。
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As part of the initialization, Yeoman will ask for permission to send diagnostic
    information (mainly which frameworks and features our app uses) back to the Yeoman
    developers. It will then give us a choice to add a few more tools to the app.
    For our example, we’ll skip any of the suggested options.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作为初始化的一部分，Yeoman将请求许可，向Yeoman开发者发送诊断信息（主要是我们的应用程序使用了哪些框架和功能）。然后，它会给我们一个选择，是否将一些额外的工具添加到应用程序中。对于我们的示例，我们将跳过任何建议的选项。
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Yeoman will then do its magic, creating several subfolders, installing extra
    tools and applications, and setting up reasonable defaults. As you watch all the
    pages and pages of installation information scroll by in your window, you can
    be glad that Yeoman is doing all this work for you. When Yeoman finishes, you’ll
    have a project structure like the one shown in [Figure 9-1](ch09.html#yeoman_creates_a_default_project_structu
    "Figure 9-1. Yeoman creates a default project structure for a web application.").
    It may not look exactly like the figure here, since web applications may have
    changed since this text was written, but rest assured that it will follow the
    best practices and conventions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Yeoman会进行魔法操作，创建几个子文件夹，安装额外的工具和应用程序，并设置合理的默认值。当你看到所有安装信息在窗口中滚动时，可以高兴地知道Yeoman正在为你做所有这些工作。当Yeoman完成时，你将拥有一个像[图9-1](ch09.html#yeoman_creates_a_default_project_structu
    "图9-1. Yeoman为Web应用程序创建一个默认的项目结构")中所示的项目结构。虽然它可能不会完全像这里的图示一样，因为自从这段文字写成以来，Web应用程序可能已经发生了变化，但可以放心，它会遵循最佳实践和规范。
- en: '![Yeoman creates a default project structure for a web application.](figs/web/09fig01.png.jpg)Figure 9-1. Yeoman
    creates a default project structure for a web application.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![Yeoman为Web应用程序创建一个默认的项目结构。](figs/web/09fig01.png.jpg)图9-1. Yeoman为Web应用程序创建一个默认的项目结构。'
- en: We’ll spend more time with most of these files and folders in the sections that
    follow, but here’s a quick overview of the project that Yeoman has set up for
    us.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将花更多时间处理这些文件和文件夹，但这里是Yeoman为我们设置的项目的快速概览。
- en: '**app/**. The folder that will contain all the code for our app'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**app/**。一个包含我们应用程序所有代码的文件夹'
- en: '**bower.json**. A file that keeps track of all the third-party libraries our
    app uses'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**bower.json**。一个用于跟踪我们的应用程序使用的所有第三方库的文件'
- en: '**gruntfile.js**. A file that controls how to test and build our app'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gruntfile.js**。一个控制如何测试和构建我们应用程序的文件'
- en: '**node_modules/**. A folder that contains the tools used to build and test
    our app'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**node_modules/**。一个包含构建和测试我们应用程序所需工具的文件夹'
- en: '**package.json**. A file that identifies the tools used to build and test our
    app'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**package.json**。一个标识用于构建和测试我们应用程序的工具的文件'
- en: '**test/**. A folder that will contain the code we’ll write to test our app'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**test/**。一个包含我们为测试应用程序而编写代码的文件夹'
- en: At this point Yeoman has set up a complete web app (albeit one that doesn’t
    do anything). You can execute the command `grunt serve` from the command prompt
    to see it in a browser.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，Yeoman已经设置了一个完整的Web应用程序（尽管它没有任何功能）。你可以从命令提示符执行`grunt serve`命令，在浏览器中查看它。
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `grunt` command runs one of the tools that’s part of the Yeoman package.
    When passed the `serve` option, it cleans up the application folder, starts a
    web server to host the application, launches a web browser, and navigates to the
    skeleton app. You’ll see something like [Figure 9-2](ch09.html#default_yeoman_web_application_runs_in_t
    "Figure 9-2. The default Yeoman web application runs in the browser.") in your
    browser.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`grunt`命令运行Yeoman包中的一个工具。传递`serve`选项时，它会清理应用程序文件夹，启动一个Web服务器来托管应用程序，打开一个Web浏览器并导航到骨架应用程序。你将在浏览器中看到类似于[图9-2](ch09.html#default_yeoman_web_application_runs_in_t
    "图9-2. 默认的Yeoman Web应用程序在浏览器中运行")的内容。'
- en: '![The default Yeoman web application runs in the browser.](figs/web/09fig02.png.jpg)Figure 9-2. The
    default Yeoman web application runs in the browser.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![默认的Yeoman Web应用程序在浏览器中运行。](figs/web/09fig02.png.jpg)图9-2. 默认的Yeoman Web应用程序在浏览器中运行。'
- en: Congratulations! Our web app, as basic as it is, is now running.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们的Web应用程序，虽然非常基础，但现在已经在运行了。
- en: 'Step 4: Add Our Unique Dependencies'
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步：添加我们独特的依赖项
- en: Yeoman sets up sensible defaults and tools for a new app, but our app needs
    a few JavaScript libraries that aren’t part of those defaults, such as Leaflet
    for maps and Flot for charts. The Moment.js (*[http://momentjs.com/](http://momentjs.com/)*)
    library for dealing with dates and times will also come in handy, as will the
    Underscore.string (*[http://epeli.github.io/underscore.string/](http://epeli.github.io/underscore.string/)*)
    library. We can add these libraries to our project with some simple commands.
    The `--save` option tells the bower tool (which is part of the Yeoman package)
    to remember that our project depends on these libraries.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Yeoman 为新应用程序设置了合理的默认设置和工具，但我们的应用程序需要一些不在默认设置中的 JavaScript 库，例如用于地图的 Leaflet
    和用于图表的 Flot。用于处理日期和时间的 Moment.js (*[http://momentjs.com/](http://momentjs.com/)*)
    库也会派上用场，Underscore.string (*[http://epeli.github.io/underscore.string/](http://epeli.github.io/underscore.string/)*)
    库也是如此。我们可以通过一些简单的命令将这些库添加到我们的项目中。`--save` 选项会告诉 bower 工具（它是 Yeoman 包的一部分）记住我们的项目依赖这些库。
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Perhaps you’ve already begun to appreciate how tools like Yeoman make development
    easier. The simple commands shown here save us from having to find the libraries
    on the Web, download the appropriate files, copy them to the right place in our
    project, and so on.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你已经开始体会到像 Yeoman 这样的工具如何简化开发。这里展示的简单命令让我们免去了在网上寻找库、下载相应的文件、将它们复制到项目中的正确位置等繁琐工作。
- en: Even more importantly, Yeoman (technically, the bower tool) automatically takes
    care of any additional libraries on which these libraries depend. The Flot library,
    for example, requires jQuery. When Yeoman installs Flot, it will also check and
    make sure that jQuery is installed in the project. In our case, it is because
    Backbone.js depends on it, but if jQuery weren’t already installed, Yeoman would
    automatically find it and install it as well.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，Yeoman（严格来说是 bower 工具）会自动处理这些库所依赖的任何其他库。例如，Flot 库依赖 jQuery。当 Yeoman 安装
    Flot 时，它还会检查并确保 jQuery 已安装在项目中。在我们的例子中，它已经安装，因为 Backbone.js 依赖于它，但如果 jQuery 尚未安装，Yeoman
    会自动找到并安装它。
- en: 'For most libraries, bower can completely install all the necessary components
    and files. In the case of Leaflet, however, we need to perform a few extra steps.
    Change directory to the *leaflet* folder within *app/bower_components*. From there,
    run two commands to install the unique tools that Leaflet requires:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数库，bower 可以完全安装所有必要的组件和文件。然而，对于 Leaflet，我们需要执行一些额外的步骤。将目录更改为 *leaflet* 文件夹，该文件夹位于
    *app/bower_components* 中。从那里运行两个命令，安装 Leaflet 所需的独特工具：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Executing the command `jake` will then run all of Leaflet’s tests and, provided
    they pass, create a Leaflet.js library for our app.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令 `jake` 将运行所有 Leaflet 的测试，如果通过测试，将为我们的应用程序创建一个 Leaflet.js 库。
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'All that’s left to do is add the other libraries into our HTML files. That’s
    easy enough. The main page for our app is *index.html* in the *app* folder. There’s
    already a block of code that includes jQuery, Underscore.js, and Backbone.js:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是将其他库添加到我们的 HTML 文件中。这很简单。我们应用程序的主页是 *index.html*，位于 *app* 文件夹中。已经有一块包含
    jQuery、Underscore.js 和 Backbone.js 的代码：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can add our new libraries after Backbone.js.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Backbone.js 后添加我们的新库。
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Leaflet, as we saw in [Chapter 6](ch06.html "Chapter 6. Visualizing Geographic
    Data"), also requires its own style sheet. We add that to the top of *index.html*
    just before *main.css*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [第 6 章](ch06.html "第 6 章。可视化地理数据") 中看到的，Leaflet 还需要自己的样式表。我们将其添加到 *index.html*
    文件的顶部，位于 *main.css* 之前。
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that we’ve set up the structure of our app and installed the necessary libraries,
    it’s time to start development.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了应用程序的结构并安装了必要的库，是时候开始开发了。
- en: Models and Views
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型和视图
- en: There are many application libraries available for web apps, and each has its
    quirks, but most of the libraries agree on the key principles that should guide
    an app’s architecture. Perhaps the most fundamental of those principles is separating
    *models* from *views.* The code that keeps track of the core data for the app
    (the models) should be separate from the code that presents that data to the user
    (the views). Enforcing this separation makes it easier to update and modify either.
    If you want to present your data in a table instead of a chart, you can do that
    without any changes to the models. And if you need to change your data source
    from a local file to a REST API, you can do that without any changes to the views.
    We’ve been employing this principle in an informal way throughout the book. In
    all of the examples, we’ve isolated the steps required to obtain and format our
    data from the steps we used to visualize it. Using an application library like
    Backbone.js gives us the tools to manage models and views more explicitly.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多适用于 Web 应用的应用程序库，每个库都有其独特之处，但大多数库在应用架构的关键原则上是达成共识的。也许最基本的原则是将*模型*与*视图*分开。用于跟踪应用核心数据（模型）的代码应该与展示这些数据给用户（视图）的代码分开。强制这种分离可以更容易地更新和修改它们。如果你想用表格而不是图表来展示数据，你可以在不改变模型的情况下做到这一点。如果你需要将数据源从本地文件更改为
    REST API，也可以在不修改视图的情况下做到这一点。在本书中，我们一直以非正式的方式运用这一原则。在所有示例中，我们都将获取和格式化数据的步骤与可视化数据的步骤隔离开来。使用像
    Backbone.js 这样的应用库为我们提供了更明确管理模型和视图的工具。
- en: 'Step 1: Define the Application’s Models'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 1：定义应用的模型
- en: Our running app is designed to work with Nike+, which provides details about
    runs—training runs, interval workouts, trail runs, races, and so on. The data
    set we want consists of nothing but runs, so our app’s core model is, naturally,
    a run.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的运行应用被设计为与 Nike+ 配合使用，Nike+ 提供关于跑步的详细信息——训练跑、间歇训练、越野跑、比赛等。我们想要的数据集只包含跑步，因此我们应用的核心模型自然是跑步。
- en: The Yeoman tool makes it very easy to define a model for our app. A simple command
    defines a new model and creates the JavaScript files and scaffolding for that
    model.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Yeoman 工具使得为我们的应用定义模型变得非常简单。一个简单的命令就可以定义一个新模型，并为该模型创建 JavaScript 文件和脚手架。
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'That command creates two new files: *run.js* in the *app/scripts/models/* folder
    and *run.spec.js* in the *test/* folder. Let’s take a look at the file Yeoman
    created for our model. It’s quite short.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会创建两个新文件：在 *app/scripts/models/* 文件夹中的 *run.js* 和在 *test/* 文件夹中的 *run.spec.js*。让我们来看看
    Yeoman 为我们的模型创建的文件。它相当简短。
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At ➊ is a comment that lists the global variables our model requires. In this
    case there are only two: `Running` (that’s our app) and `Backbone`. Next, at ➋,
    this file creates a `.Models` property of the `Running` object unless that property
    already exists.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处是一个注释，列出了我们的模型所需的全局变量。在这种情况下，只有两个变量：`Running`（即我们的应用）和 `Backbone`。接下来，在
    ➋ 处，如果 `Running` 对象尚未具有 `.Models` 属性，文件会创建该属性。
- en: When the browser encounters this line, it will check to see if `Running.Models`
    exists. If it does, then `Running.Models` won’t be `false`, and the browser never
    has to consider the second clause of the logical *or* (`||`). The statement simply
    assigns `Running.Models` to itself, so it has no practical effect. If `Running.Models`
    does not exist, however, then it evaluates to `false`, and the browser will continue
    to the second clause, where it assigns an empty object (`{}`) to `Running.Models`.
    Ultimately, this statement makes sure that the object `Running.Models` exists.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器遇到这一行时，它会检查 `Running.Models` 是否存在。如果存在，那么 `Running.Models` 就不会是 `false`，浏览器就不需要考虑逻辑*或*（`||`）的第二个条件。该语句只是将
    `Running.Models` 赋值给它自己，因此没有实际效果。然而，如果 `Running.Models` 不存在，那么它会被评估为 `false`，浏览器会继续执行第二个条件，并将一个空对象（`{}`）赋值给
    `Running.Models`。最终，这条语句确保了 `Running.Models` 对象的存在。
- en: The rest of the code in the file is enclosed within an *immediately invoked
    function expression.* If you haven’t seen this pattern before, it may look a little
    strange.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的其余代码被封装在一个*立即执行的函数表达式*中。如果你之前没有见过这种模式，它可能看起来有点奇怪。
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we rewrite the block as a single line, though, it might be easier to understand.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们将这段代码重写成一行，它可能会更容易理解。
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The statement defines a JavaScript function with a function expression, `function
    () { /* ... */ }`, and then, with the concluding `()`, it calls (technically *invokes*)
    that newly created function. All we’re really doing, therefore, is putting our
    code inside a function and calling that function. You’ll see this pattern a lot
    in professional JavaScript because it protects a block of code from interfering
    with other code blocks in the application.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句定义了一个JavaScript函数，使用函数表达式`function () { /* ... */ }`，然后通过结尾的`()`调用（技术上是*调用*）这个新创建的函数。因此，我们真正做的事情就是把代码放进一个函数里，并调用该函数。在专业的JavaScript中，你会经常看到这种模式，因为它可以保护一段代码不与应用程序中的其他代码块相互干扰。
- en: When you define a variable in JavaScript, it is a *global* variable, available
    everywhere in the code. As a consequence, if two different sections of code try
    to define the same global variable, those definitions will clash. This interaction
    can cause bugs that are very hard to find, as code in one section inadvertently
    interferes with code in a completely different section. To prevent this problem,
    we can avoid using global variables, and the easiest way to do that in JavaScript
    is to define our variables inside a function. That’s the purpose of an immediately
    invoked function expression. It makes sure that any variables our code defines
    are *local* to the function rather than global, and it prevents our code blocks
    from interfering with one another.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在JavaScript中定义一个变量时，它是一个*全局*变量，代码中的任何地方都可以访问。因此，如果两段不同的代码尝试定义相同的全局变量，这些定义就会发生冲突。这种交互可能会导致很难发现的BUG，因为一段代码无意中干扰了完全不同的另一段代码。为了防止这个问题，我们可以避免使用全局变量，而在JavaScript中避免使用全局变量的最简单方法就是将变量定义在函数内部。这就是立即调用函数表达式的目的。它确保我们代码中定义的任何变量都是*局部*的，而不是全局的，并且避免了不同代码块之间的相互干扰。
- en: 'Step 2: Implement the Model'
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤2：实现模型
- en: 'Our application really only needs this one model, and it’s already complete!
    That’s right: the scaffolding that Yeoman has set up for us is a complete and
    functioning model for a run. In fact, if it weren’t for some quirks in Nike’s
    REST API, we wouldn’t have to touch the model code at all. We’ll address those
    quirks in [Chapter 10](ch10.html "Chapter 10. Building Data-Driven Web Applications:
    Part 2").'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用实际上只需要这一模型，它已经是完整的了！没错：Yeoman为我们设置的脚手架是一个完整且功能齐全的运行模型。事实上，如果不是Nike的REST
    API存在一些特殊情况，我们根本不需要修改模型代码。我们将在[第10章](ch10.html "第10章：构建数据驱动的Web应用：第二部分")中讨论这些特殊情况。
- en: Before we move on to the next step, though, let’s look at what we can do with
    our newly created model. To do that we’ll make a temporary addition to the model
    code. We won’t use the following code in the final app; it’s only meant to show
    off what our model can already do.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在继续下一步之前，让我们看一下我们新创建的模型可以做些什么。为此，我们将在模型代码中临时添加一些内容。我们在最终的应用中不会使用以下代码；它只是用来展示我们的模型已经可以做些什么。
- en: First, let’s add the URL to retrieve details about a run (Nike+ uses the more
    general term *activity*). From the Nike+ documentation, we find that this URL
    is *[https://api.nike.com/v1/me/sport/activities/<activityId>](https://api.nike.com/v1/me/sport/activities/<activityId>)*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加一个URL来检索跑步的详细信息（Nike+使用更通用的术语*活动*）。从Nike+文档中，我们发现这个URL是*[https://api.nike.com/v1/me/sport/activities/<activityId>](https://api.nike.com/v1/me/sport/activities/<activityId>)*。
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The final part of the URL depends on the specific activity, so here we add only
    the general part of the URL to our model (➊).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: URL的最后部分取决于具体的活动，因此这里我们只将URL的一般部分添加到我们的模型中（➊）。
- en: Now imagine that we want to get the details for a specific run from the Nike+
    service. The run in question has a unique identifier of `2126456911`. If the Nike+
    API followed typical conventions, we could create a variable representing that
    run, *and get all its data*, with the hypothetical two statements that follow.
    (We’ll consider the quirks of the actual Nike+ interface in Step 7 of [Connecting
    with the Nike+ Service](ch10.html#connecting_with_the_nikeplus_service "Connecting
    with the Nike+ Service").)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想从Nike+服务中获取特定跑步的详细信息。该跑步的唯一标识符是`2126456911`。如果Nike+ API遵循典型的约定，我们可以使用以下假设的两个语句，创建一个代表该跑步的变量，并*获取它的所有数据*。（我们将在[连接Nike+服务](ch10.html#connecting_with_the_nikeplus_service
    "连接Nike+服务")的第7步中考虑实际Nike+接口的特殊情况。）
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Since many APIs *do* follow typical conventions, it’s worth spending some time
    understanding how that code works. The first statement creates a new instance
    of the Run model and specifies its identifier. The second statement tells Backbone
    to retrieve the model’s data from the server. Backbone will take care of all the
    communication with Nike+, including error handling, time-outs, parsing the response,
    and so on. Once the fetch completes, detailed information from that run will be
    available from the model. If we provide a callback function, we could output some
    of the details. Here’s an example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多API确实遵循典型的约定，因此花些时间理解这些代码的工作方式是值得的。第一条语句创建一个新的Run模型实例，并指定其标识符。第二条语句告诉Backbone从服务器检索模型的数据。Backbone将处理所有与Nike+的通信，包括错误处理、超时、解析响应等。一旦获取完成，来自该跑步的详细信息将可以从模型中获取。如果我们提供一个回调函数，我们可以输出一些细节。这里是一个示例：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output in the browser’s console would be the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器控制台中的输出将是以下内容：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Not bad for a few simple lines of code! The code in this step, though, is really
    just a detour. Our application won’t use individual models in this way. Instead,
    we’ll use an even more powerful Backbone.js feature: collections.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这几行简单的代码还不错！不过，这一步中的代码其实只是绕道而行。我们的应用程序不会以这种方式使用单独的模型。相反，我们将使用一个更强大的Backbone.js功能：集合。
- en: 'Step 3: Define the Application’s Collections'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步：定义应用程序的集合
- en: The model we created is designed to capture the data for a single run. Our users,
    however, aren’t interested in just a single run. They’d like to see all of their
    runs—dozens, hundreds, possibly thousands of them. We can handle all of these
    runs with a *collection*, or group of models. The collection is one of the core
    concepts of Backbone.js, and it will be a big help for our app. Let’s define a
    collection for all of the user’s runs.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的模型是用来捕获单次跑步的数据。然而，我们的用户并不只对单次跑步感兴趣。他们希望看到所有的跑步记录——几十个、上百个，甚至可能成千上万。我们可以通过一个*集合*（或模型的组）来处理所有这些跑步记录。集合是Backbone.js的核心概念之一，它将大大有助于我们的应用程序。让我们定义一个集合来存储所有用户的跑步记录。
- en: Yeoman makes it easy to define and set up scaffolding for our collection. We
    execute the single command `yo backbone:collection runs` from the command line.
    (Yes, we’re being very original and calling our collection of runs, well, *runs*.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Yeoman使得定义和设置集合的脚手架变得非常容易。我们只需在命令行执行单个命令`yo backbone:collection runs`。（是的，我们非常有创意地将我们的跑步集合命名为*runs*。）
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Yeoman does the same thing for collections as it did for models: it creates
    an implementation file (*runs.js* in the *app/scripts/collections/* folder) and
    a test file. For now, let’s take a look at *runs.js*.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Yeoman 对集合的处理与它对模型的处理相同：它创建一个实现文件（*runs.js*，位于*app/scripts/collections/*文件夹中）和一个测试文件。现在，让我们看看*runs.js*。
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This file is even simpler than our model; the default collection has only a
    single property to indicate what type of model the collection contains. Unfortunately,
    Yeoman isn’t smart enough to handle plurals, so it assumes the name of the model
    is the same as the name of the collection. That’s not true for our app, as our
    model is Run (singular) and the collection is Runs (plural). While we’re removing
    that *s*, we can also add a property to specify the REST API for the collection.
    That’s a URL from the Nike+ service.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件比我们的模型还简单；默认的集合只有一个属性，用来指示集合包含的模型类型。不幸的是，Yeoman并不够智能，不能处理复数形式，因此它假设模型的名称与集合的名称相同。对于我们的应用程序来说，这并不成立，因为我们的模型是Run（单数），而集合是Runs（复数）。在我们去掉那个*s*的同时，我们还可以添加一个属性来指定集合的REST
    API。这是Nike+服务的一个URL。
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With those two small changes, we’re ready to take advantage of our new collection
    (aside from handling a few quirks with the Nike+ API; we’ll ignore that complication
    for now and address it later). All we need to do is create a new instance of the
    Runs collection and then fetch its data.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两个小改动，我们已经准备好利用我们的新集合（除了处理一些Nike+ API的特殊情况；我们暂时忽略这个复杂性，稍后再处理）。我们需要做的就是创建一个新的Runs集合实例，然后获取其数据。
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That’s all it takes to build a collection containing the user’s runs. Backbone.js
    creates a model for each and retrieves the model’s data from the server. Even
    better, those run models are stored in a true Underscore.js collection, which
    gives us access to many powerful methods to manipulate and search through the
    collection. Suppose, for example, we want to find the total distance for all of
    a user’s runs. That’s tailor-made for the Underscore.js `reduce()` function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个包含用户跑步数据的集合只需要这么简单。Backbone.js 为每个跑步数据创建一个模型，并从服务器中检索该模型的数据。更好的是，这些跑步模型存储在一个真正的
    Underscore.js 集合中，这使我们能够使用许多强大的方法来操作和搜索集合。比如，假设我们想要找出用户所有跑步的总距离，这正是 Underscore.js
    的`reduce()`函数的应用场景。
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That code could tell us, for example, that the user has logged a total of 3,358
    kilometers with Nike+.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这段代码可以告诉我们，用户在 Nike+ 上总共跑了 3,358 公里。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**As you may have noticed, we’re taking advantage of many utilities from Underscore.js
    in our Backbone.js application. That is not a coincidence. Jeremy Ashkenas is
    the lead developer for both projects.**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**正如你可能已经注意到的，我们在 Backbone.js 应用中利用了许多来自 Underscore.js 的工具。这并非巧合。Jeremy Ashkenas
    是这两个项目的首席开发者。**'
- en: 'Step 4: Define the Application’s Main View'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 4：定义应用程序的主视图
- en: Now that we have all the running data for a user, it’s time to present that
    data. We’ll do that with Backbone.js *views.* To keep our example simple, we’ll
    consider only two ways to show the running data. First we’ll display a table listing
    summary information about each run. Then, if the user clicks on a table row, we’ll
    show details about that specific run, including any visualizations. The main view
    of our application will be the summary table, so let’s focus on that first.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了用户的所有跑步数据，接下来是展示这些数据。我们将通过 Backbone.js 的 *views* 来完成这一操作。为了简化示例，我们只考虑两种展示跑步数据的方式。首先，我们将显示一个表格，列出每个跑步的总结信息。然后，如果用户点击表格中的某一行，我们将展示该跑步的详细信息，包括任何可视化内容。我们的应用程序的主视图将是总结表格，因此我们首先集中关注这个部分。
- en: A Backbone.js view is responsible for presenting data to the user, and that
    data may be maintained in a collection or a model. For the main page of our app,
    we want to show summary information for all of a user’s runs. That view, therefore,
    is a view of the entire collection. We’ll call the view *Summary.*
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Backbone.js 视图负责将数据呈现给用户，这些数据可能保存在集合或模型中。对于我们应用程序的主页面，我们希望展示所有用户跑步的总结信息。因此，这个视图是整个集合的视图。我们将称这个视图为
    *Summary*。
- en: The bulk of the table for this Summary view will be a series of table rows,
    where each row presents summary data about an individual run. That means we can
    simply create a view of a single Run model presented as a table row, and design
    our main Summary view to be made up (mostly) of many SummaryRow views. We can
    once again rely on Yeoman to set up the scaffolding for both of those types of
    views.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个总结视图，表格的主体将是一系列表格行，每行展示有关单个跑步的数据总结。这意味着我们可以简单地创建一个展示单个跑步模型的视图，作为表格行，并将我们的主总结视图设计为主要由多个
    SummaryRow 视图组成。我们可以再次依赖 Yeoman 来设置这两种视图的脚手架。
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The scaffolding that Yeoman sets up is pretty much the same for each view; only
    the name varies. Here’s what a Summary view looks like.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Yeoman 设置的脚手架对每个视图几乎都是一样的；只有名称不同。以下是一个 Summary 视图的示例。
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The overall structure of the file is the same as our model and our collection,
    but there’s a bit more going on in the view itself. Let’s step through the view’s
    properties one at a time. The first property is `template`. That’s where we define
    the exact HTML markup for the view, and we’ll look at this in more detail in the
    next step.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的整体结构与我们的模型和集合相同，但在视图本身，内容要复杂一些。让我们逐一查看视图的属性。第一个属性是`template`。这是我们定义视图的确切
    HTML 标记的地方，接下来我们会更详细地看看这一部分。
- en: The `tagName` property defines the HTML tag that our view will use as its parent.
    Yeoman defaults it to a generic `<div>`, but we know that in our case, it will
    be a `<table>`. We’ll change that in a moment.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`tagName` 属性定义了我们的视图将使用的 HTML 标签作为其父级。Yeoman 默认为 `<div>`，但我们知道在我们的案例中，它将是 `<table>`。我们稍后会进行更改。'
- en: The `id` and `className` properties specify HTML `id` attributes or `class`
    values to add to the main container (in our case, the `<table>`). We could, for
    example, base some CSS styles on these values. For our example, we’re not considering
    styles, so we can leave both properties blank or delete them entirely.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`id` 和 `className` 属性指定要添加到主容器（在我们案例中是 `<table>`）的 HTML `id` 属性或 `class` 值。例如，我们可以根据这些值来设置一些
    CSS 样式。对于我们的示例，暂时不考虑样式，所以我们可以将这两个属性留空或完全删除。'
- en: Next is the `events` property. This property identifies user events (such as
    mouse clicks) that are relevant for the view. In the case of the Summary view,
    there are no events, so we can leave the object empty or simply delete it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `events` 属性。该属性用于标识与视图相关的用户事件（如鼠标点击）。对于 Summary 视图而言，没有任何事件，因此我们可以将该对象留空或直接删除。
- en: 'The last two properties, `initialize()` and `render()`, are both methods. Before
    we consider those, let’s see the Summary view after we make the tweaks just mentioned.
    Now that we’ve omitted the properties we won’t be using, we’re down to just the
    `template` and `tagName` properties, plus the `initialize()` and `render()` methods:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个属性，`initialize()` 和 `render()`，都是方法。在我们考虑这两个方法之前，让我们先看看在进行刚才提到的调整后，Summary
    视图的效果。现在，我们已经去掉了不需要的属性，剩下的只有 `template` 和 `tagName` 属性，以及 `initialize()` 和 `render()`
    方法：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now let’s look inside the last two methods, starting with `initialize()`. That
    method has a single statement (other than the `return` statement that we just
    added). By calling `listenTo()`, it tells Backbone.js that the view wants to listen
    for events. The first parameter, `this.collection`, specifies the event target,
    so the statement says that the view wants to listen to events affecting the collection.
    The second parameter specifies the type of events. In this case, the view wants
    to know whenever the collection changes. The final parameter is the function Backbone.js
    should call when the event occurs. Every time the Runs collection changes, we
    want Backbone.js to call the view’s `render()` method. That makes sense, because
    whenever the Runs collection changes, whatever we were displaying on the page
    is now out of date. To make it current, our view should refresh its contents.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下最后两个方法，首先是 `initialize()`。这个方法只有一个语句（除了我们刚才添加的 `return` 语句）。通过调用 `listenTo()`，它告诉
    Backbone.js 该视图希望监听事件。第一个参数 `this.collection` 指定了事件的目标，意思是该视图想要监听影响集合的事件。第二个参数指定了事件的类型。在这里，视图希望在集合发生变化时获知。最后一个参数是事件发生时
    Backbone.js 应该调用的函数。每次 Runs 集合变化时，我们希望 Backbone.js 调用视图的 `render()` 方法。这是合理的，因为每当
    Runs 集合发生变化时，页面上展示的内容就会过时。为了保持最新，视图应刷新其内容。
- en: Most of the real work of a view takes place in its `render()` method. After
    all, this is the code that actually creates the HTML markup for the web page.
    Yeoman has gotten us started with a template, but in the case of a collection
    view, that’s not enough. The template takes care of the HTML for the collection
    as a whole, but it doesn’t handle the models that are part of the collection.
    For the individual runs, we can use the `each()` function from Underscore.js to
    iterate through the collection and render each run.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的大部分实际工作都发生在其 `render()` 方法中。毕竟，这段代码实际上是为网页创建 HTML 标记的。Yeoman 已经为我们提供了一个模板，但对于集合视图来说，这还不够。模板负责整个集合的
    HTML，但它并没有处理集合中各个模型的 HTML。对于单个的运行，我们可以使用 Underscore.js 的 `each()` 函数来迭代集合并渲染每个运行。
- en: As you can see from the following code, we’ve also added a `return this;` statement
    to each method. In a bit we’ll take advantage of this addition to *chain* together
    calls to multiple methods in a single, concise statement.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下代码可以看出，我们还在每个方法中添加了 `return this;` 语句。稍后我们将利用这一点来*链式*调用多个方法，从而在一个简洁的语句中完成。
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we have to write the `renderRun()` method that handles each individual
    run. Here’s what we want that function to do:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要编写 `renderRun()` 方法来处理每个单独的运行。以下是我们希望该方法执行的内容：
- en: Create a new SummaryRow view for the run.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为该运行创建一个新的 SummaryRow 视图。
- en: Render that SummaryRow view.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染那个 SummaryRow 视图。
- en: Append the resulting HTML to the `<tbody>` in the Summary view.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的 HTML 附加到 Summary 视图中的 `<tbody>` 元素。
- en: The code to implement those steps is straightforward, but it’s helpful to take
    each step one at a time.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这些步骤的代码是直接的，但逐步处理每个步骤会更有帮助。
- en: 'Create a new SummaryRow view: `new SummaryRow({model: run})`'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个新的 SummaryRow 视图：`new SummaryRow({model: run})`'
- en: 'Render that SummaryRow view: `.render()`'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染那个 SummaryRow 视图：`.render()`
- en: 'Append the result: `this.$("tbody").append();`'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 追加结果：`this.$("tbody").append();`
- en: When we put the steps together, we have the `renderRun()` method.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将这些步骤组合在一起时，我们得到了`renderRun()`方法。
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Most of the changes we made to the Summary view are also appropriate for the
    SummaryRow view, although we don’t need to add anything to the `render()` method.
    Here’s our first implementation of the SummaryRow. Note that we’ve set the `tagName`
    property to `"tr"` because we want each run model presented as a table row.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对Summary视图所做的大多数更改同样适用于SummaryRow视图，尽管我们不需要在`render()`方法中添加任何内容。以下是我们对SummaryRow的第一次实现。请注意，我们已将`tagName`属性设置为`"tr"`，因为我们希望每个运行模型作为表格行展示。
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now we have all the JavaScript code we need to show the main summary view for
    our app.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们拥有了所有需要的JavaScript代码来显示我们应用程序的主要摘要视图。
- en: 'Step 5: Define the Main View Templates'
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5步：定义主要视图模板
- en: So far we’ve developed the JavaScript code to manipulate our Summary and SummaryRow
    views. That code doesn’t generate the actual HTML markup, though. For that task
    we rely on *templates*. Templates are skeletal HTML markup with placeholders for
    individual values. Confining HTML markup to templates helps keep our JavaScript
    code clean, well structured, and easy to maintain.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经开发了JavaScript代码来操作我们的Summary和SummaryRow视图。但这些代码并没有生成实际的HTML标记。为了完成这个任务，我们依赖于*模板*。模板是带有占位符的骨架HTML标记，用于填充具体值。将HTML标记限制在模板中有助于保持我们的JavaScript代码清晰、结构良好且易于维护。
- en: Just as there are many popular JavaScript application libraries, there are also
    many template languages. Our application doesn’t require any fancy template functionality,
    however, so we’ll stick with the default template process that Yeoman has set
    up for us. That process relies on a JST tool (*[https://github.com/gruntjs/grunt-contrib-jst/](https://github.com/gruntjs/grunt-contrib-jst/)*)
    to process templates, and the tool uses the Underscore.js template language (*[http://underscorejs.org/#template/](http://underscorejs.org/#template/)*).
    It’s easy to see how this works through an example, so let’s dive in.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如有许多流行的JavaScript应用程序库一样，也有许多模板语言。然而，我们的应用程序不需要任何复杂的模板功能，因此我们将继续使用Yeoman为我们设置的默认模板处理过程。该过程依赖于JST工具（*[https://github.com/gruntjs/grunt-contrib-jst/](https://github.com/gruntjs/grunt-contrib-jst/)）*来处理模板，且该工具使用Underscore.js模板语言（*[http://underscorejs.org/#template/](http://underscorejs.org/#template/)*）。通过一个示例，容易看出这个过程是如何工作的，因此让我们深入了解一下。
- en: The first template we’ll tackle is the template for a SummaryRow. In our view,
    we’ve already established that the SummaryRow is a `<tr>` element, so the template
    needs to supply only the content that lives within that `<tr>`. We’ll get that
    content from the associated Run model, which, in turn, comes from the Nike+ service.
    Here’s an example activity that Nike+ could return.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理的第一个模板是SummaryRow的模板。在我们的视图中，我们已经确定SummaryRow是一个`<tr>`元素，因此模板只需要提供该`<tr>`内的内容。我们将从关联的Run模型中获取这些内容，而该模型又来自Nike+服务。以下是Nike+可能返回的一个示例活动。
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For a first implementation, let’s show the time of the run, as well as its duration,
    distance, and calories. Our table row, therefore, will have four cells, with each
    cell holding one of these values. We can find the template, *summaryRow.ejs*,
    in the *app/scripts/templates* folder. By default, Yeoman sets it to a simple
    paragraph.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于首次实现，我们展示运行的时间，以及其持续时间、距离和卡路里。因此，我们的表格行将有四个单元格，每个单元格包含一个这些值。我们可以在*app/scripts/templates*文件夹中找到模板*summaryRow.ejs*。默认情况下，Yeoman将其设置为一个简单的段落。
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let’s replace that with four table cells.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用四个表格单元格来替换它。
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As placeholders for the cells’ content, we can use model attributes enclosed
    in special `<%=` and `%>` delimiters. The full SummaryRow template is as follows.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 作为单元格内容的占位符，我们可以使用包含在特殊`<%=`和`%>`分隔符中的模型属性。完整的SummaryRow模板如下。
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The other template we need to supply is the Summary template. Since we’ve already
    set the view’s main tag to be a `<table>`, this template should specify the content
    within that `<table>`: a table header row plus an empty `<tbody>` element (whose
    individual rows will come from the Run models).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们需要提供的模板是Summary模板。由于我们已经将视图的主要标签设置为`<table>`，因此这个模板应该指定该`<table>`中的内容：一个表头行加上一个空的`<tbody>`元素（其中的单独行将来自Run模型）。
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we’re finally ready to construct the main view for our runs. The steps
    are quite straightforward:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于准备好为我们的运行构建主要视图了。步骤非常直接：
- en: Create a new Runs collection.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Runs集合。
- en: Fetch the data for that collection from the server.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从服务器获取该集合的数据。
- en: Create a new Summary view for the collection.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为该集合创建一个新的Summary视图。
- en: Render the view.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染视图。
- en: 'Here’s the JavaScript code for those four steps:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实现这四个步骤的 JavaScript 代码：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can access the constructed `<table>` as the `el` (short for *element*) property
    of the view. It will look something like the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过视图的 `el`（*元素*）属性访问构建好的 `<table>`。它看起来大致如下：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When we insert that markup in the page, our users can see a simple summary table
    listing their runs, as shown in [Figure 9-3](ch09.html#simple_table_with_a_summary_of_run_infor
    "Figure 9-3. A simple table with a summary of run information").
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将这些标记插入页面时，用户可以看到一个简单的总结表格，列出他们的跑步记录，如 [图 9-3](ch09.html#simple_table_with_a_summary_of_run_infor
    "图 9-3. 一个包含跑步信息总结的简单表格") 所示。
- en: '![A simple table with a summary of run information](figs/web/09fig03.png.jpg)Figure 9-3. A
    simple table with a summary of run information'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![一个包含跑步信息总结的简单表格](figs/web/09fig03.png.jpg)图 9-3. 一个包含跑步信息总结的简单表格'
- en: 'Step 6: Refine the Main View'
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 6：优化主视图
- en: Now we’re starting to get somewhere, though the table contents could use some
    tweaking. After all, does the last digit in a run of 16.068001 kilometers really
    matter? Since Nike+ determines the attributes of our Run model, it might seem
    like we have no control over the values passed to our template. Fortunately, that’s
    not the case. If we look at the SummaryView’s `render()` method, we can see how
    the template gets its values.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始有了些进展，尽管表格内容仍然需要调整。毕竟，跑步距离 16.068001 公里中的最后一位数字真的重要吗？由于 Nike+ 决定了我们 Run
    模型的属性，可能看起来我们无法控制传递给模板的值。幸运的是，事实并非如此。如果我们查看 SummaryView 的 `render()` 方法，我们可以看到模板是如何获得这些值的。
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The template values come from a JavaScript object that we’re creating directly
    from the model. Backbone.js provided the `toJSON()` method, which returns a JavaScript
    object corresponding to the model’s attributes. We can actually pass any JavaScript
    object to the template, even one we create ourselves within the `render()` method.
    Let’s rewrite that method to provide a more user-friendly Summary view. We’ll
    take the model’s attributes one at a time.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 模板的值来自我们直接从模型创建的 JavaScript 对象。Backbone.js 提供了 `toJSON()` 方法，它返回一个对应于模型属性的 JavaScript
    对象。实际上，我们可以将任何 JavaScript 对象传递给模板，甚至是我们在 `render()` 方法中自己创建的对象。让我们重新编写这个方法，以提供一个更友好的
    Summary 视图。我们将逐个获取模型的属性。
- en: First is the date of the run. A date of “2013-04-09T10:54:33Z” isn’t very readable
    for average users, and it’s probably not even in their time zone. Working with
    dates and times is actually quite tricky, but the excellent Moment.js library
    (*[http://momentjs.com/](http://momentjs.com/)*) can handle all of the complexity.
    Since we added that library to our app in an earlier section, we can take advantage
    of it now.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是跑步的日期。像 “2013-04-09T10:54:33Z” 这样的日期对于普通用户来说并不易读，而且可能并不是他们所在的时区。处理日期和时间实际上是很棘手的，但优秀的
    Moment.js 库 (*[http://momentjs.com/](http://momentjs.com/)* ) 可以处理所有复杂的操作。因为我们在前面的章节中已经将该库添加到应用程序中，现在可以利用它了。
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**In the interest of brevity, we’re cheating a little with the preceding code
    because it converts the UTC timestamp to the local time zone of the browser. It
    would probably be more correct to convert it to the time zone for the run, which
    Nike+ provides in the data.**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**为了简洁起见，我们在前面的代码中做了一些简化，它将 UTC 时间戳转换为浏览器的本地时区。实际上，将其转换为跑步记录的时区可能更为准确，而这个时区在
    Nike+ 的数据中是提供的。**'
- en: Next up is the run’s duration. It’s doubtful that we need to show the fractions
    of seconds that Nike+ includes, so let’s simply drop them from the attribute.
    (It would be more precise to round up or down, but assuming our users are not
    Olympic athletes in training, a second here or there won’t matter. Besides, Nike+
    seems to always record these subsecond durations as “.000” anyway.)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是跑步的持续时间。我们不太需要显示 Nike+ 所包含的秒数的分数部分，所以我们直接从属性中去掉它们。（当然，四舍五入会更精确，但假设我们的用户不是正在训练的奥运运动员，一秒钟的差异其实不重要。而且，Nike+
    好像总是把这些小于秒的时间段记录为 ".000"）
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `distance` property can also use some adjustment. In addition to rounding
    it to a reasonable number of decimal places, we can convert from kilometers to
    miles for our US users. A single statement takes care of both.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`distance` 属性也可以做些调整。除了将其四舍五入到合理的小数位数外，我们还可以为美国用户将其从公里转换为英里。一条语句就能同时解决这两个问题。'
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `calories` property is fine as it is, so we’ll just copy it into our temporary
    object.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`calories` 属性保持原样，所以我们只需将其复制到临时对象中。'
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, if you’re an avid runner, you might have noticed that there’s an important
    value missing from the Nike+ attributes: the average pace for the run in minutes
    per mile. We have the data to calculate it, so let’s add that as well.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你是一个热衷的跑步者，可能已经注意到 Nike+ 属性中缺少一个重要的值：每英里分钟的平均配速。我们有数据来计算它，所以让我们也将其添加进去。
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now we have a new object to pass to the template.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个新的对象，可以传递给模板。
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We’ll also need to modify both templates to match the new markup. Here’s the
    updated template for SummaryRows.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改两个模板以匹配新的标记。以下是更新后的 SummaryRows 模板。
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: And here’s the Summary template with the additional column for Pace.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是包含 Pace 额外列的 Summary 模板。
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now we have a much-improved summary table for our users, shown in [Figure 9-4](ch09.html#improved_summary_table_with_cleaner-look
    "Figure 9-4. An improved summary table with cleaner-looking data").
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为用户提供了一个大大改进的总结表格，见[图 9-4](ch09.html#improved_summary_table_with_cleaner-look
    "图 9-4。改进后的总结表格，数据看起来更清晰")。
- en: '![An improved summary table with cleaner-looking data](figs/web/09fig04.png.jpg)Figure 9-4. An
    improved summary table with cleaner-looking data'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![改进后的总结表格，数据看起来更清晰](figs/web/09fig04.png.jpg)图 9-4。改进后的总结表格，数据看起来更清晰'
- en: Views for Visualizations
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化视图
- en: Now that we’ve seen how to use Backbone.js views to separate data from its presentation,
    we can consider how to use the same approach for data visualizations. When the
    presentation is simple HTML markup—as in the previous section’s tables—it’s easy
    to use templates to view a model. But templates aren’t sophisticated enough to
    handle data visualizations, so we’ll need to modify our approach for those.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用 Backbone.js 视图将数据与其展示分离，我们可以考虑如何使用相同的方法来处理数据可视化。当展示是简单的 HTML 标记时——就像前一节中的表格——使用模板查看模型非常容易。但模板不足以处理数据可视化，所以我们需要修改方法来适应这种情况。
- en: The data from the Nike+ service offers lots of opportunity for visualizations.
    Each run, for example, may include a record of the user’s heart rate, instantaneous
    pace, and cumulative distance, recorded every 10 seconds. Runs may also include
    the user’s GPS coordinates captured every second. That type of data lends itself
    to both charts and maps, and in this section, we’ll add both to our application.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Nike+ 服务的数据为可视化提供了很多机会。例如，每次跑步可能包括记录用户的心率、即时配速和每 10 秒记录一次的累计距离。跑步数据还可能包括每秒捕捉的用户
    GPS 坐标。这类数据非常适合做图表和地图，在这一节中，我们将同时将这两种可视化添加到我们的应用程序中。
- en: 'Step 1: Define the Additional Views'
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 1：定义额外视图
- en: As we did in the previous section, we’ll rely on Yeoman to create the scaffolding
    for our additional views. One view, which we’ll call *Details*, will act as the
    overall view for the details of an individual run. Within that view, we’ll create
    three additional views, each showing a different aspect of the run. We can think
    of these views in a hierarchy.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中所做的那样，我们将依赖 Yeoman 来创建额外视图的脚手架。其中一个视图，我们称之为*详情*，将作为单个运行详细信息的总体视图。在该视图内，我们将创建三个额外视图，每个视图展示运行的不同方面。我们可以将这些视图视为一个层次结构。
- en: '****Details****. A detailed view of a single run'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****详情****。单次跑步的详细视图'
- en: '****Properties****. The full set of properties associated with the run'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****属性****。与运行相关的完整属性集'
- en: '****Chart****. Charts showing performance during the run'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****图表****。展示运行期间表现的图表'
- en: '****Map****. A map of the run’s route'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****地图****。跑步路线的地图'
- en: To start the development of these views, we return to the command line and execute
    four Yeoman commands.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始开发这些视图，我们返回命令行并执行四个 Yeoman 命令。
- en: '[PRE46]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Step 2: Implement the Details View'
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 2：实现详情视图
- en: 'The Details view is really nothing more than a container for its three children,
    so its implementation is about as easy as it gets. We create a new view for each
    of the children, render the view, and add the resulting markup to the Details.
    Here is the complete code for this view:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 详情视图实际上不过是其三个子视图的容器，因此它的实现非常简单。我们为每个子视图创建一个新的视图，渲染该视图，并将生成的标记添加到详情视图中。以下是该视图的完整代码：
- en: '[PRE47]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Unlike the previous views we’ve created, this view doesn’t have an `initialize()`
    method. That’s because the Details view doesn’t have to listen for changes to
    the model, so there’s nothing to do during initialization. In other words, the
    Details view itself doesn’t actually depend on any of the properties of the Run
    model. (The child views, on the other hand, depend greatly on those properties.)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前创建的视图不同，这个视图没有 `initialize()` 方法。这是因为 Details 视图不需要监听模型的变化，因此在初始化时不需要做任何事情。换句话说，Details
    视图本身实际上并不依赖于 Run 模型的任何属性。（另一方面，子视图在很大程度上依赖这些属性。）
- en: The `render()` method itself first clears out any existing content from its
    element. This line makes it safe to call the `render()` method multiple times.
    The next three statements create each of the child views. Notice that all of the
    child views have the same model, which is the model for the Details view as well.
    This capability is the power of the model/view architecture; one data object—in
    our case, a run—can be presented in many different ways. While the `render()`
    method creates each of these child views, it also calls their `render()` methods,
    and it appends the resulting content (their `el` properties) into its own `el`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`render()` 方法本身首先清除其元素中的任何现有内容。这一行确保可以安全地多次调用 `render()` 方法。接下来的三行语句创建了每个子视图。注意，所有子视图都使用相同的模型，这也是
    Details 视图的模型。这就是模型/视图架构的强大之处；一个数据对象——在我们的例子中是一个跑步——可以以多种不同的方式呈现。当 `render()`
    方法创建这些子视图时，它也会调用它们的 `render()` 方法，并将结果内容（即它们的 `el` 属性）附加到自己的 `el` 中。'
- en: 'Step 3: Implement the Properties View'
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 3：实现属性视图
- en: 'For the Properties view, we want to show all of the properties that Nike+ has
    associated with the run. Those properties are determined by the data returned
    by the Nike+ service; here’s an example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于属性视图，我们希望展示所有与跑步相关的 Nike+ 属性。这些属性是由 Nike+ 服务返回的数据决定的；下面是一个示例：
- en: '[PRE48]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: That data can certainly benefit from a bit of cleanup to make it more user-friendly.
    To do that we’ll take advantage of the Underscore.string library we added to the
    project before. We can make sure that library is available by “mixing it into”
    the main Underscore.js library. We’ll do that right at the start of the JavaScript
    file for the Properties view.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据肯定可以通过一些清理工作变得更友好。为此，我们将利用之前添加到项目中的 Underscore.string 库。我们可以通过将该库“混合”进主
    Underscore.js 库来确保该库的可用性。我们将在属性视图的 JavaScript 文件开头做这件事。
- en: '[PRE49]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Notice that we’ve also added the global variable for Underscore.js (`_`) to
    the initial comment in the file.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还将 Underscore.js 的全局变量（`_`）添加到了文件的初始注释中。
- en: 'The most straightforward way to present this information in HTML is with a
    description list (`<dl>`). Each property can be an individual item in the list,
    with a description term (`<dt>`) holding the property name and the description
    data (`<dd>`) its value. To implement this, we set the `tagName` property of the
    view to be `"dl"`, and we create a generic list item template. Here’s the start
    of our Properties view code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以 HTML 呈现这些信息的最直接方式是使用描述列表（`<dl>`）。每个属性可以作为列表中的一个项，其中描述项（`<dt>`）包含属性名称，描述数据（`<dd>`）则包含其值。为了实现这一点，我们将视图的
    `tagName` 属性设置为 `"dl"`，并创建一个通用的列表项模板。下面是我们属性视图代码的开始部分：
- en: '[PRE50]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: And here’s the simple template that the view will use.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是视图将使用的简单模板。
- en: '[PRE51]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: A quick glance at the Nike+ data shows that it contains nested objects. The
    `metricSummary` property of the main object is itself an object. We need a function
    that will iterate through all the properties in the input object, building the
    HTML markup as it does. A recursive function can be particularly effective here,
    since it can call itself whenever it reaches another nested object. Next, we add
    an `obj2Html()` method to our view. At its core, this method will use the Underscore.js
    `reduce()` function, which is well suited to the task at hand.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看 Nike+ 数据发现，它包含嵌套对象。主对象的 `metricSummary` 属性本身就是一个对象。我们需要一个函数来遍历输入对象中的所有属性，同时构建
    HTML 标记。递归函数在这里特别有效，因为它可以在遇到另一个嵌套对象时调用自己。接下来，我们为视图添加一个 `obj2Html()` 方法。该方法的核心将使用
    Underscore.js 的 `reduce()` 函数，这对于当前任务非常适合。
- en: '[PRE52]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As we process each property, the first thing we can do is improve the key name.
    For example, we’d like to replace `startTime` with `Start Time`. That’s where
    Underscore.string comes in. Its `humanize()` function turns camelCase into separate
    words, and its `titleize()` function ensures that each word begins with an uppercase
    letter. We’ll use chaining to perform both operations in one statement.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理每个属性时，我们可以做的第一件事是改进键名。例如，我们想将`startTime`替换为`Start Time`。这时，Underscore.string就派上了用场。它的`humanize()`函数将驼峰命名法转化为分开的单词，而`titleize()`函数则确保每个单词的首字母是大写的。我们将使用链式调用来在一个语句中执行这两个操作。
- en: '[PRE53]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now we can consider the value. If it is an array, we’ll replace it with a string
    that shows the array length.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以考虑值。如果它是一个数组，我们将把它替换为显示数组长度的字符串。
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Next we check to see if the value is an object. If it is, then we’ll call the
    `obj2Html()` method recursively.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们检查值是否是一个对象。如果是，我们将递归调用`obj2Html()`方法。
- en: '[PRE55]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: For other types, we convert the value to a string, format it a bit with Underscore.string,
    and make use of our template.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他类型，我们将把值转换为字符串，使用Underscore.string稍微格式化一下，并使用我们的模板。
- en: '[PRE56]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: There are a few other minor improvements we can make to the presentation, which
    you can find in the book’s source code. The last piece of the view is implementing
    the `render()` method. In that method, we use `toJSON()` to get an object corresponding
    to the Run model, and then we start the `obj2Html()` recursion with that object.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对展示做一些其他的小改进，具体内容可以在书籍的源代码中找到。视图的最后一部分是实现`render()`方法。在这个方法中，我们使用`toJSON()`获取与Run模型对应的对象，然后开始用该对象进行`obj2Html()`递归处理。
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The result is a complete picture of the properties of the run, shown in [Figure 9-5](ch09.html#completed_properties_view_shows_all_of_t
    "Figure 9-5. The completed Properties view shows all of the data associated with
    a run.").
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个关于运行属性的完整图景，如[图 9-5](ch09.html#completed_properties_view_shows_all_of_t
    "图 9-5. 完成的属性视图展示了与运行相关的所有数据.")所示。
- en: '![The completed Properties view shows all of the data associated with a run.](figs/web/09fig05.png.jpg)Figure 9-5. The
    completed Properties view shows all of the data associated with a run.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![完成的属性视图展示了与运行相关的所有数据。](figs/web/09fig05.png.jpg)图 9-5. 完成的属性视图展示了与运行相关的所有数据。'
- en: 'Step 4: Implement the Map View'
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤4：实现地图视图
- en: To show users maps of their runs, we rely on the Leaflet library from [Chapter 6](ch06.html
    "Chapter 6. Visualizing Geographic Data"). Using the library will require some
    small modifications to the normal Backbone.js view implementation, but, as we’ll
    see, those same modifications will come in handy for other views as well. Leaflet
    builds its maps in a containing element in the page (typically a `<div>`), and
    that containing element must have an `id` attribute so that Leaflet can find it.
    Backbone.js will take care of adding that `id` if we include an `id` property
    in the view. That’s easy enough.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向用户展示他们运行的地图，我们依赖于[第6章](ch06.html "第6章. 可视化地理数据")中的Leaflet库。使用该库需要对普通的Backbone.js视图实现做一些小的修改，但正如我们所看到的，这些修改对于其他视图也同样有用。Leaflet会在页面中的一个容器元素内构建地图（通常是一个`<div>`），而这个容器元素必须有一个`id`属性，以便Leaflet能够找到它。如果我们在视图中包含一个`id`属性，Backbone.js会负责添加这个`id`。这个操作很简单。
- en: '[PRE58]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'With `<div id="map"></div>` available in the page’s markup, we can create a
    Leaflet map with the following statement:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面的标记中有`<div id="map"></div>`后，我们可以通过以下语句创建一个Leaflet地图：
- en: '[PRE59]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We might be tempted to do that directly in the view’s `render()` method, but
    there’s a problem with that approach. Adding (and removing) elements in a web
    page requires a lot of computation by the browser. When JavaScript code does that
    frequently, the performance of the page can suffer significantly. To reduce this
    problem, Backbone.js tries to minimize the number of times it adds (or removes)
    elements, and one way to do that is to add many elements at once rather than adding
    each element independently. It employs that approach when it implements a view’s
    `render()` method. Before adding any elements to the page, it lets the view finish
    constructing its entire markup; only then does it add that markup to the page.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会倾向于直接在视图的`render()`方法中做这件事，但这种方法有一个问题。往网页中添加（和删除）元素需要浏览器进行大量的计算。当JavaScript代码频繁执行这种操作时，页面的性能可能会显著下降。为了减少这个问题，Backbone.js尽量减少添加（或删除）元素的次数，一种方法是一次性添加多个元素，而不是独立地添加每个元素。当它实现视图的`render()`方法时，就采用了这种方法。在将任何元素添加到页面之前，它会让视图完成整个标记的构建；只有完成后，它才会将这些标记添加到页面中。
- en: The problem here is that when `render()` is called the first time, there won’t
    (yet) be a `<div id="map"></div>` anywhere in the page. If we call Leaflet, it
    won’t be able to find the container for its map, and it will generate an error.
    What we need to do is defer the part of `render()` that draws the map until after
    Backbone.js has added the map container to the page.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，当`render()`第一次被调用时，页面中还没有`<div id="map"></div>`元素。如果我们调用Leaflet，它将无法找到地图的容器，从而生成错误。我们需要做的是推迟`render()`中绘制地图的部分，直到Backbone.js将地图容器添加到页面之后。
- en: 'Fortunately, Underscore.js has a utility function called `defer()` to do just
    that. Instead of drawing the map directly in the `render()` method, we’ll create
    a separate method. Then, in the `render()` method, we’ll defer execution of that
    new method. Here’s what the code to do that looks like:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Underscore.js有一个名为`defer()`的工具函数，可以完成这一任务。我们将不再直接在`render()`方法中绘制地图，而是创建一个单独的方法。然后，在`render()`方法中，我们将推迟执行这个新方法。下面是实现这一点的代码：
- en: '[PRE60]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As you can see, we’re actually using a couple of Underscore.js functions in
    our `render()` method. In addition to `defer()`, we also take advantage of `bind()`.
    The latter function ensures that the `this` value when `drawMap()` is eventually
    called is the same as the `this` value within the view.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在我们的`render()`方法中，我们实际上使用了几个Underscore.js函数。除了`defer()`，我们还利用了`bind()`。后者确保在最终调用`drawMap()`时，`this`的值与视图内部的`this`值相同。
- en: There’s one change we can make to further improve this implementation. Although
    there won’t be a `<div id="map"></div>` in the page when `render()` is first called,
    that element will exist in subsequent calls to `render()`. In those cases, we
    don’t need to defer the execution of `drawMap()`. That leads to the following
    code for our `render()` method.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步改进此实现。有一个变化可以做：尽管`render()`第一次被调用时页面中没有`<div id="map"></div>`元素，但在后续调用`render()`时，该元素将会存在。在这些情况下，我们不需要推迟执行`drawMap()`。这就导致了以下我们`render()`方法的代码：
- en: '[PRE61]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'As long as we’re making optimizations, let’s also change the `initialize()`
    method slightly. The default method that Yeoman creates is this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经在进行优化，不妨稍微修改一下`initialize()`方法。Yeoman默认创建的方法是这样的：
- en: '[PRE62]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: For the Map view, however, we don’t really care if any property of the Run model
    changes. The only property the view needs is `gps`, so we can tell Backbone. js
    to bother us only if that specific property changes.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于地图视图，我们实际上并不关心`Run`模型的任何属性变化。视图所需的唯一属性是`gps`，因此我们可以告诉Backbone.js仅在该特定属性发生变化时才通知我们。
- en: '[PRE63]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You might be wondering, “Why would the `gps` property of the Run model ever
    change?” I’ll get to that when I cover the quirks of the Nike+ REST API in [Chapter 10](ch10.html
    "Chapter 10. Building Data-Driven Web Applications: Part 2").'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想：“为什么`Run`模型的`gps`属性会发生变化呢？”我将在[第10章](ch10.html "第10章. 构建数据驱动的Web应用程序：第二部分")讲解Nike+
    REST API的细节时说明这一点。
- en: 'With the preliminaries out of the way, we can implement the `drawMap()` function,
    which turns out to be a very easy implementation. The steps are as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 解决了初步问题后，我们可以实现`drawMap()`函数，这实际上是一个非常简单的实现。步骤如下：
- en: Make sure the model has a `gps` property and there are waypoints associated
    with it.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保模型有一个`gps`属性，并且与其关联了航点。
- en: If an old map exists, remove it.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果旧的地图存在，则将其移除。
- en: Extract the GPS coordinates from the waypoints array.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从航点数组中提取GPS坐标。
- en: Create a path using those coordinates.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这些坐标创建路径。
- en: Create a map that contains that path, and draw the path on the map.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含该路径的地图，并在地图上绘制该路径。
- en: Add the map tiles.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加地图瓦片。
- en: The resulting code is a straightforward implementation of those steps.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的代码是这些步骤的直接实现。
- en: '[PRE64]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As you can see from the code, we’re storing a reference to the Leaflet map object
    as a property of the view. From within the view, we can access that object using
    `this.map`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在代码中，我们将Leaflet地图对象作为视图的一个属性进行存储。在视图内部，我们可以通过`this.map`访问该对象。
- en: The result is a nice map of the run’s route, shown in [Figure 9-6](ch09.html#map_view_shows_the_route_of_a_run
    "Figure 9-6. A map view shows the route of a run.").
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个显示跑步路线的漂亮地图，如[图9-6](ch09.html#map_view_shows_the_route_of_a_run "图9-6.
    跑步路线的地图视图")所示。
- en: '![A map view shows the route of a run.](figs/web/09fig06.png.jpg)Figure 9-6. A
    map view shows the route of a run.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![跑步路线的地图视图](figs/web/09fig06.png.jpg)图9-6. 跑步路线的地图视图。'
- en: 'Step 5: Implement the Charts View'
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第5步：实现图表视图
- en: The last remaining view that we need to implement is the Charts view, where
    we want to show pace, heart rate, and elevation during the run. This view is the
    most complex, but nearly all of the code is identical to the example in [Tracking
    Data Values](ch02.html#tracking_data_values "Tracking Data Values"), so there’s
    no need to repeat it here.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的最后一个视图是图表视图，在这个视图中我们想要展示跑步过程中的步频、心率和海拔。这个视图是最复杂的，但几乎所有的代码都与[数据追踪值](ch02.html#tracking_data_values
    "数据追踪值")中的示例相同，因此这里不需要重复。
- en: You can see the interactive result in [Figure 9-7](ch09.html#alternative_view_shows_charts_of_the_run
    "Figure 9-7. An alternative view shows charts of the run.").
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[图 9-7](ch09.html#alternative_view_shows_charts_of_the_run "图 9-7. 另一种视图展示跑步的图表。")中查看交互式结果。
- en: '![An alternative view shows charts of the run.](figs/web/09fig07.png.jpg)Figure 9-7. An
    alternative view shows charts of the run.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![另一种视图展示跑步的图表。](figs/web/09fig07.png.jpg)图 9-7. 另一种视图展示跑步的图表。'
- en: 'The source code for the book includes the complete implementation. If you’re
    looking in detail at that implementation, there a few points to note:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的源代码包括完整的实现。如果你在详细查看该实现时，有几点需要注意：
- en: Just as with Leaflet and the map container, Flot expects a container for its
    chart to be present in the web page. We can use the same `defer` trick to prevent
    Flot errors.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像 Leaflet 和地图容器一样，Flot 期望在网页中存在一个图表容器。我们可以使用相同的 `defer` 技巧来防止 Flot 错误。
- en: 'Nike+ returns at least four types of charts as metrics: distance, heart rate,
    speed, and GPS signal strength. We really only care about the first two. At first,
    it might seem easiest to calculate pace from speed, but speed isn’t present in
    all activities. Distance, however, is present, and we can derive pace from distance
    and time.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nike+ 至少返回四种类型的图表作为指标：距离、心率、速度和 GPS 信号强度。我们实际上只关心前两个。一开始，似乎从速度计算步频最简单，但速度并非所有活动都有。然而，距离是有的，我们可以从距离和时间推导出步频。
- en: If GPS waypoint data is available, we can also graph elevation, but that data
    is in a separate attribute of the model (not the `metrics` attribute).
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有 GPS 路径点数据，我们还可以绘制海拔图表，但这些数据存在于模型的一个单独属性中（而不是 `metrics` 属性）。
- en: As of this writing, there’s a bit of a bug in Nike’s response for GPS data.
    It claims that the measurements are on the same time scale as the other metrics
    (every 10 seconds), but in fact the GPS measurements are reported on different
    intervals. To work around this bug, we ignore the reported interval and calculate
    one ourselves. Also, we want to normalize the elevation graph to the same time
    scale as all the others. Doing that will give us the additional benefit of averaging
    the GPS elevation data; averaging is useful here because GPS elevation measurements
    aren’t generally very accurate.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 截至目前，Nike 的 GPS 数据响应存在一个小问题。它声称测量数据与其他指标（每 10 秒一次）在相同的时间尺度上，但实际上 GPS 测量数据是在不同的间隔上报告的。为了绕过这个问题，我们忽略报告的间隔并自行计算一个间隔。同时，我们希望将海拔图表标准化为与其他图表相同的时间尺度。这样做的额外好处是可以对
    GPS 海拔数据进行平均；在这里平均值很有用，因为 GPS 海拔测量通常不太准确。
- en: Summing Up
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we’ve starting building an entire web application based on
    data and data visualizations. To help organize and coordinate our application,
    we based it on the Backbone.js library, and we relied on the Yeoman tool to create
    the application’s scaffolding and boilerplate code and templates. Backbone.js
    lets us separate our application into models and views so that the code responsible
    for managing the data doesn’t have to worry about how that data is presented (and
    vice versa).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始构建一个基于数据和数据可视化的完整 Web 应用程序。为了帮助组织和协调我们的应用程序，我们基于 Backbone.js 库，并依赖
    Yeoman 工具来创建应用程序的框架和模板代码。Backbone.js 使我们能够将应用程序分离为模型和视图，以便管理数据的代码不需要担心数据如何呈现（反之亦然）。
- en: In the next chapter, we’ll enable our application to communicate with the Nike+
    interface, and we’ll add some finishing touches to improve user interaction with
    the page.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将使我们的应用程序能够与 Nike+ 接口进行通信，并添加一些细节来改善用户与页面的交互。
