<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch25"><span epub:type="pagebreak" id="page_473"/><span class="big">25</span><br/>ELECTRIC FIELD</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">In the 1800s, Faraday and Maxwell discovered a new way to think about electric (and magnetic) phenomena that forms the basis for today’s electromagnetic theory. In this 19th century view, one particle does not directly apply a force to another particle, as Coulomb’s law would imply. Instead, one particle creates an <em>electric field</em> that applies a force to the second particle.</p>&#13;
<p class="indent">We’ll start this chapter with a short discussion of exactly what an electric field is. Then, we’ll show how to calculate the electric field produced by each of the charge distributions we studied in the previous chapter. We’ll begin with the electric field produced by a point charge, which is really the fundamental piece that governs all of the other distributions. After a single point charge, we’ll look at the electric field produced by multiple point charges. As an example, we’ll compare the electric fields produced by a simple electric dipole composed of two point charges with an ideal electric dipole.</p>&#13;
<p class="indent">To calculate the electric field, we’ll need to introduce a few new mathematical tools. Finding the electric field produced by a line charge requires a vector line integral; finding the electric field produced by a surface charge requires a vector surface integral; and finding the electric field produced by a volume charge requires a vector volume integral. We’ll introduce these as <span epub:type="pagebreak" id="page_474"/>needed, and we’ll close out the chapter with the details of sampling or discretizing curves, surfaces, and volumes, which will allow us to do numerical line, surface, and volume integrals.</p>&#13;
<h3 class="h3" id="ch25lev1">What Is an Electric Field?</h3>&#13;
<p class="noindent">An electric field is a <em>vector field</em> of the kind we talked about in <a href="ch22.xhtml">Chapter 22</a>. The electric field associates a vector <strong>E</strong>(<strong>r</strong>) with each point <strong>r</strong> in space; that vector helps determine the force on a particle if there is a particle at point <strong>r</strong> in space.</p>&#13;
<p class="indent">Is the electric field a physical thing, or is it an abstraction we use to think about electricity? I would argue it is both. The electric field is an abstract mathematical construct, as are so many of the ideas of modern theoretical physics. We describe it using mathematical language and posit axioms about it as though it had no more physical reality than a 7×7 matrix of irrational numbers.</p>&#13;
<p class="indent">In static situations, where charges are not moving or accelerating, we can remain ambivalent about the reality of the electric field, or even deny it. These static situations are the ones where Coulomb’s law makes good predictions, and the new electromagnetic theory that speaks of an electric field makes the same predictions. In static situations, then, the electric field can be viewed as merely an abstraction.</p>&#13;
<p class="indent">In dynamic situations, on the other hand, where electric charge is moving and/or accelerating, it becomes much harder to maintain the view that the electric field is only a calculational tool. The reason is that modern electromagnetic theory is, in addition to being a theory of electricity and magnetism, a theory of light and radiation. Maxwell’s insight was that electric and magnetic fields could serve to describe visible light and an entire spectrum of nonvisible light-like waves, including radio waves and microwaves. These waves are now viewed as waves in the electric and magnetic fields. Light is, according to the Faraday-Maxwell theory, an electromagnetic wave. To the extent that light and radiation are physical and real, it seems the electric field is also physical and real.</p>&#13;
<p class="indent">Introducing the electric field breaks the analysis of electrical situations into two parts. The first part is the creation of the electric field by charge, which we’ll discuss in this chapter. The second part is the force that the electric field applies to (a second) charge, which we’ll discuss in <a href="ch28.xhtml">Chapter 28</a>. <a href="ch25.xhtml#ch25fig1">Figure 25-1</a> shows the electric field’s role in a situation with two charges.</p>&#13;
<div class="imagel" id="ch25fig1"><img src="Images/474equ01.jpg" alt="Image" width="570" height="97"/></div>&#13;
<p class="figcap"><em>Figure 25-1: Conceptual diagram of the role of the electric field when two charged particles are present. Particle 1 creates the electric field. The electric field exerts a force on particle 2.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_475"/>We say that the electric field <em>mediates</em> the interaction between the two particles. In this chapter, we focus on the electric field created by static, or stationary, charges and charge distributions. The real benefit of the electric field idea appears when charges are moving rapidly or accelerating because Coulomb’s law fails to make good predictions in these cases. In general, the Maxwell equations, which we discuss in <a href="ch29.xhtml">Chapter 29</a>, describe the creation and evolution of the electric field. The Maxwell equations describe the electric field created by charge in any sort of motion, and they make different predictions from Coulomb’s theory when charge is moving or accelerating. Our introduction of the electric field in simpler static situations will put us in a better position to discuss the Maxwell equations later.</p>&#13;
<h3 class="h3" id="ch25lev2">Introductory Code</h3>&#13;
<p class="noindent"><a href="ch25.xhtml#ch25list1">Listing 25-1</a> shows the first lines of code in the <span class="literal">ElectricField</span> module we’ll write in this chapter.</p>&#13;
<pre id="ch25list1">{-# OPTIONS -Wall #-}&#13;
&#13;
module ElectricField where&#13;
&#13;
import SimpleVec&#13;
    ( R, Vec, (^+^), (^-^), (*^), (^*), (^/), (&lt;.&gt;), (&gt;&lt;)&#13;
    , sumV, magnitude, vec, xComp, yComp, zComp, kHat )&#13;
import CoordinateSystems&#13;
    ( Position, ScalarField, VectorField&#13;
    , displacement, shiftPosition, addVectorFields&#13;
    , cart, sph, vf3D, vfPNGxy, vfGrad, origin, rVF )&#13;
import Geometry ( Curve(..), Surface(..), Volume(..) )&#13;
import Charge&#13;
    ( Charge, ChargeDistribution(..)&#13;
    , diskCap, protonOrigin, simpleDipole, lineDipole )</pre>&#13;
<p class="listing"><em>Listing 25-1: Opening lines of code for the <span class="codeitalic1">ElectricField</span> module</em></p>&#13;
<p class="indent">We use types and functions from the <span class="literal">SimpleVec</span> module of <a href="ch10.xhtml">Chapter 10</a>, the <span class="literal">CoordinateSystems</span> module of <a href="ch22.xhtml">Chapter 22</a>, the <span class="literal">Geometry</span> module of <a href="ch23.xhtml">Chapter 23</a>, and the <span class="literal">Charge</span> module of <a href="ch24.xhtml">Chapter 24</a>.</p>&#13;
<h3 class="h3" id="ch25lev3">Charge Creates an Electric Field</h3>&#13;
<p class="noindent">The first part of the modern two-part view of electricity is that electric charge creates the electric field. We want to calculate the electric field created by charges of various sorts. We’ll start with a point charge, the simplest charge distribution, and then move to more complex charge distributions.</p>&#13;
<h4 class="h4" id="ch25lev4"><span epub:type="pagebreak" id="page_476"/>Electric Field Created by a Point Charge</h4>&#13;
<p class="noindent">A particle with charge <em>q</em><sub>1</sub> located at position <strong>r</strong><sub>1</sub> will create an electric field <strong>E</strong> given by the following equation:</p>&#13;
<div class="imagec"><img src="Images/476equ01.jpg" alt="Image" width="450" height="57"/></div>&#13;
<p class="indent">The electric field <strong>E</strong> is a function from position to vectors (in other words, a vector field).</p>&#13;
<p class="indent">A positive point charge produces an electric field that points away from the positive charge. A negative point charge produces an electric field that points toward the negative charge.</p>&#13;
<p class="indent">We introduced the constant <em>ϵ</em><sub>0</sub>, called the <em>permittivity of free space</em>, in <a href="ch21.xhtml">Chapter 21</a>; it is defined as</p>&#13;
<div class="imagec"><img src="Images/476equ02.jpg" alt="Image" width="82" height="49"/></div>&#13;
<p class="noindent">where <em>c</em> is the speed of light in vacuum and <em>μ</em><sub>0</sub> is a constant called the <em>permeability of free space</em>.</p>&#13;
<pre>epsilon0 :: R&#13;
epsilon0 = 1/(mu0 * cSI**2)</pre>&#13;
<p class="indent">The speed of light in vacuum is exactly <em>c</em> = 299792458 m/s (the meter is defined to be the length that light travels in a vacuum in 1/299792458 s).</p>&#13;
<pre>cSI :: R&#13;
cSI = 299792458  -- m/s</pre>&#13;
<p class="indent">Prior to the 2019 SI revision, the constant <em>μ</em><sub>0</sub> was defined to be exactly <em>μ</em><sub>0</sub> = 4<em>π</em> × 10<sup>–7</sup> N/A<sup>2</sup>. The 2019 revision chooses other constants to be exact, leaving <em>μ</em><sub>0</sub> to be determined by experiment. Nevertheless, it remains very close to this value.</p>&#13;
<pre>mu0 :: R&#13;
mu0 = 4e-7 * pi  -- N/A^2</pre>&#13;
<p class="indent">We have <em>ϵ</em><sub>0</sub> and <em>μ</em><sub>0</sub> because the units in which we measure electric and magnetic fields (or voltage and current) are rooted in experiments measuring the forces between currents and charges. These experiments predate the modern electromagnetic theory based on Maxwell’s equations. Keeping the conventional units in the presence of Maxwell’s equations requires <em>ϵ</em><sub>0</sub> and <em>μ</em><sub>0</sub> to make the units work out. If you’re willing to give up the conventional units of current and voltage (amperes and volts), you can write Maxwell’s equations without <em>ϵ</em><sub>0</sub> and <em>μ</em><sub>0</sub>.</p>&#13;
<p class="indent">The function <span class="literal">eFieldFromPointCharge</span> encodes Equation 25.1, taking the point particle’s charge and position as input and producing the electric field as output.</p>&#13;
<span epub:type="pagebreak" id="page_477"/>&#13;
<pre>eFieldFromPointCharge&#13;
    :: Charge       -- in Coulombs&#13;
    -&gt; Position     -- of point charge (in m)&#13;
    -&gt; VectorField  -- electric field (in V/m)&#13;
eFieldFromPointCharge q1 r1 r&#13;
    = let k = 1 / (4 * pi * epsilon0)&#13;
          d = displacement r1 r&#13;
      in (k * q1) *^ d ^/ magnitude d ** 3</pre>&#13;
<p class="indent">The local name <span class="literal">d</span> stands for the displacement vector <strong>r</strong> – <strong>r</strong><sub>1</sub> from the charge’s position <strong>r</strong><sub>1</sub> to the <em>field point</em> <strong>r</strong>. The field point is a position where we are looking for or talking about the electric field. No particle or matter need be present at the field point.</p>&#13;
<p class="indent">In <a href="ch24.xhtml">Chapter 24</a>, we wrote a type for charge distribution. Over the course of the present chapter, we will write functions to calculate the electric field produced by each sort of charge distribution. This allows us to encapsulate the idea that charge creates an electric field in the following function, which produces an electric field given any charge distribution.</p>&#13;
<pre>eField :: ChargeDistribution -&gt; VectorField&#13;
eField (PointCharge   q   r) = eFieldFromPointCharge   q   r&#13;
eField (LineCharge    lam c) = eFieldFromLineCharge    lam c&#13;
eField (SurfaceCharge sig s) = eFieldFromSurfaceCharge sig s&#13;
eField (VolumeCharge  rho v) = eFieldFromVolumeCharge  rho v&#13;
eField (MultipleCharges cds) = addVectorFields $ map eField cds</pre>&#13;
<p class="indent">The function <span class="literal">eField</span> uses pattern matching on the input to treat each sort of charge distribution separately. For a point charge, it uses the function <span class="literal">eFieldFromPointCharge</span> we wrote earlier. For line, surface, and volume charges, it uses functions we’ll write later in this chapter. For a combination distribution with the constructor <span class="literal">MultipleCharges</span>, it uses the <em>principle of superposition</em>, which says that the electric field produced by multiple charges is the vector sum of the electric fields produced by each individual charge. In this case, we use the function <span class="literal">addVectorFields</span> from <a href="ch22.xhtml">Chapter 22</a> to combine the electric fields of the component distributions.</p>&#13;
<p class="indent">The function <span class="literal">eField</span> is an explicitly recursive function. We see this in the last line of the definition, where <span class="literal">eField</span> is defined in terms of <span class="literal">eField</span>. I have tried to avoid writing explicitly recursive functions because they are harder to understand. In this case, the explicit recursion appears only in the <span class="literal">MultipleCharges</span> clause. It means that when multiple charges are encountered, the appropriate thing to do is, first, find the electric field of each component charge (using the same <span class="literal">eField</span> function, but probably one of the other clauses), and, second, add these component electric fields together.</p>&#13;
<p class="indent">The electric field produced by a proton at the origin is given by the vector field <span class="literal">eField protonOrigin</span>, where <span class="literal">protonOrigin</span> is the charge distribution we wrote in <a href="ch24.xhtml">Chapter 24</a> for a proton at the origin. <a href="ch25.xhtml#ch25fig2">Figure 25-2</a> shows three ways of visualizing the electric field produced by a proton.</p>&#13;
<div class="imagel" id="ch25fig2"><span epub:type="pagebreak" id="page_478"/><img src="Images/478fig01.jpg" alt="Image" width="630" height="635"/></div>&#13;
<p class="figcap"><em>Figure 25-2: Three ways of visualizing the electric field <span class="codeitalic1">eField protonOrigin</span> produced by a proton. The upper-left image is produced by <span class="codeitalic1">eFieldPicProton2D</span>, the upper-right image is produced by <span class="codeitalic1">eFieldPicProtonGrad</span>, and the lower picture is a screenshot of the 3D interactive image produced by <span class="codeitalic1">eFieldPicProton3D</span>.</em></p>&#13;
<p class="indent">The following code produced the upper-left picture in <a href="ch25.xhtml#ch25fig2">Figure 25-2</a>.</p>&#13;
<pre>eFieldPicProton2D :: IO ()&#13;
eFieldPicProton2D&#13;
     = vfPNGxy "eFieldPicProton2D.png" 3e-9 pts (eField protonOrigin)&#13;
       where&#13;
         pts = [(r * cos th, r * sin th) | r &lt;- [1,1.5,2]&#13;
               , th &lt;- [0,pi/4 .. 2*pi]]</pre>&#13;
<p class="indent">Sample points lie in the xy-plane, but any plane through the point charge would give the same image. Each arrow represents the electric field at the location of the arrow’s tail. In this picture, electric field strength is proportional to the length of arrows displayed. Since the electric field produced by a point charge is inversely proportional to the square of the distance from the point charge, the length of these arrows would get arbitrarily long as we get closer to the point charge. Thus, we chose our sample points and scale factor so that no outrageously long arrows appear on our diagram.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_479"/>The electric field produced by a proton at a point 1 m away is as follows:</p>&#13;
<div class="imagec"><img src="Images/479equ01.jpg" alt="Image" width="568" height="53"/></div>&#13;
<p class="indent">The scale factor of <span class="literal">3e-9</span> means that an electric field of 3 × 10<sup>–9</sup> N/C is displayed with an arrow of length 1 m in the scale of the picture. The arrows closest to the proton are 1 m away. Their lengths should be about (1.4 × 10<sup>–9</sup> N/C)/(3 × 10<sup>–9</sup> N/C), or about half, of the distance from the proton to the tail of the vector, which is true in this picture.</p>&#13;
<p class="indent">Now consider the following code, which produced the upper-right picture in <a href="ch25.xhtml#ch25fig2">Figure 25-2</a>:</p>&#13;
<pre>eFieldPicProtonGrad :: IO ()&#13;
eFieldPicProtonGrad&#13;
    = vfGrad (**0.2) (\(x,y) -&gt; cart x y 0) (\v -&gt; (xComp v, yComp v))&#13;
      "eFieldPicProtonGrad.png" 20 (eField protonOrigin)</pre>&#13;
<p class="indent">Again, sample points lie in the xy-plane. Each arrow represents the electric field at the location of the arrow’s center. In this picture, the electric field is stronger at the darker arrows and weaker at the lighter arrows.</p>&#13;
<p class="indent">Lastly, we have the following code, which produced the lower picture in <a href="ch25.xhtml#ch25fig2">Figure 25-2</a>:</p>&#13;
<pre>eFieldPicProton3D :: IO ()&#13;
eFieldPicProton3D = vf3D 4e-9&#13;
                 [sph r th ph | r  &lt;- [1,1.5,2]&#13;
                              , th &lt;- [0,pi/4..pi]&#13;
                              , ph &lt;- [0,pi/4..2*pi]] (eField protonOrigin)</pre>&#13;
<p class="indent">If you run the program <span class="literal">eFieldPicProton3D</span>, perhaps by making a stand-alone program and calling it <span class="literal">main</span>, a 3D vector field will pop up. You can move it around and rotate it with your mouse or pointing device.</p>&#13;
<p class="indent">This concludes our discussion of the electric field produced by a single point charge. Next we’ll look at multiple charges.</p>&#13;
<h4 class="h4" id="ch25lev5">Electric Field Created by Multiple Charges</h4>&#13;
<p class="noindent">Equation 25.1 is the fundamental equation for the electric field produced by a point charge. The principle of superposition says that the electric field produced by multiple charges is the vector sum of the electric fields produced by each charge alone. For a collection of point charges, with <em>i</em> labeling the particles, <em>q<sub>i</sub></em> the charge of particle <em>i</em>, and <strong>r</strong><sub><em>i</em></sub> the location of particle <em>i</em>, the electric field produced at field point <strong>r</strong> by the collection is</p>&#13;
<div class="imagec"><img src="Images/479equ02.jpg" alt="Image" width="461" height="57"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_480"/>This principle of superposition is already encoded in our <span class="literal">eField</span> function. Whenever we have multiple charges in a charge distribution, they are tagged with a <span class="literal">MultipleCharges</span> data constructor, which tells the <span class="literal">eField</span> function to apply the superposition principle. We used this <span class="literal">MultipleCharges</span> data constructor in the last chapter when we wrote the <span class="literal">simpleDipole</span> charge distribution. So, although Equation 25.2 is a useful and important equation, telling us how to find the electric field from multiple point charges, we do not need to write any additional code; the superposition principle is already being applied automatically by the <span class="literal">eField</span> function.</p>&#13;
<p class="indent">As a first example of multiple charges, we’ll look at a simple electric dipole composed of two particles: one positively charged and the other with an equal but opposite negative charge.</p>&#13;
<h5 class="h5" id="ch25lev6">Electric Field of a Simple Electric Dipole</h5>&#13;
<p class="noindent">In the previous chapter, we introduced <span class="literal">simpleDipole</span>, a charge distribution composed of two oppositely charged point particles separated by some distance. The electric dipole moment of sodium chloride is 2.99 × 10<sup>–29</sup> C m. The interatomic distance between the sodium and chlorine atoms is 2.36 × 10<sup>–10</sup> m. If we think of NaCl as composed of two point particles, the sodium has an effective charge about 0.8 of the proton charge and the chlorine has an effective charge about – 0.8 of the proton charge. The effective charge is not an integer multiple of the elementary charge because the electrons are shared between the ions. Here is a charge distribution for NaCl, viewed as a simple electric dipole:</p>&#13;
<pre>simpleDipoleSodiumChloride :: ChargeDistribution&#13;
simpleDipoleSodiumChloride = simpleDipole (vec 0 0 2.99e-29) 2.36e-10</pre>&#13;
<p class="indent">To find the electric field of this charge distribution, we simply use the <span class="literal">eField</span> function. Since a <span class="literal">simpleDipole</span> is a charge distribution constructed with <span class="literal">MultipleCharges</span> of two <span class="literal">PointCharge</span>s, the <span class="literal">eField</span> function comes across the <span class="literal">MultipleCharges</span> constructor first and uses that clause in the definition. The <span class="literal">MultipleCharges</span> clause says to first find the electric field of each point charge, which it does by using <span class="literal">eField</span> itself, but this time with the <span class="literal">PointCharge</span> constructor. So <span class="literal">eField</span> actually gets used three times. We use it once, but then it uses itself two more times to find the electric fields of each point charge, and then adds them together and sends the result back to us.</p>&#13;
<pre>eFieldSodiumChloride :: VectorField&#13;
eFieldSodiumChloride = eField simpleDipoleSodiumChloride</pre>&#13;
<p class="indent">The left picture in <a href="ch25.xhtml#ch25fig3">Figure 25-3</a> shows the electric field produced by NaCl. The electric field points away from the positively charged sodium atom at the top of the picture and toward the negatively charged chlorine atom at the bottom of the picture. The right picture shows the electric field produced by an ideal dipole, described in the next section. We show them side by side in one figure to see what’s common and what’s different. The central <span epub:type="pagebreak" id="page_481"/>parts of the pictures are different because charge is located in different places. The outer parts of the pictures are similar; any electric dipole produces this same electric field pattern at places a little bit away from the source.</p>&#13;
<div class="imagel" id="ch25fig3"><img src="Images/481fig01.jpg" alt="Image" width="641" height="313"/></div>&#13;
<p class="figcap"><em>Figure 25-3: Electric field produced by a simple dipole (left) and an ideal dipole (right). The simple dipole consists of one positive point charge and one negative point charge. The left image shows the electric field <span class="codeitalic1">eFieldSodiumChloride</span> and is produced by <span class="codeitalic1">eFieldPicSimpleDipole</span>; the right image shows the electric field <span class="codeitalic1">eFieldIdealDipole kHat</span> and is produced by <span class="codeitalic1">eFieldPicIdealDipole</span>.</em></p>&#13;
<p class="indent">Here is the code that produced the picture on the left in <a href="ch25.xhtml#ch25fig3">Figure 25-3</a>:</p>&#13;
<pre>eFieldPicSimpleDipole :: IO ()&#13;
eFieldPicSimpleDipole&#13;
    = vfGrad (**0.2) (\(y,z) -&gt; cart 0 (3e-10*y) (3e-10*z))&#13;
      (\v -&gt; (yComp v, zComp v)) "eFieldPicSimpleDipole.png" 20&#13;
      eFieldSodiumChloride</pre>&#13;
<p class="indent">The picture shows a square in the yz-plane, in which <em>y</em> runs from –3 × 10<sup>–10</sup> m to 3 × 10<sup>–10</sup> m, and <em>z</em> runs across the same range. This is achieved by the mapping in the second input to <span class="literal">vfGrad</span>, which scales the parameters <span class="literal">y</span> and <span class="literal">z</span> by <span class="literal">3e-10</span>. Recall that the second input of the <span class="literal">vfGrad</span> function we wrote in <a href="ch22.xhtml">Chapter 22</a> specifies the region of interest by mapping a square from (–1,–1) to (1,1) into the region we wish to visualize.</p>&#13;
<h5 class="h5" id="ch25lev7">Ideal Electric Dipole</h5>&#13;
<p class="noindent">Equally but oppositely charged particles are an example of an electric dipole. An <em>ideal electric dipole</em> is a source of an electric field formed by letting the distance between these two particles approach zero while the charges increase in magnitude so that the electric dipole moment stays constant. Let’s look at the electric field produced by an ideal electric dipole.</p>&#13;
<p class="indent">The electric field produced by an ideal electric dipole at the origin is</p>&#13;
<div class="imagec"><img src="Images/481equ01.jpg" alt="Image" width="468" height="48"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_482"/>where <strong>p</strong> is the electric dipole moment. Here it is in Haskell:</p>&#13;
<pre>eFieldIdealDipole :: Vec          -- electric dipole moment&#13;
                  -&gt; VectorField  -- electric field&#13;
eFieldIdealDipole p r&#13;
    = let k = 1 / (4 * pi * epsilon0)  -- SI units&#13;
          rMag = magnitude (rVF r)&#13;
          rUnit = rVF r ^/ rMag&#13;
      in k *^ (1 / rMag**3) *^ (3 *^ (p &lt;.&gt; rUnit) *^ rUnit ^-^ p)</pre>&#13;
<p class="indent">The right side of <a href="ch25.xhtml#ch25fig3">Figure 25-3</a> shows the electric field produced by an ideal electric dipole. The magnitude of the electric dipole moment <strong>p</strong> is not so important in this picture because the darkest arrows are those where the electric field is largest in magnitude, regardless of what that magnitude is. Equation 25.3 shows that the electric field increases linearly with the dipole moment, so the picture would be the same for any dipole moment in the z-direction.</p>&#13;
<p class="indent">Comparing the two pictures in <a href="ch25.xhtml#ch25fig3">Figure 25-3</a>, we see that the electric field differs in the centers of the pictures, close to the sources of the field. The fields around the edges of the pictures, farther from the sources, are very similar in the two pictures. It is the similarity of the fields a bit farther from the sources that entitles both sources to be called electric dipoles.</p>&#13;
<p class="indent">Here is the code to produce the picture on the right in <a href="ch25.xhtml#ch25fig3">Figure 25-3</a>:</p>&#13;
<pre>eFieldPicIdealDipole :: IO ()&#13;
eFieldPicIdealDipole&#13;
    = vfGrad (**0.2) (\(y,z) -&gt; cart 0 (3e-10*y) (3e-10*z))&#13;
      (\v -&gt; (yComp v, zComp v)) "eFieldPicIdealDipole.png" 20&#13;
                                     (eFieldIdealDipole kHat)</pre>&#13;
<p class="indent">The only differences in this program compared to <span class="literal">eFieldPicSimpleDipole</span> for NaCl are the filenames and the electric fields. The electric field here is <span class="literal">eFieldIdealDipole kHat</span>, where we use the unit vector <span class="literal">kHat</span> for the electric dipole moment because its magnitude doesn’t change the picture.</p>&#13;
<p class="indent">We’ve seen an example of the electric field produced by multiple point charges and compared it to that of an ideal electric dipole. Continuous charge distributions can be though of as a case of multiple charges, where there are many charges spread over some region. Before we turn to the question of finding the electric field produced by specific continuous charge distributions, there are a few general remarks we can make.</p>&#13;
<h5 class="h5" id="ch25lev8">Continuous Distributions</h5>&#13;
<p class="noindent">When we move from discrete point charges to a charge that is continuously distributed, we replace the sum in Equation 25.2 with an integral. A general way to write this integral is as follows:</p>&#13;
<div class="imagec"><img src="Images/482equ01.jpg" alt="Image" width="463" height="59"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_483"/>In Equation 25.4, we’ve replaced discrete quantities with continuous ones, as indicated in <a href="ch25.xhtml#ch25tab1">Table 25-1</a>, which shows the correspondence between discrete and continuous quantities.</p>&#13;
<p class="tabcap" id="ch25tab1"><strong>Table 25-1:</strong> Correspondence Between Discrete and Continuous Quantities in the Electric Field Produced by Charge</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"> </p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><strong>Discrete</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><strong>Continuous</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba">Aggregation method</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba">∑<sub><em>i</em></sub></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba">∫</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">Quantity of charge</p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><em>q<sub>i</sub></em></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><em>dq</em>′</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">Location of charge</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><strong>r</strong><em><sub>i</sub></em></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><strong>r</strong>′</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The form of the integral in Equation 25.4 is so general that we have not even specified whether the charge is distributed along a 1D curve, across a 2D surface, or throughout a 3D volume. In any case, the integral is defined by a limiting process in which the quantities of charge <em>dq</em>′ become arbitrarily small and the number of charges becomes arbitrarily large.</p>&#13;
<p class="indent">Sometimes we can evaluate such an integral exactly; however, more often, we need to compute an approximation to the integral. We do this computationally by turning the continuous integral back into a discrete sum, basically by turning Equation 25.4 back into Equation 25.2. The details depend on whether we are integrating over a 1D curve, a 2D surface, or a 3D volume. We take up each of these cases in turn in the sections that follow.</p>&#13;
<h4 class="h4" id="ch25lev9">Electric Field Created by a Line Charge</h4>&#13;
<p class="noindent">As we discussed in the previous chapter, a line charge is specified by a curve <em>C</em> and a scalar field <em>λ</em> representing the linear charge density at any point on the curve. When charge is spread along a one-dimensional curve, a little bit of charge <em>dq</em>′ at position <strong>r</strong>′ is given by the product of the linear charge density <em>λ</em>(<strong>r</strong>) and the length <em>dl</em>′ of a small section of the curve near <strong>r</strong>′.</p>&#13;
<p class="centere"><em>dq</em>′ = <em>λ</em>(<strong>r</strong>′) <em>dl</em>′</p>&#13;
<p class="indent">We then write the integral of Equation 25.4 as follows:</p>&#13;
<div class="imagec"><img src="Images/483equ01.jpg" alt="Image" width="487" height="59"/></div>&#13;
<p class="indent">Such an integral of a vector field over a curve is called a <em>vector line integral</em>. Let’s explain the vector line integral in more detail.</p>&#13;
<h5 class="h5" id="ch25lev10">Vector Line Integral</h5>&#13;
<p class="noindent">The vector line integral takes a vector field and a curve as input and returns a vector as output.</p>&#13;
<pre>type VectorLineIntegral = VectorField -&gt; Curve -&gt; Vec</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_484"/>The vector line integral of a vector field <strong>F</strong> over a curve <em>C</em> is written</p>&#13;
<div class="imagec"><img src="Images/484equ01.jpg" alt="Image" width="91" height="48"/></div>&#13;
<p class="indent">What does this integral mean? The integral is defined by dividing the curve <em>C</em> into many small segments. The vector field <strong>F</strong> is evaluated at each point <strong>r</strong><sub><em>i</em></sub> on or near the segment Δ<strong>l</strong><sub><em>i</em></sub> and scaled (multiplied) by the length Δ<em>l<sub>i</sub></em> of the segment. We then add up these vectors to form the sum</p>&#13;
<div class="imagec"><img src="Images/484equ02.jpg" alt="Image" width="102" height="46"/></div>&#13;
<p class="indent">The integral is the limit of this vector sum as the lengths of the segments approach 0 and the number of segments becomes arbitrarily large. The definition of the integral involves careful specification of the limiting process, which we’ll leave to textbooks on vector calculus.</p>&#13;
<p class="indent">The integral is not only defined by, but also approximated by, a finite sum.</p>&#13;
<div class="imagec"><img src="Images/484equ03.jpg" alt="Image" width="458" height="55"/></div>&#13;
<p class="indent">Our approximate calculation of the integral will use a finite number of segments. We will need a method to approximate a curve by a finite list of segments. We’ll represent a segment Δ<strong>l</strong><sub><em>i</em></sub> as a short displacement vector lying along the curve. In addition to the displacement vector Δ<strong>l</strong><sub><em>i</em></sub>, which describes the length and orientation of the segment, we also need a position <strong>r</strong><sub><em>i</em></sub> indicating where the segment is located on the curve. An approximation to a curve consists of a list of pairs of positions and displacement vectors. Notice that the lengths of the segments need not be the same. A curve approximation method is a function that returns such a list when given a curve.</p>&#13;
<pre>type CurveApprox = Curve -&gt; [(Position,Vec)]</pre>&#13;
<p class="indent">A pair looks like (<strong>r</strong><sub><em>i</em></sub>, Δ<strong>l</strong><sub><em>i</em></sub>). We could use many curve approximation methods; we’ll delay discussion of a curve approximation method to the final section of this chapter.</p>&#13;
<p class="indent">Here’s the Haskell definition of a vector line integral:</p>&#13;
<pre>vectorLineIntegral :: CurveApprox -&gt; VectorField -&gt; Curve -&gt; Vec&#13;
vectorLineIntegral approx vF c&#13;
    = sumV [vF r' ^* magnitude dl' | (r',dl') &lt;- approx c]</pre>&#13;
<p class="indent">The curve <span class="literal">c</span> is approximated by the function <span class="literal">approx</span>, which is provided as an input. The function <span class="literal">approx</span> will specify the number of segments into which the curve is to be divided, as well as the method for the division and determination of the associated positions of the segments. For each segment <span class="literal">dl'</span> at position <span class="literal">r'</span>, the vector field <span class="literal">vF</span> is evaluated at position <span class="literal">r'</span> and scaled by the magnitude of <span class="literal">dl'</span>. We then sum these vectors to give the approximation to the integral. <a href="ch25.xhtml#ch25tab2">Table 25-2</a> shows a correspondence between mathematical notation and Haskell notation in the definition of the vector line integral.</p>&#13;
<p class="tabcap" id="ch25tab2"><span epub:type="pagebreak" id="page_485"/><strong>Table 25-2:</strong> Correspondence Among Continuous Mathematical Notation, Discrete Mathematical Notation, and Haskell Notation for the Vector Line Integral</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:33%"/>&#13;
<col style="width:33%"/>&#13;
<col style="width:34%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><strong>Continuous math</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><strong>Discrete math</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><strong>Haskell</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="backcolort1"><p class="taba">∫</p></td>&#13;
<td style="vertical-align: top;" class="backcolort1"><p class="taba">∑<sub><em>i</em></sub></p></td>&#13;
<td style="vertical-align: top;" class="backcolort1"><p class="taba"><span class="literal">sumV</span> <span class="ent">➊</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><strong>r</strong>′</p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><strong>r</strong><sub><em>i</em></sub></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">r'</span> <span class="ent">➋</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><strong>F</strong></p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><strong>F</strong></p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><span class="literal">vF</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><strong>F</strong>(<strong>r</strong>′)</p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><strong>F</strong>(<strong>r</strong><sub><em>i</em></sub>)</p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">vF r'</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><em>C</em></p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"> </p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><span class="literal">c</span> <span class="ent">➌</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><em>dl</em>′</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">Δ<strong>l</strong><sub><em>i</em></sub></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">dl'</span> <span class="ent">➍</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><em>dl</em>′</p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba">Δ<em>l<sub>i</sub></em></p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><span class="literal">magnitude dl'</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><strong>F</strong>(<strong>r</strong>′)<em>dl</em>′</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><strong>F</strong>(<strong>r</strong><sub><em>i</em></sub>)Δ<em>l<sub>i</sub></em></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">vF r' ^* magnitude dl'</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Surprisingly, Haskell notation is closer to discrete notation only in the summation <span class="ent">➊</span>. The Haskell names we chose for segment location <span class="ent">➋</span>, curve <span class="ent">➌</span>, and segment displacement <span class="ent">➍</span> are closer to the continuous notation. This is because Haskell does not require the index <em>i</em> used in the discrete notation, so there is no reason to introduce it. Haskell computes the integral in a discrete way, but Haskell’s list syntax avoids the need to talk about the index <em>i</em> that would number the list elements.</p>&#13;
<h5 class="h5" id="ch25lev11">Back to Electric Field</h5>&#13;
<p class="noindent">From Equation 25.5, we see that the vector field <strong>F</strong> we want to integrate to find the electric field produced by a line charge is the function that maps the position <strong>r</strong>′ of a piece of charge to the vector</p>&#13;
<div class="imagec"><img src="Images/485equ01.jpg" alt="Image" width="110" height="61"/></div>&#13;
<p class="noindent">in which <strong>r</strong> is the field point, the fixed position where we want to know the electric field. In the function <span class="literal">eFieldFromLineCharge</span> below, this function is given the local name <span class="literal">integrand</span>. The local name <span class="literal">d</span> stands for the displacement <strong>r</strong> – <strong>r</strong>′ from the source point <strong>r</strong>′ to the field point <strong>r</strong>. Because the source point <span class="literal">r'</span> is introduced as a name local to the <span class="literal">integrand</span> function, we must define <span class="literal">d</span> with a <span class="literal">where</span> clause, rather than alongside the definitions of <span class="literal">k</span> and <span class="literal">integrand</span>.</p>&#13;
<pre>eFieldFromLineCharge&#13;
    :: ScalarField  -- linear charge density lambda&#13;
    -&gt; Curve        -- geometry of the line charge&#13;
    -&gt; VectorField  -- electric field (in V/m)&#13;
eFieldFromLineCharge lambda c r&#13;
    = let k = 1 / (4 * pi * epsilon0)&#13;
          integrand r' = lambda r' *^ d ^/ magnitude d ** 3&#13;
              where d = displacement r' r&#13;
      in k *^ vectorLineIntegral (curveSample 1000) integrand c</pre>&#13;
<p class="indent">We need to give only two items to find the electric field produced by a line charge: the linear charge density, expressed as a scalar field, and the <span epub:type="pagebreak" id="page_486"/>curve that describes the geometry of the line charge. The type signature of the function <span class="literal">eFieldFromLineCharge</span> makes it clear that the electric field depends only on these two items. We use the <span class="literal">vectorLineIntegral</span> we defined earlier. The curve approximation method <span class="literal">curveSample 1000</span> divides the curve into 1,000 segments and is defined later in the chapter.</p>&#13;
<p class="indent">Now that we’ve shown how to find the electric field for a line charge, let’s look at the electric field produced by the line dipole <span class="literal">lineDipole</span> we discussed in the previous chapter.</p>&#13;
<h5 class="h5" id="ch25lev12">Example of a Line Dipole</h5>&#13;
<p class="noindent">In the previous chapter, we introduced <span class="literal">lineDipole</span>, a line charge with a linearly varying charge density. Suppose we had reason to believe that the charge distribution of NaCl looked more like that of a line dipole than a simple dipole. I have no such evidence, and the charge distribution of NaCl is probably complicated, but it’s certainly reasonable to imagine that the charge density varies smoothly, if not linearly, from sodium to chlorine. To model NaCl as a line dipole, we can use the same electric dipole moment and interatomic separation we used earlier for the simple dipole. Here is a charge distribution for NaCl, viewed as a line dipole:</p>&#13;
<pre>lineDipoleSodiumChloride :: ChargeDistribution&#13;
lineDipoleSodiumChloride = lineDipole (vec 0 0 2.99e-29) 2.36e-10</pre>&#13;
<p class="indent">We can find the electric field of this charge distribution with the <span class="literal">eField</span> function, which in this case will use the <span class="literal">eFieldFromLineCharge</span> function we wrote earlier.</p>&#13;
<pre>eFieldLineDipole :: VectorField&#13;
eFieldLineDipole = eField lineDipoleSodiumChloride</pre>&#13;
<p class="indent">Exercise 25.11 asks you to make a vector field picture for this electric field, similar to the ones we made earlier for the simple dipole and the ideal dipole.</p>&#13;
<p class="indent">Now that we’ve discussed how to find the electric field from our first continuous charge distribution, that of a line charge, and shown an example, let’s turn to our second continuous charge distribution, that of a surface charge.</p>&#13;
<h4 class="h4" id="ch25lev13">Electric Field Created by a Surface Charge</h4>&#13;
<p class="noindent">As we discussed in the previous chapter, a surface charge is specified by a surface <em>S</em> and a scalar field <em>σ</em> representing the surface charge density at any point on the surface. When charge is spread along a 2D surface, a little bit of charge <em>dq</em>′ at position <strong>r</strong>′ is given by the product of the surface charge density <em>σ</em>(<strong>r</strong>′) and the area <em>da</em>′ of a small patch of the surface near <strong>r</strong>′.</p>&#13;
<p class="centere"><em>dq</em>′ = σ(<strong>r</strong>′) <em>da</em>′</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_487"/>We then write the integral of Equation 25.4 as follows:</p>&#13;
<div class="imagec"><img src="Images/487equ01.jpg" alt="Image" width="513" height="61"/></div>&#13;
<p class="indent">Such an integral of a vector field over a surface is called a <em>vector surface integral</em>. Let’s explain the vector surface integral in more detail.</p>&#13;
<h5 class="h5" id="ch25lev14">Vector Surface Integral</h5>&#13;
<p class="noindent">The vector surface integral takes a vector field and a surface as input and returns a vector as output.</p>&#13;
<pre>type VectorSurfaceIntegral = VectorField -&gt; Surface -&gt; Vec</pre>&#13;
<p class="indent">The vector surface integral of a vector field <strong>F</strong> over a surface <em>S</em> is written as follows:</p>&#13;
<div class="imagec"><img src="Images/487equ02.jpg" alt="Image" width="94" height="48"/></div>&#13;
<p class="indent">We define the integral by dividing the surface <em>S</em> into many small patches. You can think of a patch as a quadrilateral, but what’s really important is the location, area, and orientation of the patch rather than its shape. Each patch Δ<strong>a</strong><sub><em>i</em></sub> is a vector area whose magnitude gives the area of the patch and whose direction points perpendicular to the patch. We assume each patch is small enough to be considered flat. Because our surfaces are oriented, as we discussed in <a href="ch23.xhtml">Chapter 23</a>, the direction for the patch is unambiguous. The vector field <strong>F</strong> is evaluated at a point <strong>r</strong><sub><em>i</em></sub> on or near the patch Δ<strong>a</strong><sub><em>i</em></sub> and scaled by the area <em>Δa<sub>i</sub></em> of the patch. We then add up these vectors to form the sum</p>&#13;
<div class="imagec"><img src="Images/487equ03.jpg" alt="Image" width="107" height="47"/></div>&#13;
<p class="indent">The integral is the limit of this vector sum as the areas of the patches approach 0 and the number of patches becomes arbitrarily large.</p>&#13;
<p class="indent">The integral is not only defined by, but also approximated by, a finite sum.</p>&#13;
<div class="imagec"><img src="Images/487equ04.jpg" alt="Image" width="230" height="55"/></div>&#13;
<p class="indent">Our approximate calculation of the integral will use a finite number of patches. We will need a method to divide a surface into a list of patches. We’ll represent an oriented patch Δ<strong>a</strong><sub><em>i</em></sub> as a vector perpendicular to the surface. In addition to the vector Δ<strong>a</strong><sub><em>i</em></sub>, which describes the area and orientation of the patch, we also need a position <strong>r</strong><sub><em>i</em></sub> indicating where the patch is located on the surface. An approximation to a surface consists of a list of pairs of positions and area vectors.</p>&#13;
<pre>type SurfaceApprox = Surface -&gt; [(Position,Vec)]</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_488"/>A pair looks like (<strong>r</strong><sub><em>i</em></sub>, Δ<strong>a</strong><sub><em>i</em></sub>). There are many ways the surface approximation could be done, and we’ll delay discussion of this point to the last section of this chapter.</p>&#13;
<p class="indent">Here’s the Haskell definition of a vector surface integral:</p>&#13;
<pre>vectorSurfaceIntegral :: SurfaceApprox -&gt; VectorField -&gt; Surface -&gt; Vec&#13;
vectorSurfaceIntegral approx vF s&#13;
    = sumV [vF r' ^* magnitude da' | (r',da') &lt;- approx s]</pre>&#13;
<p class="indent">The surface <span class="literal">s</span> is approximated by the function <span class="literal">approx</span>, which is provided as an input. The function <span class="literal">approx</span> will specify the number of patches into which the surface is to be divided, as well as the method for the division and determination of the associated positions of the patches. For each patch <span class="literal">da'</span> at position <span class="literal">r'</span>, the vector field <span class="literal">vF</span> is evaluated at position <span class="literal">r'</span> and scaled by the magnitude of <span class="literal">da'</span>. We then sum these vectors to give the approximation to the integral. <a href="ch25.xhtml#ch25tab3">Table 25-3</a> shows a correspondence between mathematical notation and Haskell notation in the definition of the vector surface integral.</p>&#13;
<p class="tabcap" id="ch25tab3"><strong>Table 25-3:</strong> Correspondence Among Continuous Mathematical Notation, Discrete Mathematical Notation, and Haskell Notation for the Vector Surface Integral</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><strong>Continuous math</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><strong>Discrete math</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><strong>Haskell</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="backcolort1"><p class="taba">∫</p></td>&#13;
<td style="vertical-align: top;" class="backcolort1"><p class="taba">∑<sub><em>i</em></sub></p></td>&#13;
<td style="vertical-align: top;" class="backcolort1"><p class="taba"><span class="literal">sumV</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><strong>r</strong>′</p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><strong>r</strong><sub><em>i</em></sub></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">r'</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><strong>F</strong></p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><strong>F</strong></p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><span class="literal">vF</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><strong>F</strong>(<strong>r</strong>′)</p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><strong>F</strong>(<strong>r</strong><sub><em>i</em></sub>)</p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">vF r'</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><em>S</em></p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"> </p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><span class="literal">s</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><em>d</em><strong>a</strong>′</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">Δ<strong>a</strong><sub><em>i</em></sub></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">da'</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><em>da</em>′</p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba">Δ<em>a<sub>i</sub></em></p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><span class="literal">magnitude da'</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><strong>F</strong>(<strong>r</strong>′)<em>da</em>′</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><strong>F</strong>(<strong>r</strong><sub><em>i</em></sub>)Δ<em>a<sub>i</sub></em></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">vF r' ^* magnitude da'</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The first four rows of <a href="ch25.xhtml#ch25tab3">Table 25-3</a> are identical to those of <a href="ch25.xhtml#ch25tab2">Table 25-2</a> for the vector line integral because they refer to the vector field and the integration. The last four rows of this table are analogous to those of the previous table, with surface patches substituting for line segments.</p>&#13;
<h5 class="h5" id="ch25lev15">Back to Electric Field</h5>&#13;
<p class="noindent">From Equation 25.7, we see that the vector field <strong>F</strong> we want to integrate to find the electric field produced by a line charge is the function that maps the position <strong>r</strong>′ of a piece of charge to the vector</p>&#13;
<div class="imagec"><img src="Images/488equ01.jpg" alt="Image" width="119" height="59"/></div>&#13;
<p class="indent">Here we consider <strong>r</strong> the fixed position where we want to know the electric field. In the function <span class="literal">eFieldFromSurfaceCharge</span> next, which is a Haskell translation of Equation 25.7, we give this function the local name <span class="literal">integrand</span>. The local name <span class="literal">d</span> stands for the displacement <strong>r</strong> – <strong>r</strong>′ from the charge to the <span epub:type="pagebreak" id="page_489"/>field point. Because we introduce the source point <span class="literal">r'</span> as a name local to the <span class="literal">integrand</span> function, we must define <span class="literal">d</span> with a <span class="literal">where</span> clause rather than alongside the definitions of <span class="literal">k</span> and <span class="literal">integrand</span>.</p>&#13;
<pre>eFieldFromSurfaceCharge&#13;
    :: ScalarField  -- surface charge density sigma&#13;
    -&gt; Surface      -- geometry of the surface charge&#13;
    -&gt; VectorField  -- electric field (in V/m)&#13;
eFieldFromSurfaceCharge sigma s r&#13;
    = let k = 1 / (4 * pi * epsilon0)&#13;
          integrand r' = sigma r' *^ d ^/ magnitude d ** 3&#13;
              where d = displacement r' r&#13;
      in k *^ vectorSurfaceIntegral (surfaceSample 200) integrand s</pre>&#13;
<p class="indent">We need to give only two items to find the electric field produced by a surface charge: the surface charge density <em>σ</em>, expressed as a scalar field, and the surface that describes the geometry of the surface charge. The type signature of <span class="literal">eFieldFromSurfaceCharge</span> makes it clear that the electric field depends only on these two items. We use the <span class="literal">vectorSurfaceIntegral</span> we defined earlier. The function <span class="literal">surfaceSample 200</span> divides the curve into 2(200)<sup>2</sup> = 80,000 patches and is defined later in the chapter.</p>&#13;
<p class="indent">Now that we’ve shown how to find the electric field for a surface charge, let’s look at the electric field produced by the capacitor <span class="literal">diskCap</span> we discussed in the previous chapter.</p>&#13;
<h5 class="h5" id="ch25lev16">Example of a Capacitor</h5>&#13;
<p class="noindent">Let’s find the electric field produced by a parallel-plate capacitor whose plates are uniformly charged. The assumption of uniform charge is good when the plates are close together and worsens as the plates are moved farther apart. Suppose we have a capacitor with a plate separation of 4 cm in which the plates are disks with radius 5 cm. The positive plate has a surface charge density of 20 nC/m<sup>2</sup>, and the negative plate has a surface charge density of – 20 nC/m<sup>2</sup>. The expression</p>&#13;
<pre>diskCap 0.05 0.04 2e-8 :: ChargeDistribution</pre>&#13;
<p class="noindent">represents this charge distribution.</p>&#13;
<p class="indent">We can find the electric field with the <span class="literal">eField</span> function.</p>&#13;
<pre>eFieldDiskCap :: VectorField&#13;
eFieldDiskCap = eField $ diskCap 0.05 0.04 2e-8</pre>&#13;
<p class="indent">In this case, <span class="literal">eField</span> uses the function <span class="literal">eFieldFromSurfaceCharge</span> we defined earlier. To start, let’s look at the electric field at the center of the capacitor.</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:l ElectricField</span>&#13;
[ 1 of 12] Compiling Newton2          ( Newton2.hs, interpreted )&#13;
[ 2 of 12] Compiling Mechanics1D      ( Mechanics1D.hs, interpreted )&#13;
[ 3 of 12] Compiling SimpleVec        ( SimpleVec.hs, interpreted )<span epub:type="pagebreak" id="page_490"/>&#13;
[ 4 of 12] Compiling Mechanics3D      ( Mechanics3D.hs, interpreted )&#13;
[ 5 of 12] Compiling MultipleObjects  ( MultipleObjects.hs, interpreted )&#13;
[ 6 of 12] Compiling MOExamples       ( MOExamples.hs, interpreted )&#13;
[ 7 of 12] Compiling Electricity      ( Electricity.hs, interpreted )&#13;
[ 8 of 12] Compiling CoordinateSystems ( CoordinateSystems.hs, interpreted )&#13;
[ 9 of 12] Compiling Geometry         ( Geometry.hs, interpreted )&#13;
[10 of 12] Compiling VectorIntegrals  ( VectorIntegrals.hs, interpreted )&#13;
[11 of 12] Compiling Charge           ( Charge.hs, interpreted )&#13;
[12 of 12] Compiling ElectricField    ( ElectricField.hs, interpreted )&#13;
Ok, 12 modules loaded.&#13;
*ElectricField&gt; <span class="codestrong1">eFieldDiskCap (cart 0 0 0)</span>&#13;
vec 0.0 0.0 (-1419.9046806406095)</pre>&#13;
<p class="indent">The electric field is in the negative z-direction, pointing from the positive plate above toward the negative plate below.</p>&#13;
<p class="indent">For comparison, a parallel-plate capacitor with infinitely wide plates and surface charge density <em>σ</em> has electric field <em>σ</em>/<em>ϵ</em><sub>0</sub>. Physicists like the ideal parallel-plate capacitor with infinitely wide plates because there is a simple expression for the electric field it produces. The electric field outside the ideal capacitor is 0. The electric field inside the ideal capacitor (between the two plates) has a uniform value of <em>σ</em>/<em>ϵ</em><sub>0</sub> and points from the positive plate toward the negative plate. The electric field produced is independent of the plate separation. For a surface charge density of <em>σ</em> = 20 nC/m<sup>2</sup>, the electric field magnitude would be</p>&#13;
<div class="imagec"><img src="Images/490equ01.jpg" alt="Image" width="366" height="54"/></div>&#13;
<p class="indent">The value we found earlier is less than this ideal value (in magnitude) because the radii of our plates are rather modest.</p>&#13;
<p class="indent"><a href="ch25.xhtml#ch25fig4">Figure 25-4</a> shows the electric field produced by our disk capacitor.</p>&#13;
<div class="imagel" id="ch25fig4"><img src="Images/490fig01.jpg" alt="Image" width="326" height="327"/></div>&#13;
<p class="figcap"><em>Figure 25-4: Electric field <span class="codeitalic1">eFieldDiskCap</span> produced by a parallel-plate capacitor. The plates have uniform surface charge density. (Image produced by <span class="codeitalic1">eFieldPicDiskCap</span>.)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_491"/><a href="ch25.xhtml#ch25fig4">Figure 25-4</a> shows the region from –10 cm to 10 cm in the x-direction, and from –10 cm to 10 cm in the z-direction. The radii of the disks are 5 cm, so they extend horizontally over half the width of the figure. The electric field is largest in magnitude where the arrows are darkest, between the plates. The field is smaller outside the plates, but it’s not 0. The electric field appears to be fairly uniform between the plates. We see from the shading how the electric field transitions from its maximum between the plates, to moderate values near the edges of the disks, to minimal values farther from the plates. Around the outside of the picture, the electric field looks like that of an electric dipole, which is not surprising since the capacitor is an electric dipole consisting of a positive plate and a negative plate.</p>&#13;
<p class="indent">Here’s the code that produced <a href="ch25.xhtml#ch25fig4">Figure 25-4</a>:</p>&#13;
<pre>eFieldPicDiskCap :: IO ()&#13;
eFieldPicDiskCap = vfGrad (**0.2) (\(x,z) -&gt; cart (0.1*x) 0 (0.1*z))&#13;
                (\v -&gt; (xComp v, zComp v)) "eFieldPicDiskCap.png" 20&#13;
                eFieldDiskCap</pre>&#13;
<p class="indent">The program might take several minutes to run. The surface and volume charge integrals involve many computations and can be slow. The methods used here are ones that are conceptually simple rather than numerically efficient. The slowness is mostly a consequence of the simple approach and is not inherent in the use of the Haskell language. There are data structures, such as unboxed vectors, that would speed up many of the operations here, at the expense of making the code less concise.</p>&#13;
<p class="indent">We’ve talked about line charges and surface charges. Let’s turn to the third and last of our continuous charge distributions: the volume charge.</p>&#13;
<h4 class="h4" id="ch25lev17">Electric Field Created by a Volume Charge</h4>&#13;
<p class="noindent">As we discussed in the previous chapter, a volume charge is specified by a volume <em>V</em> and a scalar field <em>ρ</em> representing the volume charge density at any point in the volume. When charge is spread throughout a 3D volume, a little bit of charge <em>dq</em>′ at position <strong>r</strong>′ is given by the product of the volume charge density <em>ρ</em>(<strong>r</strong>′) and the volume <em>dv</em>′ of a small portion of the volume near <strong>r</strong>′.</p>&#13;
<p class="centere"><em>dq</em>′ = <em>ρ</em>(<strong>r</strong>′) <em>dv</em>′</p>&#13;
<p class="indent">We then write the integral of Equation 25.4 as follows:</p>&#13;
<div class="imagec"><img src="Images/491equ01.jpg" alt="Image" width="488" height="59"/></div>&#13;
<p class="indent">Such an integral of a vector field over a volume is called a <em>vector volume integral</em>. Let’s explore the vector volume integral in more detail.</p>&#13;
<h5 class="h5" id="ch25lev18">Vector Volume Integral</h5>&#13;
<p class="noindent">The vector volume integral takes a vector field and a volume as input and returns a vector as output.</p>&#13;
<span epub:type="pagebreak" id="page_492"/>&#13;
<pre>type VectorVolumeIntegral = VectorField -&gt; Volume -&gt; Vec</pre>&#13;
<p class="indent">The vector volume integral of a vector field <strong>F</strong> over a volume <em>V</em> is written as follows:</p>&#13;
<div class="imagec"><img src="Images/492equ01.jpg" alt="Image" width="95" height="48"/></div>&#13;
<p class="indent">The integral is defined by dividing the volume <em>V</em> into many small portions. The vector field <strong>F</strong> is evaluated at each point <strong>r</strong><sub><em>i</em></sub> on or near the portion and scaled by the volume Δ<em>v<sub>i</sub></em> of the portion. We then add up these vectors to form the sum</p>&#13;
<div class="imagec"><img src="Images/492equ02.jpg" alt="Image" width="111" height="46"/></div>&#13;
<p class="indent">The integral is the limit of this vector sum as the volumes of the portions approach 0 and the number of portions becomes arbitrarily large.</p>&#13;
<p class="indent">The integral is both defined by and approximated by a finite sum:</p>&#13;
<div class="imagec"><img src="Images/492equ03.jpg" alt="Image" width="230" height="55"/></div>&#13;
<p class="indent">Our approximate calculation of the integral will use a finite number of portions. We’ll represent a portion by its location <strong>r</strong><sub><em>i</em></sub> and its volume Δ<em>v<sub>i</sub></em>. An approximation to a volume consists of a list of pairs of positions and portion volumes. A volume approximation method is a function that returns such a list when given a volume.</p>&#13;
<pre>type VolumeApprox = Volume -&gt; [(Position,R)]</pre>&#13;
<p class="indent">A pair looks like (<strong>r</strong><sub><em>i</em></sub>, Δ<em>v<sub>i</sub></em>). Many volume approximation methods could be used, and, as before, we’ll delay discussion of this point until later in the chapter.</p>&#13;
<p class="indent">Here’s the Haskell definition of a vector volume integral:</p>&#13;
<pre>vectorVolumeIntegral :: VolumeApprox -&gt; VectorField -&gt; Volume -&gt; Vec&#13;
vectorVolumeIntegral approx vF vol&#13;
    = sumV [vF r' ^* dv' | (r',dv') &lt;- approx vol]</pre>&#13;
<p class="indent">The volume <span class="literal">vol</span> is approximated by the function <span class="literal">approx</span>, giving a list of portion locations and volumes. For each portion <span class="literal">(r',dv')</span>, the vector field <span class="literal">vF</span> is evaluated at position <span class="literal">r'</span> and scaled by <span class="literal">dv'</span>. We then sum these vectors to give the approximation to the integral.</p>&#13;
<p class="indent"><a href="ch25.xhtml#ch25tab4">Table 25-4</a> shows a correspondence between mathematical notation and Haskell notation in the definition of the vector volume integral.</p>&#13;
<p class="tabcap" id="ch25tab4"><strong>Table 25-4:</strong> Correspondence Among Continuous Mathematical Notation, Discrete Mathematical Notation, and Haskell Notation for the Vector Volume Integral</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><strong>Continuous math</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><strong>Discrete math</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><strong>Haskell</strong></p></td></tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><em>V</em></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"> </p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_top"><p class="taba"><span class="literal">vol</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><em>dv</em>′</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">Δ<em>v<sub>i</sub></em></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">dv'</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><strong>F</strong>(<strong>r</strong>′)<em>dv</em>′</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><strong>F</strong>(<strong>r</strong><sub><em>i</em></sub>)Δ<em>v<sub>i</sub></em></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><span class="literal">vF r' ^* dv'</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_493"/>This table is analogous to the last few rows of <a href="ch25.xhtml#ch25tab3">Table 25-3</a>. One important difference between the two is that each patch for a surface integral is a vector, while each bit of volume for a volume integral is a scalar.</p>&#13;
<h5 class="h5" id="ch25lev19">Back to Electric Field</h5>&#13;
<p class="noindent">We need to give only two items to find the electric field produced by a volume charge: the volume charge density <em>ρ</em>, expressed as a scalar field, and the volume that describes the geometry of the charge. The type signature of the following function, which is a Haskell translation of Equation 25.8, makes it clear that the electric field depends only on these two items:</p>&#13;
<pre>eFieldFromVolumeCharge&#13;
    :: ScalarField  -- volume charge density rho&#13;
    -&gt; Volume       -- geometry of the volume charge&#13;
    -&gt; VectorField  -- electric field (in V/m)&#13;
eFieldFromVolumeCharge rho v r&#13;
    = let k = 1 / (4 * pi * epsilon0)&#13;
          integrand r' = rho r' *^ d ^/ magnitude d ** 3&#13;
              where d = displacement r' r&#13;
      in k *^ vectorVolumeIntegral (volumeSample 50) integrand v</pre>&#13;
<p class="indent">Now that we have functions to calculate the electric field produced by a line charge, a surface charge, and a volume charge, we have completed the definition of <span class="literal">eField</span> we began earlier in the chapter. We now have a method to find the electric field produced by any charge distribution. In writing functions to calculate the electric field, we spent some time discussing three types of vector integrals: the vector line integral for line charges, the vector surface integral for surface charges, and the vector volume integral for volume charges. With these integrals fresh in our minds, now is a good time to extend our integral methods to scalar integrals, which we used in the last chapter to calculate total charge.</p>&#13;
<h3 class="h3" id="ch25lev20"><span epub:type="pagebreak" id="page_494"/>Scalar Integrals</h3>&#13;
<p class="noindent">In the process of calculating the electric field produced by a line charge, a surface charge, or a volume charge, we introduced the vector line integral, the vector surface integral, and the vector volume integral. We used these integrals to add up the vector contributions to the electric field from each piece of charge. There are situations in which we need to add up scalar contributions to some quantity that come from sources on a curve, a surface, or a volume. This is the purpose of the scalar line integral, scalar surface integral, and scalar volume integral. Now that we have gone through the details for the vector integrals, it will be relatively easy to understand the scalar integrals.</p>&#13;
<h4 class="h4" id="ch25lev21">Scalar Line Integral</h4>&#13;
<p class="noindent">The scalar line integral takes a scalar field <em>f</em> and a curve <em>C</em> as input and returns a scalar as output.</p>&#13;
<pre>type ScalarLineIntegral = ScalarField -&gt; Curve -&gt; R</pre>&#13;
<p class="indent">The integral is defined, and also approximated, by dividing the curve <em>C</em> into many small segments, exactly as we did for the vector line integral. The scalar field <em>f</em> is evaluated at each point <strong>r</strong><sub><em>i</em></sub> at the segment Δ<strong>l</strong><sub><em>i</em></sub>, multiplied by the length Δ<em>l<sub>i</sub></em> of the segment, and then added.</p>&#13;
<div class="imagec"><img src="Images/494equ01.jpg" alt="Image" width="451" height="55"/></div>&#13;
<p class="indent">Here is the Haskell definition of a scalar line integral:</p>&#13;
<pre>scalarLineIntegral :: CurveApprox -&gt; ScalarField -&gt; Curve -&gt; R&#13;
scalarLineIntegral approx f c&#13;
    = sum [f r' * magnitude dl' | (r',dl') &lt;- approx c]</pre>&#13;
<p class="indent">The curve <span class="literal">c</span> is approximated by the function <span class="literal">approx</span>, which is provided as an input. For each segment <span class="literal">dl'</span> at position <span class="literal">r'</span>, the scalar field <span class="literal">f</span> is evaluated at position <span class="literal">r'</span> and multiplied by the magnitude of <span class="literal">dl'</span>. We then sum these numbers to give the approximation to the integral.</p>&#13;
<h4 class="h4" id="ch25lev22">Scalar Surface Integral</h4>&#13;
<p class="noindent">The scalar surface integral takes a scalar field <em>f</em> and a surface <em>S</em> as input and returns a scalar as output.</p>&#13;
<pre>type ScalarSurfaceIntegral = ScalarField -&gt; Surface -&gt; R</pre>&#13;
<p class="indent">The integral is defined, and also approximated, by dividing the surface <em>S</em> into many small patches, exactly as we did for the vector surface integral. The scalar field <em>f</em> is evaluated at each point <strong>r</strong><sub><em>i</em></sub> at the patch Δ<strong>a</strong><sub><em>i</em></sub>, multiplied by the magnitude <em>Δa<sub>i</sub></em> of the patch, and then added.</p>&#13;
<div class="imagec"><img src="Images/495equ01.jpg" alt="Image" width="455" height="54"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_495"/>Here is the Haskell definition of a scalar surface integral:</p>&#13;
<pre>scalarSurfaceIntegral :: SurfaceApprox -&gt; ScalarField -&gt; Surface -&gt; R&#13;
scalarSurfaceIntegral approx f s&#13;
    = sum [f r' * magnitude da' | (r',da') &lt;- approx s]</pre>&#13;
<p class="indent">The surface <span class="literal">s</span> is approximated by the function <span class="literal">approx</span>. For each patch <span class="literal">da'</span> at position <span class="literal">r'</span>, the scalar field <span class="literal">f</span> is evaluated at position <span class="literal">r'</span> and multiplied by the magnitude of <span class="literal">da'</span>. We then sum these numbers to give the approximation to the integral.</p>&#13;
<h4 class="h4" id="ch25lev23">Scalar Volume Integral</h4>&#13;
<p class="noindent">The scalar volume integral takes a scalar field <em>f</em> and a volume <em>V</em> as input and returns a scalar as output.</p>&#13;
<pre>type ScalarVolumeIntegral = ScalarField -&gt; Volume -&gt; R</pre>&#13;
<p class="indent">The integral is defined, and also approximated, by dividing the volume <em>V</em> into many small portions, exactly as we did for the vector volume integral. The scalar field <em>f</em> is evaluated at each portion, multiplied by the volume Δ<sub>v<em>i</em></sub> of the portion, and then added.</p>&#13;
<div class="imagec"><img src="Images/495equ02.jpg" alt="Image" width="455" height="55"/></div>&#13;
<p class="indent">Here is the Haskell definition of a scalar volume integral:</p>&#13;
<pre>scalarVolumeIntegral :: VolumeApprox -&gt; ScalarField -&gt; Volume -&gt; R&#13;
scalarVolumeIntegral approx f vol&#13;
    = sum [f r' * dv' | (r',dv') &lt;- approx vol]</pre>&#13;
<p class="indent">The volume <span class="literal">vol</span> is approximated by the function <span class="literal">approx</span>. For each portion <span class="literal">dv'</span> at position <span class="literal">r'</span>, the scalar field <span class="literal">f</span> is evaluated at position <span class="literal">r'</span> and multiplied by <span class="literal">dv'</span>. We then sum numbers to give the approximation to the integral.</p>&#13;
<p class="indent">Before we leave this chapter, there is one detail left to discuss, and that’s the method we’ll use to approximate curves, surfaces, and volumes when we do integrals over these shapes. Let’s turn to that detail now.</p>&#13;
<h3 class="h3" id="ch25lev24">Approximating Curves, Surfaces, and Volumes</h3>&#13;
<p class="noindent">We’ve seen multiple situations in which we want to add things up over a curve, surface, or volume by doing a line integral, surface integral, or volume integral. When the things we want to add up are vectors, we use a vector line integral, vector surface integral, or vector volume integral. Similarly, when the things we want to add up are scalars, we use a scalar line integral, scalar surface integral, or scalar volume integral. Whether we are adding <span epub:type="pagebreak" id="page_496"/>scalars or vectors, our methods require us to approximate curves, surfaces, and volumes as finite lists of data. This approximation is the subject of this section; although there are many ways this approximation can be done, we’ll give only one method for approximating each geometrical object. The subject of numerical analysis is concerned with exploring different ways to make these approximations, examining the trade-offs involved, and doing it cleverly and efficiently. In our case, we’re concerned with doing it simply and understandably.</p>&#13;
<h4 class="h4" id="ch25lev25">Approximating a Curve</h4>&#13;
<p class="noindent">Recall that a curve approximation is a way of turning a curve into a list of locations and displacement vectors.</p>&#13;
<pre>-- introduced earlier in the Chapter&#13;
type CurveApprox = Curve -&gt; [(Position,Vec)]</pre>&#13;
<p class="indent">Our function <span class="literal">curveSample</span> approximates a curve as a number of segments, returning a list of segment positions and displacement vectors.</p>&#13;
<pre>curveSample :: Int -&gt; Curve -&gt; [(Position,Vec)]&#13;
curveSample n c&#13;
    = let segCent :: Segment -&gt; Position&#13;
          segCent (p1,p2) = shiftPosition ((rVF p1 ^+^ rVF p2) ^/ 2) origin&#13;
          segDisp :: Segment -&gt; Vec&#13;
          segDisp = uncurry displacement&#13;
      in [(segCent seg, segDisp seg) | seg &lt;- segments n c]</pre>&#13;
<p class="indent">The function takes an integer <span class="literal">n</span> that controls the number of segments generated, each segment being a pair of starting position and ending position.</p>&#13;
<pre>type Segment = (Position,Position)</pre>&#13;
<p class="indent">Most of the work is done by the function <span class="literal">segments</span>, defined next, which returns a list of segments when given the integer <span class="literal">n</span> and the curve <span class="literal">c</span>. The local function <span class="literal">segCent</span> finds the center of each segment. The <span class="literal">rVF</span> vector field, introduced in <a href="ch22.xhtml">Chapter 22</a>, converts positions to displacement vectors, which the <span class="literal">shiftPosition</span> function then averages and converts back to positions.</p>&#13;
<p class="indent">The local function <span class="literal">segDisp</span> then computes the displacement vector of each segment. The displacement vector points from the beginning position of a segment to the ending position of the segment. The function <span class="literal">segDisp</span> is the uncurried version of <span class="literal">displacement</span> from <a href="ch22.xhtml">Chapter 22</a>, taking the two positions as a pair rather than a curried function.</p>&#13;
<p class="indent">We defined <span class="literal">segCent</span> and <span class="literal">segDisp</span> locally because they’re not used in any other functions. Note that we can still give them type signatures if we wish, although this is not required. Special-purpose functions like these are nice to define locally because it keeps fewer items in the global namespace and helps the reader of the code understand the relationship between the local <span epub:type="pagebreak" id="page_497"/>function <span class="literal">segCent</span> and its parent function <span class="literal">curveSample</span>. The fact that <span class="literal">segCent</span> is local informs the reader that this function is not used elsewhere.</p>&#13;
<p class="indent">The function <span class="literal">segments</span> returns a list of segments when given a curve.</p>&#13;
<pre>segments :: Int -&gt; Curve -&gt; [Segment]&#13;
segments n (Curve g a b)&#13;
    = let ps = map g $ linSpaced n a b&#13;
      in zip ps (tail ps)</pre>&#13;
<p class="indent">Note the first argument to <span class="literal">segments</span> is an integer <span class="literal">n</span> that controls how many segments will be produced. We pass in the curve <span class="literal">Curve g a b</span> using pattern matching on the input because this function needs to refer to the curve’s parameter limits <span class="literal">a</span> and <span class="literal">b</span>, as well as to the parameterizing function <span class="literal">g</span>. The function begins by breaking the curve’s parameter interval from <span class="literal">a</span> to <span class="literal">b</span> into <span class="literal">n</span> equal subintervals using the function <span class="literal">linSpaced</span> defined below. At each of the <span class="literal">n+1</span> endpoints of these subintervals, we apply the function <span class="literal">g</span> to form a list <span class="literal">ps</span> of <span class="literal">n+1</span> positions along the curve. We then zip the list <span class="literal">ps</span> with its tail to produce the desired list of <span class="literal">n</span> segments. Zipping a list with its tail pairs the first and second items, the second and third items, the third and fourth items, and so on.</p>&#13;
<p class="indent">The function <span class="literal">linSpaced</span> returns a list of numbers that are linearly spaced.</p>&#13;
<pre>linSpaced :: Int -&gt; R -&gt; R -&gt; [R]&#13;
linSpaced n x0 x1 = take (n+1) [x0, x0+dx .. x1]&#13;
    where dx = (x1 - x0) / fromIntegral n</pre>&#13;
<p class="indent">The input <span class="literal">n</span> is the number of intervals, so the function returns a list of <span class="literal">n+1</span> numbers, starting at <span class="literal">x0</span> and going up to and including <span class="literal">x1</span>. Since n has type <span class="literal">Int</span> and x1 - x0 has type <span class="literal">R</span>, we need the fromIntegral function to convert n to type <span class="literal">R</span> before we do the division. We use the <span class="literal">take</span> function to treat the case in which the initial value <span class="literal">x0</span> and the final value <span class="literal">x1</span> are the same, in which case <span class="literal">dx</span> is 0 and the arithmetic sequence is an infinite list of the same number. The <span class="literal">take</span> function returns only the first <span class="literal">n+1</span> items of the infinite list.</p>&#13;
<p class="indent">Here are two examples of the use of <span class="literal">linSpaced</span>:</p>&#13;
<pre>*ElectricField&gt; <span class="codestrong1">:l ElectricField</span>&#13;
[ 1 of 12] Compiling Newton2          ( Newton2.hs, interpreted )&#13;
[ 2 of 12] Compiling Mechanics1D      ( Mechanics1D.hs, interpreted )&#13;
[ 3 of 12] Compiling SimpleVec        ( SimpleVec.hs, interpreted )&#13;
[ 4 of 12] Compiling Mechanics3D      ( Mechanics3D.hs, interpreted )&#13;
[ 5 of 12] Compiling MultipleObjects  ( MultipleObjects.hs, interpreted )&#13;
[ 6 of 12] Compiling MOExamples       ( MOExamples.hs, interpreted )&#13;
[ 7 of 12] Compiling Electricity      ( Electricity.hs, interpreted )&#13;
[ 8 of 12] Compiling CoordinateSystems ( CoordinateSystems.hs, interpreted )&#13;
[ 9 of 12] Compiling Geometry         ( Geometry.hs, interpreted )&#13;
[10 of 12] Compiling VectorIntegrals  ( VectorIntegrals.hs, interpreted )&#13;
[11 of 12] Compiling Charge           ( Charge.hs, interpreted )&#13;
[12 of 12] Compiling ElectricField    ( ElectricField.hs, interpreted )&#13;
Ok, 12 modules loaded.&#13;
<span epub:type="pagebreak" id="page_498"/>&#13;
*ElectricField&gt; <span class="codestrong1">linSpaced 4 0 2</span>&#13;
[0.0,0.5,1.0,1.5,2.0]&#13;
*ElectricField&gt; <span class="codestrong1">linSpaced 4 3 3</span>&#13;
[3.0,3.0,3.0,3.0,3.0]</pre>&#13;
<p class="indent">Now that we’ve explored one way to approximate a curve, let’s do the same for a surface.</p>&#13;
<h4 class="h4" id="ch25lev26">Approximating a Surface</h4>&#13;
<p class="noindent">Recall that a surface approximation is a way of turning a surface into a list of locations and vector areas.</p>&#13;
<pre>-- introduced earlier in the Chapter&#13;
type SurfaceApprox = Surface -&gt; [(Position,Vec)]</pre>&#13;
<p class="indent">Our function <span class="literal">surfaceSample</span> approximates a surface as a number of triangles, returning a list of triangle positions and vector areas.</p>&#13;
<pre>surfaceSample :: Int -&gt; Surface -&gt; [(Position,Vec)]&#13;
surfaceSample n s = [(triCenter tri, triArea tri) | tri &lt;- triangles n s]</pre>&#13;
<p class="indent">The function takes an integer <span class="literal">n</span> that controls the number of triangles generated. Most of the work is done by the function <span class="literal">triangles</span>, which returns a list of triangles when given the integer <span class="literal">n</span> and the surface <span class="literal">s</span>. The function <span class="literal">triCenter</span> finds the center of each triangle, and the function <span class="literal">triArea</span> computes the vector area of each triangle. These two functions are defined below.</p>&#13;
<p class="indent">A triangle is described by specifying the positions of its three vertices.</p>&#13;
<pre>data Triangle = Tri Position Position Position</pre>&#13;
<p class="indent">The triangles have an orientation, so the order in which we specify the vertices is important. If we are looking at a triangle from a place where the positions <span class="literal">p1</span>, <span class="literal">p2</span>, and <span class="literal">p3</span> of the vertices occur in a counterclockwise order, the orientation points from the triangle toward our viewing location, perpendicular to the triangle surface. The triangles <span class="literal">Tri p1 p2 p3</span>, <span class="literal">Tri p2 p3 p1</span>, and <span class="literal">Tri p3 p1 p2</span> all represent the same triangle with the same orientation, but the triangles <span class="literal">Tri p1 p3 p2</span>, <span class="literal">Tri p2 p1 p3</span>, and <span class="literal">Tri p3 p2 p1</span> represent triangles with the same vertices but an opposite orientation.</p>&#13;
<p class="indent">We find the center of a triangle by averaging the displacement vectors for the three vertices.</p>&#13;
<pre>triCenter :: Triangle -&gt; Position&#13;
triCenter (Tri p1 p2 p3)&#13;
    = shiftPosition ((rVF p1 ^+^ rVF p2 ^+^ rVF p3) ^/ 3) origin</pre>&#13;
<p class="indent">We convert positions to displacement vectors with the <span class="literal">rVF</span> vector field, introduced in <a href="ch22.xhtml">Chapter 22</a>. We then average them and convert them back to a position with the <span class="literal">shiftPosition</span> function.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_499"/>The vector area of a triangle is half the cross product of two of its vector edges. Since we care about the orientation of these triangles, we need to be careful about which way we do the cross product.</p>&#13;
<pre>triArea :: Triangle -&gt; Vec  -- vector area&#13;
triArea (Tri p1 p2 p3) = 0.5 *^ (displacement p1 p2 &gt;&lt; displacement p2 p3)</pre>&#13;
<p class="indent">The function <span class="literal">triangles</span> returns a list of triangles when given a surface.</p>&#13;
<pre>triangles :: Int -&gt; Surface -&gt; [Triangle]&#13;
triangles n (Surface g sl su tl tu)&#13;
    = let sts = [[(s,t) | t &lt;- linSpaced n (tl s) (tu s)]&#13;
                     | s &lt;- linSpaced n sl su]&#13;
          stSquares = [( sts !! j    !! k&#13;
                       , sts !! (j+1) !! k&#13;
                       , sts !! (j+1) !! (k+1)&#13;
                       , sts !! j    !! (k+1))&#13;
                      | j &lt;- [0..n-1], k &lt;- [0..n-1]]&#13;
          twoTriangles (pp1,pp2,pp3,pp4)&#13;
              = [Tri (g pp1) (g pp2) (g pp3),Tri (g pp1) (g pp3) (g pp4)]&#13;
      in concatMap twoTriangles stSquares</pre>&#13;
<p class="indent">Note the first argument to <span class="literal">triangles</span> is an integer <span class="literal">n</span> that controls how many triangles will be produced. We pass in the surface <span class="literal">Surface g sl su tl tu</span> using pattern matching on the input because this function needs to refer to the surface’s parameter limits <span class="literal">sl</span> and <span class="literal">su</span>, as well as all of the other attributes of the surface.</p>&#13;
<p class="indent">The function begins by breaking the surface’s parameter interval from <span class="literal">sl</span> to <span class="literal">su</span> into <span class="literal">n</span> equal subintervals. At each of the <span class="literal">n+1</span> endpoints of these sub-intervals, we break the parameter interval from <span class="literal">tl s</span> to <span class="literal">tu s</span> into <span class="literal">n</span> equal subintervals, where <span class="literal">s</span> is the <em>s</em> parameter value at each subinterval endpoint. The local variable <span class="literal">sts :: [[(R,R)]]</span> is a list of lists, which can be thought of as an <span class="literal">n+1</span>-by-<span class="literal">n+1</span> matrix of parameter pairs corresponding to points on the surface. The local variable <span class="literal">stSquares :: [((R,R),(R,R),(R,R),(R,R))]</span> is a list of <span class="literal">n^2</span> “squares” of parameter pairs. Each of these squares is turned into two triangles by the local function <span class="literal">twoTriangles</span>. The function <span class="literal">triangles</span> returns a list of <span class="literal">2*n^2</span> triangles approximating the surface.</p>&#13;
<p class="indent">Now that we’ve shown one way to approximate a surface, let’s turn to the question of approximating a volume.</p>&#13;
<h4 class="h4" id="ch25lev27">Approximating a Volume</h4>&#13;
<p class="noindent">A volume approximation is a way of turning a volume into a list of locations and numerical volumes.</p>&#13;
<pre>-- introduced earlier in the Chapter&#13;
type VolumeApprox = Volume -&gt; [(Position,R)]</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_500"/>Our function <span class="literal">volumeSample</span> approximates a volume by a number of tetrahedrons. A tetrahedron is a four-sided solid where each side is a triangle. The function returns a list of tetrahedron positions and numerical volumes.</p>&#13;
<pre>volumeSample :: Int -&gt; Volume -&gt; [(Position,R)]&#13;
volumeSample n v = [(tetCenter tet, tetVolume tet) | tet &lt;- tetrahedrons n v]</pre>&#13;
<p class="indent">The function takes an integer <span class="literal">n</span> that controls the number of tetrahedrons used. Most of the work is done by the function <span class="literal">tetrahedrons</span>, defined below, which returns a list of tetrahedrons when given the integer <span class="literal">n</span> and the volume <span class="literal">v</span>. The function <span class="literal">tetCenter</span> finds the center of each tetrahedron, and the function <span class="literal">tetVolume</span> computes the numerical volume of each tetrahedron. These two functions are also defined below.</p>&#13;
<p class="indent">We can describe a tetrahedron by specifying the positions of its four vertices.</p>&#13;
<pre>data Tet = Tet Position Position Position Position</pre>&#13;
<p class="indent">We can find the center of a tetrahedron by averaging displacement vectors for the four vertices.</p>&#13;
<pre>tetCenter :: Tet -&gt; Position&#13;
tetCenter (Tet p1 p2 p3 p4)&#13;
    = shiftPosition ((rVF p1 ^+^ rVF p2 ^+^ rVF p3 ^+^ rVF p4) ^/ 4) origin</pre>&#13;
<p class="indent">This function is the natural extension of the <span class="literal">triCenter</span> function for triangles to tetrahedrons.</p>&#13;
<p class="indent">The volume of a tetrahedron is 1/6 of the <em>scalar triple product</em>, defined as <strong>a</strong> ⋅ (<strong>b</strong> × <strong>c</strong>), of three vector edges originating at one vertex or terminating at one vertex. The scalar triple product is also the determinant of the matrix whose columns are the three vector edges.</p>&#13;
<pre>tetVolume :: Tet -&gt; R&#13;
tetVolume (Tet p1 p2 p3 p4)&#13;
    = abs $ (d1 &lt;.&gt; (d2 &gt;&lt; d3)) / 6&#13;
      where&#13;
        d1 = displacement p1 p4&#13;
        d2 = displacement p2 p4&#13;
        d3 = displacement p3 p4</pre>&#13;
<p class="indent">We use the <span class="literal">abs</span> function to guarantee a positive numerical volume.</p>&#13;
<p class="indent">Just as we used “parameter squares” to cover the parameter space of a surface, now we use “parameter cubes” to cover the parameter space of a volume. Let’s define a data type for parameter cube.</p>&#13;
<pre>data ParamCube&#13;
    = PC { v000 :: (R,R,R)&#13;
         , v001 :: (R,R,R)&#13;
         , v010 :: (R,R,R)&#13;
         , v011 :: (R,R,R)&#13;
         <span epub:type="pagebreak" id="page_501"/>, v100 :: (R,R,R)&#13;
         , v101 :: (R,R,R)&#13;
         , v110 :: (R,R,R)&#13;
         , v111 :: (R,R,R)&#13;
         }</pre>&#13;
<p class="indent">The function <span class="literal">tetrahedrons</span> returns a list of tetrahedrons when given a volume.</p>&#13;
<pre>tetrahedrons :: Int -&gt; Volume -&gt; [Tet]&#13;
tetrahedrons n (Volume g sl su tl tu ul uu)&#13;
    = let stus = [[[(s,t,u) | u &lt;- linSpaced n (ul s t) (uu s t)]&#13;
                            | t &lt;- linSpaced n (tl s) (tu s)]&#13;
                            | s &lt;- linSpaced n sl su]&#13;
          stCubes = [PC (stus !!  j    !!  k    !!  l   )&#13;
                        (stus !!  j    !!  k    !! (l+1))&#13;
                        (stus !!  j    !! (k+1) !!  l   )&#13;
                        (stus !!  j    !! (k+1) !! (l+1))&#13;
                        (stus !! (j+1) !!  k    !!  l   )&#13;
                        (stus !! (j+1) !!  k    !! (l+1))&#13;
                        (stus !! (j+1) !! (k+1) !!  l   )&#13;
                        (stus !! (j+1) !! (k+1) !! (l+1))&#13;
                    | j &lt;- [0..n-1], k &lt;- [0..n-1], l &lt;- [0..n-1]]&#13;
          tets (PC c000 c001 c010 c011 c100 c101 c110 c111)&#13;
              = [Tet (g c000) (g c100) (g c010) (g c001)&#13;
                ,Tet (g c011) (g c111) (g c001) (g c010)&#13;
                ,Tet (g c110) (g c010) (g c100) (g c111)&#13;
                ,Tet (g c101) (g c001) (g c111) (g c100)&#13;
                ,Tet (g c111) (g c100) (g c010) (g c001)&#13;
                ]&#13;
      in concatMap tets stCubes</pre>&#13;
<p class="indent">Note the first argument to <span class="literal">tetrahedrons</span> is an integer <span class="literal">n</span> that controls how many tetrahedrons will be produced. We use pattern matching on the input to pass in the volume <span class="literal">Volume g sl su tl tu ul uu</span> because this function needs to refer to the volume’s parameter limits <span class="literal">sl</span> and <span class="literal">su</span> as well as all of the other attributes of the volume.</p>&#13;
<p class="indent">The function begins by breaking the volume’s parameter interval from <span class="literal">sl</span> to <span class="literal">su</span> into <span class="literal">n</span> equal subintervals. At each of the <span class="literal">n+1</span> endpoints of these sub-intervals, we break the parameter interval from <span class="literal">tl s</span> to <span class="literal">tu s</span> into <span class="literal">n</span> equal subintervals, where <span class="literal">s</span> is the <em>s</em> parameter value at each subinterval endpoint. Finally, for the third dimension, we break each parameter interval from <span class="literal">ul s t</span> to <span class="literal">uu s t</span> into <span class="literal">n</span> equal subintervals, where <span class="literal">t</span> is the <em>t</em> parameter value at each sub-interval endpoint. The local variable <span class="literal">stus :: [[[(R,R,R)]]]</span> is a list of lists of lists, which can be thought of as an <span class="literal">n+1</span>-by-<span class="literal">n+1</span>-by-<span class="literal">n+1</span> array of parameter triples corresponding to points in the volume. The local variable <span class="literal">stCubes ::</span> <span class="literal">[ParamCube]</span> is a list of <span class="literal">n^3</span> parameter cubes. The local function <span class="literal">tets</span> turns each <span epub:type="pagebreak" id="page_502"/>of these cubes into five tetrahedrons. The function <span class="literal">tetrahedrons</span> returns a list of <span class="literal">5*n^3</span> tetrahedrons approximating the volume.</p>&#13;
<h3 class="h3" id="ch25lev28">Summary</h3>&#13;
<p class="noindent">This chapter showed how to calculate the electric field produced by a charge distribution. We wrote functions to find the electric field produced by a point charge, a line charge, a surface charge, and a volume charge. On the way to that goal, we introduced the vector line integral, the vector surface integral, and the vector volume integral. We wrote a function</p>&#13;
<pre>eField :: ChargeDistribution -&gt; VectorField</pre>&#13;
<p class="noindent">that calculates the electric field of any charge distribution by combining the functions we wrote for each charge distribution.</p>&#13;
<p class="indent">After introducing the three sorts of vector integrals (line, surface, and volume), we took the opportunity to define three sorts of scalar integrals, in which we were adding up numbers rather than vectors. The chapter ended with a section on approximation of curves, surfaces, and volumes. Performing numerical integrals over these geometric objects requires that we have some way to carve the object up into a finite number of pieces. We showed one way to do this for each object. The next chapter on current distributions parallels the previous chapter on charge distributions. Just as charge is the source of electric fields, current is the source of magnetic fields.</p>&#13;
<h3 class="h3" id="ch25lev29">Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 25.1.</strong> Consider a line segment of charge, with uniform linear charge density <em>λ</em><sub>0</sub>. Let us place this line segment on the x-axis from <em>x</em> = <em>–L</em>/2 to <em>x</em> = <em>L</em>/2. We want to find the electric field produced by this line segment at some point in the xy-plane. Write code to make a picture of the electric field produced by this line segment of charge. You may restrict your attention to the xy-plane. The electric field produced by a line segment of charge is an exactly solvable problem. Find or calculate the exact solution. Produce a picture of the exact electric field for comparison.</p>&#13;
<p class="noindentts"><strong>Exercise 25.2.</strong> Make a picture of the electric field produced by a uniformly charged disk. Put the disk in the xy-plane and show the electric field in the xz-plane.</p>&#13;
<p class="noindentts"><strong>Exercise 25.3.</strong> Make a graph of the magnitude of the electric field produced by a uniformly charged ball versus the distance from the ball’s center. Compare our numeric method to the exact solution.</p>&#13;
<p class="noindentts"><strong>Exercise 25.4.</strong> Consider a ring of charge in the xy-plane with radius <em>R</em> and linear charge density <em>λ</em>(<strong>r</strong>) = <em>λ</em><sub>0</sub> cos <em>ϕ</em>, where <em>ϕ</em> is the cylindrical coordinate and <em>R</em> and <em>λ</em><sub>0</sub> are constants you can choose. Create a 3D visualization of the electric field produced by this charge distribution.</p>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_503"/><strong>Exercise 25.5.</strong> An exercise in the previous chapter asked you to write a charge distribution for the hydrogen atom in its ground state. Find the electric field produced by the hydrogen atom at an arbitrary point in space. Make a graph of the magnitude of the electric field as a function of the distance from the proton.</p>&#13;
<p class="noindentts"><strong>Exercise 25.6.</strong> Produce an image of the electric field created by four equal positive point charges located at the corners of a square.</p>&#13;
<p class="noindentts"><strong>Exercise 25.7.</strong> Produce an image of the electric field in the xz-plane created by a square plate with uniform positive surface charge density in the xy-plane.</p>&#13;
<p class="noindentts"><strong>Exercise 25.8.</strong> Produce images of the electric field in the xy-plane and the yz-plane created by a uniformly charged circular ring in the xy-plane centered on the origin.</p>&#13;
<p class="noindentts"><strong>Exercise 25.9.</strong> If the functions <span class="literal">scalarLineIntegral</span> and <span class="literal">vectorLineIntegral</span> seem like they are basically doing the same thing, and that we ought to be able to exploit some sort of commonality to combine them into one function that can do both, you are right.</p>&#13;
<p class="indent">First, we define a general field that could be a scalar field, a vector field, or something else.</p>&#13;
<pre>type Field a = Position -&gt; a</pre>&#13;
<p class="indent">The type <span class="literal">ScalarField</span> is the same as <span class="literal">Field R</span> and the type <span class="literal">VectorField</span> is the same as <span class="literal">Field Vec</span>.</p>&#13;
<p class="indent">Next, we make a type class for abstract vectors, which are types that have a zero vector, can be added, and can be scaled by a real number.</p>&#13;
<pre>class AbstractVector a where&#13;
    zeroVector :: a&#13;
    add   :: a -&gt; a -&gt; a&#13;
    scale :: R -&gt; a -&gt; a</pre>&#13;
<p class="indent">We write a function <span class="literal">sumG</span> to add a list of abstract vectors. This function is modeled after the <span class="literal">sumV</span> function from <a href="ch10.xhtml">Chapter 10</a>.</p>&#13;
<pre>sumG :: AbstractVector a =&gt; [a] -&gt; a&#13;
sumG = foldr add zeroVector</pre>&#13;
<p class="indent">With these tools, we can write a general line integral function that performs the role of both the scalar line integral and the vector line integral.</p>&#13;
<pre>generalLineIntegral&#13;
    :: AbstractVector a =&gt; CurveApprox -&gt; Field a -&gt; Curve -&gt; a&#13;
generalLineIntegral approx f c&#13;
    = sumG [scale (magnitude dl') (f r') | (r',dl') &lt;- approx c]</pre>&#13;
<p class="indent">Write instance declarations that will make the types <span class="literal">R</span> and <span class="literal">Vec</span> instances of type class <span class="literal">AbstractVector</span>.</p>&#13;
<p class="noindentts"><span epub:type="pagebreak" id="page_504"/><strong>Exercise 25.10.</strong> <em>Gauss’s law</em> asserts that the <em>electric flux</em> through a closed surface is proportional to the charge enclosed by the surface. The <em>flux</em> of a vector field describes the total flow through a surface if we imagine that the vectors are the velocity of some fluid. The electric flux Φ<em><sub>E</sub></em> through a surface <em>S</em> is defined to be the dotted surface integral of the electric field.</p>&#13;
<div class="imagec"><img src="Images/504equ01.jpg" alt="Image" width="121" height="48"/></div>&#13;
<p class="indent">The definition for the dotted surface integral is a lot like that for the vector surface integral we defined in this chapter. The integral is defined by dividing the surface <em>S</em> into many small patches. Each patch Δ<strong>a</strong><sub><em>i</em></sub> is a vector whose magnitude gives the area of the patch and whose direction points perpendicular to the patch. The electric field <strong>E</strong> is evaluated at a point <strong>r</strong><sub><em>i</em></sub> on or near the patch Δ<strong>a</strong><sub><em>i</em></sub> and dotted with the vector area Δ<strong>a</strong><sub><em>i</em></sub> of the patch. We then add up these numbers to form the sum:</p>&#13;
<div class="imagec"><img src="Images/504equ02.jpg" alt="Image" width="122" height="47"/></div>&#13;
<p class="indent">The integral is the limit of this vector sum as the areas of the patches approach 0 and the number of patches becomes arbitrarily large.</p>&#13;
<p class="indent">Here is Haskell code for the dotted surface integral, also known as a <em>flux integral</em>:</p>&#13;
<pre>dottedSurfaceIntegral :: SurfaceApprox -&gt; VectorField -&gt; Surface -&gt; R&#13;
dottedSurfaceIntegral approx vF s&#13;
    = sum [vF r' &lt;.&gt; da' | (r',da') &lt;- approx s]</pre>&#13;
<p class="alphats">(a) Write a function</p>&#13;
<pre class="pre3a">electricFluxFromField :: VectorField -&gt; Surface -&gt; R&#13;
electricFluxFromField = undefined</pre>&#13;
<p class="alphats-p">that accepts an electric field and a surface as input and returns electric flux as output.</p>&#13;
<p class="alphats">(b) Write a function</p>&#13;
<pre class="pre3a">electricFluxFromCharge :: ChargeDistribution -&gt; Surface -&gt; R&#13;
electricFluxFromCharge dist = undefined dist</pre>&#13;
<p class="alphats-p">that returns the electric flux through a given surface produced by the electric field of a given charge distribution.</p>&#13;
<p class="noindentts"><strong>Exercise 25.11.</strong> Compare the electric field <span class="literal">eFieldLineDipole</span> produced by NaCl, viewed as a line dipole, to the electric fields of the simple dipole and the ideal dipole. Make a vector field picture similar to those we made for the simple dipole and the ideal dipole.</p>&#13;
<p class="noindentts"><strong>Exercise 25.12.</strong> The point charge is the fundamental source of electric field. Given a surface approximation, we can find the electric field of a surface <span epub:type="pagebreak" id="page_505"/>charge by viewing it as a collection of point charges. The surface approximation tells us where to place the point charges and what values they should have. In this way, we skip over the vector surface integral that was our primary method for calculating the field.</p>&#13;
<pre>eFieldFromSurfaceChargeP :: SurfaceApprox -&gt; ScalarField -&gt; Surface&#13;
                         -&gt; VectorField&#13;
eFieldFromSurfaceChargeP approx sigma s r&#13;
    = sumV [eFieldFromPointCharge (sigma r' * magnitude da') r' r&#13;
                | (r',da') &lt;- approx s]</pre>&#13;
<p class="indent">Write similar functions to calculate the electric field from a line charge and a volume charge.</p>&#13;
<p class="noindentts"><strong>Exercise 25.13.</strong> Write a function</p>&#13;
<pre>surfaceArea :: Surface -&gt; R&#13;
surfaceArea = undefined</pre>&#13;
<p class="noindentts">that uses <span class="literal">scalarSurfaceIntegral</span> to calculate the surface area of a surface.</p>&#13;
<p class="noindentts"><strong>Exercise 25.14.</strong> The electric potential is a scalar field that can be defined in terms of the electric field as follows:</p>&#13;
<div class="imagec"><img src="Images/505equ01.jpg" alt="Image" width="422" height="48"/></div>&#13;
<p class="indent">The integral is a dotted line integral over any curve <em>C</em> that begins at the origin and ends at the field point <strong>r</strong>. The conservative nature of the electrostatic field <strong>E</strong> guarantees the result is independent of the chosen curve <em>C</em>.</p>&#13;
<p class="indent">The dotted line integral is defined and approximated by dividing the curve <em>C</em> into many small segments, exactly as we did for the vector line integral.</p>&#13;
<div class="imagec"><img src="Images/505equ02.jpg" alt="Image" width="471" height="55"/></div>&#13;
<p class="indent">The vector field <strong>F</strong> is evaluated at each point <strong>r</strong><sub><em>i</em></sub> of the approximation, dotted with the displacement Δ<strong>l</strong><sub><em>i</em></sub> of the segment, and then added.</p>&#13;
<p class="indent">Here is the Haskell definition of the dotted line integral:</p>&#13;
<pre>dottedLineIntegral :: CurveApprox -&gt; VectorField -&gt; Curve -&gt; R&#13;
dottedLineIntegral approx f c = sum [f r' &lt;.&gt; dl' | (r',dl') &lt;- approx c]</pre>&#13;
<p class="indent">Write a function</p>&#13;
<pre>electricPotentialFromField :: VectorField  -- electric field&#13;
                           -&gt; ScalarField  -- electric potential&#13;
electricPotentialFromField ef r = undefined ef r</pre>&#13;
<p class="noindentts">that takes the electric field as input and returns the electric potential as output. To write this function, you will need to construct a curve that begins at the origin and ends at the field point where we wish to find the electric potential. This curve can then be passed to <span class="literal">dottedLineIntegral</span>.<span epub:type="pagebreak" id="page_506"/></p>&#13;
</div></body></html>