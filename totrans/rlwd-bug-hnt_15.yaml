- en: '**15'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RACE CONDITIONS**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A *race condition* occurs when two processes race to complete based on an initial
    condition that becomes invalid while the processes are executing. A classic example
    is transferring money between bank accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: You have $500 in your bank account, and you need to transfer the entire amount
    to a friend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using your phone, you log into your banking app and request a transfer of $500
    to your friend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After 10 seconds, the request is still processing. So you log into the banking
    site on your laptop, see that your balance is still $500, and request the transfer
    again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The laptop and mobile requests finish within a few seconds of each other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your bank account is now $0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your friend messages you to say he received $1,000.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You refresh your account, and your balance is still $0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although this is an unrealistic example of a race condition, because (hopefully)
    all banks prevent money from just appearing out of thin air, the process represents
    the general concept. The condition for the transfers in steps 2 and 3 is that
    you have enough money in your account to initiate a transfer. But your account
    balance is validated only at the start of each transfer process. When the transfers
    execute, the initial condition is no longer valid, but both processes still complete.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP requests can seem instantaneous when you have a fast internet connection,
    but processing requests still takes time. While you’re logged into a site, every
    HTTP request you send must be reauthenticated by the receiving site; additionally,
    the site must load the data necessary for your requested action. A race condition
    could occur in the time it takes the HTTP request to complete both tasks. The
    following are examples of race condition vulnerabilities found in web applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accepting a HackerOne Invite Multiple Times**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Low'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *hackerone.com/invitations/<INVITE_TOKEN>/*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://hackerone.com/reports/119354/](https://hackerone.com/reports/119354/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** February 28, 2016'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** Swag'
  prefs: []
  type: TYPE_NORMAL
- en: When you’re hacking, watch for situations where your action depends on a condition.
    Look for any actions that seem to execute a database lookup, apply application
    logic, and update a database.
  prefs: []
  type: TYPE_NORMAL
- en: In February 2016, I was testing HackerOne for unauthorized access to program
    data. The invite functionality that adds hackers to programs and members to teams
    caught my eye.
  prefs: []
  type: TYPE_NORMAL
- en: Although the invitation system has since changed, at the time of my testing,
    HackerOne emailed invites as unique links that weren’t associated with the recipient
    email address. Anyone could accept an invitation, but the invite link was meant
    to be accepted only once and used by a single account.
  prefs: []
  type: TYPE_NORMAL
- en: As bug hunters, we can’t see the actual process the site uses to accept invitations,
    but we can still guess how the application works and use our assumptions to find
    bugs. HackerOne used a unique, token-like link for invites. So, most likely, the
    application would look up the token in a database, add an account based on the
    database’s entry, and then update the token record in the database so the link
    couldn’t be used again.
  prefs: []
  type: TYPE_NORMAL
- en: This type of workflow can cause race conditions for two reasons. First, the
    process of looking up a record and then acting on the record using coding logic
    creates a delay. The lookup is the precondition that must be met to initiate the
    invite process. If the application code is slow, two near-instantaneous requests
    could both perform the lookup and satisfy their conditions to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Second, updating records in the database can create a delay between the condition
    and the action that modifies the condition. For example, updating records requires
    looking through the database table to find the record to update, which takes time.
  prefs: []
  type: TYPE_NORMAL
- en: To test whether a race condition existed, I created a second and third account
    in addition to my primary HackerOne account (I’ll refer to the accounts as Users
    A, B, and C). As User A, I created a program and invited User B to it. Then I
    logged out as User A. I received the invite email as User B and logged into that
    account in my browser. I logged in as User C in another private browser and opened
    the same invite.
  prefs: []
  type: TYPE_NORMAL
- en: Next, I lined up the two browsers and invite acceptance buttons so they were
    almost on top of each other, as shown in [Figure 15-1](ch15.xhtml#ch15fig01).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/15fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-1: Two stacked browser windows showing the same HackerOne invite*'
  prefs: []
  type: TYPE_NORMAL
- en: Then I clicked both Accept buttons as quickly as possible. My first attempt
    didn’t work, which meant I had to go through the process again. But my second
    attempt was successful, and I managed to add two users to a program using one
    invite.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In some cases, you can manually test for race conditions—although you might
    need to adapt your workflow so you can perform actions as quickly as possible.
    In this case, I could arrange the buttons side by side, which made the exploit
    possible. In situations where you need to perform complicated steps, you might
    not be able to use manual testing. Instead, automate your testing so you can perform
    actions almost simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exceeding Keybase Invitation Limits**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Low'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *https://keybase.io/_/api/1.0/send_invitations.json/*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://hackerone.com/reports/115007/](https://hackerone.com/reports/115007/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** February 5, 2015'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $350'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look for race conditions in situations when a site has a limit to the number
    of actions you’re permitted to perform. For example, the security app Keybase
    limited the number of people allowed to sign up by providing registered users
    with three invites. As in the previous example, hackers could guess how Keybase
    was limiting invitations: most likely, Keybase was receiving the request to invite
    another user, checking the database to see whether the user had invites left,
    generating a token, sending the invite email, and decrementing the number of invites
    the user had left. Josip Franjković recognized that this behavior could be vulnerable
    to a race condition.'
  prefs: []
  type: TYPE_NORMAL
- en: Franjković visited the URL *[https://keybase.io/account/invitations/](https://keybase.io/account/invitations/)*
    where he could send invites, enter email addresses, and submit multiple invites
    simultaneously. Unlike with HackerOne’s invitation race condition, sending multiple
    invitations would be difficult to do manually, so Franjković likely used Burp
    Suite to generate the invite HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Using Burp Suite, you can send requests to the Burp Intruder, which allows you
    to define an insertion point in HTTP requests. You can specify payloads to iterate
    through for each HTTP request and add the payload to the insertion point. In this
    case, had Franjković been using Burp, he would have specified multiple email addresses
    as the payloads and had Burp send each request simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, Franjković was able to bypass the three-user limit and invite seven
    users to the site. Keybase confirmed the faulty design when resolving the issue
    and addressed the vulnerability by using a *lock*. A lock is a programmatic concept
    that restricts access to resources so other processes can’t access them.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this case, Keybase accepted the invitation race condition, but not all bug
    bounty programs will pay an award for vulnerabilities with minor impact, as demonstrated
    earlier in “[Accepting a HackerOne Invite Multiple Times](ch15.xhtml#ch15lev1sec1)”
    on [page 150](ch15.xhtml#page_150).
  prefs: []
  type: TYPE_NORMAL
- en: '**HackerOne Payments Race Condition**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Low'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** N/A'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** Undisclosed'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** April 12, 2017'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $1,000'
  prefs: []
  type: TYPE_NORMAL
- en: Some websites update records based on your interactions with them. For example,
    when you submit a report on HackerOne, the submission triggers an email that is
    sent to the team you submitted to, which triggers an update to the team’s stats.
  prefs: []
  type: TYPE_NORMAL
- en: But some actions, such as payments, don’t occur immediately in response to an
    HTTP request. For instance, HackerOne uses a *background job* to create money
    transfer requests for payment services like PayPal. Background job actions are
    usually performed in a batch and are initiated by some trigger. Sites commonly
    use them when they need to process a lot of data, but they’re independent from
    a user’s HTTP request. This means that when a team awards you a bounty, the team
    will get a receipt for the payment as soon as your HTTP request is processed,
    but the money transfer will be added to a background job to be completed later.
  prefs: []
  type: TYPE_NORMAL
- en: Background jobs and data processing are important components in race conditions
    because they can create a delay between the act of checking the conditions (time
    of check) and the act of completing the actions (time of use). If a site only
    checks for conditions when adding something to a background job, but not when
    the condition is actually used, the site’s behavior can lead to a race condition.
  prefs: []
  type: TYPE_NORMAL
- en: In 2016, HackerOne began combining bounties awarded to hackers into a single
    payment when using PayPal as the payment processor. Previously, when you were
    awarded multiple bounties in a day, you would receive separate payments from HackerOne
    for each bounty. After the change, you’d receive a lump sum payment for all the
    bounties.
  prefs: []
  type: TYPE_NORMAL
- en: In April 2017, Jigar Thakkar tested this functionality and recognized he could
    duplicate payouts. During the payment process, HackerOne would collect the bounties
    according to email address, combine them into one amount, and then send the payment
    request to PayPal. In this case, the precondition was looking up the email addresses
    associated with the bounties.
  prefs: []
  type: TYPE_NORMAL
- en: Thakkar found that if two HackerOne users had the same email address registered
    with PayPal, HackerOne would combine the bounties into a single payment for that
    single Paypal address. But if the user who found the bug changed their PayPal
    address after the bounty payments were combined but before HackerOne’s background
    job sent the request to PayPal, the lump sum payment would go to both the original
    PayPal address and the new email address that the user who found the bug changed
    it to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although Thakkar successfully tested this bug, exploiting background jobs can
    be tricky: you have to know when the processing initiates, and you only have a
    few seconds to modify the conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you notice a site is performing actions well after you’ve visited it, it’s
    likely using a background job to process data. This is an opportunity for testing.
    Change the conditions that define the job and check whether the job is processed
    using the new conditions instead of the old ones. Be sure to test the behavior
    as though the background job would execute immediately—background processing can
    often occur quickly, depending on how many jobs have been queued and the site’s
    approach to processing data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Shopify Partners Race Condition**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** High'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** N/A'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://hackerone.com/reports/300305/](https://hackerone.com/reports/300305/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** December 24, 2017'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $15,250'
  prefs: []
  type: TYPE_NORMAL
- en: Previously disclosed reports can tell you where to find more bugs. Tanner Emek
    used this strategy to find a critical vulnerability in Shopify’s Partners platform.
    The bug allowed Emek to access any Shopify store as long as he knew the email
    address belonging to a store’s current staff member.
  prefs: []
  type: TYPE_NORMAL
- en: Shopify’s Partner platform allows shop owners to give partnered developers access
    to their stores. Partners request access to Shopify stores through the platform,
    and the store owners must approve the request before partners can access the store.
    But to send a request, a partner must have a verified email address. Shopify verifies
    email addresses by sending a unique Shopify URL to the supplied email address.
    When the partner accesses the URL, the email address is considered verified. This
    process occurs whenever a partner registers an account or changes their email
    address on an existing account.
  prefs: []
  type: TYPE_NORMAL
- en: In December 2017, Emek read a report written by @uzsunny that was awarded $20,000\.
    The report revealed a vulnerability that allowed @uzsunny to access any Shopify
    store. The bug occurred when two partner accounts shared the same email and requested
    access to the same store one after another. Shopify’s code would automatically
    convert a store’s existing staff account to a collaborator account. When a partner
    had a preexisting staff account on a store and requested collaborator access from
    the Partners platform, Shopify’s code automatically accepted and converted the
    account to a collaborator account. In most situations, this conversion made sense
    because the partner already had access to the store with a staff account.
  prefs: []
  type: TYPE_NORMAL
- en: But the code didn’t properly check what type of existing account was associated
    with the email address. An existing collaborator account in the “pending” state,
    not yet accepted by the store owner, would be converted to an active collaborator
    account. The partner would effectively be able to approve their own collaborator
    request without the store owner’s interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Emek recognized that the bug in @uzsunny’s report relied on being able to send
    a request through a verified email address. He realized that if he could create
    an account and change the account’s email address to one that matched a staff
    member’s email, he might be able to use the same method as @uzsunny to maliciously
    convert the staff account to a collaborator account he controlled. To test whether
    this bug was possible through a race condition, Emek created a partner account
    using an email address he controlled. He received a verification email from Shopify
    but didn’t visit the URL right away. Instead, in the Partner platform, he changed
    his email address to *[cache@hackerone.com](mailto:cache@hackerone.com)*, an address
    he didn’t own, and intercepted the email change request using Burp Suite. He then
    clicked and intercepted the verification link to validate his email address. Once
    he had intercepted both HTTP requests, Emek used Burp to send the email change
    request and verification request one after the other, almost simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: After sending the requests, Emek reloaded the page and found Shopify had executed
    the change request and the verification request. These actions caused Shopify
    to validate Emek’s email address as *[cache@hackerone.com](mailto:cache@hackerone.com)*.
    Requesting collaborator access to any Shopify store that had an existing staff
    member with the email address *[cache@hackerone.com](mailto:cache@hackerone.com)*
    would allow Emek access to that store without any administrator interaction. Shopify
    confirmed the bug was due to a race condition in the application’s logic when
    changing and verifying email addresses. Shopify fixed the bug by locking the account
    database record during each action and requiring store administrators to approve
    all collaborator requests.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Recall from the “[HackerOne Unintended HTML Inclusion](ch05.xhtml#ch05lev1sec2)”
    report on [page 44](ch05.xhtml#page_44) that fixing one vulnerability doesn’t
    fix all vulnerabilities associated with an application’s functionality. When a
    site discloses new vulnerabilities, read the report and retest the application.
    You might not find any issues, you might bypass the developer’s intended fix,
    or you might find a new vulnerability. At a minimum, you’ll develop new skills
    by testing that functionality. Thoroughly test any verification systems, thinking
    about how developers could have coded the functionality and whether it could be
    vulnerable to a race condition.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any time a site performs actions that depend on a condition being true and changes
    the condition as a result of the action being performed, there’s an opportunity
    for race conditions. Be on the lookout for sites that limit the number of actions
    you’re permitted to perform or that process actions using background jobs. A race
    condition vulnerability usually requires conditions to change very quickly, so
    if you think something is vulnerable, you might need multiple attempts to actually
    exploit the behavior.
  prefs: []
  type: TYPE_NORMAL
