- en: '**3**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3**'
- en: '**BASIC CPU-BASED ARCHITECTURE**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**基于CPU的基本架构**'
- en: '![Image](../images/f0073-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0073-01.jpg)'
- en: 'Modern CPUs are some of the most complex structures known to humanity, but
    the basic concepts underlying them, such as executing instructions sequentially
    or jumping forward or backward to different instructions, are actually quite simple
    and haven’t changed for over 150 years. To ease our way into the study of CPU
    architecture, this chapter introduces these fundamental concepts by looking at
    a related but simpler system: a mechanical music player. You’ll then see how the
    same concepts, together with RAM, form the basis of Charles Babbage’s Analytical
    Engine. Studying—and programming—this mechanical system will make it easier to
    understand what’s going on when we turn our attention to electronic systems in
    [Chapter 4](ch04.xhtml).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现代CPU是人类已知的最复杂的结构之一，但它们背后的基本概念，如按顺序执行指令或跳转到不同的指令，其实非常简单，并且在过去150多年里一直没有变化。为了帮助我们更容易理解CPU架构，本章通过研究一个相关但更简单的系统——机械音乐播放器，来介绍这些基本概念。然后，你将看到这些概念与RAM一起，如何构成查尔斯·巴贝奇的分析机的基础。研究和编程这个机械系统将使我们在转向电子系统时（见[第4章](ch04.xhtml)）更容易理解它们的运作。
- en: A Musical Processing Unit
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 音乐处理单元
- en: For a machine to be a computer, it needs to be *general purpose*, meaning it
    must be able to perform different tasks according to a user specification. One
    way to arrange for this is to have the user write a sequence of instructions—a
    program—and have the machine carry them out. A musical score can be viewed as
    a program, and so we can think of a machine that reads and performs musical scores
    as a kind of musical computer. We’ll call such a device a *musical processing
    unit*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使一台机器成为计算机，它需要是*通用的*，意味着它必须能够根据用户的要求执行不同的任务。实现这一点的一种方法是让用户编写一系列指令——程序——并让机器执行这些指令。乐谱可以视为一种程序，因此我们可以把一种读取并执行乐谱的机器看作是一种音乐计算机。我们将这种设备称为*音乐处理单元*。
- en: In [Chapter 1](ch01.xhtml) we looked briefly at musical processing units such
    as barrel organs and music boxes. After Babbage, musical automata and their programs
    continued to evolve. Around 1890, “book organs” replaced barrels with continuous,
    joined decks of punch cards (“book music”), which could accommodate arbitrarily
    longer compositions without the size limit imposed by a barrel. By 1900 these
    had evolved to pianolas, or player pianos ([Figure 3-1](ch03.xhtml#ch03fig1)),
    which used punched paper *piano rolls* instead of cards to drive domestic pianos,
    rather than church organs. Player pianos are still found today; you might hear
    one providing background jazz in a mid-range hotel that can afford a piano but
    not a pianist.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.xhtml)中，我们简要地看了像风琴和音乐盒这样的音乐处理单元。在巴贝奇之后，音乐自动机及其程序继续发展。大约在1890年，“书籍风琴”用连续的、连接的打孔卡片组（“书籍音乐”）代替了滚筒，这样可以容纳任意更长的乐曲，而不受滚筒大小限制。到了1900年，这些装置发展成了钢琴自鸣琴或自动钢琴（见[图3-1](ch03.xhtml#ch03fig1)），它们用打孔的*钢琴卷轴*代替卡片，驱动家用钢琴，而非教堂风琴。自动钢琴至今仍然存在；你可能会在一些中等档次的酒店里听到它提供背景爵士乐，这些酒店能够负担钢琴，但负担不起钢琴家。
- en: '![Image](../images/f0074-01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0074-01.jpg)'
- en: '*Figure 3-1: A player piano (1900)*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-1：自动钢琴（1900年）*'
- en: Let’s think about some of the types of instructions found in musical scores
    that might be playable on these machines. These will be similar to but perhaps
    more familiar than concepts that we’ll need later to make computers. We’ll consider
    only a monophonic instrument here, meaning it can only play one note at a time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下音乐乐谱中可能出现在这些机器上的指令类型。这些指令与我们稍后需要用来制造计算机的概念相似，但可能更加熟悉。我们这里只考虑单音乐器，这意味着它一次只能演奏一个音符。
- en: The set of possible instructions that we can give to an automated musical instrument
    usually contains one instruction per available note. This might be an instruction
    to “play middle C” or “play the G above middle C,” for example. Each row of a
    player piano’s paper roll represents a time and contains one column per musical
    pitch, which is specified to be either on (punched) or off (not punched) at that
    time. Modern computer music software such as Ardour 5, released in 2018, continues
    to use this type of piano roll notation (turned on its side for human viewers,
    so time scrolls more intuitively from left to right) to generate electronic music
    ([Figure 3-2](ch03.xhtml#ch03fig2)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以给自动音乐仪器的一组可能指令通常包含每个可用音符一个指令。这可能是一个指令，比如“演奏中音 C”或“演奏中音 C 上方的 G”。自动钢琴的每一行纸卷代表一个时间点，并包含每个音高的一列，指示在该时间点是否打开（打孔）或关闭（未打孔）。现代计算机音乐软件，如
    2018 年发布的 Ardour 5，继续使用这种类型的钢琴卷轴符号（旋转侧面供人类观看，使时间从左到右滚动更加直观）来生成电子音乐（[图 3-2](ch03.xhtml#ch03fig2)）。
- en: '![Image](../images/f0075-01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0075-01.jpg)'
- en: '*Figure 3-2: An Ardour 5 piano roll interface (2018)*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-2：2018 年的 Ardour 5 钢琴卷轴界面*'
- en: When a player piano reads a piano roll, one row at a time is placed into a reader
    device. Let’s call this *fetching* the instruction. The instruction is then *decoded*
    by some machinery that looks at the punch-hole coding and turns it into a physical
    activation of some machinery that is going to play the note, such as by opening
    a tube for air to flow into an organ pipe. Then this machinery actually *executes*
    the performance of the note.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当自动钢琴读取钢琴卷轴时，一次会放入一行到读取设备中。我们称之为*获取*指令。然后，指令会被一些机械设备*解码*，这些设备查看打孔编码并将其转化为激活某些机械设备的物理过程，这些设备会演奏音符，比如通过打开管道让空气流入风管。然后这些机械设备实际上会*执行*音符的演奏。
- en: Usually when a human or mechanical music player is following a music program
    (score), they will execute (play) each instruction (note) and then move on to
    the next one, advancing their position in the program by one instruction. But
    sometimes there will also be special additional instructions that tell them to
    *jump* to another place in the program rather than advancing to the next instruction.
    For example, *repeats* and *dal segno (D.S.)* are used to jump back to an earlier
    instruction and continue execution from there, while *codas* are instructions
    to jump forward to a special ending section. [Figure 3-3](ch03.xhtml#ch03fig3)
    shows a musical program.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当人类或机械音乐播放器在演奏音乐程序（乐谱）时，它们会执行（演奏）每个指令（音符），然后继续到下一个指令，通过一个指令一个指令地推进程序的位置。但有时也会有一些特殊的附加指令，告诉它们跳跃到程序中的另一个位置，而不是继续到下一个指令。例如，*重复*
    和 *dal segno (D.S.)* 用来跳回早期的指令并从那里继续执行，而 *尾声* 则是跳到一个特殊结束部分的指令。[图 3-3](ch03.xhtml#ch03fig3)
    显示了一个音乐程序。
- en: '![Image](../images/f0075-02.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0075-02.jpg)'
- en: '*Figure 3-3: A musical program with notes G, A, B, high C, and low C, as well
    as jumps shown by repeats, dal segno, and coda*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-3：一个包含 G、A、B、高音 C 和低音 C 音符的音乐程序，并通过重复、dal segno 和 coda 显示跳跃*'
- en: 'You can build a barrel organ or player piano that encodes these jump instructions
    using extra, non-note columns in their punch cards. When one of these is punched,
    it might be interpreted as an instruction to fast-forward or rewind the barrel
    or punch cards to a previous or later line. [Figure 3-3](ch03.xhtml#ch03fig3)
    could then be coded with punches representing something like:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在打孔卡片中使用额外的非音符列来构建一个管风琴或自动钢琴，编码这些跳跃指令。当其中一列被打孔时，它可能会被解释为一个指令，要求将鼓轮或打孔卡片快进或倒回到之前或之后的某一行。[图
    3-3](ch03.xhtml#ch03fig3) 可以用打孔表示类似以下内容：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you don’t read music, this program explains exactly what the musical score
    does!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不懂音乐，这个程序会准确地解释乐谱的作用！
- en: '*From Music to Calculation*'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*从音乐到计算*'
- en: It’s a small conceptual step from this musical processing unit to building a
    machine that performs arithmetical, rather than musical, operations.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个音乐处理单元到构建一个执行算术而非音乐操作的机器，只是一个小的概念步骤。
- en: Suppose you’ve already built several small mechanical devices that each perform
    some arithmetic operation. For example, Pascal’s calculator is a machine that
    performs integer addition. With some thought, we could similarly construct machines
    like Pascal’s calculator to perform integer multiplication, subtraction, division,
    and column shifting. We could then write a program, much like a musical score,
    that would specify the sequence in which we’d like each of these simple machines
    to be activated.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经制造了几个小型机械装置，每个装置执行某种算术操作。例如，帕斯卡的计算器是一台执行整数加法的机器。经过思考，我们也可以类似地构建像帕斯卡计算器那样的机器，用于执行整数乘法、减法、除法和列移位。然后，我们可以编写一个程序，像音乐乐谱一样，指定我们希望按顺序激活这些简单机器的顺序。
- en: 'Assuming that your arithmetic machines all share a single accumulator where
    the result of each operation is stored, you could describe calculations similarly
    to sequences of instructions for pressing buttons on a calculator, such as:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的算术机器都共享一个累加器，用于存储每次操作的结果，你可以将计算描述得像在计算器上按键的指令序列一样，例如：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This program would halt with the result 94 in the accumulator. The program could
    be executed by a human, activating the simple machines in sequence, or we could
    use a player piano–style roll of punch cards to specify the sequence of instructions,
    and a Jacquard loom–style mechanical reader to read them and automatically activate
    the corresponding simple machines in turn.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将在累加器中停止，结果为94。该程序可以由人类执行，通过顺序激活简单机器，或者我们可以使用类似于玩家钢琴的打孔卡卷来指定指令的顺序，并使用雅卡尔织机式的机械读取器来读取这些卡片并依次自动激活相应的简单机器。
- en: '*From Calculation to Computation*'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*从计算到计算机*'
- en: 'To make a Church computer, it’s not enough to run programs of fixed sequences
    of arithmetic instructions. Computation theory tells us that some functions can
    only be computed using decisions and jumps, so we need to add similar instructions
    to those of our musical processing unit, facilitating repeats, codas, and the
    like. This would enable programs such as:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要制造一台教堂计算机，仅仅运行固定顺序的算术指令程序是不够的。计算理论告诉我们，某些功能只能通过决策和跳转来计算，因此我们需要添加类似于我们音乐处理单元的指令，以便实现重复、尾奏等功能。这将使得以下程序成为可能：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Computation theory also tells us that some computations require memory to store
    intermediate results. To distinguish between these results, we’ll give each value
    an *address*, which for now is just an integer identifier. Memory that is addressable
    in this way is widely called *random-access memory (RAM)*. (This is not quite
    the correct definition of RAM, but you’ll get to that in [Chapter 10](ch10.xhtml).)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 计算理论还告诉我们，某些计算需要内存来存储中间结果。为了区分这些结果，我们将给每个值一个*地址*，目前它只是一个整数标识符。以这种方式可寻址的内存通常称为*随机访问内存
    (RAM)*。（这并不是RAM的完全正确定义，但你会在[第10章](ch10.xhtml)中了解更多。）
- en: 'Having RAM available means that we can add instructions to *load* (read) and
    *store* (write) to addresses, as in this program:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有RAM意味着我们可以添加*加载*（读取）和*存储*（写入）到地址的指令，如下程序所示：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Computation theory tells us that we can simulate any machine if we have the
    three kinds of instructions I just demonstrated: those that do the actual work
    of the arithmetic operations; those that make decisions and jumps; and those that
    store and load from RAM. This is exactly how Babbage’s Analytical Engine was designed.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 计算理论告诉我们，如果我们拥有我刚才展示的三种指令，我们可以模拟任何机器：那些执行实际算术运算的指令；那些做决策和跳转的指令；以及那些从RAM中存储和加载的指令。这正是巴贝奇的分析机的设计方式。
- en: Babbage’s Central Processing Unit
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 巴贝奇的中央处理单元
- en: 'Despite its age, Babbage’s Analytical Engine is a striking modern design: its
    basic architecture is still used in all modern CPUs. At the same time, it has
    only the most essential CPU features, so studying it provides a simplified introduction
    to the basic concepts underlying more modern CPUs. The motion of the Analytical
    Engine’s mechanical parts also makes it easier to visualize how it works compared
    to today’s electronic computers.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管已经有些年代，巴贝奇的分析机仍然是一个引人注目的现代设计：其基本架构至今仍在所有现代CPU中使用。同时，它仅具备最基本的CPU功能，因此研究它为我们提供了一个简化的介绍，帮助理解现代CPU的基本概念。与今天的电子计算机相比，分析机的机械部件的运动也使得它的工作原理更容易被形象化。
- en: In this section I use modern terminology to describe the Analytical Engine’s
    parts and functions. These aren’t the terms Babbage used, but they’ll help later
    when I transfer the concepts to modern machines. (Some of Babbage’s original terms
    are included in parentheses in case they’re of interest.) Babbage and Lovelace
    never left documentation for their instruction set, but it’s been largely inferred
    or fantasized from other documents. I assume the instruction set and assembly
    language notation used by the Fourmilab emulator, an online re-creation of the
    Analytical Engine (*[https://www.fourmilab.ch/babbage/](https://www.fourmilab.ch/babbage/)*).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我使用现代术语来描述分析机的各个部分和功能。这些不是巴贝奇使用的术语，但它们在后续将帮助我将概念转移到现代计算机中。（一些巴贝奇的原始术语以括号的形式附在旁边，以防它们对你有兴趣。）巴贝奇和洛夫莱斯从未留下过关于他们指令集的文档，但它们大多是从其他文献中推测或幻想出来的。我假设
    Fourmilab 模拟器使用的指令集和汇编语言符号，四米实验室是分析机的在线再现（* [https://www.fourmilab.ch/babbage/](https://www.fourmilab.ch/babbage/)*）。
- en: Both my presentation and the Fourmilab emulator take some liberties with the
    historical truth. This is easy to do because the original source documents are
    messy and often contradictory. There was never a single definitive design, so
    we can pick the versions that best suit our story. Our purpose here is really
    to understand *modern* CPU concepts, so I sometimes simplify, modernize, or outright
    lie about some of the engine’s details to make this study easier.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我的演示和 Fourmilab 模拟器都对历史事实有所修改。这很容易做到，因为原始的文献资料杂乱且常常相互矛盾。并没有一个明确的设计，因此我们可以选择最适合我们叙事的版本。我们在这里的目的实际上是理解*现代*
    CPU 概念，所以我有时会简化、现代化，或者直白地编造一些关于引擎的细节，以便让这项研究变得更容易。
- en: '*High-Level Architecture*'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*高级架构*'
- en: 'The Analytical Engine consists of three things: a CPU, which executes programs;
    RAM, which stores data and allows the CPU to read and write it; and a bus that
    connects them. If that sounds similar to the overall architecture of a modern,
    single-core computer, that’s because it is! This isn’t a coincidence: the Analytical
    Engine’s architecture was explicitly used in ENIAC (after translating its mechanics
    into electronics), and ENIAC then became the template for our modern electronic
    machines.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 分析机由三部分组成：一个执行程序的 CPU；一个存储数据并允许 CPU 读写的 RAM；一个连接它们的总线。如果这听起来和现代单核计算机的总体架构类似，那是因为它确实类似！这并不是巧合：分析机的架构在将其机械结构转换为电子后，明确地应用于
    ENIAC，ENIAC 随后成为我们现代电子计算机的模板。
- en: Physically, the Analytical Engine is made of 50 copies of the slice (what Babbage
    called a “cage”) shown in [Figure 3-4](ch03.xhtml#ch03fig4), stacked vertically,
    one on top of the other, as in [Figure 1-14](ch01.xhtml#ch01fig14).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从物理结构上看，分析机由50个“切片”（巴贝奇称之为“笼子”）组成，如[图 3-4](ch03.xhtml#ch03fig4)所示，这些切片垂直堆叠，一个接一个，如[图
    1-14](ch01.xhtml#ch01fig14)所示。
- en: '![Image](../images/f0078-01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/f0078-01.jpg)'
- en: '*Figure 3-4: Babbage’s Analytical Engine architecture (1836)*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-4：巴贝奇的分析机架构（1836年）*'
- en: The circles are mechanical gears. The CPU, RAM, and bus each extend through
    all slices, and we can see each of them in [Figure 3-4](ch03.xhtml#ch03fig4).
    For each number represented in each structure of the machine, the slice shows
    and handles one of its many digits. The stack of all the slices together handles
    all digits.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 圆圈是机械齿轮。CPU、RAM 和总线每个都贯穿所有的切片，我们可以在[图 3-4](ch03.xhtml#ch03fig4)中看到它们的身影。对于机器中每个结构表示的每个数字，切片显示并处理它的一个数字。所有切片堆叠在一起，共同处理所有的数字。
- en: The RAM (“store axes”) consists of 100 stacks of gears, with each stack representing
    one 50-digit decimal integer number. It appears on the slice as the large homogeneous
    area on the right side of [Figure 3-4](ch03.xhtml#ch03fig4). Each of these locations
    in the RAM has an address, numbered from 0 to 99 inclusive; this address distinguishes
    the location from the other locations and is used to identify it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: RAM（“存储轴”）由100堆齿轮组成，每堆代表一个50位的十进制整数。这些齿轮堆在[图 3-4](ch03.xhtml#ch03fig4)中的切片上显示为右侧的大型均匀区域。RAM中的每个位置都有一个地址，编号从0到99，这个地址使得每个位置与其他位置区分开来，并用于识别它。
- en: The RAM locations are all physically close to, but not usually touching, a mechanical
    bus (“rack”). The bus is a rack gear—exactly like the one found in modern car
    steering racks and LEGO Technic sets ([Figure 3-5](ch03.xhtml#ch03fig5)).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: RAM 的位置都物理上接近，但通常不会接触到机械总线（“机架”）。总线是一个机架齿轮——完全像现代汽车转向机架和乐高技术系列中的齿轮（[图 3-5](ch03.xhtml#ch03fig5)）。
- en: '![Image](../images/f0079-01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/f0079-01.jpg)'
- en: '*Figure 3-5: A rack (linear gear) and pinion (rotating gear)*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-5：一组齿轮（线性齿轮）和小齿轮（旋转齿轮）*'
- en: The rack gear can *physically* shift left and right. Each of the RAM locations
    can be brought into contact with the rack by levers. The gears in that RAM location
    then act as pinions so that giving off the number from the location makes the
    bus physically shift to the left by that amount. Or, acting in the opposite direction,
    shifting the bus to the right from elsewhere adds numbers into the memory location.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个齿轮架可以*物理*地向左或向右移动。每个 RAM 地址都可以通过杠杆与齿轮架接触。该 RAM 地址中的齿轮就像小齿轮一样运作，从而使得从该位置输出数字时，数据总线会向左移动相应的距离。反之，若从其他地方将数据总线向右移动，则会将数字写入内存位置。
- en: The CPU (“mill”) is the active part of the machine. It requests data from and
    sends data to the RAM on the bus, and then processes it in various ways.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: CPU（“磨坊”）是机器的活跃部分。它请求数据并通过总线将数据发送到 RAM，然后以各种方式处理数据。
- en: '*Programmer Interface*'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*程序员接口*'
- en: Unlike the Difference Engine, the Analytical Engine was designed as a general-purpose
    computer. This means we can ask it to perform different operations in different
    orders. To do this, we need a way to specify what these operations and orders
    are.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与差分引擎不同，分析引擎被设计为通用计算机。这意味着我们可以要求它按不同的顺序执行不同的操作。为了做到这一点，我们需要一种方法来指定这些操作和顺序。
- en: Let’s clarify some terms I’ve been using loosely. An ordered list of *instructions*
    to perform operations is called a *program*. The act of carrying out a program
    is called *execution* or a *run*. The set of all available instructions is the
    *instruction set*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我澄清一下我之前随意使用的一些术语。一系列按顺序执行的*指令*被称为*程序*。执行程序的行为称为*执行*或*运行*。所有可用指令的集合被称为*指令集*。
- en: Programs are stored as codes on punched cards, like those of the Jacquard loom
    seen previously in [Figure 1-11](ch01.xhtml#ch01fig11). Each card contains one
    row of holes and non-holes, which together code for one instruction. Usually the
    instructions are executed in order, with the cards advancing in sequence, but
    some instructions make the cards rewind or fast-forward to jump around in the
    program. Let’s look at what particular instructions are available.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 程序以代码的形式存储在穿孔卡片上，就像我们之前在[图1-11](ch01.xhtml#ch01fig11)中看到的织布机的 Jacquard 卡片那样。每张卡片包含一排孔和非孔，它们共同编码一条指令。通常，指令按顺序执行，卡片按顺序推进，但有些指令会让卡片倒退或快进，以便在程序中跳跃。我们来看看有哪些特定的指令可用。
- en: '**Constants**'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常量**'
- en: 'One basic instruction is to set one of the RAM addresses to a given integer.
    For example, “Put the integer 534 into RAM address 27.” This will move the gears
    in the 27th RAM location’s column to the (decimal) digits 534, with zeros on the
    gears for the thousands place and higher. Let’s first denote this using a human-readable
    notation:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的指令是将某个 RAM 地址设置为给定的整数。例如，“将整数 534 放入 RAM 地址 27。”这将移动第 27 个 RAM 地址所在列的齿轮到（十进制）数字
    534，高位的齿轮上将显示零。我们首先用易于理解的符号表示这一点：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, `N` (for *number*) tells us that this is a RAM integer-setting instruction.
    The following number (`27`) tells us which RAM location is to be set, and the
    final number (`534`) is the value we’re setting it to. A typical program begins
    by setting many RAM addresses to specific values in this manner. For example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`N`（表示*数字*）告诉我们这是一个设置 RAM 整数的指令。接下来的数字（`27`）告诉我们要设置哪个 RAM 地址，最后一个数字（`534`）是我们要设置的值。一个典型的程序开始时，通常会以这种方式将许多
    RAM 地址设置为特定的值。例如：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once we have some starting values, we can then use further instructions to compute
    with them, as in the next sections.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了一些初始值，我们就可以使用进一步的指令进行计算，如下节所示。
- en: '**Load and Store**'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**加载与存储**'
- en: 'To process values from RAM, they must be moved into the CPU. To load a value
    from RAM into the CPU, we write `L` for *load*, followed by the RAM address where
    the value is stored. For example, this program sets the 27th RAM location to the
    value 534, then loads the value from this location into the CPU:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理来自 RAM 的值，它们必须被移入 CPU。要将值从 RAM 加载到 CPU 中，我们写 `L` 表示*加载*，后跟值存储的 RAM 地址。例如，这个程序将第
    27 个 RAM 地址设置为 534 的值，然后将该值从这个位置加载到 CPU 中：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To store the CPU’s latest result to RAM address 35, we write `S` for *store*
    followed by the desired address:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 CPU 的最新结果存储到 RAM 地址 35，我们写`S`表示*存储*，后跟所需的地址：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Storing (`S`) is different from setting RAM to a constant (`N`) because it involves
    the CPU’s accumulator. It transfers whatever value is in the accumulator to the
    RAM, rather than putting a fixed constant into RAM.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 存储（`S`）与将RAM设置为常量（`N`）不同，因为它涉及到CPU的累加器。它将累加器中的值转移到RAM中，而不是将固定常量放入RAM。
- en: Now that we can move data around, we would like to perform calculations in the
    form of arithmetic on it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以移动数据了，我们希望对其进行算术运算形式的计算。
- en: '**Arithmetic**'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**算术**'
- en: 'The Analytical Engine is able to perform elementary arithmetical operations:
    addition, subtraction, multiplication, and division, all on integers. These are
    denoted by the instructions `+`, `-`, `*`, and `/`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 分析引擎能够执行基本的算术运算：加法、减法、乘法和除法，所有运算都基于整数。这些运算分别由指令`+`、`-`、`*`和`/`表示。
- en: 'To do arithmetic, you first have to set the *mode*, which tells the engine
    which of these operations you want to do. For example, to add two numbers, you
    put it into adding mode and then load the two arguments in order into the CPU.
    Consider the following program:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行算术运算，首先必须设置*模式*，以告诉引擎你想进行哪种运算。例如，要加两个数字，你需要将模式设置为加法模式，然后依次将这两个参数加载到CPU中。考虑以下程序：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This program first puts the integers `7` and `3` into addresses 0 and 1, respectively.
    It then puts the CPU into adding mode with the `+` instruction and loads the number
    from these addresses. It finally stores the result of the addition into address
    2.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序首先将整数`7`和`3`分别放入地址0和地址1。然后，它将CPU置于加法模式，使用`+`指令并从这些地址加载数字。最后，它将加法的结果存储到地址2。
- en: Now that we have arithmetic, we finally need to move from calculation to computation
    by adding jumps and branches.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了算术运算，接下来我们需要通过添加跳转和分支来从计算转向计算机运算。
- en: '**Jumps**'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**跳转**'
- en: If you want part of a program to repeat forever, a simple method is to glue
    the end of the last punch card to the top of the first one to create a physical
    loop, as in [Figure 1-15](ch01.xhtml#ch01fig15). However, this doesn’t generalize
    well, so it’s useful instead to have an instruction to rewind or fast-forward
    the cards to jump to any other line of the program when needed. Call this `C`
    for *control*. We’ll then say whether we want to go backward (`B`) or forward
    (`F`) in the cards, and by how many. We’ll also include the symbol `+` before
    the number (for reasons you’ll see in the next section). Putting it all together,
    `CB+4`, for example, is a control instruction to go backward by four cards.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望程序的一部分永远重复，一种简单的方法是将最后一张打孔卡片的末端粘到第一张卡片的顶部，形成一个物理循环，如[图1-15](ch01.xhtml#ch01fig15)所示。然而，这种方法不易推广，因此最好是使用一种指令，可以在需要时将卡片回卷或快进到程序的其他行。我们称这种指令为`C`，表示*控制*。接下来，我们会说明是想要向后（`B`）还是向前（`F`）跳转，跳多少步。我们还会在数字前加上符号`+`（具体原因将在下一节中说明）。将这些组合起来，`CB+4`例如，是一种控制指令，表示向后跳转四张卡片。
- en: 'The following program uses `CB+4` to loop forever:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序使用`CB+4`实现无限循环：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here we use address 46 as a counter, adding 1 to its value every time we go
    around the loop.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用地址46作为计数器，每次循环时将其值加1。
- en: '**Branches**'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**分支**'
- en: Looping forever often isn’t very useful; we usually want to loop *until* something
    has happened, then stop looping and move on to the next part of the program. This
    is done with a conditional *branch*, which asks whether a condition holds and
    jumps only if it does.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 永远循环通常不是很有用；我们通常希望循环*直到*某些事情发生，然后停止循环并进入程序的下一部分。这是通过条件*分支*实现的，它会检查条件是否成立，只有在条件为真时才跳转。
- en: We’ll use the same `CF` and `CB` notation we used for jumps, but with the symbol`?`
    replacing the `+` to denote that the jump is conditional. For example, `CB?4`
    is the control instruction to go backward by four cards only if some condition
    is true.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与跳转相同的`CF`和`CB`符号表示法，不过用符号`?`替换`+`，表示跳转是有条件的。例如，`CB?4`是控制指令，表示仅当某个条件为真时，才向后跳转四张卡片。
- en: The following program uses a conditional branch and an unconditional jump together
    to compute the absolute value (always positive) of the sum of two numbers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序结合了条件分支和无条件跳转，用于计算两个数字和的绝对值（始终为正数）。
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This program uses the `+` instruction to add the two numbers in RAM locations
    1 and 2, storing the result at location 3\. It then adds zero (loaded from address
    99) to that result, loaded back from location 3\. Behind the scenes this addition
    operation also sets a special *status flag* to a 1 if the sign of the result differs
    from the sign of the first input (zero is considered positive). The conditional
    instruction `(CF?1)` then uses this status flag to decide what to do. If the flag
    is a 1, we skip over the next instruction, and so we arrive at the `-` instruction
    and perform a subtraction of the result from 0 to swap its sign. If the status
    flag is a 0, the conditional jump doesn’t occur, so we simply move on to the next
    instruction `(CF+4)`. This is an unconditional jump that skips over the four lines
    of subtraction code so as not to swap the sign. The final result is stored in
    address 3.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序使用`+`指令将RAM位置1和2中的两个数字相加，将结果存储在位置3中。然后它将零（从地址99加载）加到该结果中，再从位置3加载回来。在幕后，这个加法操作还会将一个特殊的*状态标志*设置为1，如果结果的符号与第一个输入的符号不同（零被认为是正数）。条件指令`(CF?1)`然后使用这个状态标志来决定该做什么。如果标志是1，我们跳过下一条指令，这样就到了`-`指令，并执行从0开始的减法操作以交换符号。如果状态标志是0，条件跳转不会发生，我们就继续执行下一条指令`(CF+4)`。这是一个无条件跳转，跳过四行减法代码，以避免交换符号。最终结果存储在地址3中。
- en: Branching completes the instruction set of the Analytical Engine and (assuming
    enough memory is always available) makes it into a Church computer. You can try
    tackling the end-of-chapter exercises and programming the Analytical Engine now—or,
    if you’re interested to see how the machine works on the inside, read on.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 分支完成了分析引擎的指令集，并且（假设始终有足够的内存可用）使其成为一台教堂计算机。你现在可以尝试解决章节末尾的练习并编程分析引擎，或者，如果你有兴趣了解机器内部是如何工作的，可以继续阅读。
- en: '*Internal Subcomponents*'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*内部子组件*'
- en: Let’s look at the subcomponents *within* the CPU that are needed to execute
    these programs. This section describes their static structure; we’ll bring the
    subcomponents to life in the next section when we cover how they move and interact
    with one another.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看CPU内部需要执行这些程序的子组件。本节描述了它们的静态结构；我们将在下一节中介绍这些子组件是如何移动并相互作用的。
- en: 'A CPU is formed from many independent simple machines, each made from several
    number representations and the machinery that acts upon them. The simple machines
    are grouped into three types: registers, an arithmetic logic unit, and a control
    unit.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一个CPU由许多独立的简单机器组成，每个简单机器由几个数字表示和操作它们的机械装置组成。简单机器被分为三种类型：寄存器、算术逻辑单元和控制单元。
- en: As shown in [Figure 3-4](ch03.xhtml#ch03fig4), all of these simple machines
    are arranged in a circle around a single large gear called the central wheel.
    Like the bus, the central wheel makes and breaks arbitrary data connections between
    components, in this case between the simple machines inside the CPU. These connections
    are made and removed by levers that put small additional gears into contact between
    the central wheel and the various machines.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 3-4](ch03.xhtml#ch03fig4)所示，这些简单机器被安排成一个圆圈，围绕着一个叫做中央齿轮的大齿轮。就像公交车一样，中央齿轮在组件之间建立和断开任意数据连接，在这里是指CPU内部的简单机器之间的连接。这些连接是通过杠杆来完成的，杠杆将小的附加齿轮与中央齿轮和各个机器之间接触。
- en: '**Registers**'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**寄存器**'
- en: '*Registers* (what Babbage called “axes”) are small units of memory location
    inside the CPU itself, rather than in the main RAM. There are only a few registers
    in the CPU, while there are many RAM addresses.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*寄存器*（巴贝奇称之为“轴”）是位于CPU内部的小型存储单元，而不是位于主RAM中。CPU中只有少量寄存器，而RAM地址则有很多。'
- en: Recall from [Chapter 2](ch02.xhtml) that integers are represented in the Analytical
    Engine by digital, decimal gears. A digit *d* is read off a gear by rotating a
    shaft by a full circle, which results in the gear rotating by *d* tenths of a
    circle. To represent an *N*-digit integer, we simply stack *N* of these gears
    vertically, spanning the *N* cages of the machine. A register is one of these
    stacks.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第2章](ch02.xhtml)中提到的，整数在分析引擎中是通过数字十进制齿轮表示的。一个数字*d*是通过旋转轴一整圈来读取的，这样齿轮会旋转*d*十分之一圈。为了表示一个*N*位整数，我们只需将*N*个齿轮垂直堆叠，跨越机器的*N*个舱位。寄存器就是这些齿轮堆叠之一。
- en: The input register (“ingress axle”) receives incoming data from RAM. The output
    register (“egress axle”) temporarily stores (or *buffers*) results from the CPU’s
    work, which are then transferred out to RAM. Other registers are used during computations
    for other purposes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 输入寄存器（“输入轴”）接收来自RAM的输入数据。输出寄存器（“输出轴”）暂时存储（或*缓冲*）来自CPU工作的结果，然后将其传输到RAM。其他寄存器则在计算过程中用于其他目的。
- en: '**Arithmetic Logic Unit**'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**算术逻辑单元**'
- en: The *arithmetic logic unit (ALU)* is a collection of independent simple machines
    that each perform a single arithmetic operation. For example, a simple machine
    similar to Pascal’s calculator is used to do addition. Multiplying by *m* can
    be done by a machine that triggers *m* repetitions of this adder. Multiplying
    or dividing by the *n*th power of 10 can be done by an especially simple machine
    that shifts all of its digits by *n* columns, the mechanical equivalent of “putting
    a zero on the end.”
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*算术逻辑单元（ALU）*是由一组独立的简单机器组成，每台机器执行一个单一的算术运算。例如，一台与帕斯卡尔计算器类似的简单机器用于执行加法。通过*m*的乘法可以通过一台机器触发*m*次加法运算。乘法或除法以10的*n*次幂为基数，可以通过一台特别简单的机器实现，该机器将所有数字移动*n*列，相当于机械上的“在末尾加个零”。'
- en: In addition to sending the result to an output register, some ALU operations
    can also set a single *status flag* as an extra, side-effect output. The status
    flag in the Analytical Engine is a single mechanical lever that is in either the
    up (1) or down (0) position. It might have had an actual red fabric flag on it
    to visually alert human as well as mechanical observers that “something interesting
    just happened” in the ALU.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将结果发送到输出寄存器外，一些ALU操作还可以设置一个单独的*状态标志*，作为额外的副作用输出。在分析引擎中，状态标志是一个单独的机械杠杆，可以处于上（1）或下（0）位置。它可能上面有一个红色布制旗帜，用来直观地提醒人类和机械观察者，“ALU中刚刚发生了某个有趣的事情”。
- en: '**ALU MECHANISMS**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**ALU机制**'
- en: A digit *d* is given off from a gear *D* when it’s read by physically rotating
    the gear by *d* tenths of a full circle. This digit can be added to another digit
    *a* stored on gear *A* by placing the gears next to one another so that their
    teeth mesh together, then giving off from *D*. As gear *D* rotates *d* tenths
    of a circle, gear *A* will be caused to rotate by the same amount, so gear *A*
    will end up storing the digit *a* + *d*. We say that *A* acts as an *accumulator*
    because we can go on adding many digits into it, and it accumulates their sum—that
    is, until the total goes above 9.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当齿轮*D*通过旋转*D*齿轮的*d*十分之一圈来读取时，一个数字*d*被传递出来。这个数字可以通过将齿轮*A*和齿轮*D*放在一起，使它们的齿相互啮合，从而将数字添加到齿轮*A*上，然后从*D*传递出来。随着齿轮*D*旋转*d*十分之一圈，齿轮*A*也会被带动旋转相同的角度，因此齿轮*A*最终将储存数字*a*
    + *d*。我们称*A*为*累加器*，因为我们可以继续向其中添加许多数字，并且它会累积这些数字的总和——直到总和超过9。
- en: 'Integers larger than 9 are represented on stacks of gears, such as in registers.
    Adding them together is done similarly to adding in columns with pen and paper:
    the two digits in each column need to be added, but we also need to keep track
    of carrying when a digit goes above 9 by passing a 1 to the next column. Pascal
    had already developed a basic mechanical ripple carry system in his calculator,
    which allowed numbers to be added into an accumulator, and Babbage’s carries are
    based on this. The following figure shows part of Babbage’s design.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 大于9的整数通过齿轮堆叠表示，就像在寄存器中一样。将它们相加的方法类似于用笔和纸逐列加法：每列中的两个数字需要相加，但我们还需要在数字超过9时进行进位，将1传递到下一列。帕斯卡尔在他的计算器中已经开发出一种基本的机械进位系统，这使得数字可以加到累加器中，巴贝奇的进位机制就是基于这个系统。下图展示了巴贝奇设计的一部分。
- en: '![Image](../images/f0084-01.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0084-01.jpg)'
- en: When a gear reaches the number 9 and is rotated by one more position in an addition,
    such as by an incoming carry (c), a tappet (f) connects to another tappet (e).
    The latter connects to a rod (m) that transfers the carry “upstairs” to the next
    cage, where it appears as (c) for the next column. Getting the timing right for
    long ripples of carries is very difficult, and this is where Babbage spent most
    of his design time.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当齿轮达到数字9并在加法运算中再旋转一个位置时，例如由传入的进位（c）触发时，凸轮（f）会与另一个凸轮（e）连接。后者连接到一根杆（m），该杆将进位“传送到楼上”的下一个笼子，在那里它作为（c）出现在下一列。准确把握进位长时间波动的时机是非常困难的，这也是巴贝奇在设计中花费最多时间的部分。
- en: '**Control Unit**'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**控制单元**'
- en: The *control unit (CU)* reads instructions from the program in memory, decodes
    them, and passes control to the ALU or elsewhere to carry the instructions out.
    Then it updates the position in the program according to either normal sequential
    execution or a jump. The CU is like the conductor of an orchestra, coordinating
    the actions of all the other components at the right times. Babbage’s CU is shown
    in [Figure 3-6](ch03.xhtml#ch03fig6).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*控制单元（CU）*从内存中的程序中读取指令，解码后将控制传递给ALU或其他部件以执行指令。然后，它根据正常的顺序执行或跳转来更新程序中的位置。控制单元就像一个指挥家，在正确的时机协调所有其他组件的动作。巴贝奇的控制单元如[图3-6](ch03.xhtml#ch03fig6)所示。'
- en: '![Image](../images/f0085-01.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0085-01.jpg)'
- en: '*Figure 3-6: The Analytical Engine control unit*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-6：分析引擎控制单元*'
- en: A mechanical barrel, just like that of a barrel organ, rotates over time, and
    each column of the barrel has several sockets for pins that may or may not be
    present. The pins trigger tappets that activate the other simple machines in the
    CPU through a complex system of mechanical levers. This enables each phase of
    the control unit’s work to be triggered in sequence, much like a barrel organ
    playing a sequence of notes. The speed of rotation of the barrel can be controlled
    by feedback mechanisms, so the next step doesn’t commence until the current step
    has been completed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一个机械的圆桶，类似于风琴的圆桶，随着时间的推移旋转，圆桶的每一列都有几个插槽，用于放置可能存在或不存在的钉子。这些钉子触发拨片，通过复杂的机械杠杆系统激活CPU中的其他简单机械。这使得控制单元的每个工作阶段都能按顺序触发，类似于风琴演奏一系列音符。圆桶的旋转速度可以通过反馈机制控制，直到当前步骤完成，下一步才会开始。
- en: 'The configuration of the barrel’s pins is *not* the user’s program, but rather
    a lower-level *microprogram* that defines the sequencing of the CPU itself: the
    fetch-decode-execute cycle that we’ll discuss next. As the microprogram runs,
    it causes individual commands from the user’s higher-level program to be read
    into registers from punched cards, then causes those commands to be executed via
    the simple machines in the rest of the CPU.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 圆桶钉子的配置*不是*用户的程序，而是定义CPU本身顺序的较低级别*微程序*：我们接下来将讨论的获取-解码-执行周期。随着微程序的执行，它将用户更高级程序中的单个命令从打孔卡片读取到寄存器中，然后通过CPU中的简单机械执行这些命令。
- en: '*Internal Operation*'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*内部操作*'
- en: 'The CU—in Babbage’s case the rotating barrel—triggers a regular cycle of activities.
    These are usually grouped into three main stages: fetch, decode, and execute.
    All of the CU’s operations must be carefully timed to occur in the right order.
    Let’s look at these three stages in turn.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 控制单元——在巴贝奇的情况下是旋转的圆桶——触发一个规律的活动周期。这些活动通常分为三个主要阶段：获取、解码和执行。所有控制单元的操作必须精确地按照正确的顺序进行。让我们逐个来看这三个阶段。
- en: '**Fetch**'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**获取**'
- en: '*Fetching* means reading the machine code for the next instruction into the
    CPU. Recall that the human-readable assembly language instructions such as `N37
    1` and `CB+4` are actually represented as binary machine code on the punched cards.
    For the Analytical Engine, fetching could be done exactly as on the Jacquard loom,
    by attempting to insert a set of physical pins into the locations on the card.
    Where there’s a punched hole, the pin can pass through, but where there isn’t
    a hole the pin gets stuck on the card and doesn’t move as far. The physical positions
    of these pins can then be amplified and transmitted into the CPU by metal levers.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*获取*指的是将下一条指令的机器码读取到CPU中。回想一下，像`N37 1`和`CB+4`这样的可读汇编语言指令实际上在打孔卡片上是以二进制机器码表示的。对于分析引擎，获取过程可以像雅卡尔织布机一样进行，通过尝试将一组物理钉子插入卡片上的位置。如果有打孔，钉子可以穿过，但没有孔的位置，钉子会卡在卡片上，无法再移动。然后，这些钉子的物理位置可以通过金属杠杆放大并传送到CPU中。'
- en: The card reader is a physical device, rather like a typewriter, in which there’s
    a current line accessible to the pins. To read from any other line, it’s necessary
    to pull the string of punch cards through this reader until the desired line is
    positioned in it. The current physical state of the punch cards—which one is currently
    in the reader—thus acts as a form of memory. We’ll call this physical state the
    *program counter*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 卡片读取器是一个物理设备，类似于打字机，其中有一行电流可供钉子使用。要读取其他行，需要将打孔卡片串通过这个读取器，直到所需的行排到合适位置。打孔卡片的当前物理状态——即当前在读取器中的卡片——因此充当了一种内存形式。我们将这种物理状态称为*程序计数器*。
- en: The physical positions of the metal levers can also be considered as a form
    of memory that contains a copy of the current instruction inside the CPU. We’ll
    call this the *instruction memory*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 金属杠杆的物理位置也可以视为一种内存形式，包含CPU内当前指令的副本。我们将其称为*指令内存*。
- en: '**Decode**'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**解码**'
- en: 'It isn’t immediately obvious what the binary encodings on the punch cards mean,
    either to a human or a machine: at this stage, they’re just patterns of 0s and
    1s. *Decoding* means figuring out what this code means. The card-reading levers
    traveling into the CPU can activate different pieces of machinery there, depending
    on what *combinations* of levers are up or down. For example, if the load instruction
    `(L)` is represented as binary 010, a machine could be set to respond only if
    three fetch levers are down, up, and down, respectively. Similarly, numerical
    addresses included in instructions need to be decoded, from decimal codes to mechanical
    activations of the addresses they represent. The decoder is a bank of machines
    that each look for a specific pattern in the fetched signal and activate something
    when they see it.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制编码在打孔卡上对人类或机器来说并不立即显现其含义：在此阶段，它们只是0和1的模式。*解码*意味着弄清楚这些代码的含义。进入CPU的卡片读取杠杆可以激活那里的不同机械装置，具体取决于杠杆的*组合*是上还是下。例如，如果加载指令`(L)`表示为二进制010，则机器可能被设置为仅在三个取回杠杆分别处于下、上、下的位置时响应。同样，指令中包含的数字地址需要解码，从十进制代码转换为它们所表示地址的机械激活。解码器是一组机器，每台机器都会在获取到的信号中寻找特定的模式，并在看到时激活某些功能。
- en: '**Execute: Load and Store**'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**执行：加载和存储**'
- en: '*Execution* means carrying out the decoded instruction. How this is done will
    depend on what type of instruction it is. Each form of execution is implemented
    by a different simple machine, and the decoder will select and activate the appropriate
    one.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*执行*是指执行解码后的指令。如何执行取决于指令的类型。每种执行形式由不同的简单机器实现，解码器将选择并激活适当的机器。'
- en: Values can be *loaded* into the CPU registers from RAM when the CPU needs to
    use them—for example, as part of a calculation. The results of the CPU’s work
    are also placed in registers, whose values can then be *stored* by copying them
    out to RAM addresses.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当CPU需要使用某个值时，可以将其从RAM加载到CPU寄存器中，例如作为计算的一部分。CPU的工作结果也会放置在寄存器中，然后通过将其复制到RAM地址来进行*存储*。
- en: To load a value, the CU makes mechanical connections between the gears at the
    RAM address and the bus, and between the bus and input register at the CPU end.
    It then triggers a giving off at the RAM address, spinning the gears by a full
    circle so that they make the bus physically shift toward the CPU by *n* steps,
    where *n* is the digit represented. This occurs in parallel, with each column
    of the number having its own RAM gear, bus, and input register gear.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载一个值，控制单元（CU）在RAM地址的齿轮和总线之间建立机械连接，并在CPU端的总线与输入寄存器之间建立连接。然后，它会触发RAM地址上的放电，旋转齿轮一整圈，使得它们使总线物理上向CPU移动*n*步，其中*n*是所表示的数字。这是并行发生的，每一列数字都有自己独立的RAM齿轮、总线和输入寄存器齿轮。
- en: When a value is to be stored, the CU triggers the opposite set of steps. Storing
    assumes that the value to be stored is already in the output register. First,
    it clears the RAM at the target address by rotating all the digits to zero. Then
    it makes mechanical connections from the output register to the bus, and from
    the bus to the required address in RAM. Then it spins the output register by a
    full circle, which physically shifts the bus by *n* steps toward the RAM, which
    in turn rotates the RAM gear by *n* steps so that the number is stored there.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要存储一个值时，控制单元触发一组相反的步骤。存储假设要存储的值已经在输出寄存器中。首先，它通过将所有数字旋转为零来清除目标地址处的RAM。然后，它将输出寄存器与总线连接起来，并将总线连接到RAM中所需的地址。接着，它将输出寄存器旋转一整圈，物理上将总线向RAM移动*n*步，进而旋转RAM齿轮*n*步，将数字存储在那里。
- en: '**Execute: Arithmetic Instructions**'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**执行：算术指令**'
- en: When an arithmetic instruction, such as an addition, is required, the appropriate
    simple machine, such as an adder, is brought into mechanical contact with the
    input and output registers and activated. In the Analytical Engine this is done
    mechanically by inserting gears (cogs) that physically link the registers to the
    simple machine, then transmitting power to the simple machine to make it run.
    Babbage’s adder was similar to a Pascal calculator, loading in the first argument,
    adding the second argument to, and then transferring the result to the output
    register. When the calculation is done, these gears are pulled away to disable
    the simple machine.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要执行算术指令（例如加法）时，合适的简单机器（例如加法器）会与输入和输出寄存器机械连接并启动。在分析机中，这是通过插入齿轮（齿轮）实现的，齿轮将寄存器与简单机器物理连接，然后传递动力给简单机器使其运转。巴贝奇的加法器类似于帕斯卡计算器，将第一个参数加载进去，再加上第二个参数，然后将结果传输到输出寄存器。当计算完成时，这些齿轮会被拉开，从而禁用简单机器。
- en: 'In addition to affecting the output register, the ALU’s simple machines may
    also raise or lower the status flag if something interesting happens during the
    arithmetic. The different simple machines in the ALU each have their own definition
    of “interesting” and can each set the flag according to these interests: `+` and
    `-` set the status flag to true if and only if the sign of their result differs
    from the sign of their first input, while `/` sets the status flag to true if
    a division by zero was attempted.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 除了影响输出寄存器外，ALU的简单机器还可以在算术过程中如果发生某些有趣的情况时抬高或降低状态标志。ALU中的不同简单机器有各自对“有趣”事件的定义，并可以根据这些兴趣设置标志：`+`
    和 `-` 只有当它们的结果符号与第一个输入符号不同才会将状态标志设置为真，而 `/` 在尝试除以零时会将状态标志设置为真。
- en: '**Execute: Program Flow**'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**执行：程序流**'
- en: At the end of each instruction, the CU must complete the fetch-decode-execute
    cycle and prepare for the start of the next one. How this is done differs depending
    on whether we have a normal instruction (such as load and store or ALU instructions)
    or one whose purpose is to alter the program flow—that is, jumps and branches.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在每条指令的执行结束时，控制单元（CU）必须完成取指-解码-执行周期，并为下一周期的开始做好准备。如何完成这一过程取决于我们处理的是普通指令（例如加载、存储或算术逻辑单元（ALU）指令），还是用于改变程序流的指令——即跳转和分支指令。
- en: In *normal execution*, when an instruction completes, we want to advance to
    the next instruction in the program, which for Babbage is the one on the punch
    card whose top is attached by string to the bottom of the current instruction’s
    punch card. This will prepare the system for the next fetch, which will be on
    the new instruction. To do this, the CU needs to trigger and increment the program
    counter. For the Analytical Engine, this is done by making mechanical connections
    that supply power to the punch card reader to perform a line feed, pulling the
    card deck through the reader by one card.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在*正常执行*中，当一条指令完成时，我们希望继续执行程序中的下一条指令，对于巴贝奇来说，这就是通过绳子将当前指令的穿孔卡片底部与下一个指令的穿孔卡片顶部连接起来的那张穿孔卡片。这将为下一次取指做好准备，即下一条新指令。为此，控制单元需要触发并增加程序计数器。在分析机中，这是通过建立机械连接来为穿孔卡片读取器供电，以执行行进送纸操作，将卡片堆通过读取器推送一张卡片。
- en: '*Jump instructions* mean fast-forwarding or rewinding the program as requested.
    Consider the instruction `CF+4`, which means forward by four lines. When the CU
    sees this instruction, it will again modify the program counter, but rather than
    simply incrementing it, it will advance or rewind it by the number of lines requested.
    In the Analytical Engine, this is done by sending power to the line feeder for
    a longer time than a single line advancement, and also by mechanically switching
    the direction of line feed between forward and backward.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*跳转指令*意味着按要求快速前进或倒退程序。考虑指令`CF+4`，其意思是向前推进四行。当控制单元看到此指令时，它会再次修改程序计数器，但不是简单地增加它，而是按请求的行数进行推进或倒退。在分析机中，这是通过将动力送到行进送纸装置，并延长时间来完成比单行推进更长的推进，同时机械地切换送纸方向，以便前进或后退。'
- en: '*Branch instructions* such as `CB?4` are executed differently, depending on
    the state of the status flag. This instruction, for example, tells the CU to jump,
    decreasing the program counter by four, if and only if the status flag is up.
    Otherwise, the instruction has no effect, and normal execution is used to increment
    the program counter and move to the next instruction. This branching is the important
    difference that separates the Analytical Engine from previous barrel and punch
    card program machines such as music players and the Jacquard loom. Unless historians
    discover any previous machines that could do it, this engine marked the first
    time that a machine was designed to modify the execution of its own program rather
    than always follow it in the same sequence. This ability to look at the state
    of things and make decisions based on it is a key requirement of a Church computer.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*分支指令*（例如`CB?4`）的执行方式有所不同，取决于状态标志的状态。例如，这条指令告诉控制单元（CU）跳转，如果状态标志为启用，则将程序计数器减去四，否则指令无效，正常执行用于递增程序计数器并跳转到下一条指令。这种分支是分析引擎与早期的桶式和打孔卡片程序机器（如音乐播放器和贾卡尔织机）的重要区别。除非历史学家发现其他能够实现这一功能的机器，否则这台引擎标志着第一次有机器被设计用来修改其自身程序的执行，而不是始终按照相同的顺序执行。能够查看事物的状态并根据状态做出决策是教会计算机的关键要求。'
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: We’ve studied Babbage’s Analytical Engine in this chapter because it was and
    still is the blueprint for all computers that came after it, including modern
    PCs. Its high-level architecture includes a CPU, RAM, and a bus connecting them.
    Inside the CPU is an ALU, registers, and a CU that conducts a fetch-decode-execute
    cycle. The instruction set includes load and store, arithmetic, and jump and branch
    instructions. There’s a program counter storing the current program line number,
    and a status flag that gets set if something interesting happened in the latest
    arithmetic operation. All of these features are found essentially unchanged in
    a modern PC.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中研究了巴贝奇的分析引擎，因为它是所有后继计算机的蓝图，包括现代个人计算机。其高层架构包括一个中央处理单元（CPU）、随机存取存储器（RAM）和连接它们的总线。在CPU内部，有算术逻辑单元（ALU）、寄存器和执行获取-解码-执行周期的控制单元（CU）。指令集包括加载和存储、算术运算、跳转和分支指令。还有一个程序计数器，存储当前程序行号，以及一个状态标志，如果最近的算术操作发生了有趣的事情，则会设置该标志。所有这些功能在现代个人计算机中基本保持不变。
- en: As a mechanical system, the Analytical Engine can be much more concrete to visualize
    and understand than electronics. But electronic computers are based on simply
    translating each of Babbage’s components into a faster and smaller implementation
    based on electronic switches grouped into logic gates. In the second part of this
    book, you’ll see how this is done by building up the modern electronic hierarchy
    from switches to CPUs. Now that you’ve seen what a CPU needs to do, you should
    have a clearer picture of where this electronic hierarchy is heading.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个机械系统，分析引擎比电子设备更容易可视化和理解。但电子计算机的基础只是将巴贝奇的每个组件转化为更快、更小的电子开关实现，这些开关被组合成逻辑门。在本书的第二部分，你将看到如何通过从开关到CPU逐步构建现代电子层级结构。现在你已经了解了CPU需要做什么，你应该对这个电子层级结构的未来发展有更清晰的认识。
- en: Exercises
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '**Programming the Analytical Engine**'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**编程分析引擎**'
- en: Install the Fourmilab Analytical Engine emulator from *[https://www.fourmilab.ch/babbage](https://www.fourmilab.ch/babbage)*,
    or use its web interface.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 *[https://www.fourmilab.ch/babbage](https://www.fourmilab.ch/babbage)* 安装Fourmilab分析引擎模拟器，或者使用其网页界面。
- en: Enter and run the Analytical Engine programs discussed in this chapter. If you
    run the programs using the java aes -t test.card command, then the `-t` option
    will print out a trace of changes to the machine state at each step.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入并运行本章讨论的分析引擎程序。如果你使用 java aes -t test.card 命令运行程序，那么`-t`选项将打印出每一步机器状态变化的跟踪信息。
- en: '**Lovelace’s Factorial Function**'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**洛夫莱斯的阶乘函数**'
- en: Write a factorial function for the Analytical Engine. Ada Lovelace wrote one
    of these, and it has since become the standard “Hello, world!” exercise to try
    whenever you meet a new architecture. (Actually printing “Hello, world!” tends
    to be more complicated, as it requires ASCII and screen output—you’ll see how
    to do this in [Chapter 11](ch11.xhtml).)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为分析引擎编写一个阶乘函数。艾达·洛夫莱斯编写了其中一个，它后来成为了每当遇到新架构时都会尝试的标准“Hello, world!”练习。（实际上，打印“Hello,
    world!”通常更为复杂，因为它涉及到ASCII码和屏幕输出——你将在[第11章](ch11.xhtml)中看到如何做。）
- en: Further Reading
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For a more historically accurate description of the Analytical Engine, see
    A. Bromley, “Charles Babbage’s Analytical Engine, 1838,” *Annals of the History
    of Computing* 4, no. 3 (1982): 196–217.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关分析机的更准确历史描述，请参见 A. Bromley，"查尔斯·巴贝奇的分析机，1838年"，*计算机历史年鉴* 4，第3期（1982年）：196-217。
- en: 'For a more fictional version, see William Gibson and Bruce Sterling, *The Difference
    Engine* (London: Victor Gollancz, 1990). This is the original steampunk novel,
    featuring Babbage, Lovelace, and a working Analytical Engine.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如需了解更具虚构性的版本，请参见威廉·吉布森和布鲁斯·斯特林，*差异引擎*（伦敦：维克托·戈兰茨，1990年）。这是原版蒸汽朋克小说，书中有巴贝奇、洛夫莱斯以及一台正在运行的分析机。
