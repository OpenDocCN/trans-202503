- en: '**3**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3**'
- en: '**BASIC CPU-BASED ARCHITECTURE**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**基于CPU的基本架构**'
- en: '![Image](../images/f0073-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0073-01.jpg)'
- en: 'Modern CPUs are some of the most complex structures known to humanity, but
    the basic concepts underlying them, such as executing instructions sequentially
    or jumping forward or backward to different instructions, are actually quite simple
    and haven’t changed for over 150 years. To ease our way into the study of CPU
    architecture, this chapter introduces these fundamental concepts by looking at
    a related but simpler system: a mechanical music player. You’ll then see how the
    same concepts, together with RAM, form the basis of Charles Babbage’s Analytical
    Engine. Studying—and programming—this mechanical system will make it easier to
    understand what’s going on when we turn our attention to electronic systems in
    [Chapter 4](ch04.xhtml).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现代CPU是人类已知的最复杂的结构之一，但它们背后的基本概念，如按顺序执行指令或跳转到不同的指令，其实非常简单，并且在过去150多年里一直没有变化。为了帮助我们更容易理解CPU架构，本章通过研究一个相关但更简单的系统——机械音乐播放器，来介绍这些基本概念。然后，你将看到这些概念与RAM一起，如何构成查尔斯·巴贝奇的分析机的基础。研究和编程这个机械系统将使我们在转向电子系统时（见[第4章](ch04.xhtml)）更容易理解它们的运作。
- en: A Musical Processing Unit
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 音乐处理单元
- en: For a machine to be a computer, it needs to be *general purpose*, meaning it
    must be able to perform different tasks according to a user specification. One
    way to arrange for this is to have the user write a sequence of instructions—a
    program—and have the machine carry them out. A musical score can be viewed as
    a program, and so we can think of a machine that reads and performs musical scores
    as a kind of musical computer. We’ll call such a device a *musical processing
    unit*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使一台机器成为计算机，它需要是*通用的*，意味着它必须能够根据用户的要求执行不同的任务。实现这一点的一种方法是让用户编写一系列指令——程序——并让机器执行这些指令。乐谱可以视为一种程序，因此我们可以把一种读取并执行乐谱的机器看作是一种音乐计算机。我们将这种设备称为*音乐处理单元*。
- en: In [Chapter 1](ch01.xhtml) we looked briefly at musical processing units such
    as barrel organs and music boxes. After Babbage, musical automata and their programs
    continued to evolve. Around 1890, “book organs” replaced barrels with continuous,
    joined decks of punch cards (“book music”), which could accommodate arbitrarily
    longer compositions without the size limit imposed by a barrel. By 1900 these
    had evolved to pianolas, or player pianos ([Figure 3-1](ch03.xhtml#ch03fig1)),
    which used punched paper *piano rolls* instead of cards to drive domestic pianos,
    rather than church organs. Player pianos are still found today; you might hear
    one providing background jazz in a mid-range hotel that can afford a piano but
    not a pianist.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.xhtml)中，我们简要地看了像风琴和音乐盒这样的音乐处理单元。在巴贝奇之后，音乐自动机及其程序继续发展。大约在1890年，“书籍风琴”用连续的、连接的打孔卡片组（“书籍音乐”）代替了滚筒，这样可以容纳任意更长的乐曲，而不受滚筒大小限制。到了1900年，这些装置发展成了钢琴自鸣琴或自动钢琴（见[图3-1](ch03.xhtml#ch03fig1)），它们用打孔的*钢琴卷轴*代替卡片，驱动家用钢琴，而非教堂风琴。自动钢琴至今仍然存在；你可能会在一些中等档次的酒店里听到它提供背景爵士乐，这些酒店能够负担钢琴，但负担不起钢琴家。
- en: '![Image](../images/f0074-01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0074-01.jpg)'
- en: '*Figure 3-1: A player piano (1900)*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-1：自动钢琴（1900年）*'
- en: Let’s think about some of the types of instructions found in musical scores
    that might be playable on these machines. These will be similar to but perhaps
    more familiar than concepts that we’ll need later to make computers. We’ll consider
    only a monophonic instrument here, meaning it can only play one note at a time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下音乐乐谱中可能出现在这些机器上的指令类型。这些指令与我们稍后需要用来制造计算机的概念相似，但可能更加熟悉。我们这里只考虑单音乐器，这意味着它一次只能演奏一个音符。
- en: The set of possible instructions that we can give to an automated musical instrument
    usually contains one instruction per available note. This might be an instruction
    to “play middle C” or “play the G above middle C,” for example. Each row of a
    player piano’s paper roll represents a time and contains one column per musical
    pitch, which is specified to be either on (punched) or off (not punched) at that
    time. Modern computer music software such as Ardour 5, released in 2018, continues
    to use this type of piano roll notation (turned on its side for human viewers,
    so time scrolls more intuitively from left to right) to generate electronic music
    ([Figure 3-2](ch03.xhtml#ch03fig2)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以给自动音乐仪器的一组可能指令通常包含每个可用音符一个指令。这可能是一个指令，比如“演奏中音 C”或“演奏中音 C 上方的 G”。自动钢琴的每一行纸卷代表一个时间点，并包含每个音高的一列，指示在该时间点是否打开（打孔）或关闭（未打孔）。现代计算机音乐软件，如
    2018 年发布的 Ardour 5，继续使用这种类型的钢琴卷轴符号（旋转侧面供人类观看，使时间从左到右滚动更加直观）来生成电子音乐（[图 3-2](ch03.xhtml#ch03fig2)）。
- en: '![Image](../images/f0075-01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0075-01.jpg)'
- en: '*Figure 3-2: An Ardour 5 piano roll interface (2018)*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-2：2018 年的 Ardour 5 钢琴卷轴界面*'
- en: When a player piano reads a piano roll, one row at a time is placed into a reader
    device. Let’s call this *fetching* the instruction. The instruction is then *decoded*
    by some machinery that looks at the punch-hole coding and turns it into a physical
    activation of some machinery that is going to play the note, such as by opening
    a tube for air to flow into an organ pipe. Then this machinery actually *executes*
    the performance of the note.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当自动钢琴读取钢琴卷轴时，一次会放入一行到读取设备中。我们称之为*获取*指令。然后，指令会被一些机械设备*解码*，这些设备查看打孔编码并将其转化为激活某些机械设备的物理过程，这些设备会演奏音符，比如通过打开管道让空气流入风管。然后这些机械设备实际上会*执行*音符的演奏。
- en: Usually when a human or mechanical music player is following a music program
    (score), they will execute (play) each instruction (note) and then move on to
    the next one, advancing their position in the program by one instruction. But
    sometimes there will also be special additional instructions that tell them to
    *jump* to another place in the program rather than advancing to the next instruction.
    For example, *repeats* and *dal segno (D.S.)* are used to jump back to an earlier
    instruction and continue execution from there, while *codas* are instructions
    to jump forward to a special ending section. [Figure 3-3](ch03.xhtml#ch03fig3)
    shows a musical program.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当人类或机械音乐播放器在演奏音乐程序（乐谱）时，它们会执行（演奏）每个指令（音符），然后继续到下一个指令，通过一个指令一个指令地推进程序的位置。但有时也会有一些特殊的附加指令，告诉它们跳跃到程序中的另一个位置，而不是继续到下一个指令。例如，*重复*
    和 *dal segno (D.S.)* 用来跳回早期的指令并从那里继续执行，而 *尾声* 则是跳到一个特殊结束部分的指令。[图 3-3](ch03.xhtml#ch03fig3)
    显示了一个音乐程序。
- en: '![Image](../images/f0075-02.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0075-02.jpg)'
- en: '*Figure 3-3: A musical program with notes G, A, B, high C, and low C, as well
    as jumps shown by repeats, dal segno, and coda*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-3：一个包含 G、A、B、高音 C 和低音 C 音符的音乐程序，并通过重复、dal segno 和 coda 显示跳跃*'
- en: 'You can build a barrel organ or player piano that encodes these jump instructions
    using extra, non-note columns in their punch cards. When one of these is punched,
    it might be interpreted as an instruction to fast-forward or rewind the barrel
    or punch cards to a previous or later line. [Figure 3-3](ch03.xhtml#ch03fig3)
    could then be coded with punches representing something like:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在打孔卡片中使用额外的非音符列来构建一个管风琴或自动钢琴，编码这些跳跃指令。当其中一列被打孔时，它可能会被解释为一个指令，要求将鼓轮或打孔卡片快进或倒回到之前或之后的某一行。[图
    3-3](ch03.xhtml#ch03fig3) 可以用打孔表示类似以下内容：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you don’t read music, this program explains exactly what the musical score
    does!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不懂音乐，这个程序会准确地解释乐谱的作用！
- en: '*From Music to Calculation*'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*从音乐到计算*'
- en: It’s a small conceptual step from this musical processing unit to building a
    machine that performs arithmetical, rather than musical, operations.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个音乐处理单元到构建一个执行算术而非音乐操作的机器，只是一个小的概念步骤。
- en: Suppose you’ve already built several small mechanical devices that each perform
    some arithmetic operation. For example, Pascal’s calculator is a machine that
    performs integer addition. With some thought, we could similarly construct machines
    like Pascal’s calculator to perform integer multiplication, subtraction, division,
    and column shifting. We could then write a program, much like a musical score,
    that would specify the sequence in which we’d like each of these simple machines
    to be activated.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经制造了几个小型机械装置，每个装置执行某种算术操作。例如，帕斯卡的计算器是一台执行整数加法的机器。经过思考，我们也可以类似地构建像帕斯卡计算器那样的机器，用于执行整数乘法、减法、除法和列移位。然后，我们可以编写一个程序，像音乐乐谱一样，指定我们希望按顺序激活这些简单机器的顺序。
- en: 'Assuming that your arithmetic machines all share a single accumulator where
    the result of each operation is stored, you could describe calculations similarly
    to sequences of instructions for pressing buttons on a calculator, such as:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的算术机器都共享一个累加器，用于存储每次操作的结果，你可以将计算描述得像在计算器上按键的指令序列一样，例如：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This program would halt with the result 94 in the accumulator. The program could
    be executed by a human, activating the simple machines in sequence, or we could
    use a player piano–style roll of punch cards to specify the sequence of instructions,
    and a Jacquard loom–style mechanical reader to read them and automatically activate
    the corresponding simple machines in turn.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将在累加器中停止，结果为94。该程序可以由人类执行，通过顺序激活简单机器，或者我们可以使用类似于玩家钢琴的打孔卡卷来指定指令的顺序，并使用雅卡尔织机式的机械读取器来读取这些卡片并依次自动激活相应的简单机器。
- en: '*From Calculation to Computation*'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*从计算到计算机*'
- en: 'To make a Church computer, it’s not enough to run programs of fixed sequences
    of arithmetic instructions. Computation theory tells us that some functions can
    only be computed using decisions and jumps, so we need to add similar instructions
    to those of our musical processing unit, facilitating repeats, codas, and the
    like. This would enable programs such as:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要制造一台教堂计算机，仅仅运行固定顺序的算术指令程序是不够的。计算理论告诉我们，某些功能只能通过决策和跳转来计算，因此我们需要添加类似于我们音乐处理单元的指令，以便实现重复、尾奏等功能。这将使得以下程序成为可能：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Computation theory also tells us that some computations require memory to store
    intermediate results. To distinguish between these results, we’ll give each value
    an *address*, which for now is just an integer identifier. Memory that is addressable
    in this way is widely called *random-access memory (RAM)*. (This is not quite
    the correct definition of RAM, but you’ll get to that in [Chapter 10](ch10.xhtml).)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 计算理论还告诉我们，某些计算需要内存来存储中间结果。为了区分这些结果，我们将给每个值一个*地址*，目前它只是一个整数标识符。以这种方式可寻址的内存通常称为*随机访问内存
    (RAM)*。（这并不是RAM的完全正确定义，但你会在[第10章](ch10.xhtml)中了解更多。）
- en: 'Having RAM available means that we can add instructions to *load* (read) and
    *store* (write) to addresses, as in this program:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有RAM意味着我们可以添加*加载*（读取）和*存储*（写入）到地址的指令，如下程序所示：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Computation theory tells us that we can simulate any machine if we have the
    three kinds of instructions I just demonstrated: those that do the actual work
    of the arithmetic operations; those that make decisions and jumps; and those that
    store and load from RAM. This is exactly how Babbage’s Analytical Engine was designed.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 计算理论告诉我们，如果我们拥有我刚才展示的三种指令，我们可以模拟任何机器：那些执行实际算术运算的指令；那些做决策和跳转的指令；以及那些从RAM中存储和加载的指令。这正是巴贝奇的分析机的设计方式。
- en: Babbage’s Central Processing Unit
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 巴贝奇的中央处理单元
- en: 'Despite its age, Babbage’s Analytical Engine is a striking modern design: its
    basic architecture is still used in all modern CPUs. At the same time, it has
    only the most essential CPU features, so studying it provides a simplified introduction
    to the basic concepts underlying more modern CPUs. The motion of the Analytical
    Engine’s mechanical parts also makes it easier to visualize how it works compared
    to today’s electronic computers.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管已经有些年代，巴贝奇的分析机仍然是一个引人注目的现代设计：其基本架构至今仍在所有现代CPU中使用。同时，它仅具备最基本的CPU功能，因此研究它为我们提供了一个简化的介绍，帮助理解现代CPU的基本概念。与今天的电子计算机相比，分析机的机械部件的运动也使得它的工作原理更容易被形象化。
- en: In this section I use modern terminology to describe the Analytical Engine’s
    parts and functions. These aren’t the terms Babbage used, but they’ll help later
    when I transfer the concepts to modern machines. (Some of Babbage’s original terms
    are included in parentheses in case they’re of interest.) Babbage and Lovelace
    never left documentation for their instruction set, but it’s been largely inferred
    or fantasized from other documents. I assume the instruction set and assembly
    language notation used by the Fourmilab emulator, an online re-creation of the
    Analytical Engine (*[https://www.fourmilab.ch/babbage/](https://www.fourmilab.ch/babbage/)*).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Both my presentation and the Fourmilab emulator take some liberties with the
    historical truth. This is easy to do because the original source documents are
    messy and often contradictory. There was never a single definitive design, so
    we can pick the versions that best suit our story. Our purpose here is really
    to understand *modern* CPU concepts, so I sometimes simplify, modernize, or outright
    lie about some of the engine’s details to make this study easier.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '*High-Level Architecture*'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Analytical Engine consists of three things: a CPU, which executes programs;
    RAM, which stores data and allows the CPU to read and write it; and a bus that
    connects them. If that sounds similar to the overall architecture of a modern,
    single-core computer, that’s because it is! This isn’t a coincidence: the Analytical
    Engine’s architecture was explicitly used in ENIAC (after translating its mechanics
    into electronics), and ENIAC then became the template for our modern electronic
    machines.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Physically, the Analytical Engine is made of 50 copies of the slice (what Babbage
    called a “cage”) shown in [Figure 3-4](ch03.xhtml#ch03fig4), stacked vertically,
    one on top of the other, as in [Figure 1-14](ch01.xhtml#ch01fig14).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0078-01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-4: Babbage’s Analytical Engine architecture (1836)*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The circles are mechanical gears. The CPU, RAM, and bus each extend through
    all slices, and we can see each of them in [Figure 3-4](ch03.xhtml#ch03fig4).
    For each number represented in each structure of the machine, the slice shows
    and handles one of its many digits. The stack of all the slices together handles
    all digits.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The RAM (“store axes”) consists of 100 stacks of gears, with each stack representing
    one 50-digit decimal integer number. It appears on the slice as the large homogeneous
    area on the right side of [Figure 3-4](ch03.xhtml#ch03fig4). Each of these locations
    in the RAM has an address, numbered from 0 to 99 inclusive; this address distinguishes
    the location from the other locations and is used to identify it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The RAM locations are all physically close to, but not usually touching, a mechanical
    bus (“rack”). The bus is a rack gear—exactly like the one found in modern car
    steering racks and LEGO Technic sets ([Figure 3-5](ch03.xhtml#ch03fig5)).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0079-01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-5: A rack (linear gear) and pinion (rotating gear)*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: The rack gear can *physically* shift left and right. Each of the RAM locations
    can be brought into contact with the rack by levers. The gears in that RAM location
    then act as pinions so that giving off the number from the location makes the
    bus physically shift to the left by that amount. Or, acting in the opposite direction,
    shifting the bus to the right from elsewhere adds numbers into the memory location.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: The CPU (“mill”) is the active part of the machine. It requests data from and
    sends data to the RAM on the bus, and then processes it in various ways.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '*Programmer Interface*'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unlike the Difference Engine, the Analytical Engine was designed as a general-purpose
    computer. This means we can ask it to perform different operations in different
    orders. To do this, we need a way to specify what these operations and orders
    are.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Let’s clarify some terms I’ve been using loosely. An ordered list of *instructions*
    to perform operations is called a *program*. The act of carrying out a program
    is called *execution* or a *run*. The set of all available instructions is the
    *instruction set*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Programs are stored as codes on punched cards, like those of the Jacquard loom
    seen previously in [Figure 1-11](ch01.xhtml#ch01fig11). Each card contains one
    row of holes and non-holes, which together code for one instruction. Usually the
    instructions are executed in order, with the cards advancing in sequence, but
    some instructions make the cards rewind or fast-forward to jump around in the
    program. Let’s look at what particular instructions are available.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '**Constants**'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One basic instruction is to set one of the RAM addresses to a given integer.
    For example, “Put the integer 534 into RAM address 27.” This will move the gears
    in the 27th RAM location’s column to the (decimal) digits 534, with zeros on the
    gears for the thousands place and higher. Let’s first denote this using a human-readable
    notation:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, `N` (for *number*) tells us that this is a RAM integer-setting instruction.
    The following number (`27`) tells us which RAM location is to be set, and the
    final number (`534`) is the value we’re setting it to. A typical program begins
    by setting many RAM addresses to specific values in this manner. For example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once we have some starting values, we can then use further instructions to compute
    with them, as in the next sections.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '**Load and Store**'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To process values from RAM, they must be moved into the CPU. To load a value
    from RAM into the CPU, we write `L` for *load*, followed by the RAM address where
    the value is stored. For example, this program sets the 27th RAM location to the
    value 534, then loads the value from this location into the CPU:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To store the CPU’s latest result to RAM address 35, we write `S` for *store*
    followed by the desired address:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Storing (`S`) is different from setting RAM to a constant (`N`) because it involves
    the CPU’s accumulator. It transfers whatever value is in the accumulator to the
    RAM, rather than putting a fixed constant into RAM.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 存储（`S`）与将RAM设置为常量（`N`）不同，因为它涉及到CPU的累加器。它将累加器中的值转移到RAM中，而不是将固定常量放入RAM。
- en: Now that we can move data around, we would like to perform calculations in the
    form of arithmetic on it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以移动数据了，我们希望对其进行算术运算形式的计算。
- en: '**Arithmetic**'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**算术**'
- en: 'The Analytical Engine is able to perform elementary arithmetical operations:
    addition, subtraction, multiplication, and division, all on integers. These are
    denoted by the instructions `+`, `-`, `*`, and `/`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 分析引擎能够执行基本的算术运算：加法、减法、乘法和除法，所有运算都基于整数。这些运算分别由指令`+`、`-`、`*`和`/`表示。
- en: 'To do arithmetic, you first have to set the *mode*, which tells the engine
    which of these operations you want to do. For example, to add two numbers, you
    put it into adding mode and then load the two arguments in order into the CPU.
    Consider the following program:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行算术运算，首先必须设置*模式*，以告诉引擎你想进行哪种运算。例如，要加两个数字，你需要将模式设置为加法模式，然后依次将这两个参数加载到CPU中。考虑以下程序：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This program first puts the integers `7` and `3` into addresses 0 and 1, respectively.
    It then puts the CPU into adding mode with the `+` instruction and loads the number
    from these addresses. It finally stores the result of the addition into address
    2.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序首先将整数`7`和`3`分别放入地址0和地址1。然后，它将CPU置于加法模式，使用`+`指令并从这些地址加载数字。最后，它将加法的结果存储到地址2。
- en: Now that we have arithmetic, we finally need to move from calculation to computation
    by adding jumps and branches.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了算术运算，接下来我们需要通过添加跳转和分支来从计算转向计算机运算。
- en: '**Jumps**'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**跳转**'
- en: If you want part of a program to repeat forever, a simple method is to glue
    the end of the last punch card to the top of the first one to create a physical
    loop, as in [Figure 1-15](ch01.xhtml#ch01fig15). However, this doesn’t generalize
    well, so it’s useful instead to have an instruction to rewind or fast-forward
    the cards to jump to any other line of the program when needed. Call this `C`
    for *control*. We’ll then say whether we want to go backward (`B`) or forward
    (`F`) in the cards, and by how many. We’ll also include the symbol `+` before
    the number (for reasons you’ll see in the next section). Putting it all together,
    `CB+4`, for example, is a control instruction to go backward by four cards.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望程序的一部分永远重复，一种简单的方法是将最后一张打孔卡片的末端粘到第一张卡片的顶部，形成一个物理循环，如[图1-15](ch01.xhtml#ch01fig15)所示。然而，这种方法不易推广，因此最好是使用一种指令，可以在需要时将卡片回卷或快进到程序的其他行。我们称这种指令为`C`，表示*控制*。接下来，我们会说明是想要向后（`B`）还是向前（`F`）跳转，跳多少步。我们还会在数字前加上符号`+`（具体原因将在下一节中说明）。将这些组合起来，`CB+4`例如，是一种控制指令，表示向后跳转四张卡片。
- en: 'The following program uses `CB+4` to loop forever:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序使用`CB+4`实现无限循环：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here we use address 46 as a counter, adding 1 to its value every time we go
    around the loop.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用地址46作为计数器，每次循环时将其值加1。
- en: '**Branches**'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**分支**'
- en: Looping forever often isn’t very useful; we usually want to loop *until* something
    has happened, then stop looping and move on to the next part of the program. This
    is done with a conditional *branch*, which asks whether a condition holds and
    jumps only if it does.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 永远循环通常不是很有用；我们通常希望循环*直到*某些事情发生，然后停止循环并进入程序的下一部分。这是通过条件*分支*实现的，它会检查条件是否成立，只有在条件为真时才跳转。
- en: We’ll use the same `CF` and `CB` notation we used for jumps, but with the symbol`?`
    replacing the `+` to denote that the jump is conditional. For example, `CB?4`
    is the control instruction to go backward by four cards only if some condition
    is true.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与跳转相同的`CF`和`CB`符号表示法，不过用符号`?`替换`+`，表示跳转是有条件的。例如，`CB?4`是控制指令，表示仅当某个条件为真时，才向后跳转四张卡片。
- en: The following program uses a conditional branch and an unconditional jump together
    to compute the absolute value (always positive) of the sum of two numbers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序结合了条件分支和无条件跳转，用于计算两个数字和的绝对值（始终为正数）。
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This program uses the `+` instruction to add the two numbers in RAM locations
    1 and 2, storing the result at location 3\. It then adds zero (loaded from address
    99) to that result, loaded back from location 3\. Behind the scenes this addition
    operation also sets a special *status flag* to a 1 if the sign of the result differs
    from the sign of the first input (zero is considered positive). The conditional
    instruction `(CF?1)` then uses this status flag to decide what to do. If the flag
    is a 1, we skip over the next instruction, and so we arrive at the `-` instruction
    and perform a subtraction of the result from 0 to swap its sign. If the status
    flag is a 0, the conditional jump doesn’t occur, so we simply move on to the next
    instruction `(CF+4)`. This is an unconditional jump that skips over the four lines
    of subtraction code so as not to swap the sign. The final result is stored in
    address 3.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Branching completes the instruction set of the Analytical Engine and (assuming
    enough memory is always available) makes it into a Church computer. You can try
    tackling the end-of-chapter exercises and programming the Analytical Engine now—or,
    if you’re interested to see how the machine works on the inside, read on.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '*Internal Subcomponents*'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s look at the subcomponents *within* the CPU that are needed to execute
    these programs. This section describes their static structure; we’ll bring the
    subcomponents to life in the next section when we cover how they move and interact
    with one another.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'A CPU is formed from many independent simple machines, each made from several
    number representations and the machinery that acts upon them. The simple machines
    are grouped into three types: registers, an arithmetic logic unit, and a control
    unit.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 3-4](ch03.xhtml#ch03fig4), all of these simple machines
    are arranged in a circle around a single large gear called the central wheel.
    Like the bus, the central wheel makes and breaks arbitrary data connections between
    components, in this case between the simple machines inside the CPU. These connections
    are made and removed by levers that put small additional gears into contact between
    the central wheel and the various machines.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '**Registers**'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Registers* (what Babbage called “axes”) are small units of memory location
    inside the CPU itself, rather than in the main RAM. There are only a few registers
    in the CPU, while there are many RAM addresses.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Recall from [Chapter 2](ch02.xhtml) that integers are represented in the Analytical
    Engine by digital, decimal gears. A digit *d* is read off a gear by rotating a
    shaft by a full circle, which results in the gear rotating by *d* tenths of a
    circle. To represent an *N*-digit integer, we simply stack *N* of these gears
    vertically, spanning the *N* cages of the machine. A register is one of these
    stacks.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: The input register (“ingress axle”) receives incoming data from RAM. The output
    register (“egress axle”) temporarily stores (or *buffers*) results from the CPU’s
    work, which are then transferred out to RAM. Other registers are used during computations
    for other purposes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '**Arithmetic Logic Unit**'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *arithmetic logic unit (ALU)* is a collection of independent simple machines
    that each perform a single arithmetic operation. For example, a simple machine
    similar to Pascal’s calculator is used to do addition. Multiplying by *m* can
    be done by a machine that triggers *m* repetitions of this adder. Multiplying
    or dividing by the *n*th power of 10 can be done by an especially simple machine
    that shifts all of its digits by *n* columns, the mechanical equivalent of “putting
    a zero on the end.”
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: In addition to sending the result to an output register, some ALU operations
    can also set a single *status flag* as an extra, side-effect output. The status
    flag in the Analytical Engine is a single mechanical lever that is in either the
    up (1) or down (0) position. It might have had an actual red fabric flag on it
    to visually alert human as well as mechanical observers that “something interesting
    just happened” in the ALU.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '**ALU MECHANISMS**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: A digit *d* is given off from a gear *D* when it’s read by physically rotating
    the gear by *d* tenths of a full circle. This digit can be added to another digit
    *a* stored on gear *A* by placing the gears next to one another so that their
    teeth mesh together, then giving off from *D*. As gear *D* rotates *d* tenths
    of a circle, gear *A* will be caused to rotate by the same amount, so gear *A*
    will end up storing the digit *a* + *d*. We say that *A* acts as an *accumulator*
    because we can go on adding many digits into it, and it accumulates their sum—that
    is, until the total goes above 9.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Integers larger than 9 are represented on stacks of gears, such as in registers.
    Adding them together is done similarly to adding in columns with pen and paper:
    the two digits in each column need to be added, but we also need to keep track
    of carrying when a digit goes above 9 by passing a 1 to the next column. Pascal
    had already developed a basic mechanical ripple carry system in his calculator,
    which allowed numbers to be added into an accumulator, and Babbage’s carries are
    based on this. The following figure shows part of Babbage’s design.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0084-01.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: When a gear reaches the number 9 and is rotated by one more position in an addition,
    such as by an incoming carry (c), a tappet (f) connects to another tappet (e).
    The latter connects to a rod (m) that transfers the carry “upstairs” to the next
    cage, where it appears as (c) for the next column. Getting the timing right for
    long ripples of carries is very difficult, and this is where Babbage spent most
    of his design time.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '**Control Unit**'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *control unit (CU)* reads instructions from the program in memory, decodes
    them, and passes control to the ALU or elsewhere to carry the instructions out.
    Then it updates the position in the program according to either normal sequential
    execution or a jump. The CU is like the conductor of an orchestra, coordinating
    the actions of all the other components at the right times. Babbage’s CU is shown
    in [Figure 3-6](ch03.xhtml#ch03fig6).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0085-01.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-6: The Analytical Engine control unit*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: A mechanical barrel, just like that of a barrel organ, rotates over time, and
    each column of the barrel has several sockets for pins that may or may not be
    present. The pins trigger tappets that activate the other simple machines in the
    CPU through a complex system of mechanical levers. This enables each phase of
    the control unit’s work to be triggered in sequence, much like a barrel organ
    playing a sequence of notes. The speed of rotation of the barrel can be controlled
    by feedback mechanisms, so the next step doesn’t commence until the current step
    has been completed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration of the barrel’s pins is *not* the user’s program, but rather
    a lower-level *microprogram* that defines the sequencing of the CPU itself: the
    fetch-decode-execute cycle that we’ll discuss next. As the microprogram runs,
    it causes individual commands from the user’s higher-level program to be read
    into registers from punched cards, then causes those commands to be executed via
    the simple machines in the rest of the CPU.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '*Internal Operation*'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The CU—in Babbage’s case the rotating barrel—triggers a regular cycle of activities.
    These are usually grouped into three main stages: fetch, decode, and execute.
    All of the CU’s operations must be carefully timed to occur in the right order.
    Let’s look at these three stages in turn.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '**Fetch**'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Fetching* means reading the machine code for the next instruction into the
    CPU. Recall that the human-readable assembly language instructions such as `N37
    1` and `CB+4` are actually represented as binary machine code on the punched cards.
    For the Analytical Engine, fetching could be done exactly as on the Jacquard loom,
    by attempting to insert a set of physical pins into the locations on the card.
    Where there’s a punched hole, the pin can pass through, but where there isn’t
    a hole the pin gets stuck on the card and doesn’t move as far. The physical positions
    of these pins can then be amplified and transmitted into the CPU by metal levers.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: The card reader is a physical device, rather like a typewriter, in which there’s
    a current line accessible to the pins. To read from any other line, it’s necessary
    to pull the string of punch cards through this reader until the desired line is
    positioned in it. The current physical state of the punch cards—which one is currently
    in the reader—thus acts as a form of memory. We’ll call this physical state the
    *program counter*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: The physical positions of the metal levers can also be considered as a form
    of memory that contains a copy of the current instruction inside the CPU. We’ll
    call this the *instruction memory*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '**Decode**'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It isn’t immediately obvious what the binary encodings on the punch cards mean,
    either to a human or a machine: at this stage, they’re just patterns of 0s and
    1s. *Decoding* means figuring out what this code means. The card-reading levers
    traveling into the CPU can activate different pieces of machinery there, depending
    on what *combinations* of levers are up or down. For example, if the load instruction
    `(L)` is represented as binary 010, a machine could be set to respond only if
    three fetch levers are down, up, and down, respectively. Similarly, numerical
    addresses included in instructions need to be decoded, from decimal codes to mechanical
    activations of the addresses they represent. The decoder is a bank of machines
    that each look for a specific pattern in the fetched signal and activate something
    when they see it.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '**Execute: Load and Store**'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Execution* means carrying out the decoded instruction. How this is done will
    depend on what type of instruction it is. Each form of execution is implemented
    by a different simple machine, and the decoder will select and activate the appropriate
    one.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Values can be *loaded* into the CPU registers from RAM when the CPU needs to
    use them—for example, as part of a calculation. The results of the CPU’s work
    are also placed in registers, whose values can then be *stored* by copying them
    out to RAM addresses.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: To load a value, the CU makes mechanical connections between the gears at the
    RAM address and the bus, and between the bus and input register at the CPU end.
    It then triggers a giving off at the RAM address, spinning the gears by a full
    circle so that they make the bus physically shift toward the CPU by *n* steps,
    where *n* is the digit represented. This occurs in parallel, with each column
    of the number having its own RAM gear, bus, and input register gear.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: When a value is to be stored, the CU triggers the opposite set of steps. Storing
    assumes that the value to be stored is already in the output register. First,
    it clears the RAM at the target address by rotating all the digits to zero. Then
    it makes mechanical connections from the output register to the bus, and from
    the bus to the required address in RAM. Then it spins the output register by a
    full circle, which physically shifts the bus by *n* steps toward the RAM, which
    in turn rotates the RAM gear by *n* steps so that the number is stored there.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '**Execute: Arithmetic Instructions**'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When an arithmetic instruction, such as an addition, is required, the appropriate
    simple machine, such as an adder, is brought into mechanical contact with the
    input and output registers and activated. In the Analytical Engine this is done
    mechanically by inserting gears (cogs) that physically link the registers to the
    simple machine, then transmitting power to the simple machine to make it run.
    Babbage’s adder was similar to a Pascal calculator, loading in the first argument,
    adding the second argument to, and then transferring the result to the output
    register. When the calculation is done, these gears are pulled away to disable
    the simple machine.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to affecting the output register, the ALU’s simple machines may
    also raise or lower the status flag if something interesting happens during the
    arithmetic. The different simple machines in the ALU each have their own definition
    of “interesting” and can each set the flag according to these interests: `+` and
    `-` set the status flag to true if and only if the sign of their result differs
    from the sign of their first input, while `/` sets the status flag to true if
    a division by zero was attempted.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '**Execute: Program Flow**'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At the end of each instruction, the CU must complete the fetch-decode-execute
    cycle and prepare for the start of the next one. How this is done differs depending
    on whether we have a normal instruction (such as load and store or ALU instructions)
    or one whose purpose is to alter the program flow—that is, jumps and branches.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: In *normal execution*, when an instruction completes, we want to advance to
    the next instruction in the program, which for Babbage is the one on the punch
    card whose top is attached by string to the bottom of the current instruction’s
    punch card. This will prepare the system for the next fetch, which will be on
    the new instruction. To do this, the CU needs to trigger and increment the program
    counter. For the Analytical Engine, this is done by making mechanical connections
    that supply power to the punch card reader to perform a line feed, pulling the
    card deck through the reader by one card.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '*Jump instructions* mean fast-forwarding or rewinding the program as requested.
    Consider the instruction `CF+4`, which means forward by four lines. When the CU
    sees this instruction, it will again modify the program counter, but rather than
    simply incrementing it, it will advance or rewind it by the number of lines requested.
    In the Analytical Engine, this is done by sending power to the line feeder for
    a longer time than a single line advancement, and also by mechanically switching
    the direction of line feed between forward and backward.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '*Branch instructions* such as `CB?4` are executed differently, depending on
    the state of the status flag. This instruction, for example, tells the CU to jump,
    decreasing the program counter by four, if and only if the status flag is up.
    Otherwise, the instruction has no effect, and normal execution is used to increment
    the program counter and move to the next instruction. This branching is the important
    difference that separates the Analytical Engine from previous barrel and punch
    card program machines such as music players and the Jacquard loom. Unless historians
    discover any previous machines that could do it, this engine marked the first
    time that a machine was designed to modify the execution of its own program rather
    than always follow it in the same sequence. This ability to look at the state
    of things and make decisions based on it is a key requirement of a Church computer.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve studied Babbage’s Analytical Engine in this chapter because it was and
    still is the blueprint for all computers that came after it, including modern
    PCs. Its high-level architecture includes a CPU, RAM, and a bus connecting them.
    Inside the CPU is an ALU, registers, and a CU that conducts a fetch-decode-execute
    cycle. The instruction set includes load and store, arithmetic, and jump and branch
    instructions. There’s a program counter storing the current program line number,
    and a status flag that gets set if something interesting happened in the latest
    arithmetic operation. All of these features are found essentially unchanged in
    a modern PC.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: As a mechanical system, the Analytical Engine can be much more concrete to visualize
    and understand than electronics. But electronic computers are based on simply
    translating each of Babbage’s components into a faster and smaller implementation
    based on electronic switches grouped into logic gates. In the second part of this
    book, you’ll see how this is done by building up the modern electronic hierarchy
    from switches to CPUs. Now that you’ve seen what a CPU needs to do, you should
    have a clearer picture of where this electronic hierarchy is heading.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Programming the Analytical Engine**'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Install the Fourmilab Analytical Engine emulator from *[https://www.fourmilab.ch/babbage](https://www.fourmilab.ch/babbage)*,
    or use its web interface.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter and run the Analytical Engine programs discussed in this chapter. If you
    run the programs using the java aes -t test.card command, then the `-t` option
    will print out a trace of changes to the machine state at each step.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Lovelace’s Factorial Function**'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a factorial function for the Analytical Engine. Ada Lovelace wrote one
    of these, and it has since become the standard “Hello, world!” exercise to try
    whenever you meet a new architecture. (Actually printing “Hello, world!” tends
    to be more complicated, as it requires ASCII and screen output—you’ll see how
    to do this in [Chapter 11](ch11.xhtml).)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For a more historically accurate description of the Analytical Engine, see
    A. Bromley, “Charles Babbage’s Analytical Engine, 1838,” *Annals of the History
    of Computing* 4, no. 3 (1982): 196–217.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a more fictional version, see William Gibson and Bruce Sterling, *The Difference
    Engine* (London: Victor Gollancz, 1990). This is the original steampunk novel,
    featuring Babbage, Lovelace, and a working Analytical Engine.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
