<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="269" id="Page_269"/>10</span><br/>
<span class="ChapterTitle">Network Applications and Services</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">This chapter explores basic network applications—the clients and servers running in user space that reside at the application layer. Because this layer is at the top of the stack, close to end users, you may find this material more accessible than the material in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>. Indeed, you interact with network client applications such as web browsers every day.</p>
<p>To do their work, network clients connect to corresponding network servers. Unix network servers come in many forms. A server program can listen to a port on its own or through a secondary server. We’ll look at some common servers as well as tools that will help you understand and debug server operation.</p>
<p>Network clients use the operating system’s transport layer protocols and interfaces, so it’s important to understand the basics of the TCP and UDP transport layers. Let’s start looking at network applications by experimenting with a network client that uses TCP. </p>
<h2 id="h1-500402c10-0001"><span epub:type="pagebreak" title="270" id="Page_270"/>	10.1	The Basics of Services</h2>
<p class="BodyFirst">TCP services are among the easiest to understand because they are built upon simple, uninterrupted two-way data streams. Perhaps the best way to see how they work is to talk directly to an unencrypted web server on TCP port 80 to get an idea of how data moves across the connection. For example, run the following command to connect to the IANA documentation example web server: </p>
<pre><code>$ <b>telnet example.org 80</b></code></pre>
<p>You should get a response like this, indicating a successful connection to the server: </p>
<pre><code>Trying <var>some address</var>...
Connected to example.org.
Escape character is '^]'.</code></pre>
<p>Now enter these two lines:</p>
<pre><code><b>GET / HTTP/1.1</b>
<b>Host: example.org</b></code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	HTTP 1.1, like its predecessor HTTP 1.0, shows its age; there are newer protocols in use such as HTTP/2, QUIC, and the emerging HTTP/3.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Press <span class="KeyCaps">enter</span> twice after the last line. The server should send a bunch of HTML text as a response. To terminate the connection, press <span class="KeyCaps">ctrl</span>-D. </p>
<p>This exercise demonstrates that:</p>
<ul>
<li>The remote host has a web server process listening on TCP port 80. </li>
<li><code>telnet</code> was the client that initiated the connection. </li>
</ul>
<p>The reason you have to terminate the connection with <span class="KeyCaps">ctrl</span>-D is that, because most web pages need several requests to load, it makes sense to keep the connection open. If you explore web servers at the protocol level, you may find that this behavior varies. For example, many servers disconnect quickly if they do not receive a request soon after a connection opens.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	<var>telnet</var> was originally meant to enable logins to remote hosts. The client program may not be installed on your distribution by default, but is easily installed as an extra package. Although the <var>telnet</var> remote login server is completely insecure (as you will learn later), the <var>telnet</var> client can be useful for debugging remote services. <var>telnet</var> does not work with UDP or any transport layer other than TCP. If you’re looking for a general-purpose network client, consider <var>netcat</var>, described in <span class="xref" itemid="xref_target_Section 10.5.3">Section 10.5.3</span>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500402c10-0002"><span epub:type="pagebreak" title="271" id="Page_271"/>	10.2	A Closer Look</h2>
<p class="BodyFirst">In the previous example, you manually interacted with a web server on the network with <code>telnet</code>, using the HTTP application layer protocol. Although you’d normally use a web browser to make this sort of connection, let’s take just one step up from <code>telnet</code> and use a command-line program that knows how to speak to the HTTP application layer. We’ll use the <code>curl</code> utility with a special option to record details about its communication:</p>
<pre><code>$ <b>curl --trace-ascii </b><var class="bold">trace_file</var><b> http://www.example.org/</b></code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Your distribution may not have the <var>curl</var> package preinstalled, but you should have no trouble installing it if necessary.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>You’ll get a lot of HTML output. Ignore it (or redirect it to <em>/dev/null</em>) and instead look at the newly created file <em>trace_file</em>. If the connection was successful, the first part of the file should look something like the following, at the point where <code>curl</code> attempts to establish the TCP connection to the server:</p>
<pre><code>== Info:   Trying 93.184.216.34...
== Info: TCP_NODELAY set
== Info: Connected to www.example.org (93.184.216.34) port 80 (#0)</code></pre>
<p>Everything you’ve seen so far happens in the transport layer or below. However, if this connection succeeds, <code>curl</code> then tries to send the request (the “header”); this is where the application layer starts:</p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> =&gt; Send header, 79 bytes (0x4f)
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> 0000: <b>GET / HTTP/1.1</b>
0010: <b>Host: www.example.org</b>
0027: <b>User-Agent: curl/7.58.0</b>
0040: <b>Accept: */*</b>
004d: </code></pre>
<p>Line <span class="CodeAnnotation" aria-label="annotation1">1</span> is <code>curl</code> debugging output telling you what it will do next. The remaining lines show what <code>curl</code> sends to the server. The text in bold is what goes to the server; the hexadecimal numbers at the beginning are just debugging offsets <code>curl</code> adds to help you keep track of how much data was sent or received. </p>
<p>At <span class="CodeAnnotation" aria-label="annotation2">2</span>, you can see that <code>curl</code> starts by issuing a <code>GET</code> command to the server (as you did with <code>telnet</code>), followed by some extra information for the server and an empty line. Next, the server sends a reply, first with its own header, shown here in bold:</p>
<pre><code>&lt;= Recv header, 17 bytes (0x11)
0000: <b>HTTP/1.1 200 OK</b>
&lt;= Recv header, 22 bytes (0x16)
0000: <b>Accept-Ranges: bytes</b>
<span epub:type="pagebreak" title="272" id="Page_272"/>&lt;= Recv header, 12 bytes (0xc)
0000: <b>Age: 17629</b>
--<var>snip</var>--</code></pre>
<p>Much like the previous output, the <code>&lt;=</code> lines are debugging output, and <code>0000:</code> precedes the lines of output to tell you the offsets (in <code>curl</code>, the header won’t count toward the offset; that’s why all of these lines begin with 0).</p>
<p>The header in the server’s reply can be fairly long, but at some point the server transitions from transmitting headers to sending the actual requested document, like this:</p>
<pre><code>&lt;= Recv header, 22 bytes (0x16)
0000: <b>Content-Length: 1256</b>
&lt;= Recv header, 2 bytes (0x2)
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> 0000: 
&lt;= Recv data, 1256 bytes (0x4e8)
0000: <b>&lt;!doctype html&gt;.&lt;html&gt;.&lt;head&gt;.    &lt;title&gt;Example Domain&lt;/title&gt;.</b>
0040: <b>.    &lt;meta charset="utf-8" /&gt;.    &lt;meta http-equiv="Content-type</b>
--<var>snip</var>--</code></pre>
<p>This output also illustrates an important property of the application layer. Even though the debugging output says <code>Recv header</code> and <code>Recv data</code>, implying that those are two different kinds of messages from the server, there’s no difference in how <code>curl</code> talked to the operating system to retrieve the two messages, in how the operating system handled them, or in how the network handled the packets underneath. The difference is entirely within the user-space <code>curl</code> application. <code>curl</code> knew that until this point it had been getting headers, but when it received a blank line <span class="CodeAnnotation" aria-label="annotation1">1</span>, which signifies the end of headers in HTTP, it knew to interpret anything that followed as the requested document.</p>
<p>The same is true of the server sending this data. When sending the reply, the server’s operating system didn’t differentiate between header and document data; the distinctions happen inside the user-space server program.</p>
<h2 id="h1-500402c10-0003">	10.3	Network Servers</h2>
<p class="BodyFirst">Most network servers are like other server daemons on your system such as cron, except that they interact with network ports. In fact, syslogd, discussed in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>, accepts UDP packets on port 514 when started with the <code>-r</code> option.</p>
<p>Here are some other common network servers that you might find running on your system: </p>
<ol class="none">
<li><span class="RunInHead">httpd, apache, apache2, nginx</span>  Web servers</li>
<li><span class="RunInHead">sshd</span>  Secure shell daemon</li>
<li><span class="RunInHead">postfix, qmail, sendmail</span>  Mail servers</li>
<li><span epub:type="pagebreak" title="273" id="Page_273"/><span class="RunInHead">cupsd</span>  Print server</li>
<li><span class="RunInHead">nfsd, mountd</span>  Network filesystem (file-sharing) daemons</li>
<li><span class="RunInHead">smbd, nmbd</span>  Windows file-sharing daemons (see <span class="xref" itemid="xref_target_Chapter 12">Chapter 12</span>)</li>
<li><span class="RunInHead">rpcbind</span>  Remote procedure call (RPC) portmap service daemon</li>
</ol>
<p>One feature common to most network servers is that they usually operate as multiple processes. At least one process listens on a network port, and upon receiving a new incoming connection, the listening process uses <code>fork()</code> to create a child process, which is then responsible for the new connection. The child, often called a <em>worker</em> process, terminates when the connection is closed. Meanwhile, the original listening process continues to listen on the network port. This process allows a server to easily handle many connections without much trouble.</p>
<p>There are some exceptions to this model, however. Calling <code>fork()</code> adds a significant amount of system overhead. To avoid this, high-performance TCP servers such as the Apache web server may create a number of worker processes upon startup so they’re available to handle connections as needed. Servers that accept UDP packets don’t need to fork at all, as they don’t have connections to listen for; they simply receive data and react to it.</p>
<h3 id="h2-500402c10-0001">10.3.1	 Secure Shell</h3>
<p class="BodyFirst">Every network server program works a bit differently. To get hands-on experience with a server’s configuration and operation, let’s take a close look at the standalone secure shell (SSH) server. One of the most common network service applications, SSH is the de facto standard for remote access to a Unix machine. SSH is designed to allow secure shell logins, remote program execution, simple file sharing, and more—replacing the old, insecure <code>telnet</code> and <code>rlogin</code> remote-access systems with public-key cryptography for authentication and simpler ciphers for session data. Most ISPs and cloud providers require SSH for shell access to their services, and many Linux-based network appliances (such as network attached storage, or NAS, devices) provide access via SSH as well. OpenSSH (<a href="http://www.openssh.com/" class="LinkURL">http://www.openssh.com/</a>) is a popular free SSH implementation for Unix, and nearly all Linux distributions come with it preinstalled. The OpenSSH client program is <code>ssh</code>, and the server is sshd. There are two main SSH protocol versions: 1 and 2. OpenSSH supports only version 2, having dropped version 1 support due to vulnerabilities and lack of use.</p>
<p>Among its many useful capabilities and features, SSH does the following:</p>
<ul>
<li>Encrypts your password and all other session data, protecting you from snoopers. </li>
<li>Tunnels other network connections, including those from X Window System clients. (You’ll learn more about X in <span class="xref" itemid="xref_target_Chapter 14">Chapter 14</span>.)</li>
<li>Offers clients for nearly any operating system. </li>
<li>Uses keys for host authentication. </li>
</ul>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="274" id="Page_274"/><h2><span class="NoteHead">NOTE</span></h2>
<p>	<span class="Regular">Tunneling</span> is the process of packaging and transporting one network connection within another. The advantages of using SSH to tunnel X Window System connections are that SSH sets up the display environment for you, and it encrypts the X data inside the tunnel.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>SSH does have a few disadvantages. For one, in order to set up an SSH connection, you need the remote host’s public key, and you don’t necessarily get it in a secure way (though you can check it manually to make sure you’re not being spoofed). For an overview of how several methods of cryptography work, get your hands on the book <em>Serious Cryptography: A Practical Introduction to Modern Encryption</em> (No Starch Press, 2017), by Jean-Philippe Aumasson. Two in-depth books on SSH are <em>SSH Mastery: OpenSSH, PuTTY, Tunnels, and Keys</em>, 2nd edition, by Michael W. Lucas (Tilted Windmill Press, 2018) and <em>SSH, The Secure Shell: The Definitive Guide</em>, 2nd edition, by Daniel J. Barrett, Richard E. Silverman, and Robert G. Byrnes (O’Reilly, 2005).</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Public-Key Cryptography</h2>
<p class="BoxBodyFirst">We’ve been using the term <em>public key</em> without much context, so let’s step back and briefly discuss it in case you aren’t familiar with it. Until the 1970s, encryption algorithms were <em>symmetric</em>, requiring a message’s sender and recipient to have the same key. Breaking the code was a matter of stealing the key, and the more people who had it, the more opportunities there were for it to be compromised. But with public key cryptography, there are two keys: public and private. The <em>public key</em> can encrypt a message but not decrypt it; therefore, it doesn’t matter who has access to this key. Only the <em>private key</em> can decrypt a message from the public key. In most cases, it’s easier to protect the private key because there need only be one copy, and it doesn’t have to be transmitted.</p>
<p>Another application beyond encryption is authentication; there are ways to verify that someone holds a private key for a given public key without transmitting any keys.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c10-0002">10.3.2	 The sshd Server</h3>
<p class="BodyFirst">Running the sshd server to allow remote connections to your system requires a configuration file and host keys. Most distributions keep configurations in the <em>/etc/ssh</em> configuration directory and try to configure everything properly for you if you install their sshd package. (The server configuration filename <em>sshd_config</em> is easy to confuse with the client’s <em>ssh_config</em> setup file, so be careful.) </p>
<p>You shouldn’t need to change anything in <em>sshd_config</em>, but it never hurts to check. The file consists of key-value pairs, as shown in this fragment. </p>
<span epub:type="pagebreak" title="275" id="Page_275"/>
<pre><code>Port 22
#AddressFamily any

#ListenAddress 0.0.0.0
#ListenAddress ::
#HostKey /etc/ssh/ssh_host_rsa_key
#HostKey /etc/ssh/ssh_host_ecdsa_key
#HostKey /etc/ssh/ssh_host_ed25519_key
</code></pre>
<p>Lines beginning with <code>#</code> are comments, and many comments in your <em>sshd_config</em> indicate default values for various parameters, as you can see from this excerpt. The sshd_config(5) manual page contains descriptions of the parameters and possible values, but these are among the most important: </p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">HostKey </code><var class="bold">file</var></span>  Uses <var>file</var> as a host key. (Host keys are described next.)</li>
<li><span class="RunInHead"><code class="bold">PermitRootLogin </code><var class="bold">value</var></span>  Permits the superuser to log in with SSH if <var>value</var> is set to <code>yes</code>. Set <var>value</var> to <code>no</code> to prevent this. </li>
<li><span class="RunInHead"><code class="bold">LogLevel </code><var class="bold">level</var></span>  Logs messages with syslog level <var>level</var> (defaults to <code>INFO</code>).</li>
<li><span class="RunInHead"><code class="bold">SyslogFacility </code><var class="bold">name</var></span>  Logs messages with syslog facility <var>name</var> (defaults to <code>AUTH</code>).</li>
<li><span class="RunInHead"><code class="bold">X11Forwarding </code><var class="bold">value</var></span>  Enables X Window System client tunneling if <var>value</var> is set to <code>yes</code>. </li>
<li><span class="RunInHead"><code class="bold">XAuthLocation </code><var class="bold">path</var></span>  Specifies the location of the <code>xauth</code> utility on your system. X tunneling will not work without this path. If <code>xauth</code> isn’t in <em>/usr/bin</em>, set <var>path</var> to the full pathname for <code>xauth</code>. </li>
</ol>
<h4 id="h3-500402c10-0001">Creating Host Keys</h4>
<p class="BodyFirst">OpenSSH has several host key sets. Each set has a public key (with a <em>.pub</em> file extension) and a private key (with no extension).</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">WARNING</span></h2>
<p>	Do not let anyone see a private key, even on your own system, because if someone obtains it, you’re at risk from intruders. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>SSH version 2 has RSA and DSA keys. RSA and DSA are public key cryptography algorithms. The key filenames are given in <a href="#table10-1" id="tableanchor10-1">Table 10-1</a>. </p>
<figure>
<figcaption class="TableTitle"><p><a id="table10-1">Table 10-1</a>: OpenSSH Key Files</p></figcaption>
<table id="table-500402c10-0001" border="1">
<thead>
<tr>
<td><b>Filename</b></td><td><b>Key type</b></td></tr>
</thead>
<tbody>
<tr>
<td><em>ssh_host_rsa_key</em></td><td>Private RSA key</td></tr>
<tr>
<td><em>ssh_host_rsa_key.pub</em></td><td>Public RSA key</td></tr>
<tr>
<td><em>ssh_host_dsa_key</em></td><td>Private DSA key</td></tr>
<tr>
<td><em>ssh_host_dsa_key.pub</em></td><td>Public DSA key</td></tr>
</tbody>
</table>
</figure>
<p><span epub:type="pagebreak" title="276" id="Page_276"/>Creating a key involves a numerical computation that generates both public and private keys. Normally you won’t need to create the keys because the OpenSSH installation program or your distribution’s installation script will do it for you, but you need to know how to do so if you plan to use programs like <code>ssh-agent</code> that provide authentication services without a password. To create SSH protocol version 2 keys, use the <code>ssh-keygen</code> program that comes with OpenSSH: </p>
<pre><code># <b>ssh-keygen -t rsa -N '' -f /etc/ssh/ssh_host_rsa_key</b>
# <b>ssh-keygen -t dsa -N '' -f /etc/ssh/ssh_host_dsa_key</b></code></pre>
<p>The SSH server and clients also use a <em>key file</em>, called <em>ssh_known_hosts</em>, to store public keys from other hosts. If you intend to use authentication based on a remote client’s identity, the server’s <em>ssh_known_hosts</em> file must contain the public host keys of all trusted clients. Knowing about the key files is handy if you’re replacing a machine. When installing a new machine from scratch, you can import the key files from the old machine to ensure that users don’t get key mismatches when connecting to the new one.</p>
<h4 id="h3-500402c10-0002">Starting the SSH Server</h4>
<p class="BodyFirst">Although most distributions ship with SSH, they usually don’t start the sshd server by default. On Ubuntu and Debian, the SSH server is not installed on a new system; installing its package creates the keys, starts the server, and adds the server startup to the bootup configuration.</p>
<p>On Fedora, sshd is installed by default but turned off. To start sshd at boot, use <code>systemctl</code> like this:</p>
<pre><code># <b>systemctl enable sshd</b></code></pre>
<p>If you want to start the server immediately without rebooting, use:</p>
<pre><code># <b>systemctl start sshd</b></code></pre>
<p>Fedora normally creates any missing host key files upon the first sshd startup.</p>
<p>If you’re running another distribution, you likely won’t need to manually configure the sshd startup. However, you should know that there are two startup modes: standalone and on-demand. The standalone server is by far more common, and it’s just a matter of running sshd as root. The sshd server process writes its PID to <em>/var/run/sshd.pid</em> (of course, when run by systemd, it’s also tracked by its cgroup, as you saw in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>).</p>
<p>As an alternative, systemd can start sshd on demand through a socket unit. This usually isn’t a good idea, because the server occasionally needs to generate key files, and that process can take a long time.</p>
<h3 id="h2-500402c10-0003">10.3.3	 fail2ban</h3>
<p class="BodyFirst">If you set up an SSH server on your machine and open it up to the internet, you’ll quickly discover constant intrusion attempts. These brute-force <span epub:type="pagebreak" title="277" id="Page_277"/>attacks won’t succeed if your system is properly configured and you haven’t chosen stupid passwords. However, they will be annoying, consume CPU time, and unnecessarily clutter your logs.</p>
<p>To prevent this, you want to set up a mechanism to block repeated login attempts. As of this writing, the fail2ban package is the most popular way to do this; it’s simply a script that watches log messages. Upon seeing a certain number of failed requests from one host within a certain time frame, fail2ban uses <code>iptables</code> to create a rule to deny traffic from that host. After a specified period, during which the host has probably given up trying to connect, fail2ban removes the rule.</p>
<p>Most Linux distributions offer a fail2ban package with preconfigured defaults for SSH.</p>
<h3 id="h2-500402c10-0004">10.3.4	 The SSH Client</h3>
<p class="BodyFirst">To log in to a remote host, run:</p>
<pre><code>$<b> ssh </b><var class="bold">remote_username</var><b>@</b><var class="bold">remote_host</var></code></pre>
<p>You may omit <var>remote_username</var><code>@</code> if your local username is the same as on <var>remote_host</var>. You can also run pipelines to and from an <code>ssh</code> command as shown in the following example, which copies a directory <em>dir</em> to another host:</p>
<pre><code>$ <b>tar zcvf - </b><var class="bold">dir</var><b> | ssh </b><var class="bold">remote_host</var><b> tar zxvf -</b></code></pre>
<p>The global SSH client configuration file <em>ssh_config</em> should be in <em>/etc/ssh</em>, the same location as your <em>sshd_config</em> file. As with the server configuration file, the client configuration file has key-value pairs, but you shouldn’t need to change them. </p>
<p>The most frequent problem with using SSH clients occurs when an SSH public key in your local <em>ssh_known_hosts</em> or <em>.ssh/known_hosts</em> file does not match the key on the remote host. Bad keys cause errors or warnings like this: </p>
<pre><code>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that the RSA host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
38:c2:f6:0d:0d:49:d4:05:55:68:54:2a:2f:83:06:11.
Please contact your system administrator.
Add correct host key in /home/<var>user</var>/.ssh/known_hosts to get rid of this message.
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> Offending key in /home/<var>user</var>/.ssh/known_hosts:12
RSA host key for <var>host</var> has changed and you have requested
strict checking.
Host key verification failed.</code></pre>
<p><span epub:type="pagebreak" title="278" id="Page_278"/>This usually just means that the remote host’s administrator changed the keys (which often happens upon a hardware or cloud server upgrade), but it never hurts to check with the administrator if you’re not sure. In any case, the preceding message tells you that the bad key is in line 12 of a user’s <em>known_hosts</em> file <span class="CodeAnnotation" aria-label="annotation1">1</span>. </p>
<p>If you don’t suspect foul play, just remove the offending line or replace it with the correct public key. </p>
<h4 id="h3-500402c10-0003">SSH File Transfer Clients</h4>
<p class="BodyFirst">OpenSSH includes the file transfer programs <code>scp</code> and <code>sftp</code>, which are intended as replacements for the older, insecure programs <code>rcp</code> and <code>ftp</code>. You can use <code>scp</code> to transfer files to or from a remote machine to your machine or from one host to another. It works like the <code>cp</code> command. Here are a few examples.</p>
<p>Copy a file from a remote host to the current directory: </p>
<pre><code>$ <b>scp </b><var class="bold">user</var><b>@</b><var class="bold">host</var><b>:</b><var class="bold">file</var><b> .</b></code></pre>
<p>Copy a file from the local machine to a remote host:</p>
<pre><code>$ <b>scp </b><var class="bold">file</var><b> </b><var class="bold">user</var><b>@</b><var class="bold">host</var><b>:</b><var class="bold">dir</var></code></pre>
<p>Copy a file from one remote host to a second remote host:</p>
<pre><code>$ <b>scp </b><var class="bold">user1</var><b>@</b><var class="bold">host1</var><b>:</b><var class="bold">file</var><b> </b><var class="bold">user2</var><b>@</b><var class="bold">host2</var><b>:</b><var class="bold">dir</var></code></pre>
<p>The <code>sftp</code> program works like the obsolete command-line <code>ftp</code> client, using <code>get</code> and <code>put</code> commands. The remote host must have an <code>sftp-server</code> program installed, which you can expect if the remote host also uses OpenSSH.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	If you need more features and flexibility than what <var>scp</var> and <var>sftp</var> offer (for example, if you frequently transfer large numbers of files), have a look at <var>rsync</var>, described in <span class="xref" itemid="xref_target_Chapter 12">Chapter 12</span>. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-500402c10-0004">SSH Clients for Non-Unix Platforms</h4>
<p class="BodyFirst">There are SSH clients for all popular operating systems. Which one should you choose? PuTTY is a good, basic Windows client that includes a secure file-copy program. macOS is based on Unix and includes OpenSSH.</p>
<h2 id="h1-500402c10-0004">	10.4	Pre-systemd Network Connection Servers: inetd/xinetd</h2>
<p class="BodyFirst">Before the widespread use of systemd and the socket units that you saw in <span class="xref" itemid="xref_target_Section 6.3.7">Section 6.3.7</span>, there were a handful of servers that provided a standard means of building a network service. Many minor network services are very similar in their connection requirements, so implementing standalone servers for every service can be inefficient. Each server must be separately configured to handle port listening, access control, and port configuration. <span epub:type="pagebreak" title="279" id="Page_279"/>These actions are performed in the same way for most services; only when a server accepts a connection is communication handled any differently.</p>
<p>One traditional way to simplify the use of servers is with the inetd daemon, a kind of <em>superserver</em> designed to standardize network port access and interfaces between server programs and network ports. After you start inetd, it reads its configuration file and then listens on the network ports defined in that file. As new network connections come in, inetd attaches a newly started process to the connection.</p>
<p>A newer version of inetd called xinetd offers easier configuration and better access control, but xinetd has almost entirely been phased out in favor of systemd. However, you might see it on an older system or one that does not use systemd.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>TCP Wrappers: tcpd, /etc/hosts.allow, and /etc/hosts.deny</h2>
<p class="BoxBodyFirst">Before lower-level firewalls such as <code>iptables</code> became popular, many administrators used the <em>TCP wrapper</em> library and daemon to control access to network services. In these implementations, inetd runs the <code>tcpd</code> program, which first looks at the incoming connection as well as the access control lists in the <em>/etc/hosts.allow</em> and <em>/etc/hosts.deny</em> files. The <code>tcpd</code> program logs the connection, and if it decides that the incoming connection is okay, it hands it to the final service program. You might encounter systems that still use the TCP wrapper system, but we won’t cover it in detail because it has largely fallen out of use.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500402c10-0005">	10.5	Diagnostic Tools</h2>
<p class="BodyFirst">Let’s look at a few diagnostic tools that are useful for poking around the application layer. Some dig into the transport and network layers, because everything in the application layer eventually maps down to something in those lower layers.</p>
<p>As discussed in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>, <code>netstat</code> is a basic network service debugging tool that can display a number of transport and network layer statistics. <a href="#table10-2" id="tableanchor10-2">Table 10-2</a> reviews a few useful options for viewing connections.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table10-2">Table 10-2</a>: Useful Connection-Reporting Options for netstat</p></figcaption>
<table id="table-500402c10-0002" border="1">
<thead>
<tr>
<td><b>Option</b></td><td><b>Description</b></td></tr>
</thead>
<tbody>
<tr>
<td><code>-t</code></td><td>Prints TCP port information</td></tr>
<tr>
<td><code>-u</code></td><td>Prints UDP port information</td></tr>
<tr>
<td><code>-l</code></td><td>Prints listening ports</td></tr>
<tr>
<td><code>-a</code></td><td>Prints every active port</td></tr>
<tr>
<td><code>-n</code></td><td>Disables name lookups (speeds things up; also useful if DNS isn’t working)</td></tr>
<tr>
<td><code>-4</code>, <code>-6</code></td><td>Limits the output to IP version 4 or 6</td></tr>
</tbody>
</table>
</figure>
<h3 id="h2-500402c10-0005"><span epub:type="pagebreak" title="280" id="Page_280"/>10.5.1	 lsof</h3>
<p class="BodyFirst">In <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>, you learned that <code>lsof</code> not only can track open files, but can also list the programs currently using or listening to ports. For a complete list of such programs, run:</p>
<pre><code># <b>lsof -i</b></code></pre>
<p>When you run this command as a regular user, it shows only that user’s processes. When you run it as root, the output should look something like this, displaying a variety of processes and users:</p>
<pre><code>COMMAND     PID     USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME
rpcbind     700     root    6u  IPv4    10492      0t0  UDP *:sunrpc <span class="CodeAnnotation" aria-label="annotation1">1</span>
rpcbind     700     root    8u  IPv4    10508      0t0  TCP *:sunrpc (LISTEN)
avahi-dae   872    avahi   13u  IPv4 21736375      0t0  UDP *:mdns <span class="CodeAnnotation" aria-label="annotation2">2</span>
cupsd      1010     root    9u  IPv6 42321174      0t0  TCP ip6-localhost:ipp (LISTEN) <span class="CodeAnnotation" aria-label="annotation3">3</span>
ssh       14366    juser    3u  IPv4 38995911      0t0  TCP thishost.local:55457-&gt; <span class="CodeAnnotation" aria-label="annotation4">4</span>
    somehost.example.com:ssh (ESTABLISHED)
chromium- 26534    juser    8r  IPv4 42525253      0t0  TCP thishost.local:41551-&gt; <span class="CodeAnnotation" aria-label="annotation5">5</span>
    anotherhost.example.com:https (ESTABLISHED)</code></pre>
<p>This example output shows users and process IDs for server and client programs, from the old-style RPC services at the top <span class="CodeAnnotation" aria-label="annotation1">1</span>, to the multicast DNS service provided by <code>avahi</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, to even an IPv6-ready printer service, cupsd <span class="CodeAnnotation" aria-label="annotation3">3</span>. The last two entries show client connections: an SSH connection <span class="CodeAnnotation" aria-label="annotation4">4</span> and a secure web connection from the Chromium web browser <span class="CodeAnnotation" aria-label="annotation5">5</span>. Because the output can be extensive, it’s usually best to apply a filter (as discussed in the following section). </p>
<p>The <code>lsof</code> program is like <code>netstat</code> in that it tries to reverse-resolve every IP address that it finds into a hostname, which slows down the output. Use the <code>-n</code> option to disable name resolution:</p>
<pre><code># <b>lsof -n -i</b></code></pre>
<p>You can also specify <code>-P</code> to disable <em>/etc/services</em> port name lookups.</p>
<h4 id="h3-500402c10-0005">Filtering by Protocol and Port </h4>
<p class="BodyFirst">If you’re looking for a particular port (say, you know that a process is using a particular port and you want to know what that process is), use this command:</p>
<pre><code># <b>lsof -i:</b><var class="bold">port</var></code></pre>
<p>The full syntax is as follows: </p>
<pre><code># <b>lsof -i</b><var class="bold">protocol</var><b>@</b><var class="bold">host</var><b>:</b><var class="bold">port</var></code></pre>
<p><span epub:type="pagebreak" title="281" id="Page_281"/>The <var>protocol</var>, <code>@</code><var>host</var>, and <code>:</code><var>port</var> parameters are all optional and will filter the <code>lsof</code> output accordingly. As with most network utilities, <var>host</var> and <var>port</var> can be either names or numbers. For example, if you want to see connections only on TCP port 443 (the HTTPS port), use:</p>
<pre><code># <b>lsof -iTCP:443</b></code></pre>
<p>To filter based on IP version, use <code>-i4</code> (IPv4) or <code>-i6</code> (IPv6). You can add this as a separate option or just add the number in with more complex filters (for example, <code>-i6TCP:443</code>).</p>
<p>You can specify service names from <em>/etc/services</em> (as in <code>-iTCP:ssh</code>) instead of numbers.</p>
<h4 id="h3-500402c10-0006">Filtering by Connection Status</h4>
<p class="BodyFirst">One particularly handy <code>lsof</code> filter is connection status. For example, to show only the processes listening on TCP ports, enter:</p>
<pre><code># <b>lsof -iTCP -sTCP:LISTEN</b></code></pre>
<p>This command gives you a good overview of the network server processes currently running on your system. However, because UDP servers don’t listen and don’t have connections, you’ll have to use <code>-iUDP</code> to view running clients as well as servers. This usually isn’t a problem, because you probably won’t have many UDP servers on your system.</p>
<h3 id="h2-500402c10-0006">10.5.2	 tcpdump</h3>
<p class="BodyFirst">Your system normally doesn’t bother with network traffic that isn’t addressed to one of its MAC addresses. If you need to see exactly what’s crossing your network, <code>tcpdump</code> puts your network interface card into <em>promiscuous mode</em> and reports on every packet that comes across. Entering <code>tcpdump</code> with no arguments produces output like the following, which includes an ARP request and web connection:</p>
<pre><code># <b>tcpdump</b>
tcpdump: listening on eth0
20:36:25.771304 arp who-has mikado.example.com tell duplex.example.com
20:36:25.774729 arp reply mikado.example.com is-at 0:2:2d:b:ee:4e
20:36:25.774796 duplex.example.com.48455 &gt; mikado.example.com.www: S 3200063165:3200063165(0) win 5840 &lt;mss 1460,sackOK,timestamp 38815804[|tcp]&gt; (DF)
20:36:25.779283 mikado.example.com.www &gt; duplex.example.com.48455: S 3494716463:3494716463(0) ack 3200063166 win 5792 &lt;mss 1460,sackOK,timestamp 4620[|tcp]&gt; (DF)
20:36:25.779409 duplex.example.com.48455 &gt; mikado.example.com.www: . ack 1 win 5840 &lt;nop,nop,timestamp 38815805 4620&gt; (DF)
20:36:25.779787 duplex.example.com.48455 &gt; mikado.example.com.www: P 1:427(426) ack 1 win 5840 &lt;nop,nop,timestamp 38815805 4620&gt; (DF)
20:36:25.784012 mikado.example.com.www &gt; duplex.example.com.48455: . ack 427 <span epub:type="pagebreak" title="282" id="Page_282"/>win 6432 &lt;nop,nop,timestamp 4620 38815805&gt; (DF)
20:36:25.845645 mikado.example.com.www &gt; duplex.example.com.48455: P 1:773(772) ack 427 win 6432 &lt;nop,nop,timestamp 4626 38815805&gt; (DF)
20:36:25.845732 duplex.example.com.48455 &gt; mikado.example.com.www: . ack 773 win 6948 &lt;nop,nop,timestamp 38815812 4626&gt; (DF)

9 packets received by filter
0 packets dropped by kernel</code></pre>
<p>You can tell <code>tcpdump</code> to be more specific by adding filters. You can filter based on source and destination hosts, networks, Ethernet addresses, protocols at many different layers in the network model, and much more. Among the many packet protocols that <code>tcpdump</code> recognizes are ARP, RARP, ICMP, TCP, UDP, IP, IPv6, AppleTalk, and IPX packets. For example, to tell <code>tcpdump</code> to output only TCP packets, run:</p>
<pre><code># <b>tcpdump tcp</b></code></pre>
<p>To see web packets and UDP packets, enter:</p>
<pre><code># <b>tcpdump udp or port 80 or port 443</b></code></pre>
<p>The keyword <code>or</code> specifies that the condition on either the left or right can be true to pass the filter. Similarly, the <code>and</code> keyword requires both conditions to be true.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	If you need to do a lot of packet sniffing, consider using a GUI alternative to <var>tcpdump</var> such as Wireshark.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-500402c10-0007">Primitives</h4>
<p class="BodyFirst">In the preceding examples, <code>tcp</code>, <code>udp</code>, and <code>port</code> <code>80</code> are basic elements of filters called <em>primitives</em>. The most important primitives are listed in <a href="#table10-3" id="tableanchor10-3">Table 10-3</a>. </p>
<figure>
<figcaption class="TableTitle"><p><a id="table10-3">Table 10-3</a>: tcpdump Primitives</p></figcaption>
<table id="table-500402c10-0003" border="1">
<thead>
<tr>
<td><b>Primitive</b></td><td><b>Packet specification</b></td></tr>
</thead>
<tbody>
<tr>
<td><code>tcp</code></td><td>TCP packets</td></tr>
<tr>
<td><code>udp</code></td><td>UDP packets</td></tr>
<tr>
<td><code>ip</code></td><td>IPv4 packets</td></tr>
<tr>
<td><code>ip6</code></td><td>IPv6 packets</td></tr>
<tr>
<td><code>port </code><var>port</var></td><td>TCP and/or UDP packets to/from port <var>port</var></td></tr>
<tr>
<td><code>host </code><var>host</var></td><td>Packets to or from <var>host</var></td></tr>
<tr>
<td><code>net </code><var>network</var></td><td>Packets to or from <var>network</var></td></tr>
</tbody>
</table>
</figure>
<h4 id="h3-500402c10-0008"><span epub:type="pagebreak" title="283" id="Page_283"/>Operators</h4>
<p class="BodyFirst">The <code>or</code> used earlier is an <em>operator</em>. <code>tcpdump</code> can use multiple operators (such as <code>and</code> and <code>!</code>), and you can group operators in parentheses. If you plan to do any serious work with <code>tcpdump</code>, make sure to read the pcap-filter(7) manual page, especially the section that describes the primitives. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Be careful when using <var>tcpdump</var>. The <var>tcpdump</var> output shown earlier in this section includes only packet TCP (transport layer) and IP (internet layer) header information, but you can also make <var>tcpdump</var> print the entire packet contents. Even though most important network traffic is now encrypted over TLS, you shouldn’t snoop around on networks unless you own them or otherwise have permission.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c10-0007">10.5.3	 netcat</h3>
<p class="BodyFirst">If you need more flexibility in connecting to a remote host than a command like <code>telnet </code><var>host</var><code> </code><var>port</var> allows, use <code>netcat</code> (or <code>nc</code>). <code>netcat</code> can connect to remote TCP/UDP ports, specify a local port, listen on ports, scan ports, redirect standard I/O to and from network connections, and more. To open a TCP connection to a port with <code>netcat</code>, run:</p>
<pre><code>$ <b>netcat host </b><var class="bold">port</var></code></pre>
<p><code>netcat</code> terminates when the other side ends the connection, which can be confusing if you redirect standard input to <code>netcat</code>, because you might not get your prompt back after sending data (as opposed to almost any other command pipeline). You can end the connection at any time by pressing <span class="KeyCaps">ctrl-C</span>. (If you’d like the program and network connection to terminate based on the standard input stream, try the <code>sock</code> program instead.)</p>
<p>To listen on a particular port, run:</p>
<pre><code>$ <b>netcat -l </b><var class="bold">port_number</var></code></pre>
<p>If <code>netcat</code> is successful at listening on the port, it will wait for a connection, and upon establishing a connection, prints the output from that connection, and sends any standard input to the connection.</p>
<p>Here are some additional notes on <code>netcat</code>:</p>
<ul>
<li>There isn’t much debugging output by default. If something fails, <code>netcat</code> fails silently, but it does set an appropriate exit code. If you’d like some more information, add the <code>-v</code> (“verbose”) option.</li>
<li>By default, the <code>netcat</code> client tries to connect with IPv4 and IPv6. However, in server mode, <code>netcat</code> defaults to IPv4. To force the protocol, use <code>-4</code> for IPv4 and <code>-6</code> for IPv6.</li>
<li>The <code>-u</code> option specifies UDP instead of TCP.</li>
</ul>
<h3 id="h2-500402c10-0008"><span epub:type="pagebreak" title="284" id="Page_284"/>10.5.4	 Port Scanning</h3>
<p class="BodyFirst">Sometimes you don’t even know what services the machines on your networks are offering or even which IP addresses are in use. The Network Mapper (Nmap) program scans all ports on a machine or network of machines looking for open ports, and it lists the ports it finds. Most distributions have an Nmap package, or you can get it at <a href="http://www.insecure.org/" class="LinkURL">http://www.insecure.org/</a>. (See the Nmap manual page and online resources for all that Nmap can do.)</p>
<p>When listing ports on your own machine, it often helps to run the Nmap scan from at least two points: from your own machine and from another one (possibly outside your local network). Doing so will give you an overview of what your firewall is blocking. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">WARNING</span></h2>
<p>	If someone else controls the network that you want to scan with Nmap, ask for permission. Network administrators watch for port scans and usually disable access to machines that run them. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Run <code class="bold">nmap</code><code> </code><var class="bold">host</var> to run a generic scan on a host. For example: </p>
<pre><code>$ <b>nmap</b><code> </code><b>10.1.2.2</b>
Starting Nmap 5.21 ( http://nmap.org ) at 2015-09-21 16:51 PST
Nmap scan report for 10.1.2.2
Host is up (0.00027s latency).
Not shown: 993 closed ports
PORT     STATE SERVICE
22/tcp   open  ssh
25/tcp   open  smtp
80/tcp   open  http
111/tcp  open  rpcbind
8800/tcp open  unknown
9000/tcp open  cslistener
9090/tcp open  zeus-admin

Nmap done: 1 IP address (1 host up) scanned in 0.12 seconds</code></pre>
<p>As you can see here, a number of services are open, many of which are not enabled by default on most distributions. In fact, the only one here that’s usually on by default is port 111, the <code>rpcbind</code> port.</p>
<p>Nmap is also capable of scanning ports over IPv6 if you add the <code>-6</code> option. This can be a handy way of identifying services that do not support IPv6.</p>
<h2 id="h1-500402c10-0006">	10.6	Remote Procedure Calls</h2>
<p class="BodyFirst">What about the rpcbind service from the scan in the preceding section? RPC stands for <em>remote procedure call (RPC)</em>, a system residing in the lower parts of the application layer. It’s designed to make it easier for programmers to build client/server network applications, where a client program calls functions that execute on a remote server. Each type of remote server program is identified by an assigned program number. </p>
<p><span epub:type="pagebreak" title="285" id="Page_285"/>RPC implementations use transport protocols such as TCP and UDP, and they require a special intermediary service to map program numbers to TCP and UDP ports. The server is called rpcbind, and it must be running on any machine that wants to use RPC services. </p>
<p>To see what RPC services your computer has, run:</p>
<pre><code>$ <b>rpcinfo -p localhost</b></code></pre>
<p>RPC is one of those protocols that just doesn’t want to die. The Network File System (NFS) and Network Information Service (NIS) systems use RPC, but they are completely unnecessary on standalone machines. But whenever you think that you’ve eliminated all need for rpcbind, something else comes up, such as File Access Monitor (FAM) support in GNOME. </p>
<h2 id="h1-500402c10-0007">	10.7	Network Security</h2>
<p class="BodyFirst">Because Linux is a very popular Unix flavor on the PC platform, and especially because it is widely used for web servers, it attracts many unpleasant characters who try to break into computer systems. <span class="xref" itemid="xref_target_Section 9.25">Section 9.25</span> discussed firewalls, but that’s not really the whole story on security. </p>
<p>Network security attracts extremists—those who <em>really</em> like to break into systems (whether for fun or money) and those who come up with elaborate protection schemes and <em>really</em> like to swat away people trying to break into their systems. (This, too, can be very profitable.) Fortunately, you don’t need to know very much to keep your system safe. Here are a few basic rules of thumb: </p>
<ol class="none">
<li><span class="RunInHead">Run as few services as possible</span>  Intruders can’t break into services that don’t exist on your system. If you know what a service is and you’re not using it, don’t turn it on for the sole reason that you might want to use it “at some later point.” </li>
<li><span class="RunInHead">Block as much as possible with a firewall</span>  Unix systems have a number of internal services that you may not know about (such as TCP port 111 for the RPC port-mapping server), and no other system in the world <em>should</em> know about them. It can be very difficult to track and regulate the services on your system because many different kinds of programs listen on various ports. To keep intruders from discovering internal services on your system, use effective firewall rules and install a firewall at your router. </li>
<li><span class="RunInHead">Track the services that you offer to the internet</span>  If you run an SSH server, Postfix, or similar services, keep your software up to date and get appropriate security alerts. (See <span class="xref" itemid="xref_target_Section 10.7.2 ">Section 10.7.2 </span>for some online resources.)</li>
<li><span class="RunInHead">Use “long-term support” distribution releases for servers</span>  Security teams normally concentrate their work on stable, supported distribution releases. Development and testing releases such Debian Unstable and Fedora Rawhide receive much less attention.</li>
<li><span epub:type="pagebreak" title="286" id="Page_286"/><span class="RunInHead">Don’t give an account on your system to anyone who doesn’t need one</span>  It’s much easier to gain superuser access from a local account than it is to break in remotely. In fact, given the huge base of software (and the resulting bugs and design flaws) available on most systems, it can be easy to gain superuser access to a system after you get to a shell prompt. Don’t assume that your friends know how to protect their passwords (or choose good passwords in the first place). </li>
<li><span class="RunInHead">Avoid installing dubious binary packages</span>  They can contain Trojan horses. </li>
</ol>
<p>That’s the practical end of protecting yourself. But why is it important to do so? There are three basic kinds of network attacks that can be directed at a Linux machine: </p>
<ol class="none">
<li><span class="RunInHead">Full compromise</span>  This means getting superuser access (full control) of a machine. An intruder can accomplish this by trying a service attack, such as a buffer overflow exploit, or by taking over a poorly protected user account and then trying to exploit a poorly written setuid program.</li>
<li><span class="RunInHead">Denial-of-service (DoS) attack</span>  This prevents a machine from carrying out its network services or forces a computer to malfunction in some other way without the use of any special access. Normally, a DoS attack is just a flood of network requests, but it can also be an exploit of a flaw in a server program that causes a crash. These attacks are harder to prevent, but they are easier to respond to. </li>
<li><span class="RunInHead">Malware</span>  Linux users are mostly immune to malware such as email worms and viruses, simply because their email clients aren’t stupid enough to actually run programs sent in message attachments. But Linux malware does exist. Avoid downloading and installing executable software from places that you’ve never heard of.</li>
</ol>
<h3 id="h2-500402c10-0009">10.7.1	 Typical Vulnerabilities</h3>
<p class="BodyFirst">There are two basic types of vulnerabilities to worry about: direct attacks and cleartext password sniffing. <em>Direct attacks</em> try to take over a machine without being terribly subtle. One of the most common is locating an unprotected or otherwise vulnerable service on your system. This can be as simple as a service that isn’t authenticated by default, such as an administrator account without a password. Once an intruder has access to one service on a system, they can use it to try to compromise the whole system. In the past, a common direct attack was the buffer overflow exploit, where a careless programmer doesn’t check the bounds of a buffer array. This has been mitigated somewhat by Address Space Layout Randomization (ASLR) techniques in the kernel and protective measures elsewhere.</p>
<p>A <em>cleartext password sniffing attack</em> captures passwords sent across the wire as clear text, or uses a password database populated from one of many data breaches. As soon as an attacker gets your password, it’s game over. From there, the assailant will inevitably try to gain superuser access locally (which, as mentioned before, is much easier than making a remote attack), try to use the machine as an intermediary for attacking other hosts, or both. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="287" id="Page_287"/><h2><span class="NoteHead">NOTE</span></h2>
<p>	If you need to run a service that offers no native support for encryption, try Stunnel (<a href="http://www.stunnel.org/" class="LinkURL">http://www.stunnel.org/</a>), an encryption wrapper package much like TCP wrappers. Stunnel is especially good at wrapping services that you’d normally activate with systemd socket units or <var>inetd</var>. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Some services are chronic attack targets due to poor implementation and design. You should always deactivate the following services (they’re all quite dated at this point, and rarely activated by default on most systems): </p>
<ol class="none">
<li><span class="RunInHead">ftpd</span>  For whatever reason, all FTP servers seem plagued with vulnerabilities. In addition, most FTP servers use cleartext passwords. If you have to move files from one machine to another, consider an SSH-based solution or an rsync server. </li>
<li><span class="RunInHead">telnetd, rlogind, rexecd</span>  All of these services pass remote session data (including passwords) in cleartext form. Avoid them unless you have a Kerberos-enabled version. </li>
</ol>
<h3 id="h2-500402c10-0010">10.7.2	 Security Resources</h3>
<p class="BodyFirst">Here are three good security resources: </p>
<ul>
<li>The SANS Institute (<a href="http://www.sans.org/" class="LinkURL">http://www.sans.org/</a>) offers training, services, a free weekly newsletter listing the top current vulnerabilities, sample security policies, and more. </li>
<li>The CERT Division of Carnegie Mellon University’s Software Engineering Institute (<a href="http://www.cert.org/" class="LinkURL">http://www.cert.org/</a>) is a good place to look for the most severe problems. </li>
<li>Insecure.org, a project from hacker and Nmap creator Gordon “Fyodor” Lyon (<a href="http://www.insecure.org/" class="LinkURL">http://www.insecure.org/</a>), is the place to go for Nmap and pointers to all sorts of network exploit-testing tools. It’s much more open and specific about exploits than are many other sites.</li>
</ul>
<p>If you’re interested in network security, you should learn all about Transport Layer Security (TLS) and its predecessor, Secure Socket Layer (SSL). These user-space network levels are typically added to networking clients and servers to support network transactions through the use of public-key encryption and certificates. A good guide is Davies’ <em>Implementing SSL/TLS Using Cryptography and PKI</em> (Wiley, 2011) or Jean-Philippe Aumasson’s <em>Serious Cryptography: A Practical Introduction to Modern Encryption</em> (No Starch Press, 2017).</p>
<h2 id="h1-500402c10-0008">	10.8	Looking Forward</h2>
<p class="BodyFirst">If you’re interested in getting your hands dirty with some complicated network servers, some very common ones are the Apache or nginx web servers and the Postfix email server. In particular, web servers are easy to install and most distributions supply packages. If your machine is behind a firewall or NAT-enabled router, you can experiment with the configuration as much as you’d like without worrying about security.</p>
<p><span epub:type="pagebreak" title="288" id="Page_288"/>Throughout the last few chapters, we’ve been gradually moving from kernel space into user space. Only a few utilities discussed in this chapter, such as <code>tcpdump</code>, interact with the kernel. The remainder of this chapter describes how sockets bridge the gap between the kernel’s transport layer and the user-space application layer. It’s more advanced material, of particular interest to programmers, so feel free to skip to the next chapter if you like.</p>
<h2 id="h1-500402c10-0009">	10.9	Network Sockets</h2>
<p class="BodyFirst">We’re now going to shift gears and look at how processes do the work of reading data from and writing data to the network. It’s easy enough for processes to read from and write to network connections that are already set up: all you need are some system calls, which you can read about in the recv(2) and send(2) manual pages. From the point of view of a process, perhaps the most important thing to know is how to access the network when using these system calls. On Unix systems, a process uses a socket to identify when and how it’s talking to the network. <em>Sockets</em> are the interface that processes use to access the network through the kernel; they represent the boundary between user space and kernel space. They’re often also used for interprocess communication (IPC).</p>
<p>There are different types of sockets because processes need to access the network in different ways. For example, TCP connections are represented by stream sockets (<code>SOCK_STREAM</code>, from a programmer’s point of view), and UDP connections are represented by datagram sockets (<code>SOCK_DGRAM</code>).</p>
<p>Setting up a network socket can be somewhat complicated because you need to account for socket type, IP addresses, ports, and transport protocol at particular times. However, after all of the initial details are sorted out, servers use certain standard methods to deal with incoming traffic from the network. The flowchart in <a href="#figure10-1" id="figureanchor10-1">Figure 10-1</a> shows how many servers handle connections for incoming stream sockets. </p>
<figure>
<img src="image_fi/500402c10/f10001.png" alt="f10001"/>
<figcaption><p><a id="figure10-1">Figure 10-1</a>: One method for accepting and processing incoming connections </p></figcaption></figure>
<p><span epub:type="pagebreak" title="289" id="Page_289"/>Notice that this type of server involves two kinds of sockets: one for listening and one for reading and writing. The master process uses the listening socket to look for connections from the network. When a new connection comes in, the master process uses the <code>accept()</code> system call to accept the connection, which creates the read/write socket dedicated to that connection. Next, the master process uses <code>fork()</code> to create a new child process to deal with the connection. Finally, the original socket remains the listener and continues to look for more connections on behalf of the master process.</p>
<p>After a process has set up a socket of a particular type, it can interact with it in a way that fits the socket type. This is what makes sockets flexible: if you need to change the underlying transport layer, you don’t have to rewrite all of the parts that send and receive data; you mostly need to modify the initialization code.</p>
<p>If you’re a programmer and you’d like to learn how to use the socket interface, <em>Unix Network Programming, Volume 1</em>, 3rd edition, by W. Richard Stevens, Bill Fenner, and Andrew M. Rudoff (Addison-Wesley Professional, 2003), is the classic guide. Volume 2 also covers interprocess communication.</p>
<h2 id="h1-500402c10-0010">	10.10	Unix Domain Sockets</h2>
<p class="BodyFirst">Applications that use network facilities don’t have to involve two separate hosts. Many applications are built as client-server or peer-to-peer mechanisms, where processes running on the same machine use interprocess communication to negotiate what work needs to be done and who does it. For example, recall that daemons such as systemd and NetworkManager use D-Bus to monitor and react to system events.</p>
<p>Processes are capable of using regular IP networking over localhost (127.0.0.1 or ::1) to communicate with each other, but they typically use a special kind of socket called a <em>Unix domain socket</em> as an alternative. When a process connects to a Unix domain socket, it behaves almost exactly like it does with a network socket: it can listen for and accept connections on the socket, and you can even choose between different socket types to make it behave like TCP or UDP.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Keep in mind that a Unix domain socket is not a network socket, and there’s no network behind one. You don’t even need networking to be configured to use one. Unix domain sockets don’t have to be bound to socket files, either. A process can create an unnamed Unix domain socket and share the address with another process.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Developers like Unix domain sockets for IPC for two reasons. First, they allow the option to use special socket files in the filesystem to control access, so any process that doesn’t have access to a socket file can’t use it. And because there’s no interaction with the network, it’s simpler and less prone to conventional network intrusion. For example, you’ll usually find the socket file for D-Bus in <em>/var/run/dbus</em>:</p>
<pre><code>$ <b>ls -l /var/run/dbus/system_bus_socket</b> 
srwxrwxrwx 1 root root 0 Nov  9 08:52 /var/run/dbus/system_bus_socket</code></pre>
<p><span epub:type="pagebreak" title="290" id="Page_290"/>Second, because the Linux kernel doesn’t have to go through the many layers of its networking subsystem when working with Unix domain sockets, performance tends to be much better.</p>
<p>Writing code for Unix domain sockets isn’t much different from supporting normal network sockets. Because the benefits can be significant, some network servers offer communication through both network and Unix domain sockets. For example, the MySQL database server mysqld can accept client connections from remote hosts, but it usually also offers a Unix domain socket at <em>/var/run/mysqld/mysqld.sock</em>.</p>
<p>You can view a list of Unix domain sockets currently in use on your system with <code>lsof -U</code>:</p>
<pre><code># <b>lsof -U</b>
COMMAND     PID       USER   FD   TYPE     DEVICE SIZE/OFF     NODE NAME
mysqld    19701      mysql   12u  unix 0xe4defcc0      0t0 35201227 /var/run/mysqld/mysqld.sock
chromium- 26534      juser    5u  unix 0xeeac9b00      0t0 42445141 socket
tlsmgr    30480    postfix    5u  unix 0xc3384240      0t0 17009106 socket
tlsmgr    30480    postfix    6u  unix 0xe20161c0      0t0    10965 private/tlsmgr
--<var>snip</var>--</code></pre>
<p>The listing will be quite long because many applications make extensive use of unnamed sockets, which are indicated by <code>socket</code> in the <code>NAME</code> output column.</p>
</section>
</body></html>