## **17**

**GRIDLAYOUT**

![Image](graphics/common-01.jpg)

Grids are a fundamental design technique. Simple grids have been used by calligraphers since medieval times, and the modern typographic grid has been in use since the second half of the 20th century. For a few years now, efforts have been made to bring grid-based design to the Web, with a number of frameworks using floats, padding, and margins to emulate the possibilities of print, although these efforts have always felt like somewhat of a fragile hack.

Recently, however, browsers have begun to implement a native CSS grid layout system, as detailed in the Grid Layout Module (*[http://www.w3.org/TR/css-grid-1/](http://www.w3.org/TR/css-grid-1/)*). This module provides a series of properties designed specifically to create grids on screen, meaning the developer no longer has to hack them together from existing properties and behaviors.

The full range of properties in the Grid Layout Module is quite extensive, so I’ll focus on the most immediately useful aspects and not get too bogged down in detail that could be potentially confusing. When appropriate, I’ll flag spots where I’ve omitted some detail.

### **Grid Terminology**

Before introducing the new CSS grid syntax, I’ll explain some of the terminology used in the Grid Layout Module. Even if you think you’re familiar with typographic grids, take time to read through these definitions as the terminology used in CSS grids is quite distinct.

The following are the key terms used in the Grid Layout Module:

**Grid container** The container element that acts as the boundary and sets the dimensions of the grid.

**Grid lines** The dividing lines between rows and columns. These lines are notional, not actual.

**Grid tracks** A shorthand name for both rows and columns. Each column or row created in the grid is referred to as a *track*. Tracks are the spaces between lines.

**Grid cells** Each intersection of a column and a row creates a *cell*. These are like cells in a table.

**Grid areas** A cell or multiple cells that mark the space in which a *grid item* will be placed.

**Grid items** Each child element placed in the grid.

A grid is created by first setting a number of lines on the grid container to create a series of tracks. Grid items are then positioned on the tracks using lines as coordinates to create areas, as shown in [Figure 17-1](ch17.html#ch17fig1).

![Image](graphics/f17-01.jpg)

*Figure 17-1: A simple 3×3 grid showing the core terms used in the CSS Grid Layout syntax*

The grid lines are the lines between cells. They define a series of rows and columns, which are numbered for coordinate placement. (I’ll explain this concept in stages as I proceed through this chapter.)

### **Declaring and Defining the Grid**

The first step in creating a grid is to declare the *grid container,* the element used as the grid’s foundation. The dimensions of the grid container are the limits of the grid, and all of the grid’s properties are applied to it. To declare the grid container, use the `display` property with the new value `grid` like this:

```
E { display: grid; }
```

This declaration creates a block-level grid container. The next step is to define its tracks (rows and columns). You can define tracks on an *explicit grid*, with a precise number of columns and rows, or on an *implicit grid,* which is created relative to its content. You can also combine both explicit and implicit grids, and I’ll explain each in turn.

#### ***Creating Explicit Grids by Setting Track Size***

In an explicit grid, you can define a specific number of grid tracks by setting their size using a pair of properties: `grid-template-columns` and `grid-template-rows`. The value for each property is a space-separated list of lengths, which sets the width of the column or the height of the row. For example, the following code snippet creates a three-column grid, where the first and last columns are set to 20 percent of the width of the grid container and the second to 60 percent of the width:

```
E { grid-template-columns: 20% 60% 20%; }
```

You can use percentages or any unit of length, including the specialized grid unit of length called a *fraction (fr)*. One fr is equivalent to one equal share of any unassigned length in a grid. I’ll explain what I mean. Take a look at this code, where the grid container has a width value of 600px, and three columns each have a defined width:

```
E {
    display: grid;
    grid-template-columns: 100px 100px 200px;
    width: 600px; }
```

The total width of the columns is 400px, which is 200px less than the width of the container. In this case, adding an extra column of 1fr width makes that column as wide as all of the remaining space, or 200px:

```
E { grid-template-columns: 100px 100px 200px 1fr; }
```

Adding another column of the same width makes both columns 100px in width:

```
E { grid-template-columns: 100px 100px 200px 1fr 1fr; }
```

And making one of those columns 3fr in width means the remaining width is divided into four equal portions of 50px each, making 1fr equal to 50px and 3fr equal 150px:

```
E { grid-template-columns: 100px 100px 200px 1fr 3fr; }
```

Returning to the first example in this section, you could replace the percentages with the fr unit to achieve the same result:

```
E { grid-template-columns: 1fr 3fr 1fr; }
```

**NOTE**
*See “Fractions vs. Percentages” on [page 213](ch17.html#page_213) for an explanation of the advantages of using fractions for laying out grids.*

This code actually defines three grid lines, with an additional one automatically created at the start of the writing direction (which is left, in languages written from left to right). These lines create three vertical grid tracks, or columns, as shown in [Figure 17-2](ch17.html#ch17fig2).

![Image](graphics/f17-02.jpg)

*Figure 17-2: A simple three-column grid in the ratio 1:3:1 (grid lines and numbers added for clarity)*

You add rows in the same way. For example, to create three rows with the first one 60px high, the second with the value of `auto` so it’s as high as its content, and the third 5em high, you could use this code:

```
E { grid-template-rows: 60px auto 5em; }
```

Combining these properties lets you fully define your grid. For example, this code creates a basic grid of three columns and three rows, for a total of nine cells:

```
E {
  display: grid;
  grid-template-columns: 1fr 3fr 1fr;
  grid-template-rows: 60px auto 5em;
}
```

The columns of this grid are distributed in the ratio 1:3:1, and the rows are 60px at the top, 5em at the bottom, with a central row set to automatic height to accommodate its content. The resulting grid looks something like [Figure 17-3](ch17.html#ch17fig3).

![Image](graphics/f17-03.jpg)

*Figure 17-3: A 3×3 explicit grid (lines and numbers added for clarity)*

**FRACTIONS VS. PERCENTAGES**

When used on their own, percentages and fractions are interchangeable. For example, in this code, the two rules have the same result:

```
E { width: 50% 50%; }
F { width: 1fr 1fr; }
```

Where they differ is when they are mixed with length units such as `px` or `em`. Say you have a grid with one 15em column and you want to fill the remaining space with two equally sized columns. With percentages, you can’t really do this, unless you know the width of the container and are happy to perform some complex calculations. You might think you could use `calc()` (see [Chapter 16](ch16.html#ch16)) to do this:

```
E { grid-template-columns: 15em calc(50% - 7.5em) calc(50% - 7.5em); }
```

But the spec isn’t clear if `calc()` is permitted, and no current grid implementations (at the time of writing) allow you to do this.

In these cases, fractions prove more useful than percentages. When you recall that a grid fraction, or fr, sets aside an equal share of any space yet to be distributed, the fraction-based code you would use for this example becomes clear:

```
E { grid-template-columns: 15em 1fr 1fr; }
```

Here, any undistributed width in the grid will be divided into two equally sized columns.

Although, at times, you may be able to use percentages easily in your grids, fractions keep things simple.

#### ***Placing Items in an Explicit Grid***

Every immediate child of a grid container becomes a grid item and should be placed in the grid. To do so, you assign the item a cell coordinate using a set of placement properties. The first of these are `grid-column-start` and `grid-row-start`, and each takes a single whole number as a value. This number refers to the line at the start of a grid track (whether a column or a row), and the combined track references create the coordinate of a cell.

For example, to place an item in the cell in the second row of the second column, you use this code ([Figure 17-4](ch17.html#ch17fig4) shows the result):

```
F {
  grid-column-start: 2;
  grid-row-start: 2;
}
```

![Image](graphics/f17-04.jpg)

*Figure 17-4: An item placed on the grid in the second row of the second column (lines added for clarity)*

The default value of both the `grid-column-start` and `grid-row-start` properties is 1, so omitting either value places the item in the first row or column. For example, the following code places the item in the cell in the second column of the first row, as shown in [Figure 17-5](ch17.html#ch17fig5):

```
G { grid-column-start: 2; }
```

![Image](graphics/f17-05.jpg)

*Figure 17-5: A second item placed on the grid in the second column, first row (lines added for clarity)*

By default, the item is fitted into the designated cell only, with any content that doesn’t fit overflowing the cell vertically. You can make an item expand in size to create an area that covers multiple cells in rows or columns by using the `grid-column-end` and `grid-row-end` properties. Just like their counterparts, these properties take a single whole number value, which designates the line that the cell should end in. For example, to have an item span three rows, starting at line 1 and ending at 4, here’s the code you use:

```
F {
    grid-row-start: 1;
    grid-row-end: 4;
}
```

The item is placed in the first column by default; it starts at line 1 and ends at line 4, meaning it spans three rows, as shown in [Figure 17-6](ch17.html#ch17fig6).

![Image](graphics/f17-06.jpg)

*Figure 17-6: An item on the grid spanning three rows of the first column (lines added for clarity)*

As an alternative to the method just shown, you can, instead, use the `span` keyword, followed by the number of tracks the item spans. The rewritten rule looks like this:

```
F { grid-row-end: span 3; }
```

The `span` keyword becomes quite useful when you want to remain agnostic about the line at which a grid item will start, but you always want it to span the same number of columns.

#### ***Grid Placement Shorthand Properties***

Writing four individual properties to place an element in a grid seems somewhat verbose, and, indeed, shorthand properties will make your code more terse. The properties in question are `grid-column` and `grid-row`, and each has the same syntax. The first, `grid-column`, is short for `grid-column-start` and `grid-column-end`, divided by a slash; and the same goes for `grid-row` being short for `grid-row-start` and `grid-row-end`.

I’ll illustrate how to use them. Take a look at all of the individual properties applied to the same element:

```
F {
    grid-column-start: 2;
    grid-column-end: 3;
    grid-row-start: 1;
    grid-row-end: span 3;
}
```

Using the shorthand properties, you can write these in a much more manageable way:

```
F {
    grid-column: 2 / 3;
    grid-row: 1 / span 3;
}
```

If even two properties are too much for you, you can actually combine all of these instructions in a single shorthand rule, `grid-area`, which covers all four properties. Here’s the basic syntax:

```
F { grid-area: row-start / column-start / row-end / column-end; }
```

Inserting the appropriate values gives us this very terse—although, arguably, harder to read—rule:

```
F { grid-area: 1 / 2 / span 3 / 3; }
```

#### ***Repeating Grid Lines***

Although simple grids are fine for some real-world situations, more complex grids give you finer control over content. Having upward of 12 columns in large typographic grids is quite common, and each column usually has a *gutter* (empty space) between it and its neighbor. Defining a grid of 12 columns could be repetitive using the Grid Layout syntax, as you can see in this example code where I’ve mapped out 12 columns of 1fr each, with a gutter of 10px between them:

```
E { grid-template-columns: 1fr 10px 1fr 10px 1fr 10px 1fr
10px 1fr 10px 1fr 10px 1fr 10px 1fr 10px 1fr 10px 1fr 10px 1fr 10px 1fr; }
```

You can use the `repeat()` function to avoid this type of repetition when using larger grids. This function takes two arguments: an integer that sets the number of repetitions, followed by a comma separator, and the grid line values to be repeated. For example, the following rule creates the same grid as in the previous example, but much more concisely; it defines one track that is 1fr wide and then uses `repeat()` to create a pattern of a 10px gutter followed by a 1fr column eleven times, for a total of 12 columns of 1fr each.

```
E { grid-template-columns: 1fr repeat(11, 10px 1fr); }
```

#### ***Named Grid Areas***

In addition to placing items in a grid based on coordinates, you can also place items in *named areas* with the `grid-template-areas` property. With this property, you can give grid areas specific names using a series of unique identifiers in strings of text. Here, I’ll show you what I mean:

```
  E {
➊    display: grid;
➋    grid-template-areas: 'a b c';
➌    grid-template-columns: repeat(3, 1fr);
  }
```

Two of these rules should be familiar now: line ➊ sets the element to act as a grid container, and line ➌ creates three columns of 1fr each. Line ➋ uses the `grid-template-areas` property to name each of the columns: each identifier in the space-separated string (*a*, *b*, and *c*) is matched to the columns, in turn. This output is shown in [Figure 17-7](ch17.html#ch17fig7).

![Image](graphics/f17-07.jpg)

*Figure 17-7: Three columns made with named areas*

To place an item using a named area, you use the area’s identifier as a value for the `grid-area` property. For example, to place an item in the middle (*b*) column of my example grid, I use this:

```
F { grid-area: b; }
```

You don’t have to use single characters to name areas, as I’ve done here; you can use any string of characters, as long as they don’t contain a space. For example, to make your content more human-readable, you may want to describe the purpose of each area. Here’s an example:

```
E { grid-template-areas: 'nav main side'; }
F { grid-area: main; }
```

Each string of identifiers represents a grid row, so to add a new row, you just add a new string. If you use the same identifier multiple times in the same string, the area will span that number of columns. If you use the same identifier in the same position in different rows, the area will span that number of rows. You can see what I mean in the following code; in the first row, one column is called *nav* and two are called *head*, so the *head* area will span two columns; the second row also has a first column called *nav*, so the *nav* area will span two rows:

```
E {
    display: grid;
    grid-template-areas:
      'nav head head'
      'nav main side';
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: 80px auto;
}
```

Using this code, you can place grid items into areas that span multiple tracks. In the following snippet, element `*F*` is placed into the *head* area, meaning it spans the second and third columns of the first row, and element `*G*` will be placed into the *nav* area, making it span the first and second row in the first column. This is shown in [Figure 17-8](ch17.html#ch17fig8).

```
F { grid-area: head; }
G { grid-area: nav; }
```

![Image](graphics/f17-08.jpg)

*Figure 17-8: Items placed on the grid in named areas (lines added for clarity)*

**WARNING**
*If you use multiple string identifiers, you must use the same number of columns in each grid; otherwise, the rule will be declared invalid and be ignored.*

#### ***The grid-template Shorthand***

To avoid having to write three separate rules to define a grid (`grid-template-columns`, `grid-template-rows`, and `grid-template-areas`), you can use the `grid-template` shorthand. This shorthand makes defining your columns and rows, without named areas, simple. Here’s an example:

```
E { grid-template: grid-template-columns / grid-template-rows; }
```

To use the property with named grid areas, you add the identifiers after the slash, as in this example:

```
E { grid-template: repeat(3, 1fr) / 'nav head head'; }
```

And if you also want to define heights for the rows, you can add the length value of the row after each identifier string. Let’s look back at the full grid defined in the previous section:

```
E {
    grid-template-areas:
      'nav head head'
      'nav main side';
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: 80px auto;
}
```

Here’s how that grid looks if written using the `grid-template` shorthand:

```
E {
grid-template: repeat(3, 1fr) / 'nav head head' 80px 'nav main side';
}
```

**NOTE**
*I don’t declare the row height after the second named area string because it defaults to* `*auto*`.

#### ***Implicit Grids***

Implicit grids are defined by their contents, rather than the specified length values of explicit grids. When you don’t care how many rows or columns there are in your grid, only that each item in the grid has a place, you can use the `grid-auto-columns` and `grid-auto-rows` properties. Each property takes a single value to specify the width of the row or column. For example, this code says that any created columns should be 1fr wide, and that any new rows should be 80px:

```
E {
    display: grid;
    grid-auto-columns: 1fr;
    grid-auto-rows: 80px;
}
```

Now any item with a `grid-column` or `grid-row` value will be placed in the grid, and the grid will automatically adjust its size to accommodate the items, keeping all columns and rows at the set size. For example, the following code shows a grid item set to start in the second column of the first row, and to span two rows and two columns. The grid will expand to fit this item, as you can see in [Figure 17-9](ch17.html#ch17fig9).

```
F {
    grid-column: 2 / 4;
    grid-row: 1 / span 2;
}
```

![Image](graphics/f17-09.jpg)

*Figure 17-9: An implicit grid created by the item it contains (lines added for clarity)*

#### ***Grid Items Without a Declared Place***

What happens to children of the grid container that have no declared place in the grid because they don’t have either `grid-column` or `grid-row` values? They fall back to the default values of 1 and are stacked into the same cell at row one, column one.

You can alter this default behavior with the `grid-auto-flow` property, which ensures that any items without an assigned place are inserted into the grid where space is available. You can also add a level of control over where they’re placed. Here is the basic form of this rule:

```
E { grid-auto-flow: keyword; }
```

The keyword can be `column` or `row`. If you use `column`, items will fill empty cells in columns, moving down the column; if you use use `row`, the items will fill empty rows, moving across the row. For example, in [Figure 17-10](ch17.html#ch17fig10), the container on the left has a `grid-auto-flow` value of `column`, so the items that haven’t been placed fill the cells of each row down the current column and then skip up to the next column when the first column is filled. On the other hand, the container on the right has the value of `row`, so the items are placed across the row until the row is filled, at which point the items move to the second row.

![Image](graphics/f17-10.jpg)

*Figure 17-10: Comparing automatic flow: (left) items flowed into columns and (right) items flowed into rows*

### **Combining Explicit and Implicit Grids**

When you create explicit grids, you may find that the number of available grid tracks is fewer than you need for your items. Say you have a three-column grid, but a grid item is supposed to span four columns:

```
E { grid-template-columns: repeat(3, 1fr); }
F { grid-column: 1 / 5; }
```

In this case, the grid will expand to contain the tracks created by the item; an extra column will be added to the grid, making four in total. You can set the size of these extra tracks with the `grid-auto-columns` and `grid-auto-rows` properties.

The following code creates an explicit grid of three columns and two rows and allows for any items exceeding this explicit grid by adding an implicit grid. The extra columns in the implicit grid are defined as 1fr wide, with extra rows being 80px high:

```
E {
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(2, 80px);
    grid-auto-columns: 1fr;
    grid-auto-rows: 80px;
}
```

Now any items placed in this grid will fill an area that matches the dimensions of the explicit grid.

#### ***The grid Shorthand***

Defining a grid with both explicit and implicit properties can lead to a large list of rules. For example, the following code shows an element with rules to create an explicit grid with named areas, as well as implicit grid properties to allow for any items that might extend the grid, giving you a total of six rules:

```
E {
    grid-template-areas: 'a b b' 'a c d';
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: 80px auto;
    grid-auto-flow: row;
    grid-auto-columns: 1fr;
    grid-auto-rows: 80px;
}
```

Fortunately, a shorthand property is available for this list of rules. The shorthand is called `grid`—however, you can only use it to set either explicit or implicit grids, not both. To use it to set implicit grids, use this syntax:

```
E { grid: grid-auto-flow grid-auto-columns / grid-auto-rows; }
```

So here is the shorthand for the implicit grid rules shown in the previous code:

```
E { grid: row 1fr / 80px; }
```

The `grid` syntax for setting explicit grids is exactly the same as for the `grid-template` property you saw earlier in this chapter. That being the case, here is the shorthand for the explicit grid rules shown at the start of this section:

```
E { grid: repeat(3, 1fr) / 'a b b' 80px 'a c d'; }
```

You might find it strange that two shorthand properties do exactly the same thing. I can only agree with you.

### **Grid Item Stacking Order**

When placing items on a grid, areas will sometimes overlap. To handle such an eventuality, you can create a stacking order to define the way that items are stacked in the grid. For example, you could say that items that start in the third row should be stacked on top of items that start in the first row, regardless of their order in the DOM.

You can change the stacking order with the `z-index` property. The items with the highest `z-index` value will be stacked above all others. For example, the following markup shows two `div` elements that will become grid items:

```
<div class="grid-item item-one">…</div>
<div class="grid-item item-two">…</div>
```

I’ll place both items in the grid, but by adding the following code I ensure that `*item-one*` will be stacked on top of `*item-two*` by making its starting column and row greater than those of `*item-two*`:

```
.item-one {
    grid-column: 2 / 4;
    grid-row: 2;
}
.item-two {
    grid-column: 1 / 3;
    grid-row: 1 / 3;
}
```

You can see the result in the example on the left of [Figure 17-11](ch17.html#ch17fig11): `*item-one*` is stacked above `*item-two*`. But if you increase the `z-index` of `*item-two*` like so:

```
.item-two { z-index: 2; }
```

you’ll see that `*item-two*` is now stacked above `*item-one*`, as shown on the right of [Figure 17-11](ch17.html#ch17fig11).

![Image](graphics/f17-11.jpg)

*Figure 17-11: Comparing stacking order: (left) stacking follows placement, (right) stacking set by* `*z-index*`

An alternative approach uses the `order` property, introduced as part of the Flexbox Module (see [Chapter 15](ch15.html#ch15)). In explicit grids, this property acts exactly like `z-index`, changing the stacking order; in implicit grids, however, it also changes the order in which items are placed in the grid.

You can see this in action in [Figure 17-12](ch17.html#ch17fig12), where I’ve flowed three grid items (`*item-one*`, `*item-two*`, and `*item-three*`) into a grid with a `grid-auto-flow` value of `column`. In the left grid, the items are flowed into the grid in the order in which they appear in the DOM, but in the right grid, the order of two of the items is changed, as shown in [Figure 17-12](ch17.html#ch17fig12).

```
.item-one { order: 2; }
.item-two { order: 3; }
```

![Image](graphics/f17-12.jpg)

*Figure 17-12: Stacking with the* `*order*` *property in implicit grids: (left) in DOM order and (right) order set with the* `*order*` *property*

### **Internet Explorer’s Grid Layout Syntax**

Internet Explorer 10 was the first browser to implement the Grid Layout properties, although with a syntax that has since become outdated. So you can replicate certain grid layouts in IE10 and IE11 if you use caution, but with very strict limits—the most notable being that you can only create explicit grids.

All of the IE grid properties use the `-ms-` prefix, as does the value of the `display` property:

```
E { display: -ms-grid; }
```

You create tracks with the `-ms-grid-columns` and `-ms-grid-rows` properties, which are analogous to `grid-template-columns` and `grid-template-rows`. The difference is in the way you repeat track lines: When designing for IE, you put the width values in parentheses, followed by the number of repetitions in square brackets:

```
E {
    -ms-grid-columns: (1fr)[3];
    -ms-grid-rows: (80px)[2];
}
```

Grid items are placed with the `-ms-grid-column` and `-ms-grid-row` properties, which function like `grid-column` and `grid-row`, but only allow a single numeric value. To span items across multiple cells, you must use `-ms-grid-column-span` and `-ms-grid-row-span` to set the number of tracks an item should span (like the `span` keyword.)

That being the case, the rules applied to elements `*E*` and `*F*` in this code block are identical in function:

```
E {
    -ms-grid-column: 1;
    -ms-grid-column-span: 2;
    -ms-grid-row: 2;
    -ms-grid-row-span: 3;
}
F {
    grid-column: 1 / span 2;
    grid-row: 2 / span 3;
}
```

As of this writing, the IE syntax has no named areas, nor does it have anything equivalent to `grid-column-end` or `grid-row-end`.

### **Summary**

Grids are the first step toward a whole new way of laying out content on the Web. The combination of Grid Layout, Flexbox positioning, and Media Queries makes possible rich layouts that you can adapt to many different devices and viewports, ushering in a whole new world of web design, free from the constraints of float hacks and restrictive markup.

### **Grid Layout: Browser Support**

|  | **Chrome** | **Firefox** | **Safari** | **IE** |
| Grid layout | No^([*](ch17.html#footnote39a)) | No | No | IE10^([†](ch17.html#footnote40a)) |

[*](ch17.html#footnote_39a) Implemented but off by default

[†](ch17.html#footnote_40a) Syntax different from the spec; with vendor prefix