<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch4">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_169" aria-label="169"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch4">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">4</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">CONSTANTS, VARIABLES, AND DATA TYPES</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="378" height="378"/>&#13;
</figure>&#13;
<p class="ChapterIntro"><span class="chapterintro_Xref"><a href="chapter2.xhtml">Chapter 2</a></span> discussed the basic format for data in memory, and <span class="chapterintro_Xref"><a href="chapter3.xhtml">Chapter 3</a></span> covered how a computer system physically organizes that data in memory. This chapter completes that discussion by connecting the concept of <i>data representation</i> to its actual physical representation. I’ll focus on three main topics: constants, variables, and data structures.</p>&#13;
<p class="TX">This chapter doesn’t assume you’ve taken a formal course in data structures, though such experience would be useful. You’ll learn to declare and use constants, scalar variables, integers, data types, pointers, arrays, structs, and unions. Work to master these subjects before going on to the next chapter. Declaring and accessing arrays, in particular, seem to present a multitude of problems to beginning assembly language programmers, but the rest of this text depends on your understanding of these data structures and their memory representation. Do not try to skim over this material with the expectation that you’ll pick it up as needed later; you’ll need to comprehensively understand it right away.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_170" aria-label="170"/>&#13;
<h3 class="H1" id="sec1"><span id="h1-54"/><span class="SANS_Futura_Std_Bold_B_11">4.1 Gas Constant Declarations</span></h3>&#13;
<p class="TNI1">Probably the first place to start is with constant declarations that allow you to attach a name to a literal constant value. Gas provides four directives, collectively known as <i>equates</i>, that let you define constants in your assembly language programs. You’ve already seen the most common form, <span class="SANS_TheSansMonoCd_W5Regular_11">.equ</span>:</p>&#13;
<pre id="pre-240"><code>.equ<var> symbol</var>, <var>constantExpression</var></code></pre>&#13;
<p class="Continued1">For example:</p>&#13;
<pre id="pre-241"><code>.equ MaxIndex, 15</code></pre>&#13;
<p class="TX">Once you declare a symbolic constant in this manner, you may use the symbolic identifier anywhere the corresponding literal constant is legal. These constants are known as <i>manifest constants</i>—symbolic representations that allow you to substitute the literal value for the symbol anywhere in the program.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Technically, you could also use CPP macros to define constants in Gas. See <a href="chapter13.xhtml">Chapter 13</a> for more details.</i></p>&#13;
<p class="TX">Contrast this with <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span> objects: an <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span> value is a constant value, because you cannot change it at runtime. However, a memory location is associated with an <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span> declaration, and the OS, not the Gas assembler, enforces the read-only attribute. Although the following instruction sequence will crash your program when it runs, writing it is perfectly legal:</p>&#13;
<pre id="pre-242"><code>lea  x0, ReadOnlyVar&#13;
str  x1, [x0]</code></pre>&#13;
<p class="TX">On the other hand, it is no more legal to write the following, using the preceding declaration</p>&#13;
<pre id="pre-243"><code>str  x1, MaxIndex</code></pre>&#13;
<p class="Continued1">than it is to write this:</p>&#13;
<pre id="pre-244"><code>str  x1, #15</code></pre>&#13;
<p class="Continued1">In fact, both statements are equivalent: the compiler substitutes <span class="SANS_TheSansMonoCd_W5Regular_11">15</span> for <span class="SANS_TheSansMonoCd_W5Regular_11">MaxIndex</span> whenever it encounters this manifest constant.</p>&#13;
<p class="TX">Constant declarations are great for defining magic numbers that could change during program modification. Examples include constants like <span class="SANS_TheSansMonoCd_W5Regular_11">nl</span> (newline), <span class="SANS_TheSansMonoCd_W5Regular_11">maxLen</span>, and NULL.</p>&#13;
<p class="TX">The GNU <span class="SANS_TheSansMonoCd_W5Regular_11">.set</span> directive uses the following syntax:</p>&#13;
<pre id="pre-245"><code>.set <var>label</var>, <var>expression</var></code></pre>&#13;
<p class="Continued1"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_171" aria-label="171"/>This is semantically equivalent to the following:</p>&#13;
<pre id="pre-246"><code><var>label</var> = <var>expression</var></code></pre>&#13;
<p class="Continued1">Both the <span class="SANS_TheSansMonoCd_W5Regular_11">.set</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">=</span> directives allow you to redefine a symbol previously defined with these directives.</p>&#13;
<p class="TX">For example:</p>&#13;
<pre id="pre-247"><code>maxLen = 10&#13;
&#13;
<var>At this point in the code, Gas will replace maxLen with 10.</var>&#13;
   &#13;
maxLen = 256&#13;
&#13;
<var>In this section of the code, maxLen gets replaced by 256.</var></code></pre>&#13;
<p class="Continued1">You’ll see how to take advantage of this feature in <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a>,</span> which discusses macros and the Gas compile-time language.</p>&#13;
<p class="TX">Note that <span class="SANS_TheSansMonoCd_W5Regular_11">.equ</span> also allows you to redefine symbols in your source file. These many synonyms for the same directive are Gas’s attempt to maintain compatibility with multiple assemblers and assembler versions.</p>&#13;
<p class="TX">The final equate directive Gas offers is <span class="SANS_TheSansMonoCd_W5Regular_11">.equiv</span>:</p>&#13;
<pre id="pre-248"><code>.equiv <var>symbol, expression</var></code></pre>&#13;
<p class="Continued1">Unlike the other three directives, <span class="SANS_TheSansMonoCd_W5Regular_11">.equiv</span> will generate an error if the symbol is already defined. This is therefore likely the safest equate to use, unless you really need to redefine symbols in your program.</p>&#13;
<p class="TX">Expressions appearing in these equates are limited to 64 bits. If you specify a value greater than 64 bits, the assembler will report an error.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-55"/><span class="SANS_Futura_Std_Bold_B_11">4.2 The Location Counter Operator</span></h3>&#13;
<p class="TNI1">One very special constant you’ll frequently use is the current location counter value. As noted in the previous chapter, Gas will substitute the value of the current section’s location counter in place of an individual period (<span class="SANS_TheSansMonoCd_W5Regular_11">.</span>) appearing in a constant expression. You could in theory use this operator to embed a pointer to a variable within that variable itself:</p>&#13;
<pre id="pre-249"><code>ptrVar:  .dword  .   // Stores the address of ptrVar in ptrVar</code></pre>&#13;
<p class="Continued1">However, this isn’t especially useful. It’s a better idea to use the location counter operator to compute offsets and lengths within a particular section. If you subtract a label in a section from the location counter, the difference is the (signed) distance from that point in the code to the specified label. This allows you to compute string lengths, function lengths, and other values that involve measuring the byte distance within a section.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_172" aria-label="172"/>Here’s an example that uses this technique to compute a string length:</p>&#13;
<pre id="pre-250"><code>someStr:  .ascii  "Who wants to manually count the characters"&#13;
          .asciz  "in this string to determine its length?"&#13;
ssLen     =       .-someStr</code></pre>&#13;
<p class="Continued1">This counts all the bytes Gas emits (including the zero-terminating byte) by the two string directives. You can use this technique to compute the length of any data object, not just the characters in a string.</p>&#13;
<p class="TX">Intuitively, there is a subtle difference between the location counter constant (<span class="SANS_TheSansMonoCd_W5Regular_11">.</span>) and a literal constant such as <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>. The constant <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> will always have the same value wherever it appears in the source file, whereas the location counter constant will have a different value through the source file. An HLL would associate a different type with these two types of constants. The next sections discuss types in assembly language, including relocatable types (the location counter is a relocatable type in assembly language).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h3 class="H1" id="sec3"><span id="h1-56"/><span class="SANS_Futura_Std_Bold_B_11">4.3 Data Types and Gas</span></h3>&#13;
<p class="TNI1">Like most traditional (that is, 1960s-era) assemblers, Gas is completely <i>typeless</i>. It relies on you, the programmer, to make sense of all the data types you use in your program, via your choice of instructions. In particular, Gas will be more than happy to accept any of the following statements:</p>&#13;
<pre id="pre-251"><code>    .text&#13;
    .align 2&#13;
wv: .word  0&#13;
      .&#13;
      .&#13;
      .&#13;
    ldr   w0, wv  // Yes, this one's "type correct."&#13;
    ldr   x0, wv  // Loads more data than is present</code></pre>&#13;
<p class="TX">The second instruction loads 64 bits from a 32-bit variable. However, Gas accepts this erroneous code and loads the 64 bits at the address you specify, which might include the 32 bits just beyond the <span class="SANS_TheSansMonoCd_W5Regular_11">wv</span> declaration you’ve placed in your <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section.</p>&#13;
<p class="TX">Accessing data by using the wrong data type can lead to subtle defects within your code. One advantage of (strongly typed) HLLs is that they can catch most program errors resulting from the misuse of data types. Assembly language, however, provides very little in the way of type checking. Type checking is <i>your</i> responsibility in assembly language. Section 4.4, <span class="Xref">“Pointer Data Types,”</span> covers this issue next in great detail. Also see <span class="Xref">“Relocatable and Absolute Expressions”</span> on <span class="Xref"><a href="chapter4.xhtml#pg_176">page 176</a></span>, which describes one of the few cases where Gas provides a small amount of type checking on your code.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_173" aria-label="173"/>&#13;
<h3 class="H1" id="sec4"><span id="h1-57"/><span class="SANS_Futura_Std_Bold_B_11">4.4 Pointer Data Types</span></h3>&#13;
<p class="TNI1">If you had a bad experience when you first encountered pointers in an HLL, fear not: pointers are easier to deal with in assembly language. Any problems you had with pointers probably had more to do with the linked-list and tree data structures you were trying to implement with them. Pointers, on the other hand, have many uses in assembly language that have nothing to do with linked lists, trees, and other scary data structures. Indeed, simple data structures like arrays and structs often involve the use of pointers.</p>&#13;
<p class="TX">A <i>pointer</i> is a memory location whose value is the address of another memory location. Unfortunately, HLLs like C/C++ tend to hide the simplicity of pointers behind a wall of abstraction. This added complexity tends to frighten programmers because they don’t understand what’s going on behind the scenes.</p>&#13;
<p class="TX">To illuminate how pointers work, consider the following array declaration in Pascal:</p>&#13;
<pre id="pre-252"><code>M: array [0..1023] of integer;</code></pre>&#13;
<p class="TX">Even if you don’t know Pascal, the concept here is simple. <span class="SANS_TheSansMonoCd_W5Regular_11">M</span> is an array with 1,024 integers in it, indexed from <span class="SANS_TheSansMonoCd_W5Regular_11">M[0]</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">M[1023]</span>. Each one of these array elements can hold an integer value independent of the others. In other words, this array gives you 1,024 integer variables, each of which you refer to by number (the array index).</p>&#13;
<p class="TX">It’s easy to see that the statement <span class="SANS_TheSansMonoCd_W5Regular_11">M[0]:=100;</span> is storing the value <span class="SANS_TheSansMonoCd_W5Regular_11">100</span> into the first element of the array <span class="SANS_TheSansMonoCd_W5Regular_11">M</span>. The following two statements perform an identical operation:</p>&#13;
<pre id="pre-253"><code>i := 0; (* Assume "i" is an integer variable. *)&#13;
M [i] := 100;</code></pre>&#13;
<p class="TX">Indeed, you can use any integer expression in the range 0 to 1,023 as an index into this array. The following statements still perform the same operation as our single assignment to index 0:</p>&#13;
<pre id="pre-254"><code>i := 5;      (* Assume all variables are integers. *)&#13;
j := 10;&#13;
k := 50;&#13;
M [i*j-k] := 100;</code></pre>&#13;
<p class="TX">“Okay, so what’s the point?” you’re probably thinking. “Anything that produces an integer in the range 0 to 1,023 is legal. So what?” Consider the following code that adds an interesting layer of indirection:</p>&#13;
<pre id="pre-255"><code>M [1] := 0;&#13;
M [M [1]] := 100;</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_174" aria-label="174"/>With a little thought, you should see that these two instructions perform the exact same operation as the previous examples. The first statement stores <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> into array element <span class="SANS_TheSansMonoCd_W5Regular_11">M[1]</span>. The second statement fetches the value of <span class="SANS_TheSansMonoCd_W5Regular_11">M[1]</span>, a legal array index, and uses that value (<span class="SANS_TheSansMonoCd_W5Regular_11">0</span>) to control where it stores the value <span class="SANS_TheSansMonoCd_W5Regular_11">100</span>.</p>&#13;
<p class="TX">If you’re willing to accept this as reasonable, you’ll have no problems with pointers. If you were to change <span class="SANS_TheSansMonoCd_W5Regular_11">M</span> to <i>memory</i> and imagine that this array represents system memory, then <span class="SANS_TheSansMonoCd_W5Regular_11">M[1]</span> is a pointer: that is, a memory location whose value is the address (or index) of another memory location. Pointers are easy to declare and use in an assembly language program; you don’t even have to worry about array indices.</p>&#13;
<p class="TX">Okay, this section has used a Pascal array as an example of a pointer, which is fine, but how do you use pointers in an ARM assembly language program?</p>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-73"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">4.4.1 Pointer Usage in Assembly Language</span></h4>&#13;
<p class="TNI1">An ARM64 pointer is a 64-bit value that may contain the address of another variable. For a dword variable <span class="SANS_TheSansMonoCd_W5Regular_11">p</span> that contains 0x1000_0000, <span class="SANS_TheSansMonoCd_W5Regular_11">p</span> “points” at memory location 0x1000_0000. To access the dword that <span class="SANS_TheSansMonoCd_W5Regular_11">p</span> points at, you could use code like the following:</p>&#13;
<pre id="pre-256"><code>lea x0, p      // Load X0 with the &#13;
ldr x0, [x0]   // value of pointer p. &#13;
ldr x1, [x0]   // Fetch the data at which p points. </code></pre>&#13;
<p class="TX">By loading the value of <span class="SANS_TheSansMonoCd_W5Regular_11">p</span> into X0, this code loads the value 0x1000_0000 into X0 (assuming <span class="SANS_TheSansMonoCd_W5Regular_11">p</span> contains 0x1000_0000). The second instruction loads the X1 register with the dword starting at the location whose offset appears in X0. Because X0 now contains 0x1000_0000, this will load X1 from locations 0x1000_0000 through 0x1000_0007.</p>&#13;
<p class="TX">Why not just load X1 directly from location 0x1000_0000, like this?</p>&#13;
<pre id="pre-257"><code>lea x1, varAtAddress1000_0000 &#13;
ldr x1, [x1] </code></pre>&#13;
<p class="TX">The primary reason not to do so is that this <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction always loads X1 from location <span class="SANS_TheSansMonoCd_W5Regular_11">varAtAddress1000_0000</span>. You cannot change the address from where it loads X1.</p>&#13;
<p class="TX">The former instructions, however, always load X1 from the location where <span class="SANS_TheSansMonoCd_W5Regular_11">p</span> is pointing. This is easy to change under program control. Consider the following pseudocode instruction sequence:</p>&#13;
<pre id="pre-258"><code>    lea x0, i &#13;
    lea x1, p      // Set p = address of i. &#13;
    str x0, [x1] &#13;
&#13;
<var>Some code that sets or clears the carry flag ...</var> &#13;
&#13;
    bcc skipSetp &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_175" aria-label="175"/>       lea x0, j &#13;
       lea x1, p   // Set p = address of j. &#13;
       str x0, [x1] &#13;
        . &#13;
        . &#13;
        . &#13;
&#13;
&#13;
skipSetp:          // Assume both code paths wind up &#13;
    lea x0, p      // down here. &#13;
    ldr x0, [x0]   // Load p into X0. &#13;
    ldr x1, [x0]   // X1 = i or j, depending on path here. </code></pre>&#13;
<p class="TX">This short example demonstrates two execution paths through the program. The first path loads the variable <span class="SANS_TheSansMonoCd_W5Regular_11">p</span> with the address of the variable <span class="SANS_TheSansMonoCd_W5Regular_11">i</span>. The second path through the code loads <span class="SANS_TheSansMonoCd_W5Regular_11">p</span> with the address of the variable <span class="SANS_TheSansMonoCd_W5Regular_11">j</span>. Both execution paths converge on the last two <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instructions that load X1 with <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">j</span>, depending on which execution path was taken. In many respects, this is like a parameter to a procedure in an HLL like Swift. Executing the same instructions accesses different variables depending on whose address (<span class="SANS_TheSansMonoCd_W5Regular_11">i</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">j</span>) winds up in <span class="SANS_TheSansMonoCd_W5Regular_11">p</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-74"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">4.4.2 Pointer Declarations in Gas</span></h4>&#13;
<p class="TNI1">Because pointers are 64 bits long, you could use the <span class="SANS_TheSansMonoCd_W5Regular_11">.dword</span> directive to allocate storage for your pointers:</p>&#13;
<pre id="pre-259"><code>           .data &#13;
bb:        .byte   .-.  // Uninitialized &#13;
           .align  3 &#13;
d:         .dword  .-.  // Uninitialized &#13;
pByteVar:  .dword  bb   // Initialized with the address of bb &#13;
pDWordVar: .dword  d    // Initialized with the address of d </code></pre>&#13;
<p class="TX">This example demonstrates that it is possible to initialize as well as declare pointer variables in Gas. You may specify addresses of static variables (<span class="SANS_TheSansMonoCd_W5Regular_11">.data</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">.bss</span> objects) in the operand field of a <span class="SANS_TheSansMonoCd_W5Regular_11">.dword</span> directive, so you can initialize only pointer variables with the addresses of static objects by using this technique.</p>&#13;
<p class="TX">Remember that macOS does not allow you to take the address of a symbol in the <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section because of the limitation of PIE code.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-75"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">4.4.3 Pointer Constants and Expressions</span></h4>&#13;
<p class="TNI1">Gas allows very simple constant expressions wherever a pointer constant is legal. Pointer constant expressions take one of the following forms:</p>&#13;
<pre id="pre-260"><code><var>StaticVarName</var> + <var>PureConstantExpression</var> &#13;
<var>StaticVarName</var> - <var>PureConstantExpression</var> </code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_176" aria-label="176"/>The <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">PureConstantExpression</span> term is a numeric constant expression that does not involve any pointer constants (an <i>absolute constant</i>, using Gas terminology). This type of expression produces a memory address that is the specified number of bytes before or after (<span class="SANS_TheSansMonoCd_W5Regular_11">-</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">+</span>, respectively) the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">StaticVarName</span> variable in memory. The first two forms shown here are semantically equivalent: both return a pointer constant whose address is the sum of the static variable and the constant expression.</p>&#13;
<aside class="box" aria-label="box-16">&#13;
<p class="BH" id="box-16"><span class="SANS_Dogma_OT_Bold_B_11">RELOCATABLE AND ABSOLUTE EXPRESSIONS</span></p>&#13;
<p class="BTNI"><span class="SANS_Futura_Std_Book_11">Gas divides constant expressions into two categories: relocatable and absolute.</span> <span class="SANS_Futura_Std_Book_Oblique_11">Absolute expressions</span> <span class="SANS_Futura_Std_Book_11">are those that Gas can evaluate to a numeric value during assembly. Examples include the following:</span></p>&#13;
<pre id="pre-261"><code>5    8 + 2 * 3    (8 * 2) - 45    'A'    0xFFFF + 1    0xFFFE &amp; 0xABCD </code></pre>&#13;
<p class="BoxBodyContinued"><span class="SANS_Futura_Std_Book_Oblique_11">Relocatable expressions</span><span class="SANS_Futura_Std_Book_11">, on the other hand, involve symbolic names that reference memory locations in various sections of the program.</span></p>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_11">Expressions can have a mixture of absolute and relocatable components. The class of the resulting expression (that is, relocatable or absolute) depends on a few simple rules. If</span> <span class="SANS_Futura_Std_Book_Oblique_11">R</span> <span class="SANS_Futura_Std_Book_11">is a relocatable expression (for example, a single symbol) and</span> <span class="SANS_Futura_Std_Book_Oblique_11">A</span> <span class="SANS_Futura_Std_Book_11">is an absolute expression, then:</span></p>&#13;
<ul class="ul">&#13;
<li class="BoxListBullet"><span class="SANS_Futura_Std_Book_Oblique_11">R</span> <span class="SANS_Futura_Std_Book_11">+</span> <span class="SANS_Futura_Std_Book_Oblique_11">A</span> <span class="SANS_Futura_Std_Book_11">is also a relocatable expression.</span></li>&#13;
<li class="BoxListBullet"><span class="SANS_Futura_Std_Book_Oblique_11">R</span> <span class="SANS_Futura_Std_Book_11">–</span> <span class="SANS_Futura_Std_Book_Oblique_11">A</span> <span class="SANS_Futura_Std_Book_11">is also a relocatable expression.</span></li>&#13;
<li class="BoxListBullet"><span class="SANS_Futura_Std_Book_Oblique_11">R</span><span class="SANS_Futura_Std_Book_Oblique_SUB_11">1</span> <span class="SANS_Futura_Std_Book_11">–</span> <span class="SANS_Futura_Std_Book_Oblique_11">R</span><span class="SANS_Futura_Std_Book_Oblique_SUB_11">2</span> <span class="SANS_Futura_Std_Book_11">is an absolute expression (both</span> <span class="SANS_Futura_Std_Book_Oblique_11">R</span><span class="SANS_Futura_Std_Book_Oblique_SUB_11">1</span> <span class="SANS_Futura_Std_Book_11">and</span> <span class="SANS_Futura_Std_Book_Oblique_11">R</span><span class="SANS_Futura_Std_Book_Oblique_SUB_11">2</span> <span class="SANS_Futura_Std_Book_11">must be in the same section of memory).</span></li>&#13;
<li class="BoxListBullet"><span class="SANS_Futura_Std_Book_Oblique_11">R</span><span class="SANS_Futura_Std_Book_Oblique_SUB_11">1</span> <span class="SANS_Futura_Std_Book_11">+</span> <span class="SANS_Futura_Std_Book_Oblique_11">R</span><span class="SANS_Futura_Std_Book_Oblique_SUB_11">2</span> <span class="SANS_Futura_Std_Book_11">is illegal.</span></li>&#13;
</ul>&#13;
</aside>&#13;
<p class="TX">Since you can create pointer constant expressions, it should come as no surprise that Gas lets you define manifest pointer constants by using equates. Listing 4-1 demonstrates how to do this.</p>&#13;
<pre id="pre-262"><code>// Listing4-1.S &#13;
//&#13;
// Pointer constant demonstration &#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
          .section  .rodata, ""&#13;
ttlStr:   .asciz    "Listing 4-1"&#13;
fmtStr:   .ascii    "pb's value is %p\n"&#13;
          .asciz    "*pb's value is %d\n"&#13;
&#13;
          .data &#13;
bb:       .byte     0 &#13;
          .byte     1, 2, 3, 4, 5, 6, 7 &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_177" aria-label="177"/><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> pb        =         bb + 2     // Address of "2" in bb &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> pbVar:   .dword     pb &#13;
&#13;
pbValue: .word      0 &#13;
&#13;
         .text &#13;
         .align     2 &#13;
         .extern    printf &#13;
&#13;
// Return program title to C++ program: &#13;
&#13;
         .global    getTitle &#13;
getTitle: &#13;
         lea        x0, ttlStr &#13;
         ret &#13;
&#13;
// Here is the asmMain function: &#13;
&#13;
        .global     asmMain &#13;
asmMain: &#13;
        sub     sp, sp, #64     // Reserve space on stack. &#13;
        str     lr, [sp, #56]   // Save return address. &#13;
&#13;
        lea     x0, pbVar       // Get pbVar. &#13;
        ldr     x0, [x0] &#13;
        ldrb    w0, [x0]        // Fetch data at *pbVar. &#13;
      <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> lea     x1, pbValue     // Save in pbValue for now. &#13;
        str     w0, [x1] &#13;
&#13;
// Print the results: &#13;
&#13;
        lea     x0, fmtStr &#13;
      <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> vparm2  pbVar &#13;
      <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> vparm3  pbValue &#13;
        bl      printf &#13;
&#13;
        ldr     lr, [sp, #56]   // Restore return address. &#13;
        add     sp, sp, #64 &#13;
        ret     // Returns to caller </code></pre>&#13;
<p class="TX">The equate <span class="SANS_TheSansMonoCd_W5Regular_11">pb = bb + 2</span> initializes the constant <span class="SANS_TheSansMonoCd_W5Regular_11">pb</span> with the address of the third element <span class="CodeAnnotation" aria-label="annotation1">❶</span> (index 2) of the <span class="SANS_TheSansMonoCd_W5Regular_11">bb</span> array. The <span class="SANS_TheSansMonoCd_W5Regular_11">pbVar: .dword pb</span> declaration <span class="CodeAnnotation" aria-label="annotation2">❷</span> creates a pointer variable (named <span class="SANS_TheSansMonoCd_W5Regular_11">pbVar</span>) and initializes with the value of the <span class="SANS_TheSansMonoCd_W5Regular_11">pb</span> constant. Because <span class="SANS_TheSansMonoCd_W5Regular_11">pb</span> is the address of <span class="SANS_TheSansMonoCd_W5Regular_11">bb[2]</span>, this statement initializes <span class="SANS_TheSansMonoCd_W5Regular_11">pbVar</span> with the address of <span class="SANS_TheSansMonoCd_W5Regular_11">bb[2]</span>. The program stores the value held in <span class="SANS_TheSansMonoCd_W5Regular_11">pbVar</span> into the <span class="SANS_TheSansMonoCd_W5Regular_11">pbValue</span> variable <span class="CodeAnnotation" aria-label="annotation3">❸</span>, then passes <span class="SANS_TheSansMonoCd_W5Regular_11">pbVar</span> <span class="CodeAnnotation" aria-label="annotation4">❹</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">pbValue</span> <span class="CodeAnnotation" aria-label="annotation5">❺</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> to print their values.</p>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output:</p>&#13;
<pre id="pre-263"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing4-1</span> &#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing4-1</span> &#13;
Calling Listing4-1: &#13;
pb's value is 0x411042 &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_178" aria-label="178"/>*pb's value is 2 &#13;
Listing4-1 terminated </code></pre>&#13;
<p class="Continued1">The address that’s printed may vary on different machines and OSes.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h2-76"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">4.4.4 Pointer Variables and Dynamic Memory Allocation</span></h4>&#13;
<p class="TNI1">Pointer variables are the perfect place to store the return result from the C stdlib <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span> function. This function returns the address of the storage it allocates in the X0 register; therefore, you can store the address directly into a pointer variable immediately after a call to <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span>. Listing 4-2 demonstrates calls to the C stdlib <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">free()</span> functions.</p>&#13;
<pre id="pre-264"><code>// Listing4-2.S &#13;
//&#13;
// Demonstration of calls &#13;
// to C stdlib malloc &#13;
// and free functions &#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
            .section    .rodata, ""&#13;
ttlStr:     .asciz      "Listing 4-2"&#13;
fmtStr:     .asciz      "Addresses returned by malloc: %p, %p\n"&#13;
&#13;
            .data &#13;
ptrVar:     .dword      .-. &#13;
ptrVar2:    .dword      .-. &#13;
&#13;
            .text &#13;
            .align      2 &#13;
            .extern     printf &#13;
            .extern     malloc &#13;
            .extern     free &#13;
&#13;
&#13;
// Return program title to C++ program: &#13;
&#13;
            .global     getTitle &#13;
getTitle: &#13;
            lea         x0, ttlStr &#13;
            ret &#13;
&#13;
// Here is the "asmMain" function: &#13;
&#13;
            .global     asmMain &#13;
asmMain: &#13;
            sub         sp, sp, #64     // Space on stack &#13;
            str         lr, [sp, #56]   // Save return address. &#13;
&#13;
// C stdlib malloc function &#13;
//&#13;
// ptr = malloc(byteCnt); &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_179" aria-label="179"/>//&#13;
// Note: malloc has only a single parameter; it &#13;
// is passed in X0 as per ARM/macOS ABI. &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> mov         x0, #256        // Allocate 256 bytes. &#13;
            bl          malloc &#13;
            lea         x1, ptrVar      // Store pointer into &#13;
            str         x0, [x1]        // ptrVar variable. &#13;
&#13;
            mov         x0, #1024       // Allocate 1,024 bytes. &#13;
            bl          malloc &#13;
            lea         x1, ptrVar2     // Store pointer into &#13;
            str         x0, [x1]        // ptrVar2 variable. &#13;
&#13;
// Print the addresses of the two malloc'd blocks: &#13;
&#13;
            lea         x0, fmtStr &#13;
            vparm2      ptrVar &#13;
            vparm3      ptrVar2 &#13;
            bl          printf &#13;
&#13;
// Free the storage by calling &#13;
// C stdlib free function. &#13;
//&#13;
// free(ptrToFree); &#13;
//&#13;
// Once again, the single parameter gets passed in X0. &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> lea         x0, ptrVar &#13;
            ldr         x0, [x0] &#13;
            bl          free &#13;
&#13;
            lea         x0, ptrVar2 &#13;
            ldr         x0, [x0] &#13;
            bl          free &#13;
&#13;
            ldr         lr, [sp, #56]   // Get return address. &#13;
            add         sp, sp, #64     // Clean up stack. &#13;
            ret </code></pre>&#13;
<p class="TX">Because <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">free()</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span> have only a single argument, you pass those arguments to them in the X0 register. For the call to <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span>, you pass an integer value specifying the amount of storage you want to allocate on the heap. For <span class="SANS_TheSansMonoCd_W5Regular_11">free()</span>, you pass the pointer to the storage (previously allocated by <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span>) that you want to return back to the system.</p>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output:</p>&#13;
<pre id="pre-265"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing4-2</span> &#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing4-2</span> &#13;
Calling Listing4-2: &#13;
Addresses returned by malloc: 0x240b46b0, 0x240b47c0 &#13;
Listing4-2 terminated </code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_180" aria-label="180"/>As usual, the addresses you get will vary by OS and perhaps even by different runs of the program.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h2-77"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">4.4.5 Common Pointer Problems</span></h4>&#13;
<p class="TNI1">In most programming languages, programmers encounter five common problems. Some of these errors will cause your programs to immediately stop with a diagnostic message; other problems are subtler, yielding incorrect results or simply affecting the performance of your program without otherwise reporting an error. These five problems are as follows:</p>&#13;
<ul class="ul">&#13;
<li class="BL">Using an uninitialized pointer (illegal memory access)</li>&#13;
<li class="BL">Using a pointer that contains an illegal value (for example, NULL)</li>&#13;
<li class="BL">Continuing to use <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span>’d storage after that storage has been freed</li>&#13;
<li class="BL">Failing to <span class="SANS_TheSansMonoCd_W5Regular_11">free()</span> storage once the program is finished using it</li>&#13;
<li class="BL">Accessing indirect data using the wrong data type</li>&#13;
</ul>&#13;
<p class="TX">The following subsections describe each of these problems, their effects, and how to avoid them.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h5 class="H3" id="sec10"><span class="SANS_Futura_Std_Bold_Condensed_B_11">4.4.5.1 Illegal Memory Access Due to an Uninitialized Pointer</span></h5>&#13;
<p class="TNI1">Beginning programmers often don’t realize that declaring a pointer variable reserves storage only for the pointer itself; it does not reserve storage for the data that the pointer references. Therefore, you’ll run into problems if you attempt to dereference a pointer that does not contain the address of a valid memory location. Listing 4-3 demonstrates this problem (don’t try to compile and run this program; it will crash).</p>&#13;
<pre id="pre-266"><code>// Listing4-3.S &#13;
//&#13;
// Uninitialized pointer demonstration &#13;
// This program will not run properly. &#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
            .section    .rodata, ""&#13;
ttlStr:     .asciz      "Listing 4-3"&#13;
fmtStr:     .asciz      "Pointer value= %p\n"&#13;
&#13;
            .data &#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> ptrVar:     .dword      .-.   // ".-." means uninitialized. &#13;
&#13;
            .text &#13;
            .align      2 &#13;
            .extern     printf &#13;
&#13;
// Return program title to C++ program: &#13;
&#13;
            .global     getTitle &#13;
getTitle: &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_181" aria-label="181"/>            lea         x0, ttlStr &#13;
            ret &#13;
&#13;
// Here is the "asmMain" function: &#13;
&#13;
            .global     asmMain &#13;
asmMain: &#13;
            sub         sp, sp, #64     // Stack storage &#13;
            str         lr, [sp, #56]   // Save return address. &#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> lea         x0, ptrVar &#13;
            ldr         x1, [x0]        // Get ptrVar into X1. &#13;
            ldr         x2, [x1]        // Will crash the system &#13;
&#13;
            ldr         lr, [sp, #56]   // Retrieve return adrs. &#13;
            add         sp, sp, #64     // Restore stack. &#13;
            ret </code></pre>&#13;
<p class="TX">Although variables you declare in the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section are, technically, initialized, static initialization still doesn’t initialize the pointer in this program <span class="CodeAnnotation" aria-label="annotation1">❶</span> with a valid address (but instead with a 0, which is NULL).</p>&#13;
<p class="TX">Of course, there is no such thing as a truly uninitialized variable on the ARM. There are variables that you’ve explicitly given an initial value, and there are variables that happen to inherit whatever bit pattern was in memory when storage for the variable was allocated. Much of the time, these garbage bit patterns don’t correspond to a valid memory address. Attempting to <i>dereference</i> such a pointer (that is, access the data in memory at which it points <span class="CodeAnnotation" aria-label="annotation2">❷</span>) typically raises a <i>memory access violation</i> exception (segmentation fault).</p>&#13;
<p class="TX">Sometimes, however, those random bits in memory just happen to correspond to a valid memory location you can access. In this situation, the CPU will access the specified memory location without aborting the program. Although to a naive programmer this situation may seem preferable to stopping the program, in reality this is far worse, since your defective program continues to run without alerting you to the problem. If you store data through an uninitialized pointer, you may overwrite the values of other important variables in memory. This defect can produce some difficult-to-locate problems in your program.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h5 class="H3" id="sec11"><span class="SANS_Futura_Std_Bold_Condensed_B_11">4.4.5.2 Invalid Addresses</span></h5>&#13;
<p class="TNI1">The second common problem is storing invalid address values into a pointer. The previous problem is actually a special case of this second problem (with garbage bits in memory supplying the invalid address, rather than you producing it via a miscalculation). The effects are the same: if you attempt to dereference a pointer containing an invalid address, you either will get a memory access violation exception or will access an unexpected memory location.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_182" aria-label="182"/>&#13;
<h5 class="H3" id="sec12"><span class="SANS_Futura_Std_Bold_Condensed_B_11">4.4.5.3 The Dangling Pointer Problem</span></h5>&#13;
<p class="TNI1">The third problem, continuing to use <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span>’d storage after that storage has been freed, is also known as the <i>dangling pointer problem</i>. To understand this problem, consider the following code fragment:</p>&#13;
<pre id="pre-267"><code>mov  x0, #256 &#13;
bl   malloc       // Allocate some storage. &#13;
lea  x1, ptrVar &#13;
str  x0, [x1]     // Save address away in ptrVar. &#13;
 . &#13;
 .    <var> Code that uses the pointer variable ptrVar</var> &#13;
 . &#13;
lea  x0, ptrVar   // Pass ptrVar's value to free. &#13;
ldr  x0, [x0] &#13;
bl   free         // Free storage associated with ptrVar. &#13;
 . &#13;
 .    <var>Code that does not change the value in ptrVar</var> &#13;
 . &#13;
lea  x0, ptrVar &#13;
ldr  x1, [x0] &#13;
strb w2, [x1] </code></pre>&#13;
<p class="TX">This code allocates 256 bytes of storage and saves the address of that storage in the <span class="SANS_TheSansMonoCd_W5Regular_11">ptrVar</span> variable. It then uses this block of 256 bytes for a while and frees the storage, returning it to the system for other uses.</p>&#13;
<p class="TX">Calling <span class="SANS_TheSansMonoCd_W5Regular_11">free()</span> does not change the value of <span class="SANS_TheSansMonoCd_W5Regular_11">ptrVar</span> in any way; <span class="SANS_TheSansMonoCd_W5Regular_11">ptrVar</span> still points at the block of memory allocated by <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span> earlier. The value in <span class="SANS_TheSansMonoCd_W5Regular_11">ptrVar</span> is a <i>dangling pointer</i>, or <i>wild pointer</i>—a pointer that is pointing at deallocated storage. In this example, <span class="SANS_TheSansMonoCd_W5Regular_11">free()</span> does not change any data in the block allocated by <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span>, so upon return from <span class="SANS_TheSansMonoCd_W5Regular_11">free()</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">ptrVar</span> still points at the data stored into the block by this code. However, the call to <span class="SANS_TheSansMonoCd_W5Regular_11">free()</span> tells the system that the program no longer needs this 256-byte block of memory, so the system can use this region of memory for other purposes.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">free()</span> function cannot enforce the fact that you will never access this data again; you are simply promising that you won’t. Of course, the preceding code fragment breaks this promise; as you can see in the last three instructions, the program fetches the value in <span class="SANS_TheSansMonoCd_W5Regular_11">ptrVar</span> and accesses the data it points at in memory.</p>&#13;
<p class="TX">The biggest problem with dangling pointers is that you can often get away with using them. As long as the system doesn’t reuse the storage you’ve freed, a dangling pointer produces no ill effects. However, with each new call to <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span>, the system may decide to reuse the memory released by that previous call to <span class="SANS_TheSansMonoCd_W5Regular_11">free()</span>. When this happens, any attempt to dereference the dangling pointer may produce unintended consequences. The problems range from reading data that has been overwritten (by the new, legal use of the data storage), to overwriting the new data, to, in the worst case, overwriting system heap management pointers and likely crashing your program. The solution is clear: <i>never use a pointer value after you free the storage associated with that pointer.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_183" aria-label="183"/>&#13;
<h5 class="H3" id="sec13"><span class="SANS_Futura_Std_Bold_Condensed_B_11">4.4.5.4 Memory Leaks</span></h5>&#13;
<p class="TNI1">Of all the pointer problems listed at the beginning of this section, failing to free allocated storage will probably have the least negative impact. The following code fragment demonstrates this problem:</p>&#13;
<pre id="pre-268"><code>mov  x0, #256 &#13;
bl   malloc &#13;
lea  x1, ptrVar &#13;
str  x0, [x1] &#13;
&#13;
<var>Code that uses ptrVar</var> &#13;
<var>This code does not free up the storage</var> &#13;
<var>associated with ptrVar.</var> &#13;
&#13;
mov  x0, #512 &#13;
bl   malloc &#13;
lea  x1, ptrVar &#13;
str  x0, [x1] &#13;
&#13;
// At this point, there is no way to reference the original &#13;
// block of 256 bytes pointed at by ptrVar. </code></pre>&#13;
<p class="TX">In this example, the program allocates 256 bytes of storage and references it by using the <span class="SANS_TheSansMonoCd_W5Regular_11">ptrVar</span> variable. Later, the program allocates another block of bytes and overwrites the value in <span class="SANS_TheSansMonoCd_W5Regular_11">ptrVar</span> with the address of this new block. The former value in <span class="SANS_TheSansMonoCd_W5Regular_11">ptrVar</span> is lost. Because the program no longer has this address value, there is no way to call <span class="SANS_TheSansMonoCd_W5Regular_11">free()</span> to return the storage for later use.</p>&#13;
<p class="TX">As a result, these 256 bytes of memory are no longer available to your program. While this may seem like only a minor cost, imagine that this code is in a repeating loop. With each execution of the loop, the program loses another 256 bytes of memory, eventually exhausting the memory available on the heap. This problem is often called a <i>memory leak</i>, because it’s as though the memory bits are leaking out of your computer during program execution.</p>&#13;
<p class="TX">Memory leaks are far less damaging than dangling pointers. They create only two problems: the danger of running out of heap space (which ultimately may cause the program to abort, though this is rare) and performance problems due to virtual memory page swapping. Nevertheless, you should get in the habit of always freeing all storage after you have finished using it. When your program quits, the OS reclaims all storage, including the data lost via memory leaks. Therefore, memory lost via a leak is lost only to your program, not to the whole system.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h5 class="H3" id="sec14"><span class="SANS_Futura_Std_Bold_Condensed_B_11">4.4.5.5 Lack of Type-Safe Access</span></h5>&#13;
<p class="TNI1">Because Gas cannot and does not enforce pointer type checking, you can load the address of a data structure into a register and access that data as though it were a completely different type (often resulting in logic errors in your program). For example, consider Listing 4-4.</p>&#13;
<pre id="pre-269"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_184" aria-label="184"/>// Listing4-4.S &#13;
//&#13;
// Demonstration of lack of type &#13;
// checking in assembly language &#13;
// pointer access &#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
maxLen       =          256 &#13;
&#13;
            .section    .rodata, ""&#13;
ttlStr:     .asciz      "Listing 4-4"&#13;
prompt:     .asciz      "Input a string: "&#13;
fmtStr:     .asciz      "%d: Hex value of char read: %x\n"&#13;
&#13;
            .data &#13;
valToPrint: .word       .-. &#13;
bufIndex:   .dword      .-. &#13;
bufPtr:     .dword      .-. &#13;
bytesRead:  .dword      .-. &#13;
&#13;
            .text &#13;
            .align      2 &#13;
            .extern     readLine &#13;
            .extern     printf &#13;
            .extern     malloc &#13;
            .extern     free &#13;
&#13;
// Return program title to C++ program: &#13;
&#13;
            .global     getTitle &#13;
getTitle: &#13;
            lea         x0, ttlStr &#13;
            ret &#13;
&#13;
// Here is the asmMain function: &#13;
&#13;
            .global     asmMain &#13;
asmMain: &#13;
&#13;
            sub     sp, sp, #64     // Reserve stack space. &#13;
            str     lr, [sp, #56]   // Save return address. &#13;
&#13;
// C stdlib malloc function &#13;
// Allocate sufficient characters &#13;
// to hold a line of text input &#13;
// by the user: &#13;
&#13;
            mov     x0, #maxLen     // Allocate 256 bytes. &#13;
            bl      malloc &#13;
            lea     x1, bufPtr      // Save pointer to buffer. &#13;
            str     x0, [x1] &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_185" aria-label="185"/>// Read a line of text from the user and place in &#13;
// the newly allocated buffer: &#13;
&#13;
        lea     x0, prompt      // Prompt user to input &#13;
        bl      printf          // a line of text. &#13;
&#13;
        lea     x0, bufPtr &#13;
        ldr     x0, [x0]        // Pointer to input buffer &#13;
        mov     x1, #maxLen     // Maximum input buffer length &#13;
        bl      readLine        // Read text from user. &#13;
        cmp     x0, #-1         // Skip output if error. &#13;
        beq     allDone &#13;
        lea     x1, bytesRead &#13;
        str     x0, [x1]        // Save number of chars read. &#13;
&#13;
// Display the data input by the user: &#13;
&#13;
        mov     x1, #0          // Set index to 0. &#13;
        lea     x0, bufIndex &#13;
        str     x1, [x0] &#13;
dispLp: lea     x0, bufIndex    // Get buffer index &#13;
        ldr     x1, [x0]        // into X1. &#13;
        lea     x2, bufPtr      // Get pointer to buffer. &#13;
        ldr     x2, [x2] &#13;
        ldr     w0, [x2, x1]    // Read word rather than byte! &#13;
        lea     x1, valToPrint &#13;
        str     w0, [x1] &#13;
        lea     x0, fmtStr &#13;
        vparm2  bufIndex &#13;
        vparm3  valToPrint &#13;
        bl      printf &#13;
&#13;
        lea     x0, bufIndex    // Increment index by 1. &#13;
        ldr     x1, [x0] &#13;
        add     x1, x1, #1 &#13;
        str     x1, [x0] &#13;
&#13;
        lea     x0, bytesRead   // Repeat until &#13;
        ldr     x0, [x0]        // you've processed "bytesRead"&#13;
        cmp     x1, x0          // bytes. &#13;
        blo     dispLp &#13;
&#13;
// Free the storage by calling &#13;
// C stdlib free function. &#13;
//&#13;
// free(bufPtr) &#13;
&#13;
allDone: &#13;
        lea     x0, bufPtr &#13;
        ldr     x0, [x0] &#13;
        bl      free &#13;
&#13;
        ldr     lr, [sp, #56]   // Restore return address. &#13;
        add     sp, sp, #64 &#13;
        ret     // Returns to caller </code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_186" aria-label="186"/>Here are the commands to build and run the program in Listing 4-4:</p>&#13;
<pre id="pre-270"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing4-4</span> &#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing4-4</span> &#13;
Calling Listing4-4: &#13;
Input a string: Hello world &#13;
0: Hex value of char read: 6c6c6548 &#13;
1: Hex value of char read: 6f6c6c65 &#13;
2: Hex value of char read: 206f6c6c &#13;
3: Hex value of char read: 77206f6c &#13;
4: Hex value of char read: 6f77206f &#13;
5: Hex value of char read: 726f7720 &#13;
6: Hex value of char read: 6c726f77 &#13;
7: Hex value of char read: 646c726f &#13;
8: Hex value of char read: 646c72 &#13;
9: Hex value of char read: 646c &#13;
10: Hex value of char read: 64 &#13;
11: Hex value of char read: 0 &#13;
Listing4-4 terminated </code></pre>&#13;
<p class="TX">Listing 4-4 reads data from the user as character values and then displays the data as double-word hexadecimal values. While assembly language lets you ignore data types at will and automatically coerce the data without any effort, this power is a double-edged sword. If you make a mistake and access indirect data by using the wrong data type, Gas and the ARM may not catch the mistake and your program may produce inaccurate results. Therefore, you need to ensure that you use data consistently with respect to data type when working with pointers and indirection in your programs.</p>&#13;
<p class="TX">This demonstration program has one fundamental flaw that could create a problem for you: when reading the last two characters of the input buffer, the program accesses data beyond the characters input by the user. If the user inputs 255 characters (plus the zero-terminating byte that <span class="SANS_TheSansMonoCd_W5Regular_11">readLine()</span> appends), this program will access data beyond the end of the buffer allocated by <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span>. In theory, this could cause the program to crash. This is yet another problem that can occur when accessing data by using the wrong type via pointers.</p>&#13;
<p class="TX">Despite all the problems that pointers suffer from, they are essential for accessing common data structures such as arrays, structs, and strings. That’s why this chapter discussed pointers prior to these other <i>composite data types</i>. However, with the discussion of pointers out of the way, it’s time to look at those other data types.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h3 class="H1" id="sec15"><span id="h1-58"/><span class="SANS_Futura_Std_Bold_B_11">4.5 Composite Data Types</span></h3>&#13;
<p class="TNI1"><i>Composite data types</i>, also known as <i>aggregate data types</i>, are those that are built up from other, generally scalar, data types. A string, for example, is a composite data type, since it’s built from a sequence of individual characters and other data. The following sections cover several of the more <span role="doc-pagebreak" epub:type="pagebreak" id="pg_187" aria-label="187"/>important composite data types: character strings, arrays, multidimensional arrays, structs, and unions.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h3 class="H1" id="sec16"><span id="h1-59"/><span class="SANS_Futura_Std_Bold_B_11">4.6 Character Strings</span></h3>&#13;
<p class="TNI1">After integer values, character strings are probably the most common data type that modern programs use. This section provides a couple definitions of character strings (the ubiquitous zero-terminated string, the more efficient length-prefixed string, and other combinations of the two) and discusses how to process those strings.</p>&#13;
<p class="TX">In general, a <i>character string</i> is a sequence of ASCII characters that possesses two main attributes: a length and character data. Different languages use different data structures to represent strings. For assembly language (at least, sans any library routines), you can choose to implement strings in whichever format you want—perhaps based on the format’s compatibility with an HLL or on a desire to produce faster string functions. All you need do is create a sequence of machine instructions to process the string data in whatever format the strings take.</p>&#13;
<p class="TX">It’s also possible for strings to hold Unicode characters. This section uses ASCII in all the examples (because Gas does a better job of supporting ASCII characters). The principles apply to Unicode as well, with an appropriate extension in the amount of storage you use.</p>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h4 class="H2" id="sec17"><span id="h2-78"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">4.6.1 Zero-Terminated Strings</span></h4>&#13;
<p class="TNI1">Zero-terminated strings are the most common string representation in use today, since this is the native string format for C, C++, and other languages. A <i>zero-terminated string</i> consists of a sequence of zero or more ASCII characters ending with a 0 byte. For example, in C/C++, the string <span class="SANS_TheSansMonoCd_W5Regular_11">"abc"</span> requires 4 bytes: the three characters <span class="SANS_TheSansMonoCd_W5Regular_11">a</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">b</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">c</span>, followed by a byte containing 0.</p>&#13;
<p class="TX">To create zero-terminated strings in Gas, simply use the <span class="SANS_TheSansMonoCd_W5Regular_11">.asciz</span> directive. The easiest place to do this is in the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> section, using code like the following:</p>&#13;
<pre id="pre-271"><code>            .data &#13;
zeroString: .asciz  "This is the zero-terminated string"</code></pre>&#13;
<p class="TX">Whenever a character string appears in the <span class="SANS_TheSansMonoCd_W5Regular_11">.asciz</span> directive, as it does here, Gas emits each character in the string to successive memory locations and terminates the whole string with a 0 byte.</p>&#13;
<p class="TX">There are a couple of ways to accommodate a zero-terminated string that’s longer than a single source line. First, you can use <span class="SANS_TheSansMonoCd_W5Regular_11">.ascii</span> directives for all but the last source code line in a long string. For example:</p>&#13;
<pre id="pre-272"><code>             .data &#13;
longZString: .ascii  "This is the first line"&#13;
             .ascii  "This is the second line"&#13;
             .asciz  "This is the last line"</code></pre>&#13;
<p class="Continued1"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_188" aria-label="188"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">.asciz</span> directive zero-terminates the entire string. However, if you prefer, you can always use a <span class="SANS_TheSansMonoCd_W5Regular_11">.byte</span> directive to explicitly add the zero-terminating byte yourself:</p>&#13;
<pre id="pre-273"><code>             .data &#13;
longZString: .ascii  "This is the first line"&#13;
             .ascii  "This is the second line"&#13;
             .ascii  "This is the last line"&#13;
             .byte   0 </code></pre>&#13;
<p class="TX">Use whichever scheme you like. Some people prefer the explicit <span class="SANS_TheSansMonoCd_W5Regular_11">.byte</span> directive because it’s easy to add and remove strings from the list without having to worry about changing <span class="SANS_TheSansMonoCd_W5Regular_11">.ascii</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">.asciz</span> (or vice versa).</p>&#13;
<p class="TX">Zero-terminated strings have two principal attributes: they are simple to implement, and the strings can be any length. However, they also have a few drawbacks. First, zero-terminated strings cannot contain the NUL character (whose ASCII code is <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>). Generally, this isn’t a problem, but it does create havoc once in a while. Second, many operations on zero-terminated strings are somewhat inefficient. For example, to compute the length of a zero-terminated string, you must scan the entire string looking for that 0 byte (counting characters up to the 0). The following program fragment demonstrates how to compute the length of the preceding string:</p>&#13;
<pre id="pre-274"><code>          lea   x1, longZString &#13;
          mov   x2, x1         // Save pointer to string. &#13;
whileLp:  ldrb  w0, [x1], #1   // Fetch next char and inc X1. &#13;
          cmp   w0, #0         // See if 0 byte. &#13;
          bne   whileLp        // Repeat while not 0. &#13;
          sub   x0, x1, x2     // X0 = X1 - X2 &#13;
          sub   x0, x0, #1     // Adjust for extra increment. &#13;
&#13;
// String length is now in X0. </code></pre>&#13;
<p class="TX">This code saves the initial string address (in X2), then subtracts the final pointer (just beyond the 0 byte) from the initial address to compute the length. The extra <span class="SANS_TheSansMonoCd_W5Regular_11">sub</span> (by <span class="SANS_TheSansMonoCd_W5Regular_11">1</span>) is present because we don’t normally include the zero-terminating byte in the string’s length.</p>&#13;
<p class="TX">As you can see, the time it takes to compute the length of the string is proportional to the length of the string; as the string gets longer, computing its length takes longer.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h4 class="H2" id="sec18"><span id="h2-79"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">4.6.2 Length-Prefixed Strings</span></h4>&#13;
<p class="TNI1">The length-prefixed string format overcomes some of the problems with zero-terminated strings. <i>Length-prefixed strings</i> are common in languages like Pascal; they generally consist of a length byte followed by zero or more character values. The first byte specifies the string length, and the following bytes (up to the specified length) are the character data. In a length-prefixed scheme, the string <span class="SANS_TheSansMonoCd_W5Regular_11">"abc"</span> would consist of 4 bytes: <span class="SANS_TheSansMonoCd_W5Regular_11">3</span> (the string length) <span role="doc-pagebreak" epub:type="pagebreak" id="pg_189" aria-label="189"/>followed by <span class="SANS_TheSansMonoCd_W5Regular_11">a</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">b</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">c</span>. You can create length-prefixed strings in Gas by using code like the following:</p>&#13;
<pre id="pre-275"><code>                      .data &#13;
lengthPrefixedString: .byte   3 &#13;
                      .ascii "abc"</code></pre>&#13;
<p class="TX">Counting the characters ahead of time and inserting them into the byte statement, as was done here, may seem like a major pain. Fortunately, there are ways to have Gas automatically compute the string length for you.</p>&#13;
<p class="TX">Length-prefixed strings solve the two major problems associated with zero-terminated strings. It is possible to include the NUL character in length-prefixed strings, and those operations on zero-terminated strings that are relatively inefficient (for example, string length) are more efficient when using length-prefixed strings. However, length-prefixed strings have their own drawbacks; most important, they are limited to a maximum of 255 characters in length (assuming a 1-byte length prefix).</p>&#13;
<p class="TX">Of course, if you have a problem with a string-length limitation of 255 characters, you can always create a length-prefixed string by using any number of bytes for the length as you need. For example, the High-Level Assembler (HLA) uses a 4-byte length variant of length-prefixed strings, allowing strings up to 4GB long. (See section 4.11, <span class="Xref">“For More Information,”</span> on <span class="Xref"><a href="chapter4.xhtml#pg_221">page 221</a></span> for more on the HLA.) In assembly language, you can define string formats however you like.</p>&#13;
<p class="TX">To create length-prefixed strings in your assembly language programs, you don’t want to manually count the characters in the string and emit that length in your code. It’s far better to have the assembler do this kind of grunt work for you by using the location counter operator (<span class="SANS_TheSansMonoCd_W5Regular_11">.</span>), as follows:</p>&#13;
<pre id="pre-276"><code>                      .data &#13;
lengthPrefixedString: .byte  lpsLen &#13;
                      .ascii "abc"&#13;
lpsLen                =      . - lengthPrefixedString - 1 </code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">lpsLen</span> operand subtracts 1 in the address expression because</p>&#13;
<pre id="pre-277"><code>. - lengthPrefixedString </code></pre>&#13;
<p class="Continued1">also includes the length prefix byte, which isn’t considered part of the string length.</p>&#13;
<p class="TX">Gas does not require you to define <span class="SANS_TheSansMonoCd_W5Regular_11">lpsLen</span> before using it as the operand field in the <span class="SANS_TheSansMonoCd_W5Regular_11">.byte</span> directive. Gas is smart enough to go back and fill in the value after it is defined in the equate statement.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h4 class="H2" id="sec19"><span id="h2-80"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">4.6.3 String Descriptors</span></h4>&#13;
<p class="TNI1">Another common string format is a string descriptor. A <i>string descriptor</i> is typically a small data structure (see section 4.8, <span class="Xref">“Structs,”</span> on <span class="Xref"><a href="chapter4.xhtml#pg_212">page 212</a></span>) that contains several pieces of data describing a string.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_190" aria-label="190"/>At a bare minimum, a string descriptor will probably have a pointer to the actual string data and a field specifying the number of characters in the string (that is, the string length). Other possible fields might include the number of bytes currently occupied by the string, the maximum number of bytes the string could occupy, the string encoding (for example, ASCII, Latin-1, UTF-8, or UTF-16), and any other information the string data structure’s designer could dream up.</p>&#13;
<p class="TX">By far, the most common descriptor format incorporates a pointer to the string’s data and a size field specifying the number of bytes currently occupied by that string data. Note that this particular string descriptor is not the same thing as a length-prefixed string. In a length-prefixed string, the length immediately precedes the character data itself. In a descriptor, the length and a pointer are kept together, and this pair is (usually) separate from the character data itself.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h4 class="H2" id="sec20"><span id="h2-81"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">4.6.4 Pointers to Strings</span></h4>&#13;
<p class="TNI1">Often, an assembly language program won’t directly work with strings appearing in the <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> (or <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.rodata</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">.bss</span>) section. Instead, the program will work with pointers to strings (including strings whose storage the program has dynamically allocated with a call to a function like <span class="SANS_TheSansMonoCd_W5Regular_11">malloc()</span>). Listing 4-4 provided a simple (though broken) example. In such applications, your assembly code will typically load a pointer to a string into a base register and then use a second (index) register to access individual characters in the string.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h4 class="H2" id="sec21"><span id="h2-82"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">4.6.5 String Functions</span></h4>&#13;
<p class="TNI1">Unfortunately, few assemblers provide a set of string functions you can call from your assembly language programs. As an assembly language programmer, you’re expected to write these functions on your own. Fortunately, a couple of solutions are available if you don’t quite feel up to the task.</p>&#13;
<p class="TX">The first set of string functions you can call, without having to write them yourself, are the C stdlib string functions from the <i>string.h</i> header file in C. Of course, you’ll have to use C strings (zero-terminated strings) in your code when calling C stdlib functions, but this generally isn’t a big problem. Listing 4-5 provides examples of calls to various C string functions, further described in <span class="Xref"><a href="appendix-E.xhtml">Appendix E</a></span>.</p>&#13;
<pre id="pre-278"><code>// Listing4-5.S &#13;
//&#13;
// Calling C stdlib string functions&#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
maxLen      =           256 &#13;
saveLR      =           56 &#13;
&#13;
            .section    .rodata, ""&#13;
ttlStr:     .asciz      "Listing 4-5"&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_191" aria-label="191"/>prompt:     .asciz      "Input a string: "&#13;
fmtStr1:    .asciz      "After strncpy, resultStr='%s'\n"&#13;
fmtStr2:    .asciz      "After strncat, resultStr='%s'\n"&#13;
fmtStr3:    .asciz      "After strcmp (3), W0=%d\n"&#13;
fmtStr4:    .asciz      "After strcmp (4), W0=%d\n"&#13;
fmtStr5:    .asciz      "After strcmp (5), W0=%d\n"&#13;
fmtStr6:    .asciz      "After strchr, X0='%s'\n"&#13;
fmtStr7:    .asciz      "After strstr, X0='%s'\n"&#13;
fmtStr8:    .asciz      "resultStr length is %d\n"&#13;
&#13;
str1:       .asciz      "Hello, "&#13;
str2:       .asciz      "World!" &#13;
str3:       .asciz      "Hello, World!" &#13;
str4:       .asciz      "hello, world!" &#13;
str5:       .asciz      "HELLO, WORLD!" &#13;
&#13;
            .data &#13;
strLength:  .dword      .-. &#13;
resultStr:  .space      maxLen, .-. &#13;
resultPtr:  .dword      resultStr &#13;
cmpResult:  .dword      .-. &#13;
&#13;
            .text &#13;
            .align      2 &#13;
            .extern     readLine &#13;
            .extern     printf &#13;
            .extern     malloc &#13;
            .extern     free &#13;
&#13;
// Some C stdlib string functions: &#13;
//&#13;
// size_t strlen(char *str) &#13;
&#13;
            .extern     strlen &#13;
&#13;
// char *strncat(char *dest, const char *src, size_t n) &#13;
&#13;
            .extern     strncat &#13;
&#13;
// char *strchr(const char *str, int c) &#13;
&#13;
            .extern     strchr &#13;
&#13;
// int strcmp(const char *str1, const char *str2) &#13;
&#13;
            .extern     strcmp &#13;
&#13;
// char *strncpy(char *dest, const char *src, size_t n) &#13;
&#13;
            .extern     strncpy &#13;
&#13;
// char *strstr(const char *inStr, const char *search4) &#13;
&#13;
            .extern     strstr &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_192" aria-label="192"/>// Return program title to C++ program: &#13;
&#13;
            .global     getTitle &#13;
getTitle: &#13;
            lea         x0, ttlStr &#13;
            ret &#13;
&#13;
// Here is the "asmMain" function. &#13;
&#13;
            .global     asmMain &#13;
asmMain: &#13;
        sub     sp, sp, #64         // Allocate stack space. &#13;
        str     lr, [sp, #saveLR]   // Save return address. &#13;
&#13;
// Demonstrate the strncpy function to copy a &#13;
// string from one location to another: &#13;
&#13;
        lea     x0, resultStr   // Destination string &#13;
        lea     x1, str1        // Source string &#13;
        mov     x2, #maxLen     // Max number of chars to copy &#13;
        bl      strncpy &#13;
&#13;
        lea     x0, fmtStr1 &#13;
        vparm2  resultPtr &#13;
        bl      printf &#13;
&#13;
// Demonstrate the strncat function to concatenate str2 to &#13;
// the end of resultStr: &#13;
&#13;
        lea     x0, resultStr &#13;
        lea     x1, str2 &#13;
        mov     x2, #maxLen &#13;
        bl      strncat &#13;
&#13;
        lea     x0, fmtStr2 &#13;
        vparm2  resultPtr &#13;
        bl      printf &#13;
&#13;
// Demonstrate the strcmp function to compare resultStr &#13;
// with str3, str4, and str5: &#13;
&#13;
        lea     x0, resultStr &#13;
        lea     x1, str3 &#13;
        bl      strcmp &#13;
        lea     x1, cmpResult &#13;
        str     x0, [x1] &#13;
&#13;
        lea     x0, fmtStr3 &#13;
        vparm2  cmpResult &#13;
        bl      printf &#13;
&#13;
        lea     x0, resultStr &#13;
        lea     x1, str4 &#13;
        bl      strcmp &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_193" aria-label="193"/>        lea     x1, cmpResult &#13;
        str     x0, [x1] &#13;
&#13;
        lea     x0, fmtStr4 &#13;
        vparm2  cmpResult &#13;
        bl      printf &#13;
&#13;
        lea     x0, resultStr &#13;
        lea     x1, str5 &#13;
        bl      strcmp &#13;
        lea     x1, cmpResult &#13;
        str     x0, [x1] &#13;
&#13;
        lea     x0, fmtStr5 &#13;
        vparm2  cmpResult &#13;
        bl      printf &#13;
&#13;
// Demonstrate the strchr function to search for &#13;
// ',' in resultStr: &#13;
&#13;
        lea     x0, resultStr &#13;
        mov     x1, #',' &#13;
        bl      strchr &#13;
        lea     x1, cmpResult &#13;
        str     x0, [x1] &#13;
&#13;
        lea     x0, fmtStr6 &#13;
        vparm2  cmpResult &#13;
        bl      printf &#13;
&#13;
// Demonstrate the strstr function to search for &#13;
// str2 in resultStr: &#13;
&#13;
        lea     x0, resultStr &#13;
        lea     x1, str2 &#13;
        bl      strstr &#13;
        lea     x1, cmpResult &#13;
        str     x0, [x1] &#13;
&#13;
        lea     x0, fmtStr7 &#13;
        vparm2  cmpResult &#13;
        bl      printf &#13;
&#13;
// Demonstrate a call to the strlen function: &#13;
&#13;
        lea     x0, resultStr &#13;
        bl      strlen &#13;
        lea     x1, cmpResult &#13;
        str     x0, [x1] &#13;
&#13;
        lea     x0, fmtStr8 &#13;
        vparm2  cmpResult &#13;
        bl      printf &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_194" aria-label="194"/>        ldr     lr, [sp, #saveLR]   // Restore return address. &#13;
        add     sp, sp, #64         // Deallocate storage. &#13;
        ret     // Returns to caller </code></pre>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output from Listing 4-5:</p>&#13;
<pre id="pre-279"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing4-5</span> &#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing4-5</span> &#13;
Calling Listing4-5: &#13;
After strncpy, resultStr='Hello, ' &#13;
After strncat, resultStr='Hello, World!' &#13;
After strcmp (3), W0 = 0 &#13;
After strcmp (4), W0=-128 &#13;
After strcmp (5), W0 = 128 &#13;
After strchr, X0=', World!' &#13;
After strstr, X0='World!' &#13;
resultStr length is 13 &#13;
Listing4-5 terminated </code></pre>&#13;
<p class="TX">Of course, you could make a good argument that if all your assembly code does is call a bunch of C stdlib functions, you should have written your application in C in the first place. Most of the benefits of writing code in assembly language happen only when you “think” in assembly language, not C.</p>&#13;
<p class="TX">In particular, you can dramatically improve the performance of your string function calls if you stop using zero-terminated strings and switch to another string format (such as length-prefixed or descriptor-based strings that include a length component). <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span> presents some pure assembly string functions for those who want to avoid the inefficiencies of using zero-terminated strings with the C stdlib.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h3 class="H1" id="sec22"><span id="h1-60"/><span class="SANS_Futura_Std_Bold_B_11">4.7 Arrays</span></h3>&#13;
<p class="TNI1">Along with strings, arrays are probably the most commonly used composite data type. Yet most beginning programmers don’t understand their internal operation or their associated efficiency trade-offs. It’s surprising how many novice (and even advanced!) programmers view arrays from a completely different perspective once they learn how to deal with arrays at the machine level.</p>&#13;
<p class="TX">Abstractly, an <i>array</i> is an aggregate data type whose members (elements) are all the same type. Selection of a member from the array is by an integer index (or other ordinal type such as Boolean or character). Different indices select unique elements of the array. This book assumes that the integer indices are contiguous, though this is by no means required. That is, if the number <i>x</i> is a valid index into the array and <i>y</i> is also a valid index, with <i>x</i> &lt; <i>y</i>, then all <i>i</i> such that <i>x</i> &lt; <i>i</i> &lt; <i>y</i> are valid indices. Most HLLs use contiguous array indices, and they are the most efficient to use, hence their use here.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_195" aria-label="195"/>Whenever you apply the indexing operator to an array, the result is the specific array element chosen by that index. For example, <span class="SANS_TheSansMonoCd_W5Regular_11">A[i]</span> chooses the <i>i</i>th element from array <span class="SANS_TheSansMonoCd_W5Regular_11">A</span>. There is no formal requirement that element <span class="SANS_TheSansMonoCd_W5Regular_11">i</span> be anywhere near element <span class="SANS_TheSansMonoCd_W5Regular_11">i + 1</span> in memory; the definition of an array is satisfied as long as <span class="SANS_TheSansMonoCd_W5Regular_11">A[i]</span> always refers to the same memory location and <span class="SANS_TheSansMonoCd_W5Regular_11">A[i + 1]</span> always refers to its corresponding location (and the two are different).</p>&#13;
<p class="TX">As noted, this book assumes that array elements occupy contiguous locations in memory. An array with five elements will appear in memory as shown in <a href="chapter4.xhtml#fig4-1">Figure 4-1</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig4-1" src="../images/Figure4-1.jpg" alt="" width="1246" height="232"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 4-1: An array layout in memory</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The <i>base address</i> of an array is the address of that array’s first element and always appears in the lowest memory location. The second array element directly follows the first in memory, the third element follows the second, and so on. Indices are not required to start at 0. They may start with any number as long as they are contiguous. However, for the purposes of discussion, this book starts all indices at 0.</p>&#13;
<p class="TX">To access an element of an array, you need a function that translates an array index to the address of the indexed element. For a single-dimensional array, this function is very simple:</p>&#13;
<pre id="pre-280"><code><var>Element_Address</var> =&#13;
<var>   Base_Address</var> + <var>((Index</var> - <var>Initial_Index)</var> × <var>Element_Size)</var> </code></pre>&#13;
<p class="Continued1">Here, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Initial_Index</span> is the value of the first index in the array (which you can ignore if it’s 0), and the value <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Element_Size</span> is the size, in bytes, of an individual array element (this may include padding bytes used to keep elements properly aligned).</p>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h4 class="H2" id="sec23"><span id="h2-83"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">4.7.1 Declaring Arrays in Gas Programs</span></h4>&#13;
<p class="TNI1">Before you can access elements of an array, you need to set aside storage for that array. Fortunately, array declarations build on the declarations you’ve already seen. To allocate <i>n</i> elements in an array, you would use a declaration like the following in one of the variable declaration sections:</p>&#13;
<pre id="pre-281"><code><var>ArrayName</var>: .fill  <var>n</var>, <var>element_size</var>, <var>initial_value</var> </code></pre>&#13;
<p class="Continued1"><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">ArrayName</span> is the name of the array variable, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span> is the number of array elements, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">element_size</span> is the size (in bytes) of a single element, and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">initial_value</span> is the initial value to assign to each array element. The <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">element_size</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">initial _value</span> arguments are optional, defaulting to <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">0</span>, respectively.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_196" aria-label="196"/>For example, to declare an array of sixteen 32-bit words, you could use the following:</p>&#13;
<pre id="pre-282"><code>wordArray:   .fill    16, 4 </code></pre>&#13;
<p class="Continued1">This would set aside sixteen 4-byte words, each initialized with 0 (the default initial value).</p>&#13;
<p class="TX">The value for <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">element_size</span> must not exceed 8; if it does, Gas will clip the value to 8. For historical (Gas) reasons, you should limit the initial value to 32 bits; larger values are transformed in nonintuitive ways (and differently on macOS and Linux). As a general rule, I strongly recommend defaulting to 0 for each array element when using the <span class="SANS_TheSansMonoCd_W5Regular_11">.fill</span> directive.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>If you use the</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">.fill</span> <i>directive in a</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">.bss</span> <i>section, the initial value must be absent or set to 0.</i></p>&#13;
<p class="TX">An alternative to the <span class="SANS_TheSansMonoCd_W5Regular_11">.fill</span> directive is <span class="SANS_TheSansMonoCd_W5Regular_11">.space</span></p>&#13;
<pre id="pre-283"><code><var>ArrayName:</var>  .space <var>size</var>, <var>fill</var> </code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">size</span> is the number of bytes to allocate for the array and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">fill</span> is an optional 8-bit value that Gas will use to initialize each byte of the array. If the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">fill</span> argument is absent, Gas uses a default value of 0.</p>&#13;
<p class="TX">To declare an array of a type other than bytes, you must compute the size argument as <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">numberOfElements</span> × <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">elementSize</span>. For example, to create a 16-element array of words, you could use the following declaration:</p>&#13;
<pre id="pre-284"><code>wordArray:   .space    16 * (4)   // word wordArray[16] </code></pre>&#13;
<p class="TX">Because the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">fill</span> argument is not present, Gas will initialize this array with bytes containing 0s. I recommend putting parentheses around the element size in the expression to better document your intent; this differentiates the element size from the element count. As you’ll see in section 4.7.4, <span class="Xref">“Implementing Multidimensional Arrays,”</span> on <span class="Xref"><a href="chapter4.xhtml#pg_203">page 203</a></span>, the element count could be an expression based on the size of each dimension.</p>&#13;
<p class="TX">To obtain the base address of these arrays, just use <span class="SANS_TheSansMonoCd_W5Regular_11">ArrayName</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">wordArray</span> in an address expression. If you prefer to initialize an array with different values in each of the elements, you must manually supply those values in the directives <span class="SANS_TheSansMonoCd_W5Regular_11">.byte</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.hword</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.word</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.dword</span>, and so on. Here’s a 16-word array initialized with the values 0 to 15:</p>&#13;
<pre id="pre-285"><code>wordArray:    .word   0, 1, 2, 3, 4, 5, 6, 7 &#13;
              .word   8, 9, 10, 11, 12, 13, 14, 15 </code></pre>&#13;
<p class="TX">If you need to initialize a large array with different values, you’re best off either writing an external program (perhaps in an HLL like C/C++) or using Gas’s macro facilities to generate the array. I discuss this further in <span class="Xref"><a href="chapter10.xhtml">Chapters 10</a></span> and <span class="Xref"><a href="chapter13.xhtml">13</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_197" aria-label="197"/>&#13;
<h4 class="H2" id="sec24"><span id="h2-84"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">4.7.2 Accessing Elements of a Single-Dimensional Array</span></h4>&#13;
<p class="TNI1">To access an element of a zero-based array, use this formula:</p>&#13;
<pre id="pre-286"><code><var>Element_Address</var> = <var>Base_Address</var> + <var>index</var> × <var>Element_Size</var> </code></pre>&#13;
<p class="TX">If the array is located within your <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section (an array of constants), or if you’re writing a Linux application and the array isn’t farther than ±1MB from your code that accesses the array, you can use the array’s name for the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Base_Address</span> entry. This is because Gas associates the address of the first element of an array with the name of that array.</p>&#13;
<p class="TX">Otherwise, you’ll need to load the base address of the array into a 64-bit register. For example:</p>&#13;
<pre id="pre-287"><code>lea x1, <var>Base_Address</var> </code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Element_Size</span> entry is the number of bytes for each array element. If the object is an array of bytes, the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Element_Size</span> field is 1 (resulting in a very simple computation). If each element of the array is a half word (or other 2-byte type), then <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Element_Size</span> is 2, and so on. To access an element of the <span class="SANS_TheSansMonoCd_W5Regular_11">wordArray</span> array in the previous section, you’d use the following formula (the size is 4 because each element is a word object):</p>&#13;
<pre id="pre-288"><code><var>Element_Address</var> = wordArray + (<var>index</var> × 4) </code></pre>&#13;
<p class="TX">The ARM code equivalent to the statement <span class="SANS_TheSansMonoCd_W5Regular_11">w0 = wordArray[index]</span> is as follows:</p>&#13;
<pre id="pre-289"><code>lea x1, index   // Assume index is a 32-bit integer. &#13;
ldr w1, [x1]    // Get index into W1. &#13;
lea x2, wordArray &#13;
ldr w0, [x2, w1, uxtw #2] // index * 4 and zero-extended </code></pre>&#13;
<p class="TX">This instruction sequence does not explicitly compute the sum of the base address plus the index times 4 (the size of a 32-bit integer element in <span class="SANS_TheSansMonoCd_W5Regular_11">wordArray</span>). Instead, it relies on the scaled-indexed addressing mode (the <span class="SANS_TheSansMonoCd_W5Regular_11">uxtx #2</span> operand) to implicitly compute this sum. The instruction</p>&#13;
<pre id="pre-290"><code>ldr w0, [x2, w1, uxtw #2] </code></pre>&#13;
<p class="Continued1">loads W0 from location <span class="SANS_TheSansMonoCd_W5Regular_11">X2 + W1 * 4</span>, which is the base address plus <span class="SANS_TheSansMonoCd_W5Regular_11">index * 4</span> (because W1 contains <span class="SANS_TheSansMonoCd_W5Regular_11">index</span>).</p>&#13;
<p class="TX">To multiply by a constant other than 1, 2, 4, or 8 (the immediate shift constants possible with the scaled-indexed addressing mode), you’ll need to use the <span class="SANS_TheSansMonoCd_W5Regular_11">lsl</span> instruction to multiply by the element size (if multiplying by a power of 2) or the <span class="SANS_TheSansMonoCd_W5Regular_11">mul</span> instruction. You’ll see some examples in a bit.</p>&#13;
<p class="TX">The scaled-indexed addressing mode on the ARM is the natural addressing mode for accessing elements of a single-dimensional array. Make sure <span role="doc-pagebreak" epub:type="pagebreak" id="pg_198" aria-label="198"/>you remember to multiply the index by the size of an element; failure to do so will produce incorrect results.</p>&#13;
<p class="TX">The examples in this section assume that the <span class="SANS_TheSansMonoCd_W5Regular_11">index</span> variable is a 32-bit value, which is common for array indices. To use a smaller integer, you’d need to sign- or zero-extend it to 32 bits. To use a 64-bit integer, simply adjust the scaled-indexed addressing mode to use a 64-bit index register and use the shift-left scaling without zero or sign extension.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h4 class="H2" id="sec25"><span id="h2-85"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">4.7.3 Sorting an Array of Values</span></h4>&#13;
<p class="TNI1">When introducing arrays, books commonly introduce sorting the elements of an array. To acknowledge this historical precedent, this section takes a quick look at a simple sort in Gas. The program presented in this section uses a variant of the bubble sort, which is great for short lists of data and lists that are nearly sorted, but horrible for just about everything else. However, a bubble sort is easy to implement and understand, which is why this and other introductory texts continue to use it in examples.</p>&#13;
<p class="TX">Because of the relative complexity of Listing 4-6, I’ll insert comments throughout the source code rather than explaining it at the end. We begin by including <i>aoaa.inc</i>, as usual.</p>&#13;
<pre id="pre-291"><code>// Listing4-6.S &#13;
//&#13;
// A simple bubble sort example &#13;
&#13;
#include "aoaa.inc"</code></pre>&#13;
<p class="TX">Right away, let’s make some coding improvements as compared to many of the previous examples in this book. Those examples, such as Listing 4-1, used “magic” numbers, like 64 for the amount of stack space to allocate and 56 for the offset into the stack allocation where I preserve the LR register. I used these literal constants directly in the code to be as transparent as possible; however, good programming style demands the use of symbolic names in place of those magic numbers. The two equates below accomplish this.  </p>&#13;
<pre id="pre-292"><code>// Listing4-6.S (cont.) &#13;
&#13;
stackAlloc  =   64   // Space to allocate on stack &#13;
saveLR      =   56   // Save LR here (index into stack frame). </code></pre>&#13;
<p class="TX">The next couple of statements in the source file define offsets into the stack frame (allocated storage on the stack) where the program can preserve register values. In all the example programs so far, I’ve placed (global) variables in memory locations. That’s not the appropriate paradigm for RISC assembly language programming.</p>&#13;
<p class="TX">The ARM ABI reserves registers X19 through X28 for use as nonvolatile (permanent) variable storage. <i>Nonvolatile</i> means you can call functions (like <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span>) without worrying about those registers’ values being changed. The <span role="doc-pagebreak" epub:type="pagebreak" id="pg_199" aria-label="199"/>drawback to using nonvolatile registers is that you have to preserve their values upon entry into your code. The following two equates specify the offset into the stack allocation area for register preservation. This code will use registers X19 and X20 as loop control variables:</p>&#13;
<pre id="pre-293"><code>// Listing4-6.S (cont.) &#13;
&#13;
x19Save     =   saveLR - 8   // Save X19 here. &#13;
x20Save     =   x19Save - 8  // Save X20 here. </code></pre>&#13;
<p class="TX">The remaining equates define other constants used in this code:</p>&#13;
<pre id="pre-294"><code>// Listing4-6.S (cont.) &#13;
&#13;
maxLen      =   256 &#13;
true        =   1 &#13;
false       =   0 </code></pre>&#13;
<p class="TX">Next come the usual read-only and writable data sections. In particular, the .<span class="SANS_TheSansMonoCd_W5Regular_11">data</span> section contains the <span class="SANS_TheSansMonoCd_W5Regular_11">sortMe</span> array, which will be the subject of the sorting operation. Also, this block of statements contains the <span class="SANS_TheSansMonoCd_W5Regular_11">getTitle</span> function required by the <i>c.cpp</i> program:</p>&#13;
<pre id="pre-295"><code>// Listing4-6.S (cont.) &#13;
&#13;
            .section    .rodata, ""&#13;
ttlStr:     .asciz      "Listing 4-6"&#13;
fmtStr:     .asciz      "Sortme[%d] = %d\n"&#13;
&#13;
            .data &#13;
&#13;
// sortMe - A 16-element array to sort: &#13;
&#13;
sortMe: &#13;
            .word   1, 2, 16, 14 &#13;
            .word   3, 9, 4,  10 &#13;
            .word   5, 7, 15, 12 &#13;
            .word   8, 6, 11, 13 &#13;
sortSize    =       (. - sortMe) / 4   // Number of elements &#13;
&#13;
// Holds the array element during printing: &#13;
&#13;
valToPrint: .word   .-. &#13;
i:          .word   .-. &#13;
&#13;
            .text &#13;
            .align  2 &#13;
            .extern printf &#13;
&#13;
// Return program title to C++ program: &#13;
&#13;
            .global getTitle &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_200" aria-label="200"/>getTitle: &#13;
            lea     x0, ttlStr &#13;
            ret </code></pre>&#13;
<p class="TX">Now we get to the bubble-sort function itself:</p>&#13;
<pre id="pre-296"><code>// Listing4-6.S (cont.) &#13;
//&#13;
// Here's the bubble-sort function. &#13;
//&#13;
//       sort(dword *array, qword count) &#13;
//&#13;
// Note: this is not an external (C) &#13;
// function, nor does it call any &#13;
// external functions, so it will &#13;
// dispense with some of the OS-calling-&#13;
// sequence stuff. &#13;
//&#13;
// array- Address passed in X0 &#13;
// count- Element count passed in X1 &#13;
//&#13;
// Locals: &#13;
//&#13;
// W2 is "didSwap" Boolean flag. &#13;
// X3 is index for outer loop. &#13;
// W4 is index for inner loop. </code></pre>&#13;
<p class="TX">The bubble-sort function could just use register names like X0, X1, W2, and X3 for all the local variables. However, the following <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statements let you use more meaningful names. X5, X6, and X7 are pure temporaries (no meaningful name is attached to them), so this code continues to use the ARM register names for these temporary or local objects. Technically, X0 through X7 are reserved for parameters. As the <span class="SANS_TheSansMonoCd_W5Regular_11">sort</span> function has only two parameters (<span class="SANS_TheSansMonoCd_W5Regular_11">array</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">count</span>), it uses X2 through X7 as local variables (which is fine, as these registers are volatile, according to the ARM ABI):</p>&#13;
<pre id="pre-297"><code>// Listing4-6.S (cont.) &#13;
&#13;
#define array   x0 &#13;
#define count   x1 &#13;
#define didSwap w2 &#13;
#define index   x3 </code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">count</span> parameter just defined contains the number of array elements (which will be 16 in the main program). Since it’s more convenient for this to be a byte count rather than a (word) element count, the following code multiplies <span class="SANS_TheSansMonoCd_W5Regular_11">count</span> (X1) by 4, using a shift left by <span class="SANS_TheSansMonoCd_W5Regular_11">2</span>. Also, the loop executes <span class="SANS_TheSansMonoCd_W5Regular_11">count</span> –1 times, so this code also preps <span class="SANS_TheSansMonoCd_W5Regular_11">count</span> by subtracting 1 from it:</p>&#13;
<pre id="pre-298"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_201" aria-label="201"/>// Listing4-6.S (cont.) &#13;
&#13;
sort:&#13;
&#13;
        sub     count, count, #1   // numElements - 1 &#13;
        lsl     count, count, #2   // Make byte count. </code></pre>&#13;
<p class="TX">The bubble sort works by making <span class="SANS_TheSansMonoCd_W5Regular_11">count</span> – 1 passes through the array, where <span class="SANS_TheSansMonoCd_W5Regular_11">count</span> is the number of elements. On each pass, it compares each adjacent pair of array elements; if the first element is greater than the second one, the program swaps them. At the end of each pass, one element winds up being moved to its final position. As an optimization, if no swaps occur, then all the elements are already in place, so the sort terminates:</p>&#13;
<pre id="pre-299"><code>// Listing4-6.S (cont.) &#13;
//&#13;
// Outer loop &#13;
&#13;
outer:  mov     didSwap, #false &#13;
&#13;
        mov     index, #0          // Outer loop index &#13;
inner:  cmp     index, count       // while outer &lt; count - 1 &#13;
        bhs     xInner &#13;
&#13;
        add     x5, array, index   // W5 = &amp;array[index] &#13;
        ldr     w6, [x5]           // W6 = array[index] &#13;
        ldr     w7, [x5, #4]       // W7 = array[index + 1] &#13;
        cmp     w6, w7             // If W5 &gt; W &#13;
        bls     dontSwap           // then swap. &#13;
&#13;
        // sortMe[index] &gt; sortMe[index + 1], so swap elements. &#13;
&#13;
        str     w6, [x5, #4] &#13;
        str     w7, [x5] &#13;
        mov     didSwap, #true &#13;
&#13;
dontSwap: &#13;
        add     index, index, #4    // Next word &#13;
        b.al    inner &#13;
&#13;
// Exited from inner loop, test for repeat &#13;
// of outer loop: &#13;
&#13;
xInner: cmp     didSwap, #true &#13;
        beq     outer &#13;
&#13;
        ret </code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_202" aria-label="202"/>The main program begins by preserving the nonvolatile registers (LR, X19, and X20) that it uses:</p>&#13;
<pre id="pre-300"><code>// Listing4-6.S (cont.) &#13;
//&#13;
// Here is the asmMain function: &#13;
&#13;
            .global asmMain &#13;
asmMain: &#13;
&#13;
            sub     sp, sp, #stackAlloc   // Allocate stack space. &#13;
            str     lr, [sp, #saveLR]     // Save return address. &#13;
            str     x19, [sp, #x19Save]   // Save nonvolatile &#13;
            str     x20, [sp, #x20Save]   // X19 and X20. </code></pre>&#13;
<p class="TX">Next, the main program calls the <span class="SANS_TheSansMonoCd_W5Regular_11">sort</span> function to sort the array. As per the ARM ABI, this program passes the first argument (the address of the array) in X0 and the second argument (element count) in X1:</p>&#13;
<pre id="pre-301"><code>// Listing4-6.S (cont.) &#13;
//&#13;
// Sort the "sortMe" array: &#13;
&#13;
            lea     x0, sortMe &#13;
            mov     x1, #sortSize   // 16 elements in array &#13;
            bl      sort </code></pre>&#13;
<p class="TX">Once <span class="SANS_TheSansMonoCd_W5Regular_11">sort</span> has finished, the program executes a loop to display the 16 values in the array. This loop uses the nonvolatile registers X19 and X20 to hold the base address of the array and the loop index, so these values don’t have to be reloaded on each iteration of the loop. Because they are nonvolatile, we know that <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span> won’t disturb their values:</p>&#13;
<pre id="pre-302"><code>// Listing4-6.S (cont.) &#13;
//&#13;
// Display the sorted array. &#13;
&#13;
            lea     x19, sortMe &#13;
            mov     x20, xzr                 // X20 = 0 (index) &#13;
dispLp:     ldr     w0, [x19, x20, lsl #2]   // W0 = sortMe[X20] &#13;
            lea     x1, valToPrint &#13;
            str     w0, [x1] &#13;
            lea     x1, i &#13;
            str     x20, [x1] &#13;
&#13;
            lea     x0, fmtStr      // Print the index &#13;
            vparm2  i               // and array element &#13;
            vparm3  valToPrint      // on this loop iteration. &#13;
            bl      printf &#13;
&#13;
            add     x20, x20, #1    // Bump index by 1. &#13;
            cmp     x20, #sortSize  // Are we done yet? &#13;
            blo     dispLp </code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_203" aria-label="203"/>Once the output is complete, the main program must restore the nonvolatile registers before returning to the C++ program:</p>&#13;
<pre id="pre-303"><code>// Listing4-6.S (cont.) &#13;
&#13;
            ldr     x19, [sp, #x19Save]  // Restore nonvolatile &#13;
            ldr     x20, [sp, #x20Save]  // registers. &#13;
            ldr     lr, [sp, #saveLR]    // Restore rtn adrs. &#13;
            add     sp, sp, #stackAlloc  // Restore stack. &#13;
            ret     // Returns to caller </code></pre>&#13;
<p class="TX">You could slightly optimize this program by using the <span class="SANS_TheSansMonoCd_W5Regular_11">stp</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ldp</span> instructions to preserve both X19 and X20. To emphasize saving and restoring both registers as independent operations, I didn’t make that optimization here. However, you should get in the habit of optimizing your code in this manner in order to reap the benefits of using assembly language.</p>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and output for Listing 4-6:</p>&#13;
<pre id="pre-304"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing4-6</span> &#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing4-6</span> &#13;
Calling Listing4-6: &#13;
Sortme[0] = 1 &#13;
Sortme[1] = 2 &#13;
Sortme[2] = 3 &#13;
Sortme[3] = 4 &#13;
Sortme[4] = 5 &#13;
Sortme[5] = 6 &#13;
Sortme[6] = 7 &#13;
Sortme[7] = 8 &#13;
Sortme[8] = 9 &#13;
Sortme[9] = 10 &#13;
Sortme[10] = 11 &#13;
Sortme[11] = 12 &#13;
Sortme[12] = 13 &#13;
Sortme[13] = 14 &#13;
Sortme[14] = 15 &#13;
Sortme[15] = 16 &#13;
Listing4-6 terminated </code></pre>&#13;
<p class="TX">As is typical for a bubble sort, this algorithm terminates if the innermost loop completes without swapping any data. If the data is already presorted, the bubble sort is very efficient, making only one pass over the data. Unfortunately, if the data is not sorted (or, worst case, if the data is sorted in reverse order), then this algorithm is extremely inefficient. <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span> provides an example of a more efficient sorting algorithm, quicksort, in ARM assembly language.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h4 class="H2" id="sec26"><span id="h2-86"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">4.7.4 Implementing Multidimensional Arrays</span></h4>&#13;
<p class="TNI1">The ARM hardware can easily handle single-dimensional arrays. Unfortunately, however, accessing elements of <i>multidimensional arrays</i> takes some work and several instructions.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_204" aria-label="204"/>Before discussing how to declare or access multidimensional arrays, I’ll show you how to implement them in memory. First, how do you store a multidimensional object into a one-dimensional memory space? Consider for a moment a Pascal array of this form:</p>&#13;
<pre id="pre-305"><code>A:array[0..3,0..3] of char; </code></pre>&#13;
<p class="TX">This array contains 16 bytes organized as four rows of four characters. Somehow, you have to draw a correspondence with each of the 16 bytes in this array and 16 contiguous bytes in main memory. <a href="chapter4.xhtml#fig4-2">Figure 4-2</a> shows one way to do this.</p>&#13;
<figure class="IMG"><img class="img7" id="fig4-2" src="../images/Figure4-2.jpg" alt="" width="912" height="802"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 4-2: Mapping a 4×4 array to sequential memory locations</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The actual mapping is not important as long as two things occur: (1) each element maps to a unique memory location (no two entries in the array occupy the same memory locations), and (2) the mapping is consistent (a given element in the array always maps to the same memory location). Therefore, you need a function with two input parameters (row and column) that produces an offset into a linear array of 16 memory locations.</p>&#13;
<p class="TX">Any function that satisfies these constraints will work fine. Indeed, you could randomly choose a mapping, as long as it’s consistent. However, you really want a mapping that is efficient to compute at runtime and that works for any size array (not just 4×4 or even limited to two dimensions). While many possible functions fit this bill, two in particular are used by most programmers and HLLs: row-major ordering and column-major ordering.</p>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h5 class="H3" id="sec27"><span class="SANS_Futura_Std_Bold_Condensed_B_11">4.7.4.1 Row-Major Ordering</span></h5>&#13;
<p class="TNI1"><i>Row-major ordering</i> assigns successive elements, moving across the rows and then down the columns, to successive memory locations. <a href="chapter4.xhtml#fig4-3">Figure 4-3</a> demonstrates this mapping.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_205" aria-label="205"/>&#13;
<figure class="IMG"><img class="img7" id="fig4-3" src="../images/Figure4-3.jpg" alt="" width="922" height="873"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 4-3: Row-major ordering of array elements</span></p></figcaption>&#13;
</figure>&#13;
<aside class="box" aria-label="box-17">&#13;
<p class="BH" id="box-17"><span class="SANS_Dogma_OT_Bold_B_11">ROW AND COLUMN INDICES VS. NUMBERS</span></p>&#13;
<p class="BTNI"><span class="SANS_Futura_Std_Book_11">When discussing multidimensional arrays, it is easy to confuse row and column numbers and indices. A</span> <span class="SANS_Futura_Std_Book_Oblique_11">row number</span> <span class="SANS_Futura_Std_Book_11">is, quite literally, the number associated with a row. In <a href="chapter4.xhtml#fig4-3">Figure 4-3</a>, the row numbers are the values 0, 1, 2, and 3 to the left of the 4×4 matrix, numbering each of the rows. Similarly, the</span> <span class="SANS_Futura_Std_Book_Oblique_11">column numbers</span> <span class="SANS_Futura_Std_Book_11">are the values 0, 1, 2, and 3 at the top of the matrix, numbering each of the columns.</span></p>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_11">An</span> <span class="SANS_Futura_Std_Book_Oblique_11">index</span> <span class="SANS_Futura_Std_Book_11">into a row is the offset from the beginning of each row into the elements of that row. For example, in row 1 in <a href="chapter4.xhtml#fig4-3">Figure 4-3</a>, the element at index 2 contains the value 6. Similarly, a column index is an index into a column (moving from top to bottom in <a href="chapter4.xhtml#fig4-3">Figure 4-3</a>). The array element in column 2 at column index 3 is the value 14.</span></p>&#13;
<p class="BoxBodyLast"><span class="SANS_Futura_Std_Book_11">Here’s where confusion could occur: a column number is the same as a row index; likewise, a row number is the same as a column index. When this chapter presents the formulas for indexing into multidimensional arrays, be cognizant of the difference between row and column numbers and indices.</span></p>&#13;
</aside>&#13;
<p class="TX">Row-major ordering is the method most HLLs employ. It is easy to implement and use in machine language: you start with the first row (row 0) and then concatenate the second row to its end. You then concatenate the third row to the end of the list, then the fourth row, and so on (see <a href="chapter4.xhtml#fig4-4">Figure 4-4</a>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_206" aria-label="206"/>&#13;
<figure class="IMG"><img class="img1" id="fig4-4" src="../images/Figure4-4.jpg" alt="" width="1304" height="631"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 4-4: Another view of row-major ordering for a 4×4 array</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The function that converts a list of index values into an offset is a slight modification of the formula for computing the address of an element of a single-dimensional array. The formula to compute the offset for a two-dimensional row-major ordered array is as follows:</p>&#13;
<pre id="pre-306"><code><var>Element_Address</var> =&#13;
    <var>Base_Address</var> +&#13;
      (<var>colindex</var> × <var>row_size</var> + <var>rowindex</var>) × <var>Element_Size</var> </code></pre>&#13;
<p class="TX">As usual, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Base_Address</span> is the address of the first element of the array (<span class="SANS_TheSansMonoCd_W5Regular_11">A[0][0]</span> in this case), and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Element_Size</span> is the size of an individual element of the array, in bytes. <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">colindex</span> is the leftmost index, and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">rowindex</span> is the rightmost index into the array. <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">row_size</span> is the number of elements in one row of the array (4, in this case, because each row has four elements). Assuming <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Element_Size</span> is 1, this formula computes the following offsets from the base address:</p>&#13;
<pre id="pre-307"><code>Column          Row             Offset &#13;
Index                           into Array &#13;
0               0               0 &#13;
0               1               1 &#13;
0               2               2 &#13;
0               3               3 &#13;
1               0               4 &#13;
1               1               5 &#13;
1               2               6 &#13;
1               3               7 &#13;
2               0               8 &#13;
2               1               9 &#13;
2               2               10 &#13;
2               3               11 &#13;
3               0               12 &#13;
3               1               13 &#13;
3               2               14 &#13;
3               3               15 </code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_207" aria-label="207"/>For a three-dimensional array, the formula to compute the offset into memory is the following:</p>&#13;
<pre id="pre-308"><code><var>Address </var>=&#13;
    <var>Base </var>+ ((<var>depthindex </var>× <var>col_size </var>+ <var>colindex</var>) × <var>row_size </var>+&#13;
             <var>rowindex</var>) × <var>Element_Size</var> </code></pre>&#13;
<p class="Continued1"><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">col_size</span> is the number of items in a column, and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">row_size</span> is the number of items in a row.</p>&#13;
<p class="TX">In C/C++, if you’ve declared the array as</p>&#13;
<pre id="pre-309"><code><var>type</var> A[i][j][k]; </code></pre>&#13;
<p class="Continued1">then <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">row_size</span> is equal to <span class="SANS_TheSansMonoCd_W5Regular_11">k</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">col_size</span> is equal to <span class="SANS_TheSansMonoCd_W5Regular_11">j</span>.</p>&#13;
<p class="TX">For a four-dimensional array, declared in C/C++ as</p>&#13;
<pre id="pre-310"><code><var>type</var> A[i][j][k][m]; </code></pre>&#13;
<p class="Continued1">the formula for computing the address of an array element is shown here:</p>&#13;
<pre id="pre-311"><code><var>Address</var> =&#13;
    <var>Base</var> +&#13;
      (((<var>LeftIndex</var> × <var>depth_size</var> + <var>depthindex</var>) × <var>col_size</var> +&#13;
         <var>colindex</var>) × <var>row_size</var> + <var>rowindex</var>) × <var>Element_Size</var> </code></pre>&#13;
<p class="Continued1"><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">depth_size</span> is equal to <span class="SANS_TheSansMonoCd_W5Regular_11">j</span>, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">col_size</span> is equal to <span class="SANS_TheSansMonoCd_W5Regular_11">k</span>, and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">row_size</span> is equal to <span class="SANS_TheSansMonoCd_W5Regular_11">m</span>. <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">LeftIndex</span> represents the value of the leftmost index.</p>&#13;
<p class="TX">By now you’re probably beginning to see a pattern. A generic formula will compute the offset into memory for an array with <i>any</i> number of dimensions; however, you’ll rarely use more than four.</p>&#13;
<p class="TX">Another convenient way to think of row-major arrays is as arrays of arrays. Consider the following single-dimensional Pascal array definition</p>&#13;
<pre id="pre-312"><code>A: array [0..3] of <var>sometype</var>; </code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">sometype</span> is the type <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">sometype</span> <span class="SANS_TheSansMonoCd_W5Regular_11">= array [0..3] of char;</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">A</span> is a single-dimensional array. Its individual elements happen to be arrays, but you can safely ignore that for the time being.</p>&#13;
<p class="TX">Here is the formula to compute the address of an element in a single- dimensional array:</p>&#13;
<pre id="pre-313"><code><var>Element_Address</var> = <var>Base</var> + <var>Index</var> × <var>Element_Size</var> </code></pre>&#13;
<p class="Continued1">In this case, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Element_Size</span> happens to be 4 because each element of <span class="SANS_TheSansMonoCd_W5Regular_11">A</span> is an array of four characters. Therefore, this formula computes the base address of each row in this 4×4 array of characters (see <a href="chapter4.xhtml#fig4-5">Figure 4-5</a>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_208" aria-label="208"/>&#13;
<figure class="IMG"><img class="img7" id="fig4-5" src="../images/Figure4-5.jpg" alt="" width="785" height="707"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 4-5: Viewing a 4×4 array as an array of arrays</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Of course, once you compute the base address of a row, you can reapply the single-dimensional formula to get the address of a particular element. While this doesn’t affect the computation, it’s probably a little easier to deal with several single-dimensional computations rather than a complex multidimensional array computation.</p>&#13;
<p class="TX">Consider a Pascal array defined as follows:</p>&#13;
<pre id="pre-314"><code>A:array [0..3, 0..3, 0..3, 0..3, 0..3] of char; </code></pre>&#13;
<p class="TX">You can view this five-dimensional array as a single-dimensional array of arrays. The following Pascal code provides such a definition:</p>&#13;
<pre id="pre-315"><code>type &#13;
 OneD = array[0..3] of char; &#13;
 TwoD = array[0..3] of OneD; &#13;
 ThreeD = array[0..3] of TwoD; &#13;
 FourD = array[0..3] of ThreeD; &#13;
var &#13;
 A: array[0..3] of FourD; </code></pre>&#13;
<p class="TX">The size of <span class="SANS_TheSansMonoCd_W5Regular_11">OneD</span> is 4 bytes. Because <span class="SANS_TheSansMonoCd_W5Regular_11">TwoD</span> contains four <span class="SANS_TheSansMonoCd_W5Regular_11">OneD</span> arrays, its size is 16 bytes. Likewise, <span class="SANS_TheSansMonoCd_W5Regular_11">ThreeD</span> is four <span class="SANS_TheSansMonoCd_W5Regular_11">TwoD</span>s, so it is 64 bytes long. Finally, <span class="SANS_TheSansMonoCd_W5Regular_11">FourD</span> is four <span class="SANS_TheSansMonoCd_W5Regular_11">ThreeD</span>s, so it is 256 bytes long. To compute the address of <span class="SANS_TheSansMonoCd_W5Regular_11">A[b, c, d, e, f]</span>, you could use the following steps:</p>&#13;
<div class="top">&#13;
<p class="ListNumber">  1.  Compute the address of <span class="SANS_TheSansMonoCd_W5Regular_11">A[b]</span> as <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Base</span> <span class="SANS_TheSansMonoCd_W5Regular_11">+ b ×</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">size</span>. Here <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">size</span> is 256 bytes. Use this result as the new base address in the next computation.</p>&#13;
<p class="ListNumber">  2.  Compute the address of <span class="SANS_TheSansMonoCd_W5Regular_11">A[b, c]</span> by the formula <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Base</span> <span class="SANS_TheSansMonoCd_W5Regular_11">+ c ×</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">size</span>, where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Base</span> is the value obtained in the previous step and <span class="SANS_TheSansMonoCd_W5Regular_11">size</span> is 64. Use the result as the new base in the next computation.</p>&#13;
<p class="ListNumber">  3.  Compute the base address of <span class="SANS_TheSansMonoCd_W5Regular_11">A [b, c, d]</span> by <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Base</span> <span class="SANS_TheSansMonoCd_W5Regular_11">+ d ×</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">size</span>, where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Base</span> comes from the previous computation and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">size</span> is 16. Use the result as the new base in the next computation.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_209" aria-label="209"/>&#13;
<p class="ListNumber">  4.  Compute the address of <span class="SANS_TheSansMonoCd_W5Regular_11">A[b, c, d, e]</span> with the formula <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Base</span> <span class="SANS_TheSansMonoCd_W5Regular_11">+ e ×</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">size</span>, using <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Base</span> from the previous step and a size of 4. Use this value as the base for the next computation.</p>&#13;
<p class="ListNumber">  5.  Finally, compute the address of <span class="SANS_TheSansMonoCd_W5Regular_11">A[b, c, d, e, f]</span> by using the formula <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Base</span> <span class="SANS_TheSansMonoCd_W5Regular_11">+ f ×</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">size</span>, where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Base</span> comes from the previous computation and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">size</span> is 1 (obviously, you can ignore this final multiplication). The result you obtain at this point is the address of the desired element.</p>&#13;
</div>&#13;
<p class="TX">One of the main reasons you won’t find higher-dimensional arrays in assembly language is that assembly language emphasizes the inefficiencies associated with such access. It’s easy to enter something like <span class="SANS_TheSansMonoCd_W5Regular_11">A[b, c, d, e, f]</span> into a Pascal program, not realizing what the compiler is doing with the code. Assembly language programmers are not so cavalier—they see the mess you wind up with when you use higher-dimensional arrays. Indeed, good assembly language programmers try to avoid two-dimensional arrays and often resort to tricks in order to access data in such an array when its use becomes absolutely mandatory.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
&#13;
<h5 class="H3" id="sec28"><span class="SANS_Futura_Std_Bold_Condensed_B_11">4.7.4.2 Column-Major Ordering</span></h5>&#13;
<p class="TNI1"><i>Column-major ordering</i> is the other function HLLs frequently use to compute the address of an array element. FORTRAN and various dialects of BASIC (for example, older versions of Microsoft BASIC) use this method.</p>&#13;
<p class="TX">In row-major ordering, the rightmost index increases the fastest as you move through consecutive memory locations. In column-major ordering, the leftmost index increases the fastest. Pictorially, a column-major ordered array is organized as shown in <a href="chapter4.xhtml#fig4-6">Figure 4-6</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig4-6" src="../images/Figure4-6.jpg" alt="" width="1054" height="870"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 4-6: Column-major ordering of array elements</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_210" aria-label="210"/>The formula for computing the address of an array element when using column-major ordering is similar to that for row-major ordering. You reverse the indices and sizes in the computation.</p>&#13;
<p class="TX">For a two-dimensional column-major array:</p>&#13;
<pre id="pre-316"><code><var>Element_Address</var> = <var>Base_Address</var> +&#13;
                (<var>rowindex</var> × <var>col_size</var> + <var>colindex</var>) × <var>Element_Size</var> </code></pre>&#13;
<p class="TX">For a three-dimensional column-major array:</p>&#13;
<pre id="pre-317"><code><var>Address</var> = <var>Base</var> + ((<var>rowindex</var> × <var>col_size</var> + <var>colindex</var>) ×&#13;
        <var>depth_size</var> + <var>depthindex</var>) × <var>Element_Size</var> </code></pre>&#13;
<p class="TX">For a four-dimensional column-major array:</p>&#13;
<pre id="pre-318"><code><var>Address</var> =&#13;
    <var>Base</var> + (((<var>rowindex</var> × <var>col_size</var> + <var>colindex</var>) × <var>depth_size</var> +&#13;
      <var>depthindex</var>) × <var>Left_size</var> + <var>Leftindex</var>) × <var>Element_Size</var> </code></pre>&#13;
<p class="TX">The formulas for higher-dimension arrays progress in a like fashion.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
&#13;
<h5 class="H3" id="sec29"><span class="SANS_Futura_Std_Bold_Condensed_B_11">4.7.4.3 Storage Allocation for Multidimensional Arrays</span></h5>&#13;
<p class="TNI1">If you have an <i>m</i>×<i>n</i> array, it will have <i>m</i> × <i>n</i> elements and require <i>m</i> × <i>n</i> × <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Element_Size</span> bytes of storage. To allocate storage for an array, you must reserve this memory. As usual, you can accomplish this task in several ways. The most common way to declare a multidimensional array in Gas is to use the <span class="SANS_TheSansMonoCd_W5Regular_11">.space</span> directive:</p>&#13;
<pre id="pre-319"><code><var>ArrayName</var>: .space <var>size</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> * <var>size</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span> * <var>size</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">3</span> * ... * <var>size</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">n</span> * (<var>Element_Size</var>) </code></pre>&#13;
<p class="Continued1">Here, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">size</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> to <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">size</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">n</span> are the sizes of each of the dimensions of the array, and <span class="SANS_TheSansMonoCd_W5Regular_11">(</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Element_Size</span><span class="SANS_TheSansMonoCd_W5Regular_11">)</span> is the size (in bytes) of a single element. I recommend putting parentheses around the <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Element_Size</span> component of this expression to emphasize that it is not another dimension in the multidimensional array.</p>&#13;
<p class="TX">For example, here is a declaration for a 4×4 array of characters:</p>&#13;
<pre id="pre-320"><code>GameGrid: .space 4 * 4 // <var>Element_Size</var> is 1. </code></pre>&#13;
<p class="TX">Here is another example that shows how to declare a three-dimensional array of strings (assuming the array holds 64-bit pointers to the strings):</p>&#13;
<pre id="pre-321"><code>NameItems: .space 2 * 3 * 3 * (8)  // dword NameItems[2, 3, 3] </code></pre>&#13;
<p class="TX">As with single-dimensional arrays, you may initialize every element of the array to a specific value by following the declaration with the values of the array constant. Array constants ignore dimension information; all that matters is that the number of elements in the array constant corresponds to the number of elements in the actual array. The following example shows the <span class="SANS_TheSansMonoCd_W5Regular_11">GameGrid</span> declaration with an initializer:</p>&#13;
<pre id="pre-322"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_211" aria-label="211"/>GameGrid: .byte 'a', 'b', 'c', 'd' &#13;
          .byte 'e', 'f', 'g', 'h' &#13;
          .byte 'i', 'j', 'k', 'l' &#13;
          .byte 'm', 'n', 'o', 'p' </code></pre>&#13;
<p class="TX">This example was laid out to enhance readability. Gas does not interpret the four separate lines as representing rows of data in the array; humans do, which is why it’s good to write the data in this manner. If you have a large array, an array with really large rows, or an array with many dimensions, there is little hope for winding up with something readable; in this case, comments that carefully explain everything come in handy.</p>&#13;
<p class="TX">The use of a constant expression to compute the number of array elements rather than simply using the constant 16 (4 × 4) more clearly suggests that this code is initializing each element of a 4×4 element array than does the simple literal constant 16.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
&#13;
<h5 class="H3" id="sec30"><span class="SANS_Futura_Std_Bold_Condensed_B_11">4.7.4.4 How to Access Elements of Multidimensional Arrays</span></h5>&#13;
<p class="TNI1">To access elements of a multidimensional array, you’ll need to be able to multiply two values; this is done using the <span class="SANS_TheSansMonoCd_W5Regular_11">mul</span> (multiply) and <span class="SANS_TheSansMonoCd_W5Regular_11">madd</span> (multiply and add) instructions.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">mul</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">madd</span> instructions have the following syntax</p>&#13;
<pre id="pre-323"><code>mul  <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">d</span><var>, reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span><var>, reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">r</span><var>        </var>// <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">d</span> = <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">l</span> * <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">r</span> &#13;
madd <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">d</span><var>, reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">l</span><var>, reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">r</span><var>, reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">a  </span> // <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">d</span> = <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">l</span> * <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">r</span> + <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">a</span> </code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">d</span> is the destination register (32 or 64 bits), <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">l</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">r</span> are source registers (left- and right-hand operands), and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">reg</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">a</span> is a third source operand. These instructions perform the calculations described in the comments.</p>&#13;
<p class="TX">These instructions do not have a form with an <span class="SANS_TheSansMonoCd_W5Regular_11">s</span> suffix and therefore do not update the flags after their execution. An <i>n</i>-bit × <i>n</i>-bit multiplication can produce a 2 × <i>n</i> bit result; however, these instructions maintain only <i>n</i> bits in the destination register. Any overflow is lost. Sadly, these instructions do not allow immediate operands, though this would be useful.</p>&#13;
<p class="TX">The multiply instruction has several other variants that are used for other purposes. These are covered in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>.</p>&#13;
<p class="TX">Now that you’ve seen the formulas for computing the address of a multidimensional array element, it’s time to see how to access elements of those arrays with assembly language. The <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">lsl</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">mul</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">madd</span> instructions make short work of the various equations that compute offsets into multidimensional arrays. First, consider a two-dimensional array:</p>&#13;
<pre id="pre-324"><code>         .data &#13;
i:       .word  .-. &#13;
j:       .word  .-. &#13;
TwoD:    .word  4 * 8  * (4) &#13;
           . &#13;
           . &#13;
           . &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_212" aria-label="212"/>// To perform the operation TwoD[i,j] := 5; &#13;
// you'd use code like the following. &#13;
// Note that the array index computation is (i * 4 + j) * 4. &#13;
&#13;
         lea x0, i &#13;
         ldr w0, [x0]    // Clears HO bits of X0 &#13;
         lsl x0, x0, #2  // Multiply i by 4. &#13;
         lea x1, j &#13;
         ldr w1, [x1] &#13;
         add w0, w0, w1  // W0 = i * 4 + j &#13;
         lea x1, TwoD    // X1 = base &#13;
         mov w2, #5      // [TwoD + (i * 4 + j) * 4] = 5 &#13;
         str w2, [x1, x0, lsl #2] // Scaled by 4 (element size) </code></pre>&#13;
<p class="TX">Now consider a second example that uses a three-dimensional array:</p>&#13;
<pre id="pre-325"><code>        .data &#13;
i:      .word  .-. &#13;
j:      .word  .-. &#13;
k:      .word  .-. &#13;
ThreeD: .space 3 * 4 * 5 * (4) // word ThreeD[3, 4, 5] &#13;
          . &#13;
          . &#13;
          . &#13;
// To perform the operation ThreeD[i,j,k] := W7; &#13;
// you'd use the following code that computes &#13;
// ((i * 4 + j) * 5 + k) * 4 as the address of ThreeD[i,j,k]. &#13;
&#13;
          lea  x0, i &#13;
          ldr  w0, [x0] &#13;
          lsl  w0, w0, #2  // Four elements per column &#13;
          lea  x1, j       // Add in j. &#13;
          ldr  w1, [x1] &#13;
          add  w0, w0, w1 &#13;
          mov  w1, #5      // Five elements per row &#13;
          lea  x2, k &#13;
          ldr  w2, [x2] &#13;
          madd w0, w0, w1, w2 // ((i * 4 + j) * 5 + k) &#13;
          lea  x1, ThreeD &#13;
          str  w7, [x1, w0, uxtw #2] // ThreeD[i,j,k] = W7 </code></pre>&#13;
<p class="TX">This code uses the <span class="SANS_TheSansMonoCd_W5Regular_11">madd</span> instruction to multiply the value in W0 by 5 and add in the <span class="SANS_TheSansMonoCd_W5Regular_11">k</span> index at the same time. Because the <span class="SANS_TheSansMonoCd_W5Regular_11">lsl</span> instruction can multiply a register by only a power of 2, we must resort to a multiplication here. While there are ways to multiply the value in a register by a constant other than a power of 2, the <span class="SANS_TheSansMonoCd_W5Regular_11">madd</span> instruction is more convenient, especially as it handles an addition operation at the same time.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec31">&#13;
&#13;
<h3 class="H1" id="sec31"><span id="h1-61"/><span class="SANS_Futura_Std_Bold_B_11">4.8 Structs</span></h3>&#13;
<p class="TNI1">Another major composite data structure is the Pascal <i>record</i> or C/C++/C# <i>struct</i>. The Pascal terminology is probably better, because it tends to avoid confusion with the more general term <i>data structure</i>. However, this book <span role="doc-pagebreak" epub:type="pagebreak" id="pg_213" aria-label="213"/>uses the term <i>struct</i>, as C-based languages are more commonly used these days. (Records and structures also go by other names in other languages, but most people recognize at least one of these names.)</p>&#13;
<p class="TX">Whereas an array is homogeneous, with elements that are all the same type, the elements in a struct can have different types. Arrays let you select a particular element via an integer index. With structs, you must select an element, known as a <i>field,</i> by offset (from the beginning of the struct).</p>&#13;
<p class="TX">The whole purpose of a struct is to let you encapsulate different, though logically related, data into a single package. The Pascal record declaration for a hypothetical student is a typical example:</p>&#13;
<pre id="pre-326"><code>student =&#13;
     record &#13;
          sName:    string[64]; &#13;
          Major:    integer; &#13;
          SSN:      string[11]; &#13;
          Midterm1: integer; &#13;
          Midterm2: integer; &#13;
          Final:    integer; &#13;
          Homework: integer; &#13;
          Projects: integer; &#13;
     end; </code></pre>&#13;
<p class="TX">Most Pascal compilers allocate each field in a record to contiguous memory locations. This means that Pascal will reserve the first 65 bytes for the name, the next 2 bytes hold the <span class="SANS_TheSansMonoCd_W5Regular_11">Major</span> code (assuming a 16-bit integer), the next 12 bytes hold the Social Security number, and so on. (Strings require an extra byte, in addition to all the characters in the string, to encode the length.) The <span class="SANS_TheSansMonoCd_W5Regular_11">John</span> variable declaration allocates 89 bytes of storage laid out in memory, as shown in <a href="chapter4.xhtml#fig4-7">Figure 4-7</a> (assuming no padding or alignment of fields).</p>&#13;
<figure class="IMG"><img class="img1" id="fig4-7" src="../images/Figure4-7.jpg" alt="" width="1228" height="303"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 4-7: Student data structure in memory</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If the label <span class="SANS_TheSansMonoCd_W5Regular_11">John</span> corresponds to the base address of this record, the <span class="SANS_TheSansMonoCd_W5Regular_11">sName</span> field is at offset <span class="SANS_TheSansMonoCd_W5Regular_11">John + 0</span>, the <span class="SANS_TheSansMonoCd_W5Regular_11">Major</span> field is at offset <span class="SANS_TheSansMonoCd_W5Regular_11">John + 65</span>, the <span class="SANS_TheSansMonoCd_W5Regular_11">SSN</span> field is at offset <span class="SANS_TheSansMonoCd_W5Regular_11">John + 67</span>, and so on. In assembly language, if X0 holds the base address of the <span class="SANS_TheSansMonoCd_W5Regular_11">John</span> structure, you could access the <span class="SANS_TheSansMonoCd_W5Regular_11">Major</span> field by using the following instruction:</p>&#13;
<pre id="pre-327"><code>ldrh  w0, [x0, #65] </code></pre>&#13;
<p class="TX">This loads W0 with the 16-bit value at the address specified by <span class="SANS_TheSansMonoCd_W5Regular_11">John + 65</span>.</p>&#13;
<section epub:type="division" aria-labelledby="sec32">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_214" aria-label="214"/>&#13;
<h4 class="H2" id="sec32"><span id="h2-87"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">4.8.1 Dealing with Limited Gas Support for Structs</span></h4>&#13;
<p class="TNI1">Unfortunately, Gas provides only the smallest amount of support for structures via the <span class="SANS_TheSansMonoCd_W5Regular_11">.struct</span> directive (see <span class="Xref">“Linux</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.struct</span> <span class="Xref">Directive”</span> on <span class="Xref"><a href="chapter4.xhtml#pg_217">page 217</a></span>). Even more unfortunately, the macOS assembler doesn’t support <span class="SANS_TheSansMonoCd_W5Regular_11">.struct</span>.</p>&#13;
<p class="TX">To use structures under macOS and Linux together, you’ll need a way to specify the offsets to all the fields of a structure for use in the register indirect-plus-offset addressing mode (such as in the last example line of the previous section). In theory, you could manually use equates to define all the offsets:</p>&#13;
<pre id="pre-328"><code>.equ sName, 0 &#13;
.equ Major, 65 &#13;
.equ SSN, 67 &#13;
.equ Mid1, 79 &#13;
.equ Mid2, 81 &#13;
.equ Final, 83 &#13;
.equ Homework, 85 &#13;
.equ Projects, 87 </code></pre>&#13;
<p class="TX">However, this is an absolutely horrible, error-prone, and difficult-to-maintain approach. The ideal method would be to supply a structure name (the type name) and a list of the field names and their types. From this, you’d aim to get offsets for all the fields, plus the size of the entire structure (which you can use with the <span class="SANS_TheSansMonoCd_W5Regular_11">.space</span> directive to allocate storage for the structure).</p>&#13;
<p class="TX">The <i>aoaa.inc</i> include file contains several macro definitions that can help you declare and use structures in your assembly language source files. These macros aren’t amazingly robust, but when used carefully, they get the job done. <a href="chapter4.xhtml#tab4-1">Table 4-1</a> lists these macros and their arguments. Field names must be unique throughout the program, not just in the structure definition. Also note that the <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">ends</span> macros do not support nesting.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_215" aria-label="215"/>&#13;
&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab4-1"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 4-1:</span></span> <span class="SANS_Futura_Std_Book_11">The</span> <span class="SANS_Futura_Std_Book_Oblique_11">aoaa.inc</span> <span class="SANS_Futura_Std_Book_11">Macros for Defining Structures</span></p>&#13;
</caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Macro</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Argument(s)</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">struct</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">name</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">offset</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Begin a structure definition. The offset field is optional and can be either a (small) negative number or 0. The default (and most commonly used) value is 0.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ends</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">name</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Ends a structure definition. The</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">name</span> <span class="SANS_Futura_Std_Book_11">argument must match the name supplied in the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span> <span class="SANS_Futura_Std_Book_11">invocation.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">byte</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">name</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">elements</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Create a field of type byte.</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">name</span> <span class="SANS_Futura_Std_Book_11">is the unique field name.</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">elements</span> <span class="SANS_Futura_Std_Book_11">is optional (default value is 1) and specifies the number of array elements.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">hword</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">name</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">elements</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Create a field of type hword.</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">name</span> <span class="SANS_Futura_Std_Book_11">is the (unique) field name.</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">elements</span> <span class="SANS_Futura_Std_Book_11">is optional (default value is 1) and specifies the number of array elements.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">word</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">name</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">elements</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Create a field of type word.</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">name</span> <span class="SANS_Futura_Std_Book_11">is the unique field name.</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">elements</span> <span class="SANS_Futura_Std_Book_11">is optional (default value is 1) and specifies the number of array elements.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">dword</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">name</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">elements</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Create a field of type dword.</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">name</span> <span class="SANS_Futura_Std_Book_11">is the unique field name.</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">elements</span> <span class="SANS_Futura_Std_Book_11">is optional (default value is 1) and specifies the number of array elements.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">qword</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">name</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">elements</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Create a field of type qword.</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">name</span> <span class="SANS_Futura_Std_Book_11">is the unique field name.</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">elements</span> <span class="SANS_Futura_Std_Book_11">is optional (default value is 1) and specifies the number of array elements.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">single</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">name</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">elements</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Create a field of type single.</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">name</span> <span class="SANS_Futura_Std_Book_11">is the unique field name.</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">elements</span> <span class="SANS_Futura_Std_Book_11">is optional (default value is 1) and specifies the number of array elements.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">double</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">name</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">elements</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Create a field of type double.</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">name</span> <span class="SANS_Futura_Std_Book_11">is the unique field name.</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">elements</span> <span class="SANS_Futura_Std_Book_11">is optional (default value is 1) and specifies the number of array elements.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">For strings, you’d specify either a <span class="SANS_TheSansMonoCd_W5Regular_11">dword</span> field (to hold a pointer to the field) or a <span class="SANS_TheSansMonoCd_W5Regular_11">byte</span> field with a sufficient number of elements to hold all the characters in the string.</p>&#13;
<p class="TX">The student example from the previous section could be encoded as follows:</p>&#13;
<pre id="pre-329"><code>struct student &#13;
    byte  sName, 65 // Includes zero-terminating byte &#13;
    hword Major &#13;
    byte  SSN, 12   // Includes zero-terminating byte &#13;
    hword Midterm1 &#13;
    hword Midterm2 &#13;
    hword Final &#13;
    hword Homework &#13;
    hword Projects &#13;
ends student </code></pre>&#13;
<p class="TX">You would declare a variable of type <span class="SANS_TheSansMonoCd_W5Regular_11">student</span> like this:</p>&#13;
<pre id="pre-330"><code>student John </code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">ends</span> macro automatically generates a macro with the same name as the structure name, so you can use that like a directive to allocate sufficient space to hold an instance of the structure type.</p>&#13;
<p class="TX">You could access fields of <span class="SANS_TheSansMonoCd_W5Regular_11">John</span> as follows:</p>&#13;
<pre id="pre-331"><code>lea  x0, John &#13;
ldrh w1, [x0, #Midterm1] &#13;
ldrh w2, [x0, #Midterm2] &#13;
ldrh w3, [x0, #Final]   // And so on ... </code></pre>&#13;
<p class="TX">This macro package has a couple of issues. First of all, the field names must be unique throughout the assembly language source file (unlike standard structures, where the field names are local to the structure itself). As a result, these structures tend to suffer from <i>namespace pollution</i>, which happens when you try to reuse some of the field names for other purposes. For example, <span class="SANS_TheSansMonoCd_W5Regular_11">sName</span> will likely be used again elsewhere in the source file, since it’s a common identifier. A quick-and-dirty solution to this problem is to always prefix the field names with the structure name and a period. For example:</p>&#13;
<pre id="pre-332"><code>struct student &#13;
    byte  student.sName, 65 &#13;
    hword student.Major &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_216" aria-label="216"/>    byte  student.SSN, 12 &#13;
    hword student.Midterm1 &#13;
    hword student.Midterm2 &#13;
    hword student.Final &#13;
    hword student.Homework &#13;
    hword student.Projects &#13;
ends student </code></pre>&#13;
<p class="Continued1">This requires a bit more typing, but it resolves the namespace pollution issue most of the time.</p>&#13;
<p class="TX">Consider the <span class="SANS_TheSansMonoCd_W5Regular_11">student John</span> macro invocation/declaration given in this section. This macro expands into</p>&#13;
<pre id="pre-333"><code>John:  .fill student.size </code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_11">student.size</span> is an extra field that the <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span> macro generates, specifying the total size of the structure (in bytes).</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span> macro accepts a second (optional) parameter: the <i>starting offset</i> for fields in the structure. By default, this is 0. If you supply a negative number here, the directive/macro that <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span> generates works a little differently. Consider the following structure definition:</p>&#13;
<pre id="pre-334"><code>struct HLAstring, -4 &#13;
word   HLAstring.len &#13;
byte   HLAstring.chars, 256 &#13;
ends   HLAstring </code></pre>&#13;
<p class="Continued1">HLA strings are actually a bit different from the structure provided here, but this does serve as a good example of negative starting offsets.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">HLAstring</span> macro that <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span> generates does the following:</p>&#13;
<pre id="pre-335"><code>            HLAstring myString &#13;
         // Expands to &#13;
           .fill      4 &#13;
myString:  .fill      256 </code></pre>&#13;
<p class="TX">This expansion places the <span class="SANS_TheSansMonoCd_W5Regular_11">myString</span> label after the first 4 bytes of the beginning of the structure. This is because the <span class="SANS_TheSansMonoCd_W5Regular_11">HLAstring.len</span> field’s offset is –4, meaning that the length field starts 4 bytes before the base address of the structure (and the structure variable’s name is always associated with the base address). You’ll see some important uses for this feature in the next chapter.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span> macro does not allow positive offsets (values greater than 0). It will generate an error at assembly time if you specify a positive value.</p>&#13;
<aside class="box" aria-label="box-18">&#13;
<p class="BH" id="box-18"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_217" aria-label="217"/><span class="SANS_Dogma_OT_Bold_B_11">LINUX .STRUCT DIRECTIVE</span></p>&#13;
<p class="BTNI"><span class="SANS_Futura_Std_Book_11">The Gas</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.struct</span> <span class="SANS_Futura_Std_Book_11">directive (available only under Linux) doesn’t begin a structure definition in the sense of an HLL like C/C++. Instead, it begins a new section (similar to</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span><span class="SANS_Futura_Std_Book_11">, or</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.section</span><span class="SANS_Futura_Std_Book_11">). However, rather than creating a memory section that can be relocated in memory when the OS loads the program, the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.struct</span> <span class="SANS_Futura_Std_Book_11">section is an absolute section located in memory at the address specified by</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">constExpression</span><span class="SANS_Futura_Std_Book_11">. Furthermore, this is a phantom section, insofar as Gas doesn’t actually write any data to the object file in response to this directive;</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.struct</span> <span class="SANS_Futura_Std_Book_11">exists only for the purpose of associating offsets with symbols created within the section.</span></p>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_11">Consider the following simple example:</span></p>&#13;
<pre id="pre-336"><code>        .struct     0 &#13;
f1:     .byte       0 &#13;
f2:     .hword      0 &#13;
f3:     .word       0 &#13;
f4:     .dword      0 &#13;
size    =           . </code></pre>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_11">During assembly, Gas will set the location counter of the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.struct</span> <span class="SANS_Futura_Std_Book_11">section to 0 (because of the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">0</span> <span class="SANS_Futura_Std_Book_11">operand after</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.struct</span><span class="SANS_Futura_Std_Book_11">). Therefore, symbol</span> <span class="SANS_TheSansMonoCd_W5Regular_11">f1</span> <span class="SANS_Futura_Std_Book_11">will have the offset 0 associated with it, as it is the first symbol defined in the section. Because</span> <span class="SANS_TheSansMonoCd_W5Regular_11">f1</span> <span class="SANS_Futura_Std_Book_11">is a byte (and consumes 1 byte of memory), the location counter advances to 1 when Gas encounters symbol</span> <span class="SANS_TheSansMonoCd_W5Regular_11">f2</span><span class="SANS_Futura_Std_Book_11">. Therefore,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">f2</span> <span class="SANS_Futura_Std_Book_11">has the offset 2 associated with it. Similarly,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">f3</span> <span class="SANS_Futura_Std_Book_11">has the offset 3, and</span> <span class="SANS_TheSansMonoCd_W5Regular_11">f4</span> <span class="SANS_Futura_Std_Book_11">has the offset 7 (the offsets are the sums of the sizes of all the prior objects in the section). The symbol size is given the value of the location counter at the end of the sequence, so it has the value 15.</span></p>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_11">You can use the symbol names defined in a</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.struct</span> <span class="SANS_Futura_Std_Book_11">section as offsets in an address expression. For example, if you’ve defined the structure object</span> <span class="SANS_TheSansMonoCd_W5Regular_11">s1</span> <span class="SANS_Futura_Std_Book_11">as</span> <span class="SANS_TheSansMonoCd_W5Regular_11">s1: .space size</span><span class="SANS_Futura_Std_Book_11">, you can access the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">f3</span> <span class="SANS_Futura_Std_Book_11">field of</span> <span class="SANS_TheSansMonoCd_W5Regular_11">s1</span> <span class="SANS_Futura_Std_Book_11">as follows</span></p>&#13;
<pre id="pre-337"><code>lea x0, s1 &#13;
ldr w0, [x0, #f1] </code></pre>&#13;
<p class="BoxBodyContinued"><span class="SANS_Futura_Std_Book_11">where</span> <span class="SANS_TheSansMonoCd_W5Regular_11">#f1</span> <span class="SANS_Futura_Std_Book_11">is the offset into the struct from its base address (held in X0).</span></p>&#13;
</aside>&#13;
<p class="TX">One issue with the <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span> macro is that it doesn’t provide a way to initialize the fields of the structure. To learn how to do that, keep reading.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec33">&#13;
&#13;
<h4 class="H2" id="sec33"><span id="h2-88"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">4.8.2 Initializing Structs</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span> macro definitions do not provide any way to initialize the fields of a structure at compile time. You’ll have to either assign the values at <span role="doc-pagebreak" epub:type="pagebreak" id="pg_218" aria-label="218"/>runtime or manually build up the structure variable by using Gas directives. For example:</p>&#13;
<pre id="pre-338"><code>John:    .asciz  "John Somebody"   // sName &#13;
         .space  65 - (.-John)     // Must be 65 bytes long! &#13;
         .hword  0                 // Major &#13;
         .asciz  "123-45-6578"     // SSN-Exactly 12 bytes long &#13;
         .hword  75                // Midterm1 &#13;
         .hword  82                // Midterm2 &#13;
         .hword  90                // Final &#13;
         .hword  72                // Homework &#13;
         .hword  80                // Projects </code></pre>&#13;
<p class="Continued1">This initializes the fields of the structure to the corresponding values.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec34">&#13;
&#13;
<h4 class="H2" id="sec34"><span id="h2-89"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">4.8.3 Creating Arrays of Structs</span></h4>&#13;
<p class="TNI1">A common pattern in program design is to create an array of structures. To do so, create a <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span> type and multiply its size by the number of array elements when declaring the array variable, as shown in the following example:</p>&#13;
<pre id="pre-339"><code>numStudents = 30 &#13;
   . &#13;
   . &#13;
   . &#13;
Class:  .fill student.size * numStudents </code></pre>&#13;
<p class="TX">To access an element of this array, use the standard array-indexing techniques. Because <span class="SANS_TheSansMonoCd_W5Regular_11">class</span> is a single-dimensional array, you’d compute the address of an element of this array by using the formula <span class="SANS_TheSansMonoCd_W5Regular_11">baseAddress + index × student.size</span>. For example, to access an element of <span class="SANS_TheSansMonoCd_W5Regular_11">class</span>, you’d use code like the following:</p>&#13;
<pre id="pre-340"><code>// Access field Final, of element i of class: &#13;
// X1 := i * student.size + offset Final &#13;
&#13;
    lea  x1, i &#13;
    ldr  x1, [x1] &#13;
    mov  x2, #student.size &#13;
    mov  x3, #student.Final &#13;
    madd x1, x1, x2, x3   // Include offset to field. &#13;
    lea  x2, class &#13;
    ldrh w0, [x2, x1]     // Accesses class[i].Final </code></pre>&#13;
<p class="TX">You must sum in the offset to the field you want to access. Sadly, the scaled-indexed addressing mode doesn’t include an offset component as part of the addressing mode, but <span class="SANS_TheSansMonoCd_W5Regular_11">madd</span> saves us an instruction by working in this addition as part of the multiplication.</p>&#13;
<p class="TX">Naturally, you can create multidimensional arrays of structs as well, using the row-major or column-major order functions to compute the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_219" aria-label="219"/>address of an element within such structs. The only real change is that the size of each element is the size of the struct object:</p>&#13;
<pre id="pre-341"><code>        .data &#13;
&#13;
numStudents = 30 &#13;
numClasses  = 2 &#13;
&#13;
// student Instructor[numClasses][numStudents] &#13;
&#13;
Instructor:   .fill  numStudents * numClasses * (student.size) &#13;
whichClass:   .dword 1 &#13;
whichStudent: .dword 10 &#13;
          . &#13;
          . &#13;
          . &#13;
// Access element [whichClass,whichStudent] of class &#13;
// and load Major into W0: &#13;
&#13;
     lea  x0, whichClass &#13;
     ldr  x1, [x0] &#13;
     mov  x2, #numStudents    // X1 = whichClass * numStudents &#13;
     mul  x1, x1, x2 &#13;
     lea  x0, whichStudent &#13;
     ldr  x2, [x0]            // X1 = (whichClass * numStudents +&#13;
     add  x1, x1, x2          //  numStudents) &#13;
     mov  x2, #student.size   //   * sizeStudent + offset Major &#13;
     mov  x3, #Major &#13;
     madd x1, x1, x2, x3 &#13;
&#13;
     lea  x0, Instructor // W0 =  Instructor[whichClass] &#13;
     ldrh w0, [x0, x1]   //         [whichStudent].Major </code></pre>&#13;
<p class="Continued1">This demonstrates how to access fields of an array of structs.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec35">&#13;
&#13;
<h4 class="H2" id="sec35"><span id="h2-90"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">4.8.4 Aligning Fields Within a Struct</span></h4>&#13;
<p class="TNI1">To achieve maximum performance in your programs, or to ensure that Gas structures properly map to records or structures in an HLL, you will often need to be able to control the alignment of fields within a struct. For example, you might want to ensure that a double-word field’s offset is a multiple of 4. You can use the <span class="SANS_TheSansMonoCd_W5Regular_11">salign</span> macro to do this. The following creates a structure with aligned fields:</p>&#13;
<pre id="pre-342"><code>struct tst &#13;
byte bb &#13;
salign 2   // Aligns offset to next 4-byte boundary &#13;
byte c &#13;
ends tst </code></pre>&#13;
<p class="TX">As for the <span class="SANS_TheSansMonoCd_W5Regular_11">.align</span> directive, the <span class="SANS_TheSansMonoCd_W5Regular_11">salign</span> macro aligns the structure’s offset to 2<i><sup>n</sup></i>, where <i>n</i> is the value specified as the <span class="SANS_TheSansMonoCd_W5Regular_11">salign</span> argument. In this example, <span class="SANS_TheSansMonoCd_W5Regular_11">c</span>’s offset is set to 4 (the macro rounds up the field offset from 1 to 4).</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_220" aria-label="220"/>Field alignment is up to you when you’re creating your own structure variables. However, if you’re linking with code written in an HLL that uses structures, you’ll need to determine field alignment for that particular language. Most modern HLLs use <i>natural alignment</i>: fields are aligned on a boundary that is the size of that field (or an element of that field). The structure itself is aligned at an address rounded to the size of the largest object in the structure. See section 4.11, <span class="Xref">“For More Information,”</span> on <span class="Xref"><a href="chapter4.xhtml#pg_221">page 221</a></span> for appropriate links.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec36">&#13;
&#13;
<h3 class="H1" id="sec36"><span id="h1-62"/><span class="SANS_Futura_Std_Bold_B_11">4.9 Unions</span></h3>&#13;
<p class="TNI1"><i>Unions</i> (in an HLL like C/C++) are similar to structures insofar as they create an aggregate data type containing several fields. Unlike structures, however, the fields of a union all occupy the same offset in the data structure.</p>&#13;
<p class="TX">Programmers typically use unions for one of two reasons: to conserve memory or to create aliases. Memory conservation is the intended use of this data structure facility. To see how this works, consider the following struct type:</p>&#13;
<pre id="pre-343"><code>struct numericRec &#13;
       word  i &#13;
       word  u &#13;
       dword q &#13;
ends   numericRec </code></pre>&#13;
<p class="TX">If you declare a variable, say <span class="SANS_TheSansMonoCd_W5Regular_11">n</span>, of type <span class="SANS_TheSansMonoCd_W5Regular_11">numericRec</span>, you access the fields as <span class="SANS_TheSansMonoCd_W5Regular_11">n.i</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">n.u</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">n.q</span>. A struct assigns different offsets to each field, effectively allocating separate storage to each field. A union, on the other hand, assigns the same offset (typically 0) to each of these fields, allocating the same storage to each.</p>&#13;
<p class="TX">For <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span>, then, <span class="SANS_TheSansMonoCd_W5Regular_11">numericRec.size</span> is 16 because the struct contains two word fields and a double-word field. The size of the corresponding <span class="SANS_TheSansMonoCd_W5Regular_11">union</span>, however, would be 8. This is because all the fields of a union occupy the same memory locations, and the size of a union object is the size of the largest field of that object (see <a href="chapter4.xhtml#fig4-8">Figure 4-8</a>).</p>&#13;
<figure class="IMG"><img class="img1" id="fig4-8" src="../images/Figure4-8.jpg" alt="" width="1161" height="568"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 4-8: The layout of a union versus a structure variable</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_221" aria-label="221"/>Programs use unions for several purposes: preserving memory, overlaying data types, and creating <i>variant types</i> (dynamically typed values whose type can change during execution). Because you probably won’t use unions that often in an assembly language program, I’ve not bothered creating a union macro in the <i>aoaa.inc</i> include file. However, if you really need a union macro, you could take the information in <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span> and the source code to the <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span> macro in <i>aoaa.inc</i> and write your own.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec37">&#13;
&#13;
<h3 class="H1" id="sec37"><span id="h1-63"/><span class="SANS_Futura_Std_Bold_B_11">4.10 Moving On</span></h3>&#13;
<p class="TNI1">This chapter concludes the machine organization component of this book, which dealt with the organization of memory, constants, data, and data types. It discussed memory variables and data types, arrays, row-major and column-major ordering, structs and unions, and strings, including zero-terminated, length-prefixed, and descriptor-based strings. It also covered issues you may encounter when using pointers, including uninitialized pointers, illegal pointer values, dangling pointers, memory leaks, and type-unsafe access.</p>&#13;
<p class="TX">Now it’s time to begin studying assembly language <i>programming</i> in earnest. The next section of the book will begin discussing procedures and functions (<span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>), arithmetic (<span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>), low-level control structures (<span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>), and advanced arithmetic (<span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec38">&#13;
&#13;
<h3 class="H1" id="sec38"><span id="h1-64"/><span class="SANS_Futura_Std_Bold_B_11">4.11 For More Information</span></h3>&#13;
<ul class="ul">&#13;
<li class="BL">For additional information about data structure representation in memory, consider reading my book <i>Write Great Code</i>, Volume 1, 2nd edition (No Starch Press, 2020). For an in-depth discussion of data types, consult a textbook on data structures and algorithms such as <i>Introduction to Algorithms</i>, 3rd edition (MIT Press, 2009), by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein.</li>&#13;
<li class="BL">You can find information about the GNU assembler (including the <span class="SANS_TheSansMonoCd_W5Regular_11">.struct</span> directive) in the manual at <i><a href="https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_chapter/as_toc.html">https://<wbr/>ftp<wbr/>.gnu<wbr/>.org<wbr/>/old<wbr/>-gnu<wbr/>/Manuals<wbr/>/gas<wbr/>-2<wbr/>.9<wbr/>.1<wbr/>/html<wbr/>_chapter<wbr/>/as<wbr/>_toc<wbr/>.html</a></i>.</li>&#13;
<li class="BL">As noted in <span class="listplain_Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, you can find more information about ARM CPUs at the developer website at <i><a href="https://developer.arm.com">https://<wbr/>developer<wbr/>.arm<wbr/>.com</a></i>. To learn more about field alignment in particular, see <i><a href="https://developer.arm.com/documentation/dui0491/i/C-and-C---Implementation-Details/Structures--unions--enumerations--and-bitfields?lang=en">https://<wbr/>developer<wbr/>.arm<wbr/>.com<wbr/>/documentation<wbr/>/dui0491<wbr/>/i<wbr/>/C<wbr/>-and<wbr/>-C<wbr/>-<wbr/>-<wbr/>-Implementation<wbr/>-Details<wbr/>/Structures<wbr/>-<wbr/>-unions<wbr/>-<wbr/>-enumerations<wbr/>-<wbr/>-and<wbr/>-bitfields<wbr/>?lang<wbr/>=en</a></i>.</li>&#13;
<li class="BL">For more on dangling pointers, see <i><a href="https://en.wikipedia.org/wiki/Dangling_pointer">https://<wbr/>en<wbr/>.wikipedia<wbr/>.org<wbr/>/wiki<wbr/>/Dangling<wbr/>_pointer</a></i>.</li>&#13;
<li class="BL">For more on the High-Level Assembler, see the online resources at my website, <i><a href="https://www.randallhyde.com/AssemblyLanguage/HighLevelAsm/">https://<wbr/>www<wbr/>.randallhyde<wbr/>.com<wbr/>/AssemblyLanguage<wbr/>/HighLevelAsm<wbr/>/</a></i>.</li>&#13;
</ul>&#13;
<aside class="box" aria-label="box-19">&#13;
<p class="BH" id="box-19"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_222" aria-label="222"/><span class="SANS_Dogma_OT_Bold_B_11">TEST YOURSELF</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  1.  What is a manifest constant?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  2.  Which directive(s) would you use to create a manifest constant?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  3.  What is a constant expression, and how would you determine the number of data elements in the operand field of a byte directive?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  4.  What is the location counter?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  5.  What operator returns the current location counter?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  6.  How would you compute the number of bytes between two declarations in the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> <span class="SANS_Futura_Std_Book_11">section?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  7.  What is a pointer and how is it implemented?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  8.  How do you dereference a pointer in assembly language?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  9.  How do you declare pointer variables in assembly language?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">10.  What are the five common problems encountered when using pointers in a program?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">11.  What is a dangling pointer?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">12.  What is a memory leak?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">13.  What is a composite data type?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">14.  What is a zero-terminated string?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">15.  What is a length-prefixed string?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">16.  What is a descriptor-based string?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">17.  What is an array?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">18.  What is the base address of an array?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">19.  Provide an example of an array declaration.</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">20.  Describe how to create an array whose elements you initialize at assembly time.</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">21.  What is the formula for accessing elements of a:</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">a. Single-dimensional array</span> <span class="SANS_TheSansMonoCd_W5Regular_11">dword A[10]</span><span class="SANS_Futura_Std_Book_11">?</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">b. Two-dimensional array</span> <span class="SANS_TheSansMonoCd_W5Regular_11">word W[4, 8]</span><span class="SANS_Futura_Std_Book_11">?</span></p>&#13;
<p class="BoxListLetterSubl"><span class="SANS_Futura_Std_Book_11">c. Three-dimensional array</span> <span class="SANS_TheSansMonoCd_W5Regular_11">double R[2, 4, 6]</span><span class="SANS_Futura_Std_Book_11">?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">22.  What is row-major order?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">23.  What is column-major order?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">24.  Provide an example of a two-dimensional array declaration (word array</span> <span class="SANS_TheSansMonoCd_W5Regular_11">W[4, 8]</span><span class="SANS_Futura_Std_Book_11">).</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">25.  What is a struct (record)?</span></p>&#13;
<p class="BoxListNumber"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_223" aria-label="223"/><span class="SANS_Futura_Std_Book_11">26.  How do you declare a struct data structure?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">27.  How do you access fields of a struct?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">28.  What is a union?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">29.  What is the difference between the memory organization of fields in a union versus those in a struct?</span></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>