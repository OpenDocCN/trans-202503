<html><head></head><body>
<h2 class="h2" id="ch13"><span epub:type="pagebreak" id="page_173"/><span class="big">13</span><br/>APPLICATION SECURITY</h2>&#13;
<div class="imagel"><img alt="Image" src="../images/common.jpg"/></div>&#13;
<p class="noindent">In <a href="ch10.xhtml">Chapters 10</a> and <a href="ch11.xhtml">11</a>, I discussed the importance of keeping your networks and operating systems secure. Part of keeping attackers from interacting with your networks and subverting your operating system security is ensuring the security of your applications.</p>&#13;
<p class="indent">In December 2013, the Target Corporation, a retailer operating more than 1,800 stores throughout the United States, reported a breach of customer data that included 40 million customer names, card numbers, card expiration dates, and card security codes.<a href="notes.xhtml#ch13fn1" id="kch13fn1"><sup>1</sup></a> A month later, Target announced that an additional 70 million customers had had their personal data breached.<a href="notes.xhtml#ch13fn2" id="kch13fn2"><sup>2</sup></a></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_174"/>This breach didn’t originate in Target’s systems at all, but rather those of a vendor, Fazio Mechanical, that was connected to Target’s network. Experts believe the attack to have occurred as follows:<a href="notes.xhtml#ch13fn3" id="kch13fn3"><sup>3</sup></a></p>&#13;
<ol>&#13;
<li><p class="noindent">Attackers compromised the systems of Fazio Mechanical with a trojan (a type of malware), using a phishing attack to get it in place.</p></li>&#13;
<li><p class="noindent">Because of poor network segmentation practices, the attackers were able to use Fazio’s access to Target’s network to gain access to other portions of the Target network.</p></li>&#13;
<li><p class="noindent">Attackers installed the credit card harvesting BlackPOS malware on the Target point-of-sale (POS) systems (cash registers, basically) and used the malware to collect information from payment cards scanned by the POS.</p></li>&#13;
<li><p class="noindent">Attackers moved the collected credit card numbers to compromised File Transfer Protocol (FTP) servers on the Target network and then sent them outside of the company, where they eventually ended up on a server in Russia.</p></li>&#13;
<li><p class="noindent">Attackers then sold the stolen credit card and personal data on the black market.</p></li>&#13;
</ol>&#13;
<p class="indent">A variety of issues at several levels allowed this attack to take place. Any one of these missing or lapsed controls—the lack of network segmentation, the lack of anti-malware tools, and the lack of data loss prevention tools—could have prevented the attack from succeeding. In this chapter, you’ll look at application vulnerabilities introduced during software development, vulnerabilities commonly found in web applications, and vulnerabilities that affect the databases that applications use. I’ll also discuss tools you can use to protect your applications.</p>&#13;
<h3 class="h3" id="ch13lev1sec1">Software Development Vulnerabilities</h3>&#13;
<p class="noindent">Many common software development vulnerabilities can lead to security issues in your applications. These include buffer overflows, race conditions, input validation attacks, authentication attacks, authorization attacks, and cryptographic attacks, as shown in <a href="#ch13fig1">Figure 13-1</a>. I’ll go over each kind of vulnerability in this section.</p>&#13;
<p class="indent">You can avoid all these vulnerabilities with relative ease when developing new software by simply not using the programming techniques that enable them to exist. The Computer Emergency Response Team at Carnegie Mellon University publishes a set of documentation that defines secure software development standards for several programming languages, and it’s a good overall resource for further investigation into secure coding in general.<a href="notes.xhtml#ch13fn4" id="kch13fn4"><sup>4</sup></a></p>&#13;
<span epub:type="pagebreak" id="page_175"/>&#13;
<div class="image" id="ch13fig1"><img alt="Image" src="../images/13fig01.jpg"/></div>&#13;
<p class="figcap"><em>Figure 13-1: Software development vulnerabilities</em></p>&#13;
<h4 class="h4" id="ch13lev2sec1"><em>Buffer Overflows</em></h4>&#13;
<p class="noindent"><em>Buffer overflows</em>, or buffer overruns, occur when you don’t properly account for the size of the data input into your applications. If an application accepts data, most programming languages will require you to specify the amount of data you expect to receive and then set aside storage for that data. If you don’t set a limit on the amount of data you take in (a process called <em>bounds checking</em>), you may receive 1,000 characters of input when you had allocated storage for only 50 characters.</p>&#13;
<p class="indent">In this case, the excess 950 characters of data may overwrite other areas in memory that are used by other applications or the operating system. Attackers might exploit this technique to tamper with other applications or cause the operating system to execute their own commands.</p>&#13;
<p class="indent">Proper bounds checking can nullify this type of attack entirely. Some languages, such as Java and C#, implement bounds checking automatically.</p>&#13;
<h4 class="h4" id="ch13lev2sec2"><em>Race Conditions</em></h4>&#13;
<p class="noindent">Race conditions occur when multiple processes (or multiple threads within a process) control or share access to a resource and the correct handling of that resource depends on the proper ordering or timing of transactions.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_176"/>For example, if you’re making a $20 withdrawal from your bank account via an automatic teller machine (ATM), the process might go as follows:</p>&#13;
<ol>&#13;
<li><p class="noindent">Check the account balance ($100).</p></li>&#13;
<li><p class="noindent">Withdraw funds ($20).</p></li>&#13;
<li><p class="noindent">Update the account balance ($80).</p></li>&#13;
</ol>&#13;
<p class="indent">If someone else starts the same process at roughly the same time and tries to make a $30 withdrawal, you might end up with a bit of a problem.</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>User 1</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>User 2</strong></p></td></tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Check the account balance ($100).</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Check the account balance ($100).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Withdraw funds ($20).</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Withdraw funds ($30).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Update the account balance ($80).</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Update the account balance ($70).</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Because two users share access to the resource, the account ends up recording a balance of $70 where you should see only $50. The two users “race” to access the resource, and undesirable conditions occur. (Note that most actual banks implement measures to keep this from happening.)</p>&#13;
<p class="indent">Race conditions can be difficult to detect in existing software, as they’re hard to reproduce. When you’re developing new applications, you can generally avoid these issues if you carefully handle the way users access resources to avoid dependencies on timing.</p>&#13;
<h4 class="h4" id="ch13lev2sec3"><em>Input Validation Attacks</em></h4>&#13;
<p class="noindent">If you’re not careful to <em>validate</em> the input to your applications—in other words, make sure any input that users submit, such as the answers to forms, arrives in an acceptable format—you might fall victim to problems such as a format string attack.</p>&#13;
<p class="indent">In <em>format string attacks</em>, attackers use certain print functions within a programming language that are meant to format the output but instead allow the attacker to manipulate or view an application’s internal memory. In some languages, such as C and C++, you can insert certain characters into the input, such as <span class="literal">%f</span>, <span class="literal">%n</span>, and <span class="literal">%p</span>, to apply formatting to the data you’re printing to the screen. Attackers could, for example, include the <span class="literal">%n</span> (write an integer into memory) parameter in a specially crafted input to write a value into a location in memory that they might not normally be able to access. They could use this technique to crash an application or cause the operating system to run a command, potentially compromising the system.</p>&#13;
<p class="indent">To solve this attack, you should validate your input by filtering it for unexpected or undesirable content. In the case of the format string attack, you may be able to remove the offending characters from the input, or you could put error handling in place to ensure that you anticipate and compensate for such issues so that they don’t cause a problem.</p>&#13;
<h4 class="h4" id="ch13lev2sec4"><span epub:type="pagebreak" id="page_177"/><em>Authentication Attacks</em></h4>&#13;
<p class="noindent">Authentication attacks are those that attempt to gain access to resources without the proper credentials to do so. Putting strong authentication mechanisms in place in your applications will help resist these kinds of attacks.</p>&#13;
<p class="indent">If you require users of applications to create strong passwords, you’ll help keep attackers out. If you use an eight-character, all-lowercase password, such as <em>hellobob</em>, a reasonably powerful machine may be able to break the password almost instantaneously. If you use a ten-character, mixed-case password that also includes numbers and a symbol, such as <em>H3lloBob!1</em>, the time needed to crack it increases to more than 20 years.<a href="notes.xhtml#ch13fn5" id="kch13fn5"><sup>5</sup></a> Furthermore, your applications should not use passwords that are built-in and impossible to change (often called <em>hard-coded</em> passwords).</p>&#13;
<p class="indent">Additionally, you should avoid performing authentication on the client side (the end user’s machine), because you’d then place such measures where they may easily be attacked. As with most security measures, when you give attackers direct access to your controls to manipulate them as they please, you largely remove the effectiveness of the control.</p>&#13;
<p class="indent">If you depend on a local application or script to perform authentication steps and then simply send the “all clear” message to the server end, nothing prevents an attacker from repeating this message to your back end directly, without completing the authentication. Authentication efforts should always be placed as far out of reach of attackers as you can make them, and entirely on the server side, if possible.</p>&#13;
<h4 class="h4" id="ch13lev2sec5"><em>Authorization Attacks</em></h4>&#13;
<p class="noindent"><em>Authorization attacks</em> are attacks that attempt to gain access to resources without the appropriate authorization to do so. Like authentication mechanisms, placing authorization mechanisms on the client side is a bad idea. Any process performed in a space where it might be subject to direct attack or manipulation by users is almost guaranteed to be a security issue at some point. You should instead authenticate against a remote server or on the hardware of the device if the device is portable, which gives you considerably more control.</p>&#13;
<p class="indent">When you’re authorizing a user for some activity, you should do so using the principle of least privilege, as discussed in <a href="ch03.xhtml">Chapter 3</a>. If you’re not careful to allow the minimum permissions required, both for your users and for your software, you may leave yourself open for attack and compromise.</p>&#13;
<p class="indent">Additionally, whenever a user or process attempts an activity that requires privileges, you should always check again to ensure that the user is indeed authorized for the activity in question, each time it’s attempted. If you have a user who, whether by accident or by design, gains access to restricted portions of your application, you should have measures in place that stop the user from proceeding.</p>&#13;
<h4 class="h4" id="ch13lev2sec6"><span epub:type="pagebreak" id="page_178"/><em>Cryptographic Attacks</em></h4>&#13;
<p class="noindent">Cryptography is easy to implement badly, and doing so can give you a false sense of security. One of the big mistakes when implementing cryptography in your applications is to develop your own cryptographic scheme. The major cryptographic algorithms in use today, such as Advanced Encryption Standard (AES) and Rivest-Shamir-Adleman (RSA), have been developed and tested by thousands of people who are very skilled and make their living developing such tools. Additionally, these algorithms are in general use because they have been able to stand the test of time without serious compromise. Although it’s possible that your homegrown algorithm may have some security benefit, you probably shouldn’t test it on software that stores or processes sensitive data.</p>&#13;
<p class="indent">In addition to using known algorithms, you should plan for the possibility that the mechanisms you select will become obsolete or compromised in the future. This means you should design the software in such a way to support the use of different algorithms or at least design your applications in such a way that changing them is not a Herculean task. You should also make it possible to change the encryption keys the software uses, in case your keys break or become exposed.</p>&#13;
<h3 class="h3" id="ch13lev1sec2">Web Security</h3>&#13;
<p class="noindent">Attackers can use an enormous variety of techniques to target web applications and compromise your machines, steal sensitive information, and trick you into carrying out activities without your knowledge. You can separate these attacks into two main categories: client-side attacks and server-side attacks.</p>&#13;
<h4 class="h4" id="ch13lev2sec7"><em>Client-Side Attacks</em></h4>&#13;
<p class="noindent">Client-side attacks either take advantage of weaknesses in the software loaded on the user’s clients or rely on social engineering to fool the user. There are many such attacks, but I’ll focus specifically on some that use the web as an attack vehicle.</p>&#13;
<p class="indent"><em>Cross-site scripting (XSS)</em> is an attack carried out by placing code written in a scripting language into a web page, or other media like Adobe Flash animation and some types of video files, that is displayed by a client browser. When other people view the web page or media, they execute the code automatically, and the attack is carried out.</p>&#13;
<p class="indent">For example, the attacker might leave a comment containing the attack script in the comments section of an entry on a blog. People visiting the web page with their browsers would execute the attack.</p>&#13;
<p class="indent">Cross-site request forgery and clickjacking, two attacks mentioned in <a href="ch03.xhtml">Chapter 3</a>, are also client-side attacks. In a cross-site request forgery attack, the attacker places a link, or links, on a web page in such a way that they’ll <span epub:type="pagebreak" id="page_179"/>execute automatically. The link initiates an activity on another web page or application where the user is currently authenticated, such as adding items to their shopping cart on Amazon or transferring money from one bank account to another.</p>&#13;
<p class="indent">If you’re browsing several pages and are still authenticated to the page the attack is intended for, you might execute the attack in the background and never know it. For example, if you have several pages open in your browser, including one for <em>MySpiffyBank.com</em>, a common banking institution, and you’re still logged in to that page when you visit <em>BadGuyAttackSite.com</em>, the links on the attack page may automatically execute to get you to transfer money to another account. Although attackers most likely won’t know which websites a user is authenticated to, they can make educated guesses, such as banks or shopping sites, and include components to target those specifically.</p>&#13;
<p class="indent">Clickjacking is an attack that takes advantage of your browser’s graphical display capabilities to trick you into clicking something you might not click otherwise. Clickjacking attacks work by placing another layer of graphics or text over the page, or portions of the page, to obscure what you’re clicking. For example, the attacker might hide a Buy Now button under another layer with a More Information button.</p>&#13;
<p class="indent">These types of attacks are, for the most part, thwarted by the newer versions of common browsers, such as Internet Explorer, Firefox, Safari, and Chrome. The most common attacks discussed in this section will be blocked by these automatically, but in many cases, new attack vectors simply allow for new variations of old attacks. Additionally, many clients are running on outdated or unpatched software that remain vulnerable to attacks that are years old. Understanding how the common attacks work and protecting against them not only gives you an additional measure of security but also helps you understand how attackers develop newer attacks.</p>&#13;
<p class="indent">It’s important to keep up with the most recent browser versions and updates, as the vendors that produce them regularly update their protections. Furthermore, some browsers let you apply additional tools to protect you from client-side attacks. One of the better known of these tools is NoScript (<em><a href="http://noscript.net/">http://noscript.net/</a></em>) for Firefox. NoScript blocks most web page scripts by default and requires you to specifically enable those you’d like to run. When used carefully, script-blocking tools such as these can disable many of the web-based threats you’re likely to encounter.</p>&#13;
<h4 class="h4" id="ch13lev2sec8"><em>Server-Side Attacks</em></h4>&#13;
<p class="noindent">Several vulnerabilities on the server side of web transactions may cause problems, as well. These threats and vulnerabilities can vary widely depending on your operating system, web server software and its versions, scripting languages, and many other factors. However, these vulnerabilities are typically caused by a few common factors.</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_180"/>Lack of Input Validation</h5>&#13;
<p class="noindent">As discussed earlier in the chapter, software developers often neglect to properly validate user input, and some of the most common server-side web attacks use this weakness to carry out their attacks.</p>&#13;
<p class="indent"><em>Directory traversal attacks</em> present a strong example of what might happen if you don’t validate input to your web applications. Attackers can use these attacks to gain access to the file system outside of the web server’s structure where content is stored by using the <em>../</em> character sequence, which moves up one level of a directory to change directories. For example, browsing to <em>https://www.vulnerablewebserver.com/../../../etc/passwd</em> on a vulnerable server would display the contents of the <em>/etc/password</em> file. To break this down further, this URL asks the web server to move in the file system in this fashion:</p>&#13;
<ol>&#13;
<li><p class="noindent">From <em>/var/www/html</em> (where web content is normally stored)</p></li>&#13;
<li><p class="noindent">To <em>/var/www</em></p></li>&#13;
<li><p class="noindent">Then to <em>/var</em></p></li>&#13;
<li><p class="noindent">Then to / (the root directory)</p></li>&#13;
<li><p class="noindent">Then back down to <em>/etc</em></p></li>&#13;
<li><p class="noindent">Then to display the contents of <em>/etc/passwd</em></p></li>&#13;
</ol>&#13;
<p class="indent">If you’re careful to validate the input you accept into your web applications and filter out characters that might be used to compromise your security, you can often fend off such an attack before it even begins. In many cases, filtering out special characters, such as the ones described and *, %, ‘, ;, and / will defeat such attacks entirely.</p>&#13;
<h5 class="h5">Improper or Inadequate Permissions</h5>&#13;
<p class="noindent">Assigning improper user permissions can often cause problems with web applications and internet-facing applications of most any kind. Web applications and pages often use sensitive files and directories that will cause security issues if they’re exposed to general users.</p>&#13;
<p class="indent">For example, one area that might cause trouble is the exposure of configuration files. Many web applications that make use of databases (which is a clear majority of applications) have <em>configuration files</em> that hold the credentials the application uses to access the database. If these files and the directories that hold them aren’t properly secured, attackers may simply read your credentials from the file and access the database as they please. For applications that hold sensitive data, this could be disastrous.</p>&#13;
<p class="indent">Likewise, if you don’t take care to secure the directories on your web servers, you may find files changed in your applications, new files added, or the contents of some files deleted entirely. Insecure applications that are internet-facing don’t tend to last long before being compromised.</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_181"/>Extraneous Files</h5>&#13;
<p class="noindent">When a web server moves from development into production, developers often forget to clean up any files not directly related to running the site or application, or files that might be artifacts of the development or build process.</p>&#13;
<p class="indent">If you leave archives of the source code from which your applications are built, backup copies of your files, text files containing your notes or credentials, or any such related files, you may be handing attackers exactly the materials they need to compromise your system. One of the final steps when rolling out a web server should be to make sure all such files are cleaned up or moved elsewhere if they’re still needed. This is also a good periodic check to ensure that, during troubleshooting or upgrading, these items haven’t been left behind where they’re visible to the public.</p>&#13;
<h3 class="h3" id="ch13lev1sec3">Database Security</h3>&#13;
<p class="noindent">Many websites and applications in use today rely on databases to store the information they display and process. In some cases, the database applications may hold very sensitive data, such as tax returns, medical information, or legal records, or they may contain only the contents of a knitting discussion forum. In either case, the data is important to the owners of the application, and they’d be inconvenienced if it were damaged or manipulated in an unauthorized manner.</p>&#13;
<p class="indent">Several issues can harm the security of your databases. The canonical list includes the following:<a href="notes.xhtml#ch13fn6" id="kch13fn6"><sup>6</sup></a></p>&#13;
<ul>&#13;
<li><p class="noindent">Unauthenticated flaws in network protocols</p></li>&#13;
<li><p class="noindent">Authenticated flaws in network protocols</p></li>&#13;
<li><p class="noindent">Flaws in authentication protocols</p></li>&#13;
<li><p class="noindent">Unauthenticated access to functionality</p></li>&#13;
<li><p class="noindent">Arbitrary code execution in intrinsic SQL elements</p></li>&#13;
<li><p class="noindent">Arbitrary code execution in securable SQL elements</p></li>&#13;
<li><p class="noindent">Privilege escalation via SQL injection</p></li>&#13;
<li><p class="noindent">Local privilege escalation issues</p></li>&#13;
</ul>&#13;
<p class="indent">Although this may seem like a horribly complex set of issues to worry about, you can break them down into four major categories, as shown in <a href="#ch13fig2">Figure 13-2</a>. I’ll cover each of these categories in detail in this section.</p>&#13;
<span epub:type="pagebreak" id="page_182"/>&#13;
<div class="image" id="ch13fig2"><img alt="Image" src="../images/13fig02.jpg"/></div>&#13;
<p class="figcap"><em>Figure 13-2: Categories of database vulnerabilities</em></p>&#13;
<h4 class="h4" id="ch13lev2sec9"><em>Protocol Issues</em></h4>&#13;
<p class="noindent">Vulnerabilities might exist in the protocols used by any given database. This includes the network protocols used to communicate with the database. The vulnerabilities in these protocols often involve common software development issues, such as the buffer overflows discussed earlier in this chapter.</p>&#13;
<p class="indent">To mitigate <em>known</em> protocol issues, you should use the most current software version and patches for the database software in question, as discussed in <a href="ch11.xhtml">Chapter 11</a>. To protect your databases from <em>unknown</em> issues (issues that haven’t been discovered yet), you should limit access to your databases, either by limiting who is able to connect to the database over the network, by using some of the methods discussed in <a href="ch10.xhtml">Chapter 10</a>, or by limiting the privileges and accounts you make available for the database itself, following the principle of least privilege.</p>&#13;
<p class="indent">You may also discover issues in the protocols used to authenticate to your database, depending on the specific software and version in use. In general, the older and more out-of-date your software becomes, the more likely it is that you’re using an authentication protocol that isn’t robust. Many older applications will use authentication protocols known to have been broken at some point or to have obvious architectural flaws, such as sending login credentials over the network in plaintext, which Telnet (a tool remotely accessing to a device) does. Again, the best defense here is to ensure that you’re using the most current versions of all software.</p>&#13;
<h4 class="h4" id="ch13lev2sec10"><span epub:type="pagebreak" id="page_183"/><em>Unauthenticated Access</em></h4>&#13;
<p class="noindent">When you give a user or process the opportunity to interact with your database without supplying a set of credentials, you create the possibility for security issues. For example, some simple queries to the database through a web interface might accidentally expose information contained in the database; or you might expose information about the database itself, such as a version number, giving an attacker additional material with which to compromise your application. You might also experience a wide variety of issues related to the secure software development practices discussed at the beginning of the chapter.</p>&#13;
<p class="indent">If, instead, the user or process is forced to send a set of credentials to begin a transaction, the transaction can be monitored and appropriately restricted, based on those credentials. If you allow access to part of your application or toolset without requiring credentials, you may lose visibility and control over the actions taking place.</p>&#13;
<h4 class="h4" id="ch13lev2sec11"><em>Arbitrary Code Execution</em></h4>&#13;
<p class="noindent"><em>Arbitrary code execution</em> (also known as <em>remote code execution</em> when conducted over the network) is the ability for attackers to execute any commands on a system that they choose, without restriction. When it comes to database security, attackers are able to do this because of security flaws related to the languages you use to talk to databases. Structured Query Language (SQL) is the language used to communicate with many of the common databases currently on the market. It contains several built-in elements that can create these security risks, some of which you can limit the use of and some of which you can’t.</p>&#13;
<p class="indent">These language elements can help facilitate bugs in the software you’re using, or they can create issues if you use insecure coding practices, such as allowing attackers to execute arbitrary code within the application. For example, if the server was not appropriately and securely configured, anyone could read from and write to the file system of the server (with the <span class="literal">load_file</span> and <span class="literal">outfile</span> functions), a common ability in many database systems. Once you’re able to interface with the operating system itself, you have a foothold to conduct further attacks, steal data, and so on.</p>&#13;
<p class="indent">Your best defenses against such attacks are twofold. From the consumer side, you should use the current versions and patch levels of all software. From the vendor side, you should mandate secure coding practices, in all cases, to eliminate the vulnerabilities in the first place, as well as conduct internal reviews to ensure that such practices are being followed.</p>&#13;
<h4 class="h4" id="ch13lev2sec12"><em>Privilege Escalation</em></h4>&#13;
<p class="noindent">The last kind of major database security issue is privilege escalation. <em>Privilege escalation attacks</em> are those that increase your level of access above what you’re <span epub:type="pagebreak" id="page_184"/>authorized to have on the system or application. Privilege escalation is aimed at gaining administrative access to the software to carry out other attacks that need a high level of access.</p>&#13;
<p class="indent">You can often conduct privilege escalation through <em>SQL injection</em>, an attack in which input containing SQL commands is submitted to the application. For example, one of the more common SQL injection examples is to send the string <span class="literal">' or '1'='1</span> as the input in a username field for an application. If the application has not filtered the input properly, this string may cause it to automatically record that you’ve entered a legitimate username, because you have set up a condition that always evaluates to true, 1 = 1. This allows you to potentially escalate your level of privilege.</p>&#13;
<p class="indent">Privilege escalation in your databases can also occur if you fail to properly secure your operating system. Database applications run on the operating system, using the credentials and privileges of an operating system user, just like a web browser or any other. If you’re not careful to protect your operating systems and the user accounts that run on them, as discussed in <a href="ch10.xhtml">Chapters 10</a> and <a href="ch11.xhtml">11</a>, any database security measures you put in place might have no effect. If attackers gain access to the account under which the database software is running, they’ll likely have privileges to do anything they care to do, including deleting the database itself, changing passwords for any of the database users, changing the settings for the way the database functions, manipulating data, and so on.</p>&#13;
<p class="indent">Your best defenses against operating system issues such as these are the set of hardening and mitigation steps discussed in <a href="ch11.xhtml">Chapter 11</a>. If you can keep attackers from compromising your system in the first place, you can largely avoid this concern.</p>&#13;
<h3 class="h3" id="ch13lev1sec4">Application Security Tools</h3>&#13;
<p class="noindent">You can use tools to assess and improve the security of your applications. I discussed some of them, such as sniffers, in <a href="ch10.xhtml">Chapters 10</a> and <a href="ch11.xhtml">11</a>. Others are less familiar and more complex, such as fuzzers and reverse engineering tools. Some also require a certain amount of software development experience and familiarity with the technologies concerned to use effectively.</p>&#13;
<h4 class="h4" id="ch13lev2sec13"><em>Sniffers</em></h4>&#13;
<p class="noindent">You can use sniffers to watch the specific network traffic that is being exchanged with an application or protocol. In <a href="#ch13fig3">Figure 13-3</a>, I’m using Wireshark to examine Hypertext Transfer Protocol (HTTP) traffic specifically.</p>&#13;
<span epub:type="pagebreak" id="page_185"/>&#13;
<div class="image" id="ch13fig3"><img alt="Image" src="../images/13fig03.jpg"/></div>&#13;
<p class="figcap"><em>Figure 13-3: HTTP traffic in Wireshark</em></p>&#13;
<p class="indent">In some cases, you can also use tools specific to certain operating systems to get additional information from sniffing tools. A good example of this is Linux’s network monitoring tool EtherApe, which enables you to not only sniff the network traffic but also easily associate the traffic you see with network destinations or specific protocols, as shown in <a href="#ch13fig4">Figure 13-4</a>.</p>&#13;
<div class="image" id="ch13fig4"><img alt="Image" src="../images/13fig04.jpg"/></div>&#13;
<p class="figcap"><em>Figure 13-4: EtherApe</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_186"/>Often, graphical representations such as these allow you to parse data more intuitively and easily discern patterns of traffic that might otherwise go unnoticed.</p>&#13;
<h4 class="h4" id="ch13lev2sec14"><em>Web Application Analysis Tools</em></h4>&#13;
<p class="noindent">A great number of tools exist for analyzing web pages or web-based applications, some of them commercial and some of them free. Most of these tools search for common flaws, such as XSS or SQL injection vulnerabilities, as well as improperly set permissions, extraneous files, outdated software versions, and many other security issues.</p>&#13;
<h5 class="h5">OWASP Zed Attack Proxy</h5>&#13;
<p class="noindent">OWASP Zed Attack Proxy (ZAP), shown in <a href="#ch13fig5">Figure 13-5</a>, is a free and open source web server analysis tool that performs checks for many of the common vulnerabilities mentioned in this chapter.</p>&#13;
<div class="image" id="ch13fig5"><img alt="Image" src="../images/13fig05.jpg"/></div>&#13;
<p class="figcap"><em>Figure 13-5: ZAP</em></p>&#13;
<p class="indent">ZAP indexes all the files and directories it can see on the target web server, a process commonly referred to as <em>spidering</em>, and then locates and reports on any potential issues it finds.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><span epub:type="pagebreak" id="page_187"/><strong>TRUST BUT VERIFY</strong></p>&#13;
<p class="noindent">It’s important to note, when using web analysis tools, that not everything the tool reports as a potential issue will be an actual security problem. These tools almost universally return a certain number of false positives, indicating a problem that doesn’t actually exist. It is important to manually verify that the issue really exists before acting to mitigate it.</p>&#13;
</div>&#13;
<h5 class="h5">Burp Suite</h5>&#13;
<p class="noindent">You can also choose from quite a few commercial web analysis tools, which vary in price from several hundred dollars to many thousands of dollars. One such tool, Burp Suite (<em><a href="https://portswigger.net/burp/">https://portswigger.net/burp/</a></em>), tends toward the lower end of the cost scale for the professional version ($399 per year at the time of this writing) but still presents a solid set of features. Burp Suite runs in a GUI interface, as shown in <a href="#ch13fig6">Figure 13-6</a>, and, in addition to the standard set of features found in any web assessment product, it includes several more advanced tools for conducting more in-depth attacks.</p>&#13;
<div class="image" id="ch13fig6"><img alt="Image" src="../images/13fig06.jpg"/></div>&#13;
<p class="figcap"><em>Figure 13-6: Burp Suite</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_188"/>Burp Suite is also available in a free community version that allows you to use the standard scanning and assessment tools but doesn’t include access to the more advanced features.</p>&#13;
<h4 class="h4" id="ch13lev2sec15"><em>Fuzzers</em></h4>&#13;
<p class="noindent">In addition to all the tools you can use to look over your software for various known vulnerabilities, there are tools that can help you find completely unexpected problems through a process referred to as <em>fuzz testing</em>. The tools used for this technique, called <em>fuzzers</em>, work by bombarding your applications with all manner of data and inputs from a wide variety of sources, in the hope that you can cause the application to fail or to perform some unexpected behavior.</p>&#13;
<p class="indent">The concept of fuzzing was first developed by Barton Miller for a graduate-level university operating system class in the late 1980s,<a href="notes.xhtml#ch13fn7" id="kch13fn7"><sup>7</sup></a> and it’s become popular among security researchers and those conducting security assessments on applications. Miller’s fuzzing web page at the University of Wisconsin is a great resource for further reading on fuzzing, and it includes the document that spawned this field of analysis. You can find it at <em><a href="http://pages.cs.wisc.edu/~bart/fuzz/">http://pages.cs.wisc.edu/~bart/fuzz/</a></em>.</p>&#13;
<p class="indent">A wide variety of fuzzing tools are available; some have a specific focus, such as web applications or hardware devices, and some are more general. OWASP’s fuzzing page (<em><a href="https://www.owasp.org/index.php/Fuzzing">https://www.owasp.org/index.php/Fuzzing</a></em>) lists many current fuzzing tools and materials.</p>&#13;
<h3 class="h3" id="ch13lev1sec5">Summary</h3>&#13;
<p class="noindent">Several common vulnerabilities, introduced during the software development process, can affect the security of your applications. You might encounter buffer overflows, race conditions, input validation attacks, authentication attacks, authorization attacks, and cryptographic attacks, just to name a few. Although such issues are common, you can resolve most of them with relative ease by following secure coding guidelines, either those internal to your organization or from external sources such as the National Institute of Standards and Technologies (NIST) or the United States Computer Emergency Readiness Team (US-CERT).</p>&#13;
<p class="indent">In terms of web security, you should look for client-side issues and server-side issues. Client-side issues involve attacks against the client software you’re running or the people using the software. You can help mitigate these by ensuring that you’re using the most current version of the software and any associated patches and sometimes by adding extra security tools or plug-ins. Server-side attacks are attacks directed against the web server itself. These attacks often take advantage of a lack of strict permissions, a lack of input validation, and the presence of leftover files from development or troubleshooting efforts. Fixing such issues requires scrutiny by both developers and security personnel.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_189"/>Database security is a large concern for almost any internet-facing application. You should look out for protocol issues, unauthenticated access, arbitrary code execution, and privilege escalation. You can mitigate many of these problems by following secure coding practices, keeping up-to-date on your software versions and patches, and following the principle of least privilege.</p>&#13;
<p class="indent">Application security tools can help your applications resist attack. As with network and host security, you can put sniffers to use to examine the network data that enters and exits your applications. You can also use tools to examine how existing applications operate and determine what weaknesses they might have that a skilled attacker could exploit. In addition, fuzzing tools and web application analysis tools can locate vulnerabilities, whether known or unknown.</p>&#13;
<h3 class="h3" id="ch13lev1sec6">Exercises</h3>&#13;
<ol>&#13;
<li><p class="noindent">What does a fuzzing tool do?</p></li>&#13;
<li><p class="noindent">Give an example of a race condition.</p></li>&#13;
<li><p class="noindent">Why is it important to remove extraneous files from a web server?</p></li>&#13;
<li><p class="noindent">What does the tool Burp Suite do and in what situation might you use it?</p></li>&#13;
<li><p class="noindent">Name the two main categories of web security.</p></li>&#13;
<li><p class="noindent">Is a SQL injection attack an attack on the database or an attack on the web application?</p></li>&#13;
<li><p class="noindent">Why is input validation important?</p></li>&#13;
<li><p class="noindent">Explain a cross-site request forgery attack and what you might do to prevent it.</p></li>&#13;
<li><p class="noindent">How might you use a sniffer to increase the security of your applications?</p></li>&#13;
<li><p class="noindent">How can you prevent buffer overflows in your applications?<span epub:type="pagebreak" id="page_190"/></p></li>&#13;
</ol>&#13;
</body></html>