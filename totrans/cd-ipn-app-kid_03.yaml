- en: '**2**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2**'
- en: LEARNING TO CODE IN A PLAYGROUND
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在playground中学习编程
- en: '![image](Image00001.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00001.jpg)'
- en: A “[Hello, world!](text00011.html#ch01) ” app is no small accomplishment, but
    now it’s time to really learn how to write some code. Xcode provides a special
    type of document called a *playground* , which is a great place to learn how to
    program. In a playground, you can write and run code immediately to see the results,
    without going through the trouble of writing a whole app, as we did in [Chapter
    1](text00011.html#ch01) .
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一个“[Hello, world!](text00011.html#ch01)”应用程序不是一项小成就，但现在是时候真正学习如何编写代码了。Xcode提供了一种特殊类型的文档，叫做*playground*，这是学习编程的好地方。在playground中，你可以立即编写并运行代码，查看结果，而不必像我们在[第1章](text00011.html#ch01)中那样编写整个应用程序。
- en: Let’s open a playground. Open Xcode and select **Get started with a playground**
    , as shown in the Welcome to Xcode dialog in [Figure 2-1](text00012.html#ch02fig1)
    . If this window doesn’t automatically open, select **Welcome to Xcode** from
    the Window option in the menu or press ⌘ -SHIFT -1.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开一个playground。打开Xcode并选择**开始使用playground**，如[图2-1](text00012.html#ch02fig1)中的Xcode欢迎对话框所示。如果这个窗口没有自动打开，请从菜单中的“窗口”选项选择**Welcome
    to Xcode**，或者按下⌘-SHIFT-1。
- en: '![image](Image00033.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00033.jpg)'
- en: '*Figure 2-1: Getting started with a playground*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-1：开始使用playground*'
- en: You’ll be asked to name your playground ([Figure 2-2](text00012.html#ch02fig2)
    ). In this example, we’ll keep the default name *MyPlayground* . Make sure that
    you choose iOS as the platform to run the playground.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 系统会要求你为你的playground命名（见[图2-2](text00012.html#ch02fig2)）。在这个示例中，我们将保持默认名称*MyPlayground*。确保你选择iOS作为运行playground的平台。
- en: '![image](Image00034.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00034.jpg)'
- en: '*Figure 2-2: Naming the playground and selecting the platform*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-2：命名playground并选择平台*'
- en: When the playground first opens, you’ll see two panels in the window, just like
    in [Figure 2-3](text00012.html#ch02fig3) . On the left is the playground editor,
    where you’ll write your code. On the right is the results sidebar, which displays
    the results of your code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当playground首次打开时，你会看到窗口中有两个面板，就像在[图2-3](text00012.html#ch02fig3)中所示。左边是playground编辑器，你将在这里编写代码。右边是结果侧边栏，它显示代码的执行结果。
- en: The line var str = "Hello, playground" in [Figure 2-3](text00012.html#ch02fig3)
    creates a variable named str . A *variable* is like a container; you can use it
    to hold almost anything—a simple number, a string of letters, or a complex object
    (we’ll explain what that is later). Let’s take a closer look at how variables
    work.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-3](text00012.html#ch02fig3)中的代码行var str = "Hello, playground"创建了一个名为str的变量。*变量*就像一个容器；你可以用它来存放几乎任何东西——一个简单的数字、一串字母，或者一个复杂的对象（我们稍后会解释那是什么）。让我们更仔细地看看变量是如何工作的。'
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00035.jpg)![image](Image00036.jpg)'
- en: '*Figure 2-3: Playground editor and results sidebar*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-3：Playground编辑器和结果侧边栏*'
- en: '**CONSTANTS AND VARIABLES**'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**常量和变量**'
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自[图2-3](text00012.html#ch02fig3)的代码行：
- en: '![Image](Image00037.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00037.jpg)'
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 它做了两件事。首先，它创建了一个名为str的变量。这被称为*声明*，因为我们在声明我们希望创建一个变量。要创建变量，你输入关键字var，然后输入变量的名称——在这个例子中是str。命名变量时有一些规则，我们稍后会讨论，所以现在先按照这个例子来做。
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，这行代码使用=运算符将“Hello, playground”的值赋给str。这被称为*赋值*，因为我们正在给新创建的变量赋值。记住，你可以把变量看作一个容器，用来存放某些东西。所以现在我们有一个名为str的容器，里面存放着“Hello,
    playground”。
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这行代码读作“变量str等于Hello, playground”。正如你所看到的，Swift通常非常易读；这行代码几乎用英文告诉你它在做什么。
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 变量很有用，因为如果你想打印“Hello, playground”这句话，你只需要在 `str` 上使用 `print` 命令，就像下面的代码：
- en: '![Image](Image00038.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00038.jpg)'
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在结果侧边栏中打印 "Hello, playground\n"。`\n` 会自动添加到你打印内容的末尾。它被称为*换行*字符，告诉计算机换到下一行。
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看程序的实际运行结果，打开调试区域，它会出现在两个面板下方，如[图 2-4](text00012.html#ch02fig4)所示。要做到这一点，请在
    Xcode 菜单中选择 **视图** ▸ **调试区域** ▸ **显示调试区域**，或者按 ⌘ -SHIFT -Y。当 `str` 在调试区域的控制台中打印出来时，你会看到
    “Hello, playground” 之间的引号和换行符不会出现。这就是如果你正式运行该程序时 `str` 的实际样子！
- en: '![image](Image00039.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：在调试区域查看程序的真实输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以在你的程序中变化（或*变化*！），因此你可以更改变量的值以存储其他内容。让我们现在试试。将以下几行添加到你的 playground 中。
- en: '![Image](Image00040.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改变量的值，输入其名称并使用 `=` 运算符将其设置为新值。我们在 ➊ 处做这件事，将 `str` 的值更改为 "Hello, world"。计算机会丢弃
    `str` 之前的内容，并说，“好的，老板，`str` 现在是 Hello, world ”（如果它能说话的话，应该是这样说！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们更改 `str` 的值时，我们不会再次写 `var`。计算机会记住我们在前一行代码中声明了 `str`，并知道 `str` 已经存在。所以我们不需要重新创建
    `str`。我们只是想把不同的内容放入其中。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以声明*常量*。像变量一样，常量也存储值。常量和变量之间的最大区别是，常量的值永远不能改变。变量可以变化，而常量则是，嗯，常量！声明常量和声明变量类似，不过我们使用的是
    `let` 而不是 `var`：
- en: '![Image](Image00041.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个叫做 `myName` 的常量，并将其赋值为 "Gloria"。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个常量并赋予它一个值，它将保持这个值直到时间的尽头。可以把常量看作是一块你雕刻了自己值的大石头。如果你尝试给 `myName` 赋予另一个值，比如
    "Matt" ，你将得到一个像[图 2-5](text00012.html#ch02fig5)中那样的错误。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00042.jpg)![image](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：尝试更改常量的值是行不通的。*'
- en: '**NOTE**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 playground 中，一个红色圆圈内有一个小白点的错误会出现。点击错误标记将显示错误信息，并告诉你出了什么问题。如果你打开了调试区域，你还会看到描述发生了什么的信息，有时甚至会告诉你如何修复它。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量——干得好！但是，什么时候应该使用其中之一呢？在 Swift 中，最佳实践是使用常量而不是变量，除非你预计这个值会发生变化。常量有助于使代码更“安全”。如果你知道某个值永远不会变化，为什么不把它刻在石头上，避免以后可能的混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，你想跟踪你教室中的窗户总数和今天打开的窗户数。你教室中的窗户数不会变化，因此你应该使用常量来存储这个值。至于你教室中打开的窗户数，它会根据天气和时间变化，因此你应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00044.jpg)![Image](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 numberOfWindows 设为常量并将其值设置为 8，因为窗户的总数永远是 8。我们将 numberOfWindowsOpen 设为变量并将其值设置为
    3，因为我们希望在开关窗户时更改该值。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用 var 来声明变量，使用 let 来声明常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**命名常量和变量**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以给变量或常量起几乎任何你想要的名字，但有一些例外。你不能将它们命名为 Swift 中已经是关键字的词。例如，你不能将一个变量命名为 var。写 var
    var 会让你和计算机都感到困惑。如果你尝试使用 Swift 的保留字命名变量或常量，编译器会报错。你也不能在同一个代码块中有两个名字相同的变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则外，在 Swift 中命名时还有一些其他好的编程指南。你的变量名应该始终以小写字母开头。为变量或常量命名时，使用*非常*具有描述性的名称也是一个好主意（名称可以尽量长）。使用描述性名称时，更容易理解该变量或常量的含义。如果你在看别人写的代码，你会觉得哪个变量名更容易理解呢：numKids
    还是 numberOfKidsInMyClass？第一个比较模糊，而第二个则很具描述性。常见的命名方式是将多个单词组合在一起，比如 numberOfKidsInMyClass。这样的命名风格，通常每个单词的首字母大写，这种风格叫做*驼峰命名法*（camel
    case）。因为这种大小写字母交替的方式像骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你可以选择变量或常量要保存的数据类型。记得我们说过，变量可以看作是一个容器，它保存某些东西吗？那么，数据类型就像是容器的类型。计算机需要知道我们将把什么类型的东西放入每个容器中。在
    Swift 编程中，一旦你告诉计算机你想要一个变量或常量保存某种数据类型，它就不会允许你将其他类型的东西放入那个变量或常量中。如果你有一个专门用来装土豆的篮子，把水倒进那个篮子里就不太合适——除非你喜欢水洒得到处都是！
- en: '![image](Image00047.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，你可以告诉计算机它将保存什么类型的数据。在我们关于教室窗户的例子中，我们知道这个变量将始终是一个*整数*（即一个整数——你不可能有半个窗户），所以我们可以指定一个整数数据类型，如下所示：
- en: '![Image](Image00048.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示“是类型”。用通俗的语言来说，这行代码的意思是：“变量 numberOfWindowsOpen，它是一个整数，等于 3。”所以这一行代码创建了一个变量，给它命名，告诉计算机它的数据类型，并赋值。呼！一行代码就做了这些？我们有提到过
    Swift 是一种非常*简洁*的语言吗？某些语言可能需要几行代码才能做到同样的事情。Swift 设计得很巧妙，可以用一行代码完成许多操作！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要声明一次数据类型。当我们告诉计算机一个变量将保存整数时，我们不需要再次告诉它。事实上，如果我们这么做，Xcode 会给我们报错。一旦数据类型被声明，变量或常量将永远保存该类型的数据。一次整数，永远是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要知道一件关于数据类型的事情：一个变量或常量不能保存与其数据类型不符的内容。例如，如果你试图将一个小数值放入 numberOfWindowsOpen
    中，你会得到一个错误，如[图 2-6](text00012.html#ch02fig6)所示。
- en: '![image](Image00049.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：你不能把一个小数值放入一个本应保存整数的变量中。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将 numberOfWindowsOpen 设置为 5 或 0 是有效的并且可以正常工作。但你不能将 numberOfWindowsOpen 设置为 1.5。
- en: '**COMMON DATA TYPES**'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚刚学到的，数据类型让计算机知道它正在处理哪种*类型*的数据，并且如何将其存储在内存中。那么，数据类型有哪些呢？一些常见的数据类型包括 Int、Double、Float、Bool
    和 String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下这些数据类型究竟是什么！
- en: '**Int (Integers)**'
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**整数（Int）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经稍微谈过整数了，但让我们更详细地讲解一下它们。整数，在 Swift 中叫做 Int，是没有小数或分数部分的整数。你可以把它们当作计数数字来理解。整数是*有符号*的，意味着它们可以是负数、正数（或零）。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Double 和 Float（小数数字）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*小数数字*是小数点后有数字的数字，例如 3.14。（如果你希望一个整数 3 成为小数数字，它会被写作 3.0。）有两种数据类型可以存储小数数字：Double
    和 Float（即*浮点数*）。Double 数据类型在 Swift 中更常用，因为它能存储更大的数字，因此我们将重点讲解 Double。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当你赋值给一个 Double 时，必须在小数点左侧有一个数字，否则会出错。例如，假设香蕉每个19分钱：
- en: '![Image](Image00050.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码会导致错误，因为它小数点左侧没有数字。➋ 处的代码正常工作，因为它有一个前导零。（// ERROR 和 // CORRECT 是*注释*，它们是程序中的注释，计算机会忽略它们。请参阅
    “[关于注释的一些简短说明](text00012.html#ch02sb01)” 在 [第32页](text00012.html#page_32)。）
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Bool（布尔值，或真/假）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值*只能是两种值之一：真或假。在 Swift 中，布尔数据类型叫做 Bool。'
- en: '![Image](Image00051.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值通常用于 if-else 语句中，告诉计算机程序应该走哪条路径。（我们将在[第3章](text00013.html#ch03)中更详细地讲解布尔值和
    if-else 语句。）
- en: '**String**'
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符串**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: String 数据类型用于存储单词和短语。*字符串*是由引号括起来的一系列字符。例如，"Hello, playground" 就是一个字符串。字符串可以由各种字符组成：字母、数字、符号等。引号很重要，因为它们告诉计算机，所有在引号之间的内容都是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串连接在一起来构建句子，这个过程叫做字符串*连接*。让我们看看它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用加号（+）将字符串连接在一起，这段代码创建了一个名为 specialGreeting 的变量，其值为字符串 "Good Morning Jude"。注意，这里我们需要在
    morningGreeting 和 friend 之间加一个包含空格字符（" "）的字符串，否则 specialGreeting 将变成 "Good MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在我们声明变量时，有时会包含数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们不会包含数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是怎么回事？计算机实际上足够智能，大多数情况下能推断出数据类型。这就是所谓的*类型推断*——因为计算机会根据我们提供的线索，*推断*（或猜测）我们使用的数据类型。当你创建一个变量并给它一个初始值时，这个值对计算机来说是一个重要的线索。这里有一些例子：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值为没有小数的数字（如3），计算机会认为它是一个Int类型。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值为带小数的数字（如3.14），计算机会认为它是一个Double类型。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值为*true*或*false*（没有引号），计算机会认为它是一个Bool类型。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值为一个或多个带引号的字符，计算机会认为它是一个String类型。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量的类型就会像你自己声明数据类型一样被设置。这完全是为了方便。你可以在每次声明新的常量或变量时都指定数据类型，这完全没问题。但为什么不让计算机自己推断出来，节省时间并减少输入呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**通过强制转换转换数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*强制转换*是一种临时转换变量或常量数据类型的方法。你可以把它想象成对变量施放一个咒语——让它的值表现得像是另一种数据类型，但仅仅是短暂的。为此，你需要写下一个新的数据类型，后跟括号，括号内是你要强制转换的变量。注意，这*并不会实际改变数据类型*。它只是为那一行代码提供了一个临时的值。这里有一些强制转换Int和Double之间的示例。查看代码执行结果旁边的结果面板。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![Image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，我们将Int类型的变量months强制转换为Double，并存储在一个名为doubleMonths的新变量中。这为其添加了一个小数位，强制转换的结果是12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将Double转换为Int：
- en: '![Image](Image00058.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，我们将Double类型的days强制转换为Int类型。你可以看到小数点和后面的所有数字都被去掉了：我们的数字变成了365。这是因为Int类型无法容纳小数——它只能包含整数，因此小数点后面的部分被截去。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，强制转换实际上并不会改变数据类型。在我们的例子中，即使经过强制转换，days *仍然*是一个Double类型。我们可以通过打印days来验证这一点：
- en: '![Image](Image00059.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 结果面板显示，days的值依然是365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将介绍一些使用强制转换的示例。所以如果你现在不明白为什么要强制转换一个变量，再稍等一下！
- en: '**OPERATORS**'
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，有许多算术运算符可以用来做数学运算。你已经见过基本的赋值运算符=。你可能也熟悉加法（+）、减法（-）、乘法（*）和除法（/）。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符对Int、Float和Double数据类型进行数学运算。被运算的数字称为*操作数*。通过在你的Playground中输入如下代码，试验这些数学运算符：
- en: '![Image](Image00060.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在你的Playground中输入这段代码，你将看到每个数学表达式的结果出现在侧边栏中。写数学表达式的代码与正常书写它们没有太大区别。例如，16减去2写作16
    – 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数学表达式的结果保存在一个变量或常量中，以便在代码的其他地方使用。要了解如何工作，请在Playground中输入这些行：
- en: '![Image](Image00061.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印sum ➊时，你将在侧边栏看到7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在数学表达式中使用了数字，但数学运算符也适用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的Playground中：
- en: '![Image](Image00062.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以像对数字一样对变量和常量使用数学运算符。
- en: '**SPACES MATTER**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，运算符周围的空格很重要。你可以在数学运算符的两边写一个空格，或者完全不写空格。但不能只在运算符的一边加空格，而另一边没有空格。那会导致错误。请查看[图2-7](text00012.html#ch02fig7)。
- en: '![image](Image00063.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-7：确保运算符两边有相同数量的空格。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点很重要：你只能对相同数据类型的变量或常量使用数学运算符。在前面的代码中，三和五都是Int数据类型。常量half和quarter是Double数据类型，因为它们是小数。如果你尝试将Int和Double相加或相乘，你会得到类似[图2-8](text00012.html#ch02fig8)中的错误。
- en: '![image](Image00064.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-8：在Swift中，不能对混合数据类型进行数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你真的想对混合数据类型进行数学运算呢？例如，假设你想计算你年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行将会导致错误，因为我们尝试将一个Int与一个Double相乘。但别担心！你有几种方法可以确保操作数是相同的数据类型。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选择是将myAge声明为Double类型，如下所示：
- en: '![Image](Image00066.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有效，因为我们在乘两个Double数据类型。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是使用类型转换。（我说过我们会回到这个问题！）类型转换在这种情况下是一个很好的解决方案，因为我们不想将 myAge 永久地改变为 Double
    类型，我们只是希望能够像 Double 一样对它进行数学运算。我们来看一个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 myAge 转换为 Double 类型后再进行乘法运算。这样我们就不再有混合类型，因此代码能够正常运行。但在 ➋ 处，我们会得到一个错误。这是因为
    myAge 仍然是一个 Int 类型。将它在 ➊ 处转换为 Double 类型并没有永久地改变它的类型。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能将乘数转换为一个 Int 吗？当然可以！这样我们就对两个整数进行了数学运算，效果很好。然而，这样会导致计算不够精确，因为我们丢失了小数位。当你将一个
    Double 类型的变量转换为 Int 时，计算机会简单地去掉小数点后的数字，使其成为一个整数。在这种情况下，你的乘数 0.1 会被转换为 Int 类型的
    0。我们来在 Playground 中转换一些变量，看看会得到什么结果：
- en: '![Image](Image00068.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，将我们的 Double 类型变量乘数转换为 Int 后得到 0。这个值转换后与原值差异很大，因为我们丢失了小数位：0.1 变成了 0。如果我们没有预料到这种情况，这在代码中可能是一个非常糟糕的事情。在进行类型转换时，必须小心，以确保不会意外地改变值。在
    ➋ 处，另一个将 Double 转换为 Int 的例子，如你所见，1.9 并没有四舍五入为 2，它的小数部分被去掉了，结果是 1。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个数学运算符是 *取模运算符*（%），可能你不太熟悉。取模运算符（也叫 *模*）给出除法运算后的余数。例如，7 % 2 = 1，因为 7 除以 2
    的余数是 1。试试在 Playground 中使用取模运算符，如下所示。
- en: '![Image](Image00069.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，取模运算符对于判断一个数是否为偶数（evenNumber % 2 等于 0）➊ 或奇数（oddNumber % 2 等于 1）➋ 很有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算顺序**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们每行代码只进行了一个数学运算，但在一行代码中做多个运算是很常见的。我们来看一个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元钞票和两张一美元钞票，你总共有多少钱？我们来在一行中计算一下：
- en: '![Image](Image00070.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 17 的值赋给 myMoney。计算机会将 5 乘以 3，然后加上 2。那么计算机是如何知道先乘后加 2 的呢？它是从左到右计算的吗？不是！看看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移动了数字，结果仍然是 17。如果计算机仅仅是从左到右进行计算，它会先计算 2 + 5，得到 7。然后它会将结果 7 乘以 3，得到 21。尽管我们改变了数学表达式中数字的顺序，但计算机仍然首先进行乘法（得到
    15），然后再加上 2 得到 17。*计算机会始终先进行乘法和除法，然后进行加法和减法。*这就是所谓的*运算顺序*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号的运算顺序**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必像我们在货币示例中那样依赖计算机来确定应该先做哪个步骤。你，程序员，拥有决定权！你可以使用括号将操作分组。当你将括号放在某个操作周围时，你是在告诉计算机先执行这个步骤：
- en: '![Image](Image00072.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，括号告诉计算机首先计算 5 乘以 3，然后加上 2。结果是 17。在 ➋ 处，括号告诉计算机首先计算 2 加 5，然后将结果乘以 3，得到
    21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在其他括号内部使用括号来使代码更加具体。计算机会先评估内部的括号，然后再评估外部的括号。试试这个例子：
- en: '![Image](Image00073.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，计算机会在内括号中计算 2 和 3 的和。然后，它将结果乘以 4，因为这在外部括号内。最后，它会加上外部括号外的 1。最终结果是 21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值运算符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的另一类运算符是*复合赋值运算符*。这些是将数学运算符和赋值运算符（=）结合起来的“快捷方式”运算符。例如，以下表达式：
- en: '[PRE0]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: becomes
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 会变成：
- en: '[PRE1]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符通过对变量或常量进行操作来更新其值。简单来说，像 a += b 这样的表达式表示“将 b 加到 a 上，并将新值存储到 a 中。”[表
    2-1](text00012.html#ch2tab1) 显示了使用复合赋值运算符的数学表达式及其长写形式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-1：** 简写赋值运算符与长写表达式'
- en: '| **Short form** | **Long form** |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| **简写形式** | **长写形式** |'
- en: '| --- | --- |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 += 运算符的实际应用。假设我们正在编写一个程序来计算方舟上的动物数量。首先，我们创建一个名为 animalsOnArk 的变量并将其设置为
    0，因为方舟上还没有动物。当不同种类的动物登上方舟时，我们希望增加 animalsOnArk 来计算所有动物的数量。如果两只长颈鹿登上了方舟，那么我们需要将
    2 加到 animalsOnArk 上。如果两只大象登上了方舟，我们再次需要加 2。如果四只羚羊登上了方舟，那么我们需要将 animalsOnArk 增加
    4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00074.jpg)![Image](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在两只长颈鹿、两只大象和四只羚羊登上方舟后，animalsOnArk的最终值为8。真是一座动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的几点快速说明**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都提供了在代码中写注释的方式。注释是计算机忽略的备注，用来帮助阅读代码的人理解发生了什么。虽然没有注释程序也能正常运行，但在代码中不清楚或令人困惑的部分添加注释是个好主意。即使你不打算向别人展示你的程序，注释也会帮助你记住编写这段代码时的思路或想法。过去几个月或几年你写的代码，有时你会发现自己已经完全不记得当时的想法。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中有两种添加注释的方法。第一种方法是在你想添加的文本前面放两个斜杠（//）。这些注释可以单独放在一行，就像这样：
- en: '[PRE2]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 或者注释也可以放在代码行的同一行内——只要注释放在代码*后面*：
- en: '[PRE3]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法用于长注释，或者*多行*注释，其中注释的开始和结束由/*和*/标记。（注意，在本书中我们将使用-- *snip* --来显示我们为节省空间而省略的更多代码行。）
- en: '[PRE4]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不希望计算机运行你代码的某部分，因为你正在寻找一个bug，但又不想删除所有辛苦写的代码，你可以使用多行注释来*暂时注释掉*代码的某些部分。当你将一段代码格式化为注释时，计算机会像忽略其他任何注释一样忽略这些代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何在Swift playground中编写代码，这让你可以立刻看到结果。你创建了变量和常量，并学会了如何使用基本的数据类型和操作符，这些内容你在编写自己的计算机程序时将反复使用。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](text00013.html#ch03)中，你将使用条件语句，它告诉计算机你希望它执行哪个代码路径。代码路径的选择是基于条件值的。
- en: LEARNING TO CODE IN A PLAYGROUND
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在游乐场中学习编程
- en: '![image](Image00001.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00001.jpg)'
- en: A “[Hello, world!](text00011.html#ch01) ” app is no small accomplishment, but
    now it’s time to really learn how to write some code. Xcode provides a special
    type of document called a *playground* , which is a great place to learn how to
    program. In a playground, you can write and run code immediately to see the results,
    without going through the trouble of writing a whole app, as we did in [Chapter
    1](text00011.html#ch01) .
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 “[Hello, world!](text00011.html#ch01)” 应用程序并不是什么小成就，但现在是时候真正学习如何编写代码了。Xcode提供了一种特殊类型的文档，叫做*playground*，这是学习编程的好地方。在playground中，你可以立即编写和运行代码来查看结果，而无需像我们在[第1章](text00011.html#ch01)中那样编写一个完整的应用程序。
- en: Let’s open a playground. Open Xcode and select **Get started with a playground**
    , as shown in the Welcome to Xcode dialog in [Figure 2-1](text00012.html#ch02fig1)
    . If this window doesn’t automatically open, select **Welcome to Xcode** from
    the Window option in the menu or press ⌘ -SHIFT -1.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开一个游乐场。打开 Xcode 并选择 **开始使用游乐场**，如[图 2-1](text00012.html#ch02fig1)中欢迎进入 Xcode
    对话框所示。如果这个窗口没有自动打开，可以从菜单的窗口选项中选择 **欢迎使用 Xcode**，或者按 ⌘-SHIFT-1。
- en: '![image](Image00033.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00033.jpg)'
- en: '*Figure 2-1: Getting started with a playground*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：开始使用游乐场*'
- en: You’ll be asked to name your playground ([Figure 2-2](text00012.html#ch02fig2)
    ). In this example, we’ll keep the default name *MyPlayground* . Make sure that
    you choose iOS as the platform to run the playground.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 系统会要求你为游乐场命名（见[图 2-2](text00012.html#ch02fig2)）。在这个示例中，我们保持默认名称 *MyPlayground*。确保选择
    iOS 作为运行游乐场的平台。
- en: '![image](Image00034.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00034.jpg)'
- en: '*Figure 2-2: Naming the playground and selecting the platform*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：命名游乐场并选择平台*'
- en: When the playground first opens, you’ll see two panels in the window, just like
    in [Figure 2-3](text00012.html#ch02fig3) . On the left is the playground editor,
    where you’ll write your code. On the right is the results sidebar, which displays
    the results of your code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当游乐场首次打开时，你会看到窗口中有两个面板，就像在[图 2-3](text00012.html#ch02fig3)中那样。左边是游乐场编辑器，你将在这里编写代码。右边是结果侧边栏，显示你的代码结果。
- en: The line var str = "Hello, playground" in [Figure 2-3](text00012.html#ch02fig3)
    creates a variable named str . A *variable* is like a container; you can use it
    to hold almost anything—a simple number, a string of letters, or a complex object
    (we’ll explain what that is later). Let’s take a closer look at how variables
    work.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-3](text00012.html#ch02fig3)中的这行代码 `var str = "Hello, playground"` 创建了一个名为
    str 的变量。*变量*就像一个容器；你可以用它来存储几乎任何东西——一个简单的数字、一串字母，或者一个复杂的对象（我们稍后会解释这是什么）。让我们更仔细地看看变量是如何工作的。'
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00035.jpg)![image](Image00036.jpg)'
- en: '*Figure 2-3: Playground editor and results sidebar*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：游乐场编辑器和结果侧边栏*'
- en: '**CONSTANTS AND VARIABLES**'
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**常量和变量**'
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是[图 2-3](text00012.html#ch02fig3)中的代码行：
- en: '![Image](Image00037.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00037.jpg)'
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 它做了两件事。首先，它创建了一个名为 str 的变量。这称为*声明*，因为我们声明了我们想要创建一个变量。要创建一个变量，您输入关键字 var，然后输入变量的名称——在这个例子中是
    str。命名变量时有一些规则，我们稍后会讲到，所以现在请使用这个示例。
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这行代码通过 = 运算符给 str 赋值为 "Hello, playground"。这叫做*赋值*，因为我们正在给我们新创建的变量赋值。记住，你可以把变量当作一个容器，它用来存储某些东西。所以现在我们有一个名为
    str 的容器，它存储着 "Hello, playground"。
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这行代码理解为“变量 str 等于 Hello, playground”。如你所见，Swift 通常非常易读；这行代码几乎用英语告诉你它在做什么。
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 变量很方便，因为如果你想打印“Hello, playground”，你只需要使用命令 `print` 在 str 上，就像以下代码一样：
- en: '![Image](Image00038.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00038.jpg)'
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在结果侧边栏打印出 "Hello, playground\n"。\n 会自动添加到你打印的内容的末尾。它被称为*换行符*，指示计算机换行。
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看程序的实际运行结果，可以打开调试区域，它将出现在两个面板下方，如[图 2-4](text00012.html#ch02fig4)所示。为此，在Xcode菜单中选择**视图**
    ▸ **调试区域** ▸ **显示调试区域**，或者按下⌘-SHIFT-Y。当`str`在调试区域的控制台中打印出来时，你会看到Hello, playground的引号和换行符没有出现。这就是如果你正式运行此程序时`str`的真实样子！
- en: '![image](Image00039.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：在调试区域查看程序的实际输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以在程序中改变（或*变化*！），因此你可以更改变量的值以保存其他内容。现在我们就来试试。将以下几行代码添加到你的游乐场中。
- en: '![Image](Image00040.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改变量的值，输入其名称并使用`=`运算符将其设置为新值。我们在➊处执行此操作，将`str`的值更改为“Hello, world”。计算机会丢弃`str`原来的值，并说：“好的，老板，`str`现在是‘Hello,
    world’”（也就是，如果它能说话的话！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们更改`str`的值时，我们不会再写`var`。计算机会记住我们之前在代码中声明过`str`，并知道`str`已经存在。所以我们不需要再次创建`str`。我们只是想给它赋一个不同的值。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以声明*常量*。像变量一样，常量也可以保存值。常量和变量之间的最大区别是常量的值永远无法改变。变量是可变的，而常量则是，嗯，常量！声明常量与声明变量类似，不过我们使用的是`let`而不是`var`：
- en: '![Image](Image00041.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们创建了一个名为`myName`的常量，并将它的值设置为“Gloria”。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个常量并给它赋值，它将保持这个值直到时间的尽头。把常量想象成一块大石头，你在上面雕刻了你的值。如果你试图给`myName`另一个值，比如“Matt”，你会得到一个像[图
    2-5](text00012.html#ch02fig5)那样的错误。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00042.jpg)![image](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：尝试更改常量的值是行不通的。*'
- en: '**NOTE**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*在游乐场中，错误会以一个红色圆圈和里面的小白圆圈的形式显示。点击错误标记会显示错误信息，并告诉你哪里出了问题。如果你已经显示了调试区域，你还会看到描述发生了什么的信息，有时甚至会告诉你如何修复它。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量——做得好！但是，什么时候应该使用常量，什么时候应该使用变量呢？在Swift中，最好使用常量而不是变量，除非你预期值会发生变化。常量有助于使代码“更安全”。如果你知道某个值永远不会改变，为什么不把它刻在石头上，避免将来可能产生的任何混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想追踪教室中窗户的总数和今天开着的窗户数。教室中窗户的总数是不会变化的，因此你应该使用常量来存储这个值。而开着的窗户数会根据天气和时间变化，所以你应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00044.jpg)![Image](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 numberOfWindows 设置为常量，并将其设置为 8，因为窗户的总数始终是 8。我们将 numberOfWindowsOpen 设置为变量，并将其初始化为
    3，因为我们希望在开关窗户时改变这个值。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用 var 来声明变量，使用 let 来声明常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**命名常量和变量**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以为变量或常量命名任何你想要的名字，但有一些例外。你不能使用 Swift 中已经是保留字的词作为变量名。例如，你不能将变量命名为 var。写 var
    var 会让你和计算机都感到困惑。如果你尝试使用 Swift 的保留字命名变量或常量，程序会报错。同时，在同一代码块中，不能有两个变量或常量使用相同的名称。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则之外，在 Swift 中命名时还有一些其他好的编程指南。你的名称应该始终以小写字母开头。拥有*非常*具有描述性的名称也是一个好主意（它们可以尽可能长）。使用描述性名称时，通常更容易理解该变量或常量的含义。如果你正在查看别人的代码，你会更容易理解哪个变量名称：numKids
    还是 numberOfKidsInMyClass？前者模糊不清，而后者则更具描述性。你会经常看到一些由多个单词组合而成的变量和常量名称，如 numberOfKidsInMyClass。这种将多个单词连接起来组成变量名称时，每个单词首字母大写的命名风格被称为*驼峰式命名法*。这是因为字母大小写的模式看起来像是骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你可以选择变量或常量要保存的数据类型。还记得我们之前提到过，可以将变量看作是一个容器来存放某些东西吗？那么数据类型就像是容器的类型。计算机需要知道我们会往每个容器中放入什么样的东西。在
    Swift 编程中，一旦你告诉计算机一个变量或常量要保存某种数据类型，它就不允许你往该变量或常量里放入除了该数据类型之外的任何东西。如果你有一个用来装土豆的篮子，往里面装水肯定是个坏主意——除非你喜欢水漏到鞋子里！
- en: '![image](Image00047.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，你可以告诉计算机它将保存什么类型的数据。在我们关于教室窗户的例子中，我们知道这个变量将始终是一个*整数*（也就是一个整数——你不能真的有半个窗户），所以我们可以指定一个整数数据类型，像这样：
- en: '![Image](Image00048.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示“是类型”。用简单的英语来说，这行代码的意思是：“变量numberOfWindowsOpen，它是一个整数，等于3。”所以这一行代码创建了一个变量，给它命名，告诉计算机它的数据类型，并为其赋值。呼！一行代码做了这些事情？我们有提到过Swift是一种非常*简洁*的语言吗？一些语言可能需要几行代码才能做到同样的事情。而Swift的设计就是让你只用一行代码就能做很多事情！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要声明一次数据类型。当我们告诉计算机一个变量将保存整数时，我们不需要再告诉它一次。事实上，如果我们再告诉它，Xcode会给我们一个错误。数据类型一旦声明，变量或常量将永远保存该类型的数据。一旦是整数，就永远是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件关于数据类型你需要知道的事：变量或常量不能保存不属于其数据类型的内容。例如，如果你试图将一个小数赋值给numberOfWindowsOpen，你会收到一个错误，如[图2-6](text00012.html#ch02fig6)所示。
- en: '![image](Image00049.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-6：你不能将小数赋值给一个应该保存整数的变量。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 将numberOfWindowsOpen = 5和numberOfWindowsOpen = 0是有效的且可以工作的。但你不能将numberOfWindowsOpen
    = 1.5。
- en: '**COMMON DATA TYPES**'
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚刚学到的，数据类型让计算机知道它正在处理什么*类型*的数据，并且如何将其存储在内存中。那么，数据类型有哪些呢？一些常见的包括Int、Double、Float、Bool和String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解每个数据类型实际是什么！
- en: '**Int (Integers)**'
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Int（整数）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经稍微谈了一下整数，但让我们更详细地讲讲它们。在Swift中，整数（Int）是没有小数或分数部分的整数。你可以把它们看作是计数数字。整数是*有符号的*，这意味着它们可以是负数、正数或者零。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Double和Float（小数）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*小数*是指小数点后有数字的数字，例如3.14。（如果你希望它是一个小数，整数3会写作3.0。）有两种数据类型可以存储小数：Double和Float（即*浮点数*）。在Swift中，Double数据类型更常见，因为它可以保存更大的数字，所以我们将重点讲解它。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当你赋值给一个Double类型时，必须在小数点左边有一个数字，否则会报错。例如，假设香蕉每个19美分：
- en: '![Image](Image00050.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码会报错，因为它在小数点左侧没有数字。➋ 处的代码没有问题，因为它有一个前导零。（“// ERROR”和“// CORRECT”是*注释*，它们是程序中的说明，计算机会忽略这些内容。请参阅[“关于注释的一些快速说明”](text00012.html#ch02sb01)，详见[第
    32 页](text00012.html#page_32)。）
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Bool（布尔类型，或真/假）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*布尔值*只能是两者之一：真（true）或假（false）。在 Swift 中，布尔数据类型称为 Bool。
- en: '![Image](Image00051.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值通常用于 if-else 语句中，告诉计算机程序应该走哪条路径。（我们将在[第 3 章](text00013.html#ch03) 中更详细地讨论布尔值和
    if-else 语句。）
- en: '**String**'
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**String**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: String 数据类型用于存储单词和短语。一个*字符串*是由一系列字符组成，并被引号括起来。例如，"Hello, playground" 就是一个字符串。字符串可以由各种字符组成：字母、数字、符号等等。引号很重要，因为它告诉计算机，引号之间的内容是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串连接在一起，来构建句子，这个过程叫做字符串*连接*。让我们看看它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将字符串与加号（+）连接，这段代码创建了一个名为 specialGreeting 的变量，并赋值为字符串 "Good Morning Jude"。注意，在
    morningGreeting 和 friend 之间需要加上包含空格字符（" "）的字符串，否则 specialGreeting 会变成 "Good MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，有时候我们在声明一个变量时会包含数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们不包含数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事？计算机其实非常聪明，通常可以自行判断数据类型。这被称为*类型推断*——因为计算机会根据我们提供的线索*推断*（或猜测）我们使用的数据类型。当你创建一个变量并为它赋一个初始值时，这个值对计算机来说是一个很重要的线索。以下是一些示例：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个没有小数点的数字（比如 3），计算机会认为它是一个 Int 类型。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个有小数点的数字（比如 3.14），计算机会认为它是一个 Double 类型。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值*true* 或 *false*（没有引号），计算机会认为它是一个 Bool 类型。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个或多个用引号括起来的字符，计算机会认为它是一个 String 类型。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量会被设置为该数据类型，就像你自己声明数据类型一样。这完全是为了方便。你可以在每次声明新常量或变量时都写上数据类型，这完全可以。但为什么不让计算机自动推断出来，省下时间和打字呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**通过类型转换改变数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换* 是一种临时改变变量或常量数据类型的方法。你可以把它当作对变量施下的一个魔法——你让它的值像其他数据类型一样表现，但只是暂时的。要做到这一点，你需要写出一个新的数据类型，并在其后加上包含你正在转换的变量的括号。请注意，这*并不会实际改变数据类型*。它只是在这一行代码中为你提供一个临时的值。以下是
    Int 和 Double 之间进行类型转换的几个示例。查看代码的结果，可以看到这些转换的效果。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![Image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Int 类型的变量 months 转换为 Double，并将其存储在一个新的变量 doubleMonths 中。这样就添加了一个小数点，转换后的结果是
    12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将 Double 转换为 Int：
- en: '![Image](Image00058.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Double 类型的变量 days 转换为 Int。你可以看到小数点和所有后续的数字都被去掉了：我们的数字变成了 365。这是因为
    Int 类型无法保存小数，它只能包含整数，因此小数点后的内容会被截断。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，类型转换并不会真正改变数据类型。在我们的例子中，即使进行了类型转换，days 仍然是*Double* 类型。我们可以通过打印 days 来验证这一点：
- en: '![Image](Image00059.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 结果侧边栏显示 days 仍然等于 365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将介绍一些使用类型转换的示例。如果你现在还不清楚为什么要进行类型转换，请稍等片刻！
- en: '**OPERATORS**'
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中有许多算术运算符，你可以用它们来进行数学运算。你已经见过基本的赋值运算符 = 。你可能也熟悉加法 (+)、减法 (-)、乘法 (*)
    和除法 (/ )。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符对 Int、Float 和 Double 数据类型进行数学运算。被操作的数字叫做*操作数*。通过在你的 Playground 中输入如下代码，试验这些数学运算符：
- en: '![Image](Image00060.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Playground 中输入这段代码，你会看到每个数学表达式的结果出现在侧边栏。编写数学表达式的代码与正常书写数学表达式并没有太大区别。例如，16
    减去 2 可以写作 16 – 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数学表达式的结果保存到变量或常量中，以便在代码的其他地方使用。要了解如何操作，请在 Playground 中输入以下代码：
- en: '![Image](Image00061.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印 sum ➊ 时，你会在侧边栏看到 7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在数学表达式中只使用了数字，但数学运算符同样适用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的 playground 中：
- en: '![Image](Image00062.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以像对数字一样，对变量和常量使用数学运算符。
- en: '**SPACES MATTER**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，运算符两边的空格非常重要。你可以在数学运算符两边各写一个空格，或者完全不写空格。但不能只在运算符的一边加空格，而另一边不加。那样会导致错误。看看[图
    2-7](text00012.html#ch02fig7)。
- en: '![image](Image00063.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：确保运算符两边的空格数量相同。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件重要的事情需要注意：你只能对*相同*数据类型的变量或常量使用数学运算符。在之前的代码中，数字三和五都是 Int 数据类型。常量 half 和 quarter
    是 Double 数据类型，因为它们是小数。如果你尝试将 Int 和 Double 相加或相乘，你会遇到像[图 2-8](text00012.html#ch02fig8)中那样的错误。
- en: '![image](Image00064.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-8：在 Swift 中，你不能对混合数据类型进行数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 可是，如果你真的想对混合数据类型进行数学运算怎么办？比如，假设你想计算你年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行会导致错误，因为我们尝试将 Int 与 Double 相乘。但别担心！你有几个方法可以确保操作数是相同的数据类型。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是将 myAge 声明为 Double 类型，如下所示：
- en: '![Image](Image00066.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以正常工作，因为我们在对两个 Double 数据类型进行乘法运算。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是使用类型转换。（我告诉过你我们会回到这个话题！）类型转换在这种情况下是一个很好的解决方案，因为我们不想将 myAge 永久转换为 Double
    类型，我们只是想将它当作 Double 来进行数学运算。我们来看一个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们先将 myAge 转换为 Double 类型，再进行乘法运算。这样我们就不再有混合类型了，代码可以正常工作。但在 ➋ 处，我们会遇到错误。这是因为
    myAge 仍然是 Int 类型。我们在 ➊ 处将它转换为 Double 类型，但这个转换并没有永久改变它的类型。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 multiplier 转换为 Int 吗？当然可以！这样我们就可以对两个整数进行运算，结果是正确的。不过，这样会导致计算精度降低，因为我们会丢失小数部分。当你将一个
    Double 类型的变量转换为 Int 时，计算机会直接去掉小数点后的数字，使其成为一个整数。在这种情况下，你的 multiplier 0.1 会被转换为
    0。让我们在 playground 中转换一些变量，看看会得到什么：
- en: '![Image](Image00068.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ ，将我们的 Double 类型转换为 Int 时，得到的是 0。这个值在转换后有很大不同，因为我们失去了小数部分：0.1 变成了 0。如果我们没有预料到这种情况，这可能会对我们的代码产生非常不好的影响。你必须小心在转换时，确保不会无意中改变你的值。在
    ➋ ，这里有另一个将 Double 转换为 Int 的例子，正如你所看到的，1.9 并没有被四舍五入成 2。它的小数部分只是被去掉了，最终我们得到了 1。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个数学运算符，*取模运算符*（%），它可能对你来说不太熟悉。取模运算符（也叫 *模数*）给出除法后的余数。例如，7 % 2 = 1，因为 7 除以
    2 的余数是 1。你可以在你的 playground 中尝试一下取模运算符，像这样。
- en: '![Image](Image00069.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，取模运算符对判断一个数字是偶数（evenNumber % 2 等于 0） ➊ 还是奇数（oddNumber % 2 等于 1） ➋ 非常有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算顺序**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们每行代码只做了一个数学运算，但在一行代码中做多个运算是很常见的。让我们看一个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元的钞票和两张一美元的钞票，你有多少钱？我们在一行代码中计算一下：
- en: '![Image](Image00070.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将值 17 赋给 myMoney。计算机会先计算 5 乘以 3，然后再加上 2。但是计算机是怎么知道先乘法再加法的呢？它仅仅是从左到右工作吗？不！看看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们改变了数字的位置，但结果仍然是 17。如果计算机仅仅从左到右执行，它会先将 2 + 5 相加得到 7。然后它会将这个结果 7 乘以 3，得到 21。即使我们改变了数学表达式中数字的顺序，计算机仍然会先做乘法（得到
    15），然后加上 2 得到 17。*计算机会始终先执行乘法和除法，然后才是加法和减法*。这被称为 *运算顺序*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号的运算顺序**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必像在钱的例子中那样依赖计算机来决定先做哪一步。你，作为程序员，有权决定！你可以使用括号将运算组合在一起。当你把括号加到某个部分时，你是在告诉计算机先做这一步：
- en: '![Image](Image00072.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ ，括号告诉计算机先计算 5 乘以 3，然后再加上 2。这会得到 17。 在 ➋ ，括号告诉计算机先计算 2 加 5，然后再将结果乘以 3，得到
    21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在括号内部再使用括号来让代码更加精确。计算机会先计算内部的括号，然后再计算外部的。试试看这个例子：
- en: '![Image](Image00073.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，计算机会将内括号中的2和3相加。然后，它会将结果乘以4，因为这是外括号内的部分。最后，它会将1加上，因为它在两个括号外面。最终结果是21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值运算符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的另一类运算符是*复合赋值运算符*。这些是将数学运算符与赋值运算符（=）结合的“快捷”运算符。例如，以下表达式
- en: '[PRE5]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: becomes
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 变成
- en: '[PRE6]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符通过对变量或常量执行操作来更新其值。通俗地说，像`a += b`这样的表达式表示“将b加到a上，并将新值存储到a中。”[表 2-1](text00012.html#ch2tab1)展示了使用复合赋值运算符的数学表达式及其长格式表达式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-1：** 短格式赋值运算符与长格式表达式'
- en: '| **Short form** | **Long form** |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| **短格式** | **长格式** |'
- en: '| --- | --- |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`+=`运算符的实际应用。假设我们正在编写一个程序来计算方舟上动物的数量。首先，我们创建一个名为animalsOnArk的变量，并将其设置为0，因为方舟上还没有动物。当不同种类的动物登上方舟时，我们希望增加animalsOnArk的值来计算所有动物的数量。如果两只长颈鹿登上方舟，那么我们需要将2加到animalsOnArk。如果两只大象登上方舟，那么我们需要再加2。如果四只羚羊登上方舟，那么我们需要将animalsOnArk增加4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00074.jpg)![Image](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在两只长颈鹿、两只大象和四只羚羊登上方舟后，animalsOnArk的最终值为8。真是一个动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的几点快速说明**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都提供了一种方式来在代码中添加内联注释。注释是计算机忽略的注释，用来帮助阅读代码的程序员理解发生了什么。尽管没有注释程序依然可以正常运行，但对于那些可能不清楚或令人困惑的代码段，最好加上注释。即使你不打算将程序展示给别人，注释也会帮助你记住当时编写代码时的思路。你很可能会在几个月或几年后回到某段代码，却完全忘记当时的思考过程。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中有两种方式添加注释。第一种方式是在你想添加注释的文本前加上两个正斜杠（//）。这些注释可以单独放在一行，就像这样：
- en: '[PRE7]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它们也可以放在与代码行相同的行内，只要注释在代码*之后*：
- en: '[PRE8]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式用于长注释或*多行*注释，其中注释的开始和结束由/* 和 */标记。（请注意，在本书中，我们将使用-- *snip* --来表示我们为节省空间而省略的更多代码行。）
- en: '[PRE9]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不想让计算机运行代码的某部分，因为你正在尝试查找错误，但又不想删除你辛辛苦苦写的代码，可以使用多行注释来临时*注释掉*部分代码。当你将一块代码格式化为注释时，计算机会像忽略其他注释一样忽略这段代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在 Swift playground 中编写代码，这样你可以立即看到结果。你创建了变量和常量，并学习了如何使用基本数据类型和运算符，这些内容将在你编写自己的计算机程序时反复出现。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](text00013.html#ch03)中，你将使用条件语句，这些语句告诉计算机你希望它执行哪条代码路径。代码路径的选择取决于条件的值。
- en: '![image](Image00001.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00001.jpg)'
- en: A “[Hello, world!](text00011.html#ch01) ” app is no small accomplishment, but
    now it’s time to really learn how to write some code. Xcode provides a special
    type of document called a *playground* , which is a great place to learn how to
    program. In a playground, you can write and run code immediately to see the results,
    without going through the trouble of writing a whole app, as we did in [Chapter
    1](text00011.html#ch01) .
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 一个“[Hello, world!](text00011.html#ch01)”应用程序是一个不小的成就，但现在是时候真正学习如何编写代码了。Xcode
    提供了一种特殊类型的文档，叫做*playground*，这是学习编程的好地方。在 playground 中，你可以立即编写和运行代码，看到结果，而无需像我们在[第
    1 章](text00011.html#ch01)中那样麻烦地编写整个应用程序。
- en: Let’s open a playground. Open Xcode and select **Get started with a playground**
    , as shown in the Welcome to Xcode dialog in [Figure 2-1](text00012.html#ch02fig1)
    . If this window doesn’t automatically open, select **Welcome to Xcode** from
    the Window option in the menu or press ⌘ -SHIFT -1.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开一个 playground。打开 Xcode 并选择**开始使用 playground**，如[图 2-1](text00012.html#ch02fig1)中“欢迎使用
    Xcode”对话框所示。如果这个窗口没有自动打开，可以从菜单中的“窗口”选项选择**欢迎使用 Xcode**，或者按 ⌘-SHIFT-1。
- en: '![image](Image00033.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00033.jpg)'
- en: '*Figure 2-1: Getting started with a playground*'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：开始使用 playground*'
- en: You’ll be asked to name your playground ([Figure 2-2](text00012.html#ch02fig2)
    ). In this example, we’ll keep the default name *MyPlayground* . Make sure that
    you choose iOS as the platform to run the playground.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被要求为你的 playground 命名（[图 2-2](text00012.html#ch02fig2)）。在这个例子中，我们将保持默认名称*MyPlayground*。确保选择
    iOS 作为运行 playground 的平台。
- en: '![image](Image00034.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00034.jpg)'
- en: '*Figure 2-2: Naming the playground and selecting the platform*'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：命名 playground 并选择平台*'
- en: When the playground first opens, you’ll see two panels in the window, just like
    in [Figure 2-3](text00012.html#ch02fig3) . On the left is the playground editor,
    where you’ll write your code. On the right is the results sidebar, which displays
    the results of your code.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当 playground 首次打开时，你会看到窗口中有两个面板，正如在[图 2-3](text00012.html#ch02fig3)中所示。左侧是 playground
    编辑器，你将在其中编写代码。右侧是结果侧边栏，显示你的代码结果。
- en: The line var str = "Hello, playground" in [Figure 2-3](text00012.html#ch02fig3)
    creates a variable named str . A *variable* is like a container; you can use it
    to hold almost anything—a simple number, a string of letters, or a complex object
    (we’ll explain what that is later). Let’s take a closer look at how variables
    work.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-3](text00012.html#ch02fig3)中的代码行 var str = "Hello, playground" 创建了一个名为
    str 的变量。*变量*就像一个容器；你可以用它来存储几乎任何东西——一个简单的数字、一串字母，或者一个复杂的对象（我们稍后会解释这是什么）。让我们更详细地看看变量是如何工作的。'
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00035.jpg)![image](Image00036.jpg)'
- en: '*Figure 2-3: Playground editor and results sidebar*'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：Playground 编辑器和结果侧边栏*'
- en: '**CONSTANTS AND VARIABLES**'
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**常量和变量**'
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是来自[图 2-3](text00012.html#ch02fig3)的代码行：
- en: '![Image](Image00037.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00037.jpg)'
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 它做了两件事。首先，它创建了一个名为 str 的变量。这被称为*声明*，因为我们正在声明我们希望创建一个变量。要创建一个变量，你输入关键字 var，然后为你的变量起一个名字——在这个例子中是
    str。命名变量时有一些规则，我们稍后会讨论，所以现在就按照这个例子来。
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这一行代码使用 = 操作符将“Hello, playground”赋值给 str。这被称为*赋值*，因为我们正在将一个值赋给我们新创建的变量。记住，你可以把变量看作一个容器，用来存放某些东西。现在我们有了一个名为
    str 的容器，它保存着“Hello, playground”。
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这一行代码理解为“变量 str 等于 Hello, playground”。正如你所看到的，Swift 通常非常易读；这一行代码几乎用英语告诉你它在做什么。
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 变量很有用，因为如果你想打印“Hello, playground”这句话，你只需要在 str 上使用命令 print，如以下代码所示：
- en: '![Image](Image00038.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00038.jpg)'
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在结果侧边栏中打印“Hello, playground\n”。\n 会自动加在你打印的内容末尾。它被称为*换行符*，它告诉计算机换到新的一行。
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看程序的实际运行结果，可以打开调试区域，它会出现在两个面板下方，如[图 2-4](text00012.html#ch02fig4)所示。操作方法是，在
    Xcode 菜单中选择**视图** ▸ **调试区域** ▸ **显示调试区域**，或按下 ⌘ -SHIFT -Y。当在调试区域的控制台中打印 str 时，你会发现围绕着“Hello,
    playground”的引号和换行符并没有出现。这就是如果你正式运行这个程序时，str 的真实样子！
- en: '![image](Image00039.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：在调试区域查看程序的实际输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在你的程序中是可以变化的（或者说*变化*！），所以你可以改变一个变量的值，让它保存其他内容。现在就试试看吧。将以下几行代码添加到你的 playground
    中。
- en: '![Image](Image00040.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变一个变量的值，输入它的名称，并使用 = 操作符将其设置为新值。我们在 ➊ 处这样做，将 str 的值改为“Hello, world”。计算机会丢弃
    str 原来保存的内容，并说：“好的，老板，str 现在是 Hello, world”（当然，如果它能说话的话！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们改变 str 的值时，我们并没有再次写 var。计算机记住了我们在之前的代码行中声明了 str，并知道 str 已经存在。所以我们不需要重新创建
    str，我们只需要为它赋予不同的值。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以声明 *常量*。与变量一样，常量也存储值。常量与变量的最大区别在于常量的值永远无法改变。变量可以变化，而常量则是恒定的！声明常量与声明变量类似，但我们使用
    let 而不是 var：
- en: '![Image](Image00041.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 myName 的常量，并将其赋值为 "Gloria"。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个常量并赋予它一个值，它将一直保持这个值，直到永远。可以把常量想象成一块大岩石，你在上面刻下了这个值。如果你尝试给 myName 赋予另一个值，比如
    "Matt"，你会看到像 [图 2-5](text00012.html#ch02fig5) 中那样的错误。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00042.jpg)![image](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：尝试更改常量的值是行不通的。*'
- en: '**NOTE**'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 Playground 中，错误会以一个红色圆圈显示，其中有一个小小的白色圆点。点击错误标记会显示错误信息，并告诉你哪里出错了。如果你显示了调试区域，你也会看到描述发生了什么的信息，有时甚至会告诉你如何修复它。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-391
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量——做得好！但是，什么时候应该使用一个而不是另一个呢？在 Swift 中，最好是使用常量而不是变量，除非你预期该值会改变。常量有助于让代码更加“安全”。如果你知道某个值永远不会改变，为什么不把它刻进石头里，避免以后出现任何混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想跟踪教室里窗户的总数以及今天开着的窗户数。教室里的窗户数量不会改变，因此应该使用常量来存储这个值。教室里开着的窗户数会根据天气和时间而变化，因此应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00044.jpg)![image](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 numberOfWindows 设为常量，并将其值设为 8，因为窗户的总数始终是 8。我们将 numberOfWindowsOpen 设为变量，并将其值设为
    3，因为在打开或关闭窗户时，我们需要更改该值。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用 var 来定义变量，使用 let 来定义常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-397
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**命名常量和变量**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以给变量或常量起任何名字，但有一些例外。你不能把它们命名为已经是 Swift 关键字的词。例如，你不能命名一个变量为 var。写 var var
    会让你和计算机都感到困惑。如果你尝试使用 Swift 的保留字命名变量或常量，你会遇到错误。你也不能在同一代码块中有两个同名的变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则外，命名时还有一些其他好的编程指南可以遵循。你的名字应该总是以小写字母开头。给变量起个*非常*有描述性的名字也是个好主意（它们可以尽可能长）。当你使用一个描述性的名字时，理解该变量或常量的用途就变得容易多了。如果你在看别人的代码，哪个变量名更容易理解：numKids
    还是 numberOfKidsInMyClass？第一个名字模糊不清，但第二个名字却很具描述性。常见的变量和常量命名方式是将一串单词连接在一起，比如numberOfKidsInMyClass。每个单词的首字母大写的这种命名风格叫做*驼峰命名法*，因为这种大小写字母的模式看起来像是骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，你可以选择变量或常量将存储什么样的数据——*数据类型*。记得我们说过，你可以把变量当作一个容器来存放某些东西吗？嗯，数据类型就像是容器类型。计算机需要知道我们将把什么样的东西放进每个容器里。在Swift编程中，一旦你告诉计算机你希望变量或常量存储某个数据类型，它就不会让你往该变量或常量中放入除该数据类型之外的任何东西。如果你有一个设计用来装土豆的篮子，把它装满水显然是个糟糕的主意——除非你喜欢水漏得到处都是！
- en: '![image](Image00047.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-404
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，你可以告诉计算机它将存储哪种类型的数据。在我们关于教室窗户的例子中，我们知道这个变量将始终是一个*整数*（即一个整数——你不可能有半个窗户），所以我们可以指定一个整数数据类型，像这样：
- en: '![Image](Image00048.jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示“是类型”。用通俗的语言来说，这行代码的意思是：“变量numberOfWindowsOpen，它是一个整数，等于3。”所以这一行代码创建了一个变量，给它命名，告诉计算机它的数据类型，并赋予它一个值。呼！一行代码就做了这一切？我们提到过Swift是一个非常*简洁*的语言吗？有些语言可能需要多行代码来完成相同的操作。Swift的设计让你只需用一行代码就能做很多事！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要声明一次数据类型。当我们告诉计算机某个变量将存储整数时，我们不需要再次告诉它。实际上，如果我们再这样做，Xcode会给我们一个错误。一旦声明了数据类型，变量或常量将永远保持该数据类型。一次整数，永远是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要知道一件事：变量或常量不能存储与其数据类型不匹配的内容。例如，如果你尝试将小数存储到 numberOfWindowsOpen 中，你将会得到一个错误，如[图
    2-6](text00012.html#ch02fig6)所示。
- en: '![image](Image00049.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：你不能将小数存储到应当存储整数的变量中。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 将 numberOfWindowsOpen = 5 和 numberOfWindowsOpen = 0 是有效的，并且可以正常工作。但你不能将 numberOfWindowsOpen
    设置为 1.5。
- en: '**COMMON DATA TYPES**'
  id: totrans-413
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所学，数据类型告诉计算机它正在处理哪种*类型*的数据，以及如何在内存中存储它。那么，数据类型到底是什么呢？一些常见的数据类型包括 Int、Double、Float、Bool
    和 String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下这些数据类型的具体含义！
- en: '**Int (Integers)**'
  id: totrans-416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**整数（Int）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经稍微讨论过整数，但让我们再详细了解一下它们。在 Swift 中，整数（Int）是没有小数或分数部分的整数。你可以把它们当作计数数字。整数是*有符号的*，意味着它们可以是负数、正数或零。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-418
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**双精度浮点数和浮点数（小数）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '*小数*是指在小数点后有数字的数字，例如 3.14。（如果你想将整数 3 表示为小数，可以写作 3.0。）有两种数据类型可以存储小数：Double 和
    Float（浮动点数的简写）。在 Swift 中，Double 数据类型更为常见，因为它可以存储更大的数字，因此我们将重点讨论 Double。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 当你赋值一个 Double 时，必须在小数点左边有一个数字，否则你会得到错误。例如，假设香蕉的价格是每个 19 分：
- en: '![Image](Image00050.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码会导致错误，因为它没有小数点左边的数字。➋ 处的代码没有问题，因为它有一个前导零。（// ERROR 和 // CORRECT 是 *注释*，它们是程序中的备注，计算机会忽略这些注释。请参见
    “[关于注释的一些快速说明](text00012.html#ch02sb01)” 第 32 页 [page 32](text00012.html#page_32)。）
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**布尔值（Bool，真/假）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值*只能是两种值之一：true 或 false。在 Swift 中，布尔数据类型叫做 Bool。'
- en: '![Image](Image00051.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值通常用于 if-else 语句中，告诉计算机程序应当走哪条路径。（我们将在[第 3 章](text00013.html#ch03) 中更详细地讲解布尔值和
    if-else 语句。）
- en: '**String**'
  id: totrans-427
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符串**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: String 数据类型用于存储单词和短语。*字符串*是由引号括起来的一组字符。例如，"Hello, playground" 就是一个字符串。字符串可以由各种各样的字符组成：字母、数字、符号等等。引号非常重要，因为它们告诉计算机引号中的内容是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串相加来构建句子，这个过程叫做字符串*连接*。让我们来看一下它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用加号（+）将字符串相加，这段代码创建了一个名为specialGreeting的变量，值为字符串"Good Morning Jude"。注意，我们需要在morningGreeting和friend之间添加一个包含空格字符（"
    "）的字符串，否则specialGreeting将会是"Good MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-433
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，有时我们声明一个变量时，会包括数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们并不包括数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事？实际上，计算机足够智能，能够推断出数据类型，大多数时候都是如此。这就是所谓的*类型推断*——因为计算机会根据我们提供的线索*推断*（或者猜测）我们使用的数据类型。当你创建一个变量并给它一个初始值时，这个值就是计算机的一个重要线索。以下是一些示例：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个没有小数值的数字（如3），计算机会假定它是一个Int类型。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个带小数的数字（如3.14），计算机会假定它是一个Double类型。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个*true*或*false*（没有引号），计算机会假定它是一个Bool类型。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个带引号的字符，计算机会假定它是一个String类型。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量会被设定为该数据类型，就像你自己声明数据类型一样。这完全是为了方便。你可以在每次声明新的常量或变量时都包括数据类型，这完全没有问题。但是，为什么不让计算机自己推断出来，从而节省时间并减少多余的输入呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-444
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**通过类型转换变换数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换*是一种临时转换变量或常量数据类型的方法。你可以把它看作是对变量施放一个魔法——你让它的值表现得像另一个数据类型，但只是短暂的。要做到这一点，你写下新的数据类型，后面跟着括号，括号里放着你要转换的变量。注意，这*并不会真正改变数据类型*。它只是为这一行代码提供一个临时值。以下是一些Int和Double之间的类型转换示例。查看你的代码在结果侧边栏中的输出。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![Image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将Int类型的变量months转换为Double类型，并将其存储在一个新的变量doubleMonths中。这会添加一个小数点，转换后的结果是12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将一个Double类型转换为Int类型：
- en: '![Image](Image00058.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将Double类型的days转换为Int类型。你可以看到小数点和其后的所有数字都被去掉了：我们的数字变成了365。这是因为Int类型不能存储小数，只能包含整数，所以小数点后的部分会被截断。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，类型转换并不会真正改变数据类型。在我们的例子中，即使经过转换，days*仍然*是一个Double类型。我们可以通过打印days来验证这一点：
- en: '![Image](Image00059.jpg)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 结果侧边栏显示天数仍然等于365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将介绍一些关于何时以及如何使用类型转换的例子。所以如果你现在不清楚为什么需要转换变量，稍等一下吧！
- en: '**OPERATORS**'
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中有许多算术运算符，可以用来进行数学运算。你已经见过基本的赋值运算符 = 。你可能也熟悉加法 (+)、减法 (-)、乘法 (*) 和除法 (/)。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符对Int、Float和Double数据类型进行数学运算。正在操作的数字被称为*操作数*。在你的Playground中，通过输入以下代码，试着使用这些数学运算符进行实验：
- en: '![Image](Image00060.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在你的 Playground 中输入这段代码，你会看到每个数学表达式的结果出现在侧边栏中。在代码中编写数学表达式和正常书写它们并没有太大区别。例如，16减去2可以写成16
    – 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数学表达式的结果保存在变量或常量中，这样你就可以在代码的其他地方使用它。为了查看如何操作，在你的Playground中输入以下几行代码：
- en: '![Image](Image00061.jpg)'
  id: totrans-461
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印sum ➊时，你会在侧边栏看到7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在数学表达式中使用了数字，但数学运算符同样适用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的Playground：
- en: '![Image](Image00062.jpg)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以像对数字一样，对变量和常量使用数学运算符。
- en: '**SPACES MATTER**'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，运算符两边的空格非常重要。你可以在运算符两边写空格，或者完全不加空格。但你不能只在一个运算符的一边加空格，另一边不加，这会导致错误。看看[图2-7](text00012.html#ch02fig7)。
- en: '![image](Image00063.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-7：确保运算符两边的空格数量相同。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点非常重要：你只能对相同数据类型的变量或常量使用数学运算符。在之前的代码中，三和五都是Int数据类型。常量half和quarter是Double数据类型，因为它们是小数。如果你尝试对一个Int和一个Double进行加法或乘法运算，你会得到类似[图2-8](text00012.html#ch02fig8)中的错误。
- en: '![image](Image00064.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-8：在Swift中，不能对混合数据类型进行数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你真的想对混合数据类型进行数学运算呢？例如，假设你想计算你年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行会报错，因为我们试图将一个Int与一个Double相乘。但别担心！你有几个选择来确保操作数是相同的数据类型。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是将myAge声明为Double类型，像这样：
- en: '![Image](Image00066.jpg)'
  id: totrans-478
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以正常运行，因为我们在对两个Double数据类型进行乘法运算。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选择是使用类型转换。（我告诉过你我们会回到这个话题！）在这种情况下，类型转换是一个很好的解决方案，因为我们不想永久地将myAge改成Double类型，我们只是希望能像对待Double类型一样对其进行数学运算。让我们看个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将myAge转换为Double类型后再进行乘法运算。这意味着我们不再有混合类型，因此代码可以正常运行。但在➋处，我们会遇到错误。那是因为myAge仍然是Int类型。在➊处将其转换为Double类型并没有永久改变它的类型。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能将乘数转换为Int吗？当然可以！然后我们就能对两个整数进行数学运算，这样是没问题的。然而，这会导致计算精度降低，因为我们会丢失小数部分。当你将一个变量从Double转换为Int时，计算机会简单地去掉小数点后的数字，使其变成一个整数。在这种情况下，你的0.1乘数会转换为Int类型的0。让我们在游乐场中进行一些变量转换，看看会得到什么结果：
- en: '![Image](Image00068.jpg)'
  id: totrans-484
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，将我们的Double类型变量multiplier转换为Int后得到0。转换后的值差异很大，因为我们丢失了小数部分：0.1变成了0。如果我们没有预料到这一点，这在我们的代码中可能会造成非常严重的问题。在进行类型转换时，你必须小心，以确保不会意外改变值。在➋处，另一个将Double转换为Int的例子，正如你所看到的，1.9没有四舍五入到2，它的小数部分被直接去掉，我们只剩下1。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个数学运算符，*模运算符*（%），它可能对你来说不太熟悉。模运算符（也叫做*取余*）给出除法后的余数。例如，7 % 2 = 1，因为7除以2的余数是1。试试在你的游乐场中使用模运算符，方法如下：
- en: '![Image](Image00069.jpg)'
  id: totrans-487
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，模运算符对于确定一个数字是偶数（evenNumber % 2 等于 0）➊或奇数（oddNumber % 2 等于 1）➋非常有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-489
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算顺序**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们每行代码只做了一次数学运算，但通常在一行代码中会做多个运算。让我们看个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元的钞票和两张一美元的钞票，你有多少钱？让我们在一行代码中计算一下：
- en: '![Image](Image00070.jpg)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为myMoney赋值17。计算机会先进行5乘3的运算，再加上2。但计算机是如何知道先乘法后加法的呢？它只是按从左到右的顺序工作吗？不是的！看看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移动了数字，结果仍然是17。如果计算机仅仅按从左到右的顺序进行，它会先计算2 + 5得到7。然后它会将结果7乘以3得到21。尽管我们改变了数学表达式中数字的顺序，但计算机仍然首先进行乘法运算（得到15），然后加上2，得到17。*计算机总是先进行乘法和除法运算，再进行加法和减法运算*。这就是所谓的*运算顺序*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-496
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号控制运算顺序**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必像在金钱例子中那样依赖计算机来判断该先做哪个步骤。你，程序员，有权决定！你可以使用括号将运算分组。当你在某个操作周围加上括号时，你告诉计算机先执行那一步：
- en: '![Image](Image00072.jpg)'
  id: totrans-498
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，括号告诉计算机先进行5乘3的运算，再加上2，这将得到17。在➋处，括号告诉计算机先将2与5相加，再乘以3，这样得到21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在其他括号内使用括号，你可以使代码更加具体。计算机会先计算内层的括号，再计算外层的括号。试试这个例子：
- en: '![Image](Image00073.jpg)'
  id: totrans-501
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机首先会在内层括号中将2和3相加。然后，它会将结果乘以4，因为它位于外层括号内。最后，它会将1加到结果中，因为它在两个括号外面。最终结果是21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-503
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值运算符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的另一类运算符是*复合赋值运算符*。这些是将数学运算符与赋值运算符（=）结合起来的“快捷”运算符。例如，这个表达式：
- en: '[PRE10]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: becomes
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 变成
- en: '[PRE11]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符通过对变量或常量执行运算来更新它的值。用通俗的话来说，像a += b这样的表达式表示“将b加到a上，并将新值存储在a中”。[表2-1](text00012.html#ch2tab1)展示了使用复合赋值运算符的数学表达式及其长形式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-1：** 简化赋值运算符与长形式表达式'
- en: '| **Short form** | **Long form** |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '| **简化形式** | **长形式** |'
- en: '| --- | --- |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 += 运算符的实际应用。假设我们正在编写一个程序来计算方舟上的动物数量。首先，我们创建一个名为 animalsOnArk 的变量，并将其设置为
    0，因为方舟上还没有动物。当不同种类的动物登上方舟时，我们希望增加 animalsOnArk 来统计所有动物。如果两只长颈鹿登上方舟，那么我们需要将 animalsOnArk
    加 2。如果两只大象登上方舟，那么我们再次将 animalsOnArk 加 2。如果四只羚羊登上方舟，那么我们需要将 animalsOnArk 增加 4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-517
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00074.jpg)![Image](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 在两只长颈鹿、两只大象和四只羚羊登上方舟后，animalsOnArk 的最终值是 8。真是一个动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的几点简短说明**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都有一种方法可以在代码中写内联注释。注释是被计算机忽略的说明，目的是帮助阅读代码的人理解代码的作用。虽然程序在没有注释的情况下也能正常运行，但在那些可能不太清晰或令人困惑的代码部分加入注释是个好主意。即使你不会把程序展示给别人看，注释也能帮助你记住自己在写代码时的想法。回过头来看你几个月或几年之前写的代码时，常常会对当时的想法一无所知。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中有两种添加注释的方式。第一种方式是在你想添加注释的文本前面加上两个斜杠（//）。这些注释可以单独放在一行，就像这样：
- en: '[PRE12]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它们也可以放在与代码同一行——只要注释位于代码的*后面*：
- en: '[PRE13]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式适用于长注释或*多行*注释，其中注释的开始和结束由 /* 和 */ 标记。（注意，在本书中我们将使用 -- *snip* -- 来表示我们省略的代码行，以节省空间。）
- en: '[PRE14]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不想让计算机运行代码中的某部分，因为你正在寻找一个错误，但你又不想删除所有辛苦写的代码，你可以使用多行注释来*暂时注释掉*某些代码块。当你将一段代码格式化为注释时，计算机会像忽略其他任何注释一样忽略这段代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-528
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在 Swift playground 中编写代码，这样你可以立刻看到结果。你创建了变量和常量，学习了如何使用基本的数据类型和运算符，这些内容在你编写自己的计算机程序时将会反复使用。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](text00013.html#ch03)，你将使用条件语句，告诉计算机你希望它走哪条代码路径。代码路径是根据条件的值来选择的。
- en: A “[Hello, world!](text00011.html#ch01) ” app is no small accomplishment, but
    now it’s time to really learn how to write some code. Xcode provides a special
    type of document called a *playground* , which is a great place to learn how to
    program. In a playground, you can write and run code immediately to see the results,
    without going through the trouble of writing a whole app, as we did in [Chapter
    1](text00011.html#ch01) .
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: “[Hello, world!](text00011.html#ch01)” 应用并不简单，但现在是时候真正学习如何编写代码了。Xcode 提供了一种特殊类型的文档，称为
    *playground*，这是一个学习编程的好地方。在 playground 中，你可以立即编写并运行代码，看到结果，而无需像我们在 [第 1 章](text00011.html#ch01)
    中那样编写整个应用。
- en: Let’s open a playground. Open Xcode and select **Get started with a playground**
    , as shown in the Welcome to Xcode dialog in [Figure 2-1](text00012.html#ch02fig1)
    . If this window doesn’t automatically open, select **Welcome to Xcode** from
    the Window option in the menu or press ⌘ -SHIFT -1.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开一个 playground。打开 Xcode 并选择 **Get started with a playground**，如 [图 2-1](text00012.html#ch02fig1)
    中的 Xcode 欢迎对话框所示。如果此窗口没有自动打开，可以从菜单的 Window 选项中选择 **Welcome to Xcode**，或者按 ⌘ -SHIFT
    -1。
- en: '![image](Image00033.jpg)'
  id: totrans-533
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00033.jpg)'
- en: '*Figure 2-1: Getting started with a playground*'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：开始使用 playground*'
- en: You’ll be asked to name your playground ([Figure 2-2](text00012.html#ch02fig2)
    ). In this example, we’ll keep the default name *MyPlayground* . Make sure that
    you choose iOS as the platform to run the playground.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为你的 playground 命名（[图 2-2](text00012.html#ch02fig2)）。在这个示例中，我们将保留默认名称 *MyPlayground*。确保选择
    iOS 作为运行 playground 的平台。
- en: '![image](Image00034.jpg)'
  id: totrans-536
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00034.jpg)'
- en: '*Figure 2-2: Naming the playground and selecting the platform*'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：命名 playground 并选择平台*'
- en: When the playground first opens, you’ll see two panels in the window, just like
    in [Figure 2-3](text00012.html#ch02fig3) . On the left is the playground editor,
    where you’ll write your code. On the right is the results sidebar, which displays
    the results of your code.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 当 playground 初次打开时，你会看到窗口中有两个面板，就像 [图 2-3](text00012.html#ch02fig3) 中所示。左侧是
    playground 编辑器，你将在其中编写代码；右侧是结果侧边栏，显示代码的执行结果。
- en: The line var str = "Hello, playground" in [Figure 2-3](text00012.html#ch02fig3)
    creates a variable named str . A *variable* is like a container; you can use it
    to hold almost anything—a simple number, a string of letters, or a complex object
    (we’ll explain what that is later). Let’s take a closer look at how variables
    work.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-3](text00012.html#ch02fig3) 中的代码行 var str = "Hello, playground" 创建了一个名为
    str 的变量。*变量*就像一个容器，你可以用它来保存几乎任何东西——一个简单的数字、一串字母，或者一个复杂的对象（我们稍后会解释这是什么）。让我们仔细看看变量是如何工作的。'
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  id: totrans-540
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00035.jpg)![image](Image00036.jpg)'
- en: '*Figure 2-3: Playground editor and results sidebar*'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：Playground 编辑器和结果侧边栏*'
- en: '**CONSTANTS AND VARIABLES**'
  id: totrans-542
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**常量和变量**'
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 [图 2-3](text00012.html#ch02fig3) 中的那行代码：
- en: '![Image](Image00037.jpg)'
  id: totrans-544
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00037.jpg)'
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 这做了两件事。首先，它创建了一个名为 str 的变量。这被称为 *声明*，因为我们声明了我们想要创建一个变量。要创建变量，你需要输入 var 这个关键词，然后给你的变量命名——在这个例子中是
    str。命名变量时有一些规则，我们稍后会讲解，所以现在先使用这个例子。
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这行代码使用 = 操作符给 str 赋值为 "Hello, playground"。这被称为 *赋值*，因为我们正在给新创建的变量分配一个值。记住，你可以把变量看作一个容器，用来存放东西。所以现在我们有一个名为
    str 的容器，它存放的是 "Hello, playground"。
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这一行代码理解为“变量 str 等于 Hello, playground。”正如你所见，Swift 通常非常易读；这行代码几乎用英语告诉你它在做什么。
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 变量非常方便，因为如果你想打印出“Hello, playground”，你只需要像下面的代码一样在 str 上使用 print 命令：
- en: '![Image](Image00038.jpg)'
  id: totrans-549
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00038.jpg)'
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在结果侧边栏中打印"Hello, playground\n"。\n会自动添加到你打印内容的末尾。它被称为*换行*字符，告诉计算机跳到下一行。
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看程序实际运行时的结果，打开调试区，调试区会出现在两个面板下方，如[图2-4](text00012.html#ch02fig4)所示。为此，去**视图**
    ▸ **调试区域** ▸ **显示调试区域**，或者按⌘ -SHIFT -Y。在调试区的控制台中打印str时，你可以看到“Hello, playground”周围的引号和换行符不会显示。这就是str如果你正式运行这个程序时的样子！
- en: '![image](Image00039.jpg)'
  id: totrans-552
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-4：在调试区查看你程序的实际输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以在你的程序中改变（或者*变化*！），因此你可以改变变量的值，让它保存其他东西。现在让我们试试。将以下行添加到你的 playground。
- en: '![Image](Image00040.jpg)'
  id: totrans-555
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变变量的值，输入变量名并使用=操作符将其设置为新值。我们在➊处这样做，将str的值改为"Hello, world"。计算机会抛弃str原本的值，并说：“好的，老板，str现在是Hello,
    world”（如果它能说话的话，它肯定会这么说！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们改变str的值时，我们没有再次写var。计算机会记得我们在之前的代码行中声明了str，并知道str已经存在。因此我们不需要再次创建str，只需要给它放入不同的值。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以声明*常量*。像变量一样，常量也保存值。常量和变量之间的最大区别在于，常量的值永远无法改变。而变量可以变化，常量则是，嗯，常量！声明常量和声明变量类似，但我们使用的是let而不是var：
- en: '![Image](Image00041.jpg)'
  id: totrans-559
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们创建了一个名为myName的常量，并将其值赋为"Gloria"。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个常量并赋予它一个值，它将一直保持这个值直到时间的尽头。可以把常量看作是一块大石头，你在上面刻下了你的值。如果你试图给myName另一个值，比如"Matt"，你会得到类似[图2-5](text00012.html#ch02fig5)中的错误。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-562
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00042.jpg)![image](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-5：尝试改变常量的值是行不通的。*'
- en: '**NOTE**'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '*在playground中，错误会以一个红色圆圈和一个小白点显示。点击错误标记会显示错误信息并告诉你哪里出错了。如果你打开了调试区域，你还会看到描述发生了什么的相关信息，有时甚至会告诉你如何修复它。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-566
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量——做得好！但是，什么时候应该使用一个而不是另一个呢？在 Swift 中，除非你预计值会变化，否则最佳实践是使用常量而非变量。常量有助于使代码更加“安全”。如果你知道某个值永远不会改变，为什么不将其“刻在石头上”，避免将来可能的混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想跟踪你教室里窗户的总数和今天打开的窗户数量。你教室里窗户的数量不会改变，因此你应该使用常量来存储这个值。然而，教室里打开的窗户数量会根据天气和一天中的时间变化，所以你应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-569
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00044.jpg)![Image](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `numberOfWindows` 设为常量并将其设置为 8，因为窗户的总数始终是 8。我们将 `numberOfWindowsOpen` 设为变量并将其设置为
    3，因为当我们打开或关闭窗户时，我们需要改变这个值。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用 `var` 来声明变量，使用 `let` 来声明常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-572
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常量和变量的命名**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以随意为变量或常量命名，只有少数例外。你不能使用已经是 Swift 关键字的词汇命名。例如，你不能命名一个变量为 var。写 `var var`
    会让你和计算机都感到困惑。如果你尝试使用 Swift 的保留字来命名变量或常量，你会得到一个错误。你也不能在同一个代码块中有两个相同名称的变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则之外，在 Swift 中命名时还有一些其他良好的编程规范。你的变量名应该始终以小写字母开头。使用*非常*具描述性的名称也是一个好主意（名称可以尽可能长）。使用描述性名称时，理解这个变量或常量的作用会更加容易。如果你在查看别人的代码，你觉得哪个变量名更容易理解：`numKids`
    还是 `numberOfKidsInMyClass`？第一个名称模糊，而第二个名称则很具描述性。常见的变量和常量命名方式是将多个单词连接在一起，如 `numberOfKidsInMyClass`。这种将多个单词的首字母大写的命名风格被称为*驼峰式命名法*。之所以叫这个名字，是因为字母的大小写模式看起来像骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-575
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-576
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，你可以选择你希望变量或常量保存哪种类型的数据——即*数据类型*。还记得我们之前说过，你可以把变量当作一个容器来理解吗？数据类型就像是容器的类型。计算机需要知道我们将把什么样的东西放入每个容器中。在Swift编程中，一旦你告诉计算机一个变量或常量将保存某种数据类型，它就不会允许你在该变量或常量中放入除该数据类型之外的任何东西。如果你有一个设计用来装土豆的篮子，把篮子装满水是个坏主意——除非你喜欢水漏得满鞋子都是！
- en: '![image](Image00047.jpg)'
  id: totrans-578
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-579
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，你可以告诉计算机它将保存什么类型的数据。在我们关于教室窗户的例子中，我们知道这个变量将始终是一个*整数*（也就是一个整数——你不可能有半个窗户），所以我们可以指定一个整数数据类型，像这样：
- en: '![Image](Image00048.jpg)'
  id: totrans-581
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示“是某种类型”。用简单的语言来说，这行代码的意思是：“变量numberOfWindowsOpen，它是一个整数，等于3。”所以这行代码创建了一个变量，给它起了个名字，告诉计算机它的数据类型，并给它赋值。呼！一行代码做了这一切？我们是不是提到过Swift是一种非常*简洁*的语言？一些语言可能需要几行代码来做同样的事情。而Swift的设计让你能够用一行代码做很多事情！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要声明一次数据类型。当我们告诉计算机一个变量将保存整数时，我们不需要再次告诉它。事实上，如果我们再做这样的声明，Xcode会给我们一个错误。一旦数据类型被声明，变量或常量将永远保存该类型的数据。一旦是整数，永远是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件你需要了解的关于数据类型的事：一个变量或常量不能保存不属于其数据类型的东西。例如，如果你尝试把一个小数放入numberOfWindowsOpen，你将会得到一个错误，正如在[图2-6](text00012.html#ch02fig6)中所示。
- en: '![image](Image00049.jpg)'
  id: totrans-585
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-6：你不能把小数放入应该保存整数的变量中。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 设置numberOfWindowsOpen = 5和numberOfWindowsOpen = 0是有效的且可行的。但你不能设置numberOfWindowsOpen
    = 1.5。
- en: '**COMMON DATA TYPES**'
  id: totrans-588
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 如你刚刚学到的，数据类型让计算机知道它正在处理的是什么*类型*的数据，以及如何将其存储在内存中。那么数据类型都有哪些呢？一些常见的有Int、Double、Float、Bool和String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下这些数据类型到底是什么！
- en: '**Int (Integers)**'
  id: totrans-591
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Int（整数）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经稍微讨论了一些整数，接下来让我们更详细地讲解它们。在 Swift 中，整数（Int）是没有小数或分数部分的整数。你可以把它们看作是计数数字。整数是
    *有符号的* ，意味着它们可以是负数、正数或零。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-593
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Double 和 Float（十进制数）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '*十进制数* 是在小数点后有数字的数字，比如 3.14。（如果你希望整数像 3 一样表示为十进制数，可以写成 3.0。）有两种数据类型可以存储十进制数：Double
    和 Float（即 *浮动点数*）。在 Swift 中，Double 数据类型更常见，因为它可以存储更大的数字，因此我们将重点讨论它们。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 当你赋值给一个 Double 时，必须确保小数点左边有一个数字，否则会出现错误。例如，假设香蕉每个 19 分：
- en: '![Image](Image00050.jpg)'
  id: totrans-596
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码会导致错误，因为它没有小数点左边的数字。➋ 处的代码则正常工作，因为它有一个前导零。（短语 // ERROR 和 // CORRECT 是
    *注释* ，注释是程序中的说明，计算机会忽略它们。参见 “[关于注释的简短说明](text00012.html#ch02sb01)” [第 32 页](text00012.html#page_32)
    。）
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-598
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Bool（布尔值，或真/假）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值* 只能是两者之一：true 或 false。在 Swift 中，布尔数据类型叫做 Bool。'
- en: '![Image](Image00051.jpg)'
  id: totrans-600
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值通常用于 if-else 语句中，以告诉计算机程序应该走哪条路径。（我们将在[第 3 章](text00013.html#ch03)中更详细地介绍布尔值和
    if-else 语句。）
- en: '**String**'
  id: totrans-602
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符串**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: String 数据类型用于存储单词和短语。一个 *字符串* 是由引号括起来的一系列字符。例如，"Hello, playground" 就是一个字符串。字符串可以由各种字符组成：字母、数字、符号等等。引号很重要，因为它们告诉计算机，所有在引号中的内容都是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串连接在一起，以构建句子，这个过程叫做字符串 *连接*。让我们来看一下它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-605
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用加号（+）将字符串连接起来，这段代码创建了一个名为 specialGreeting 的变量，值为字符串 "Good Morning Jude"。请注意，我们需要在
    morningGreeting 和 friend 之间添加一个包含空格字符（" "）的字符串，否则 specialGreeting 的值将是 "Good MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-607
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-608
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，有时在声明变量时，我们会包括数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-610
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们不包括数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-612
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 这是怎么回事？计算机实际上足够智能，能够在大多数情况下推断出数据类型。这被称为*类型推断*——因为计算机会根据我们给出的线索*推测*，或者说猜测我们正在使用的数据类型。当你创建一个变量并给它一个初始值时，这个值就是计算机的一个重要线索。以下是一些示例：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个没有小数部分的数字（如 3），计算机会假设它是一个 Int。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个带小数部分的数字（如 3.14），计算机会假设它是一个 Double。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值单词*true* 或 *false*（没有引号），计算机会假设它是一个 Bool 类型。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个或多个带引号的字符，计算机会假设它是一个 String 类型。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量会被设置为该数据类型，就好像你自己声明了数据类型一样。这纯粹是为了方便。每次声明新的常量或变量时，你可以包含数据类型，这也是完全可以的。但是，为什么不让计算机来推断，省去你额外的时间和打字呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-619
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**通过类型转换转换数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换*是一种临时改变变量或常量数据类型的方式。你可以把它看作是对变量施了一个“魔法”——让它的值暂时表现得像另一种数据类型，但仅仅是暂时的。为了实现这一点，你需要在变量后面写上一个新的数据类型，并用括号包裹住你要转换的变量。请注意，这*并不会真正改变数据类型*。它只是为这一行代码提供了一个临时值。这里有一些
    Int 和 Double 之间转换的示例。看看你代码运行后的结果，在结果边栏中查看。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-621
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![Image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Int 类型的变量 months 转换为 Double，并将其存储在一个名为 doubleMonths 的新变量中。这加入了小数点，转换结果是
    12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将 Double 转换为 Int：
- en: '![Image](Image00058.jpg)'
  id: totrans-624
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Double 类型的 days 转换为 Int。你可以看到小数部分和后面的所有数字都被去掉了：我们的数字变成了 365。这是因为 Int
    无法保存小数——它只能包含整数，所以小数点后的部分会被截去。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，类型转换并不会真正改变数据类型。在我们的示例中，即使进行了转换，days 依然是*Double*。我们可以通过打印 days 来验证这一点：
- en: '![Image](Image00059.jpg)'
  id: totrans-627
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 结果边栏显示，days 仍然等于 365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将涵盖一些关于何时和在哪里使用类型转换的示例。所以，如果你现在还不清楚为什么要进行类型转换，稍等一会儿，我们会进一步解释！
- en: '**OPERATORS**'
  id: totrans-630
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中有许多算术运算符可以用来进行数学运算。你已经看到过基本的赋值运算符 =。你可能也熟悉加法（+）、减法（-）、乘法（*）和除法（/）。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符对 Int、Float 和 Double 数据类型进行数学运算。被操作的数字称为 *操作数*。通过输入以下代码，你可以在 Playground
    中试验这些数学运算符：
- en: '![Image](Image00060.jpg)'
  id: totrans-633
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Playground 中输入这段代码，你将在侧边栏看到每个数学表达式的结果。在代码中编写数学表达式与平常书写没有太大区别。例如，16 减去 2
    写作 16 – 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数学表达式的结果保存在一个变量或常量中，这样你就可以在代码的其他地方使用它。要查看这如何工作，请在 Playground 中输入以下代码：
- en: '![Image](Image00061.jpg)'
  id: totrans-636
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印 sum ➊ 时，你将在侧边栏看到 7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的数学表达式中只使用了数字，但数学运算符也适用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的 Playground 中：
- en: '![Image](Image00062.jpg)'
  id: totrans-640
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以像对待数字一样使用数学运算符对变量和常量进行操作。
- en: '**SPACES MATTER**'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，运算符周围的空格非常重要。你可以在数学运算符的两边都写一个空格，或者干脆不写空格。但你不能只在运算符的一边加空格，另一边不加，这样会导致错误。请查看[图
    2-7](text00012.html#ch02fig7)。
- en: '![image](Image00063.jpg)'
  id: totrans-644
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：确保运算符两边有相同数量的空格。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点需要注意：你只能对相同数据类型的变量或常量使用数学运算符。在之前的代码中，三和五都是 Int 数据类型。常量 half 和 quarter 是 Double
    数据类型，因为它们是小数。如果你尝试将 Int 和 Double 相加或相乘，你会得到像[图 2-8](text00012.html#ch02fig8)那样的错误。
- en: '![image](Image00064.jpg)'
  id: totrans-647
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-8：在 Swift 中，无法对混合数据类型进行数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你真的想对混合数据类型进行数学运算呢？例如，假设你想计算自己年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-650
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行会导致错误，因为我们尝试将一个 Int 与一个 Double 相乘。但别担心！你有几个选项可以确保操作数是相同的数据类型。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选择是将 myAge 声明为 Double 类型，像这样：
- en: '![Image](Image00066.jpg)'
  id: totrans-653
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有效，因为我们正在相乘两个 Double 数据类型。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是使用类型转换。（我告诉过你我们会再回到这个话题！）在这种情况下，类型转换是一个很好的解决方案，因为我们不想永久地将myAge转换为Double类型，我们只想能像Double类型一样进行数学运算。让我们看一个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-656
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们在乘法运算前将myAge转换为Double类型。这意味着我们不再有混合类型，所以代码可以正常工作。但在➋处，我们会得到一个错误。那是因为myAge仍然是Int类型。将其在➊处转换为Double并没有永久改变它的类型。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能把乘数转换为Int类型吗？当然可以！然后我们就在对两个整数进行运算，这样也能正常工作。然而，这样会导致计算结果的精度降低，因为我们会丢失小数点。当你将一个Double类型的变量转换为Int时，计算机会简单地去掉小数部分，将它变成整数。在这个例子中，0.1的乘数会被转换为Int类型的0。让我们在playground中转换一些变量，看看结果：
- en: '![Image](Image00068.jpg)'
  id: totrans-659
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将Double类型的乘数转换为Int类型，结果为0。这个值在转换后发生了很大变化，因为我们丢失了小数点：0.1变成了0。如果我们没有预料到这一点，这在代码中可能会造成很大的问题。进行类型转换时，你必须小心，确保不会意外地改变你的值。在➋处，另一个Double到Int的转换示例，如你所见，1.9并没有四舍五入为2，它的小数部分被去掉了，结果剩下1。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个数学运算符，*取模运算符*（%），它可能不太为你所熟悉。取模运算符（也叫*余数运算符*）给出的是除法后的余数。例如，7 % 2 = 1，因为7除以2的余数是1。试试看在你的playground中使用取模运算符，像这样：
- en: '![Image](Image00069.jpg)'
  id: totrans-662
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，取模运算符对判断一个数是否是偶数（evenNumber % 2 等于0）➊或者是奇数（oddNumber % 2 等于1）➋非常有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-664
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算顺序**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们每一行代码只做了一个数学运算，但通常一行代码会进行多个运算。让我们看一个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元的钞票和两张一美元的钞票，你有多少钱？我们可以用一行代码来计算这个：
- en: '![Image](Image00070.jpg)'
  id: totrans-667
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给myMoney赋值为17。计算机先进行5乘以3，然后加上2。但计算机是如何知道先乘法再加法的呢？它只是从左到右操作吗？不是！看看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-669
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移动了数字，但结果仍然是17。如果计算机只是从左到右进行计算，它会先加2 + 5得到7。然后它会将结果7乘以3，得到21。即使我们改变了数学表达式中数字的顺序，计算机仍然会先做乘法（得到15），然后加上2得到17。*计算机总是先进行乘法和除法，再进行加法和减法*。这被称为*运算顺序*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-671
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**用括号确定操作顺序**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必像我们在钱的例子中那样依赖计算机来判断应该先做哪一步。你，程序员，拥有决定权！你可以使用括号将操作组合在一起。当你在某个表达式周围加上括号时，你告诉计算机先执行那一步：
- en: '![Image](Image00072.jpg)'
  id: totrans-673
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，括号告诉计算机先将5乘以3，再加上2。这会得到17。在➋处，括号告诉计算机先加上2和5，然后将结果乘以3，得到21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在其他括号内部使用括号来使你的代码更加具体。计算机会先计算内层括号中的内容，然后再计算外层括号中的内容。试试这个例子：
- en: '![Image](Image00073.jpg)'
  id: totrans-676
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 首先计算机在内层括号中加上2和3。然后，它会将结果乘以4，因为这在外层括号内。最后，它会加上1，因为1在两个括号之外。最终结果是21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-678
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值运算符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的另一类运算符是*复合赋值运算符*。这些是将数学运算符与赋值运算符（=）结合的“快捷”运算符。例如，这个表达式
- en: '[PRE15]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: becomes
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 变为
- en: '[PRE16]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符通过对变量或常量进行操作来更新其值。用简单的语言来说，像`a += b`这样的表达式表示“将b加到a，并将新值存储在a中。”[表 2-1](text00012.html#ch2tab1)显示了使用复合赋值运算符的数学表达式及其长形式表达式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-1：** 短形式赋值运算符与长形式表达式'
- en: '| **Short form** | **Long form** |'
  id: totrans-685
  prefs: []
  type: TYPE_TB
  zh: '| **短形式** | **长形式** |'
- en: '| --- | --- |'
  id: totrans-686
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-687
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-688
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-689
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-690
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`+=`运算符的应用。假设我们正在编写一个程序来计算方舟上的动物数量。首先，我们创建一个名为`animalsOnArk`的变量，并将其设置为0，因为方舟上还没有动物。当不同种类的动物登上方舟时，我们希望增加`animalsOnArk`以计算所有动物。如果两只长颈鹿登上方舟，那么我们需要将2加到`animalsOnArk`上。如果两只大象登上方舟，我们需要再加2。如果四只羚羊登上方舟，那么我们需要将`animalsOnArk`增加4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-692
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00074.jpg)![Image](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 两只长颈鹿、两只大象和四只羚羊登上方舟后，animalsOnArk 的最终值为 8。真是一个动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的一些快速提示**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都提供了将注释放在代码行内的方式。注释是计算机忽略的说明，旨在帮助阅读代码的人理解代码的含义。虽然程序没有注释也能正常运行，但在一些可能不清楚或令人困惑的代码段中添加注释是一个好主意。即使你不打算将程序展示给别人，注释也能帮助你记住在编写代码时你是怎么想的，或者为什么这么做。很多时候，你会回到几个月或几年前写的代码，完全不记得当时的思路。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中有两种添加注释的方法。第一种方法是在你想要添加注释的文本前加上两个正斜杠（//）。这些注释可以单独放在一行，就像这样：
- en: '[PRE17]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它们可以与代码行放在同一行，只要注释在代码*之后*：
- en: '[PRE18]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法适用于长注释或*多行*注释，其开始和结束由 /* 和 */ 标记。（请注意，在本书中，我们将使用 -- *省略* -- 来表示为了节省空间而省略的代码行。）
- en: '[PRE19]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不希望计算机执行某部分代码，因为你正在尝试找出一个错误，但又不想删除所有的工作，可以使用多行注释暂时*注释掉*代码段。当你将一段代码格式化为注释时，计算机会像忽略其他注释一样忽略这段代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-703
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在 Swift 游乐场中编写代码，这样你可以立刻看到结果。你创建了变量和常量，并学习了如何使用基本的数据类型和运算符，这些将是你在编写自己的计算机程序时反复遇到的内容。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](text00013.html#ch03)中，你将使用条件语句，告诉计算机你希望它执行哪个代码路径。代码路径是基于条件的值来选择的。
- en: Let’s open a playground. Open Xcode and select **Get started with a playground**
    , as shown in the Welcome to Xcode dialog in [Figure 2-1](text00012.html#ch02fig1)
    . If this window doesn’t automatically open, select **Welcome to Xcode** from
    the Window option in the menu or press ⌘ -SHIFT -1.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开一个游乐场。打开 Xcode，并选择 **开始使用游乐场**，如[图 2-1](text00012.html#ch02fig1)中的“欢迎使用
    Xcode”对话框所示。如果这个窗口没有自动打开，可以从菜单中的窗口选项选择 **欢迎使用 Xcode**，或者按 ⌘ -SHIFT -1。
- en: '![image](Image00033.jpg)'
  id: totrans-707
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00033.jpg)'
- en: '*Figure 2-1: Getting started with a playground*'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：开始使用游乐场*'
- en: You’ll be asked to name your playground ([Figure 2-2](text00012.html#ch02fig2)
    ). In this example, we’ll keep the default name *MyPlayground* . Make sure that
    you choose iOS as the platform to run the playground.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被要求为你的游乐场命名（见[图 2-2](text00012.html#ch02fig2)）。在这个例子中，我们将保留默认名称 *MyPlayground*。确保选择
    iOS 作为运行游乐场的平台。
- en: '![image](Image00034.jpg)'
  id: totrans-710
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00034.jpg)'
- en: '*Figure 2-2: Naming the playground and selecting the platform*'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：命名游乐场并选择平台*'
- en: When the playground first opens, you’ll see two panels in the window, just like
    in [Figure 2-3](text00012.html#ch02fig3) . On the left is the playground editor,
    where you’ll write your code. On the right is the results sidebar, which displays
    the results of your code.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 当 playground 首次打开时，你会看到窗口中有两个面板，就像在[图 2-3](text00012.html#ch02fig3) 中一样。左侧是
    playground 编辑器，你将在这里编写代码；右侧是结果侧边栏，它显示你的代码的结果。
- en: The line var str = "Hello, playground" in [Figure 2-3](text00012.html#ch02fig3)
    creates a variable named str . A *variable* is like a container; you can use it
    to hold almost anything—a simple number, a string of letters, or a complex object
    (we’ll explain what that is later). Let’s take a closer look at how variables
    work.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 2-3](text00012.html#ch02fig3) 中的代码行 var str = "Hello, playground" 创建了一个名为
    str 的变量。一个*变量*就像一个容器；你可以用它来保存几乎任何东西——一个简单的数字、一串字母，或者一个复杂的对象（我们稍后会解释这是什么意思）。让我们仔细看看变量是如何工作的。
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  id: totrans-714
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00035.jpg)![image](Image00036.jpg)'
- en: '*Figure 2-3: Playground editor and results sidebar*'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：Playground 编辑器和结果侧边栏*'
- en: '**CONSTANTS AND VARIABLES**'
  id: totrans-716
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**常量和变量**'
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 这是[图 2-3](text00012.html#ch02fig3) 中的代码行，再次展示：
- en: '![Image](Image00037.jpg)'
  id: totrans-718
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00037.jpg)'
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 它做了两件事。首先，它创建了一个名为 str 的变量。这被称为*声明*，因为我们声明我们想创建一个变量。要创建一个变量，你输入关键字 var，然后给你的变量命名——在这里是
    str。命名变量时有一些规则，稍后我们会介绍，所以现在暂时按照这个示例来做。
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这行代码使用 = 运算符将 "Hello, playground" 的值赋给了 str。这被称为*赋值*，因为我们正在给我们新创建的变量赋一个值。记住，你可以把变量看作是一个容器，用来保存某个东西。所以现在我们有了一个名为
    str 的容器，里面保存着 "Hello, playground"。
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这行代码理解为“变量 str 等于 Hello, playground”。如你所见，Swift 通常非常易于阅读；这行代码几乎在英文中告诉你它在做什么。
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 变量很方便，因为如果你想打印出“Hello, playground”这句话，你只需对字符串使用 print 命令，就像以下代码所示：
- en: '![Image](Image00038.jpg)'
  id: totrans-723
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00038.jpg)'
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在结果侧边栏打印出 "Hello, playground\n"。\n 会自动添加到你打印的任何内容的末尾。它被称为*换行符*，它告诉计算机跳到新的一行。
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看程序实际运行时的结果，调出调试区域，它会出现在两个面板下方，如[图 2-4](text00012.html#ch02fig4) 所示。为此，你可以在
    Xcode 菜单中选择 **View** ▸ **Debug Area** ▸ **Show Debug Area**，或者按 ⌘ -SHIFT -Y。当
    str 在调试区域的控制台中打印时，你会发现 “Hello, playground” 周围的引号和换行符不会出现。这就是如果你正式运行这个程序时，str 看起来的样子！
- en: '![image](Image00039.jpg)'
  id: totrans-726
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：在调试区域查看程序的真实输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在你的程序中是可以改变的（或者说是*变化*的！），所以你可以改变一个变量的值，让它保存其他的东西。我们现在就试试这个。将以下几行添加到你的 playground
    中。
- en: '![Image](Image00040.jpg)'
  id: totrans-729
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改变量的值，输入其名称并使用`=`操作符将其设置为新值。我们在➊处执行此操作，将`str`的值更改为“Hello, world”。计算机会丢弃`str`之前的内容，并说：“好的，老板，`str`现在是Hello,
    world”（如果计算机能说话的话！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们更改`str`的值时，我们不会再次写`var`。计算机会记住我们在之前的代码行中声明了`str`，并知道`str`已经存在。因此，我们不需要再次创建`str`。我们只是想给它赋一个不同的值。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以声明*常量*。像变量一样，常量也存储值。常量与变量的最大区别在于常量的值永远无法更改。变量的值是可变的，而常量的值是固定的！声明常量与声明变量类似，但我们使用`let`而不是`var`：
- en: '![Image](Image00041.jpg)'
  id: totrans-733
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`myName`的常量，并将其值赋为"Gloria"。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了一个常量并赋值，它将一直保持该值直到永远。可以把常量想象成一块大石头，你在上面雕刻了你的值。如果你尝试给`myName`赋另一个值，比如"Matt"，你将遇到像[图2-5](text00012.html#ch02fig5)中那样的错误。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-736
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00042.jpg)![图片](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-5：尝试更改常量的值是行不通的。*'
- en: '**NOTE**'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '*在Playground中，错误会以一个红色圆圈和一个小白色圆圈的形式出现。点击错误标记将显示错误信息并告诉你出了什么问题。如果你显示了调试区域，你应该还能看到描述发生了什么的信息，有时甚至会告诉你如何修复它。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-740
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经成功创建了一个变量和一个常量——做得好！但是什么时候该使用一个而不是另一个呢？在Swift中，最好使用常量而不是变量，除非你预计值会发生变化。常量帮助使代码“更安全”。如果你知道某个值永远不会改变，为什么不把它刻在石头上，避免以后可能出现的混乱呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想跟踪教室里窗口的总数和今天打开的窗口数量。教室中的窗口数量不会改变，因此应该使用常量来存储该值。然而，教室中打开的窗口数量会根据天气和时间变化，因此应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-743
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00044.jpg)![图片](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`numberOfWindows`设置为常量并赋值为8，因为总窗口数始终为8。我们将`numberOfWindowsOpen`设置为变量并赋值为3，因为当我们打开或关闭窗口时，需要更改该值。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用`var`声明变量，使用`let`声明常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-746
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常量和变量的命名**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以随意为变量或常量命名，但有几个例外。你不能命名一个已经是 Swift 关键字的名字。例如，你不能将变量命名为 var。写 var var 会让你和计算机都感到困惑。如果你尝试使用
    Swift 的保留字命名变量或常量，编译器会报错。你也不能在同一个代码块中有两个同名的变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则外，在 Swift 中命名时还有一些其他好的编程指南。你的变量名应该总是以小写字母开头。给变量取一个*非常*具有描述性的名字也是个好主意（长度可以随意）。使用描述性名字时，更容易理解该变量或常量的作用。如果你在看别人的代码，你会觉得哪个变量名更容易理解：numKids
    还是 numberOfKidsInMyClass？第一个名字很模糊，而第二个名字很有描述性。常见的做法是将多个单词拼接成一个变量名，比如 numberOfKidsInMyClass。这种风格称为*驼峰命名法*（camel
    case），因为这种小写字母和大写字母交替的模式像是骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-749
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-750
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你可以选择变量或常量要存储的数据类型（*数据类型*）。还记得我们说过，变量可以看作是一个容器，里面放着某些东西吗？那么，数据类型就像是容器的类型。计算机需要知道我们将把什么样的东西放入每个容器中。在
    Swift 编程中，一旦你告诉计算机一个变量或常量将存储某种数据类型，它就不会让你往这个变量或常量中放入任何其他类型的值。如果你有一个专门用来装土豆的篮子，那就不应该把水装进去——除非你喜欢水弄得满地都是！
- en: '![image](Image00047.jpg)'
  id: totrans-752
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-753
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，可以告诉计算机它将保存哪种类型的数据。在我们关于教室窗户的示例中，我们知道这个变量始终是一个*整数*（也就是一个整数——你不能有半个窗户），所以我们可以指定一个整数类型，如下所示：
- en: '![Image](Image00048.jpg)'
  id: totrans-755
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示“是某种类型”。用简单的语言来说，这行代码的意思是：“名为 numberOfWindowsOpen 的变量，它是一个整数，值为 3。”因此，这行代码创建了一个变量，给它命名，告诉计算机它的数据类型，并为它赋值。呼！一行代码就做到了这一切？我们有没有提到
    Swift 是一种非常*简洁*的语言？有些编程语言可能需要几行代码来完成同样的操作。而 Swift 的设计是让你可以用一行代码完成很多事情！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要声明一次数据类型。当我们告诉计算机一个变量将存储整数时，我们不需要再次告诉它。事实上，如果我们再声明，Xcode 会给出错误。一旦声明了数据类型，变量或常量将永远只能存储该类型的数据。一次整数，永远是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数据类型，还有一件事需要了解：变量或常量不能存储不符合其数据类型的内容。例如，如果你尝试将一个小数存入`numberOfWindowsOpen`，就会出现错误，正如[图
    2-6](text00012.html#ch02fig6)所示。
- en: '![image](Image00049.jpg)'
  id: totrans-759
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：你不能将小数存入一个本应存储整数的变量中。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`numberOfWindowsOpen = 5`和`numberOfWindowsOpen = 0`是有效的，并且可以正常工作。但你不能设置`numberOfWindowsOpen
    = 1.5`。
- en: '**COMMON DATA TYPES**'
  id: totrans-762
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所学，数据类型让计算机知道它正在处理的数据*类型*是什么，并且如何在内存中存储它。那么，数据类型有哪些呢？一些常见的类型包括Int、Double、Float、Bool和String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解每一种数据类型！
- en: '**Int (Integers)**'
  id: totrans-765
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Int（整数）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经简单讨论过整数，但让我们更详细地了解它们。整数，在Swift中称为Int，是没有小数或分数部分的整数。你可以将它们视为计数数字。整数是*有符号的*，意味着它们可以是负数、正数或零。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-767
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Double和Float（小数）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '*小数*是指小数点后有数字的数字，例如3.14。（如果你想让一个整数变为小数数字，它会写作3.0）。有两种数据类型可以存储小数：Double和Float（即*浮点数*）。在Swift中，Double数据类型更为常用，因为它可以存储更大的数字，因此我们将重点讨论Double。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 当你给一个Double赋值时，必须确保小数点左边有一个数字，否则会出现错误。例如，假设香蕉每个售价19美分：
- en: '![Image](Image00050.jpg)'
  id: totrans-770
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: ➊处的代码会导致错误，因为小数点左边没有数字。➋处的代码可以正常工作，因为它有一个前导零。（“// ERROR”和“// CORRECT”是*注释*，是程序中的注释，计算机会忽略它们。请参见[《关于注释的一些快速说明》](text00012.html#ch02sb01)，详细内容见[第32页](text00012.html#page_32)。）
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-772
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Bool（布尔值，或真/假）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*布尔值*只能是两者之一：真或假。在Swift中，布尔数据类型叫做Bool。
- en: '![Image](Image00051.jpg)'
  id: totrans-774
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值通常用于if-else语句中，告诉计算机程序应走哪条路径。（我们将在[第3章](text00013.html#ch03)中更详细地讲解布尔值和if-else语句。）
- en: '**String**'
  id: totrans-776
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**String**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: String 数据类型用于存储单词和短语。一个 *字符串* 是一组被引号括起来的字符。例如，"Hello, playground" 是一个字符串。字符串可以由各种字符组成：字母、数字、符号等等。引号非常重要，因为它们告诉计算机，所有引号之间的内容都是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串连接起来，构建句子，这个过程叫做字符串*连接*。让我们看看它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-779
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用加号（+）将字符串连接起来，这段代码创建了一个名为 specialGreeting 的变量，值为字符串 "Good Morning Jude"。注意，我们需要在
    morningGreeting 和 friend 之间添加一个包含空格字符（" "）的字符串，否则 specialGreeting 的值将会是 "Good
    MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-781
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-782
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，当我们声明一个变量时，有时会包括数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-784
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们不会包括数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-786
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事？计算机实际上足够聪明，通常能推断出数据类型。这就是所谓的*类型推断*——因为计算机会*推断*，或者说猜测我们正在使用的数据类型，这个过程基于我们给它的线索。当你创建一个变量并给它初始值时，这个值就是给计算机的一个重要线索。下面是一些例子：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值为没有小数值的数字（例如 3），计算机会认为它是一个 Int 类型。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你为一个数字赋值为小数（例如 3.14），计算机会认为它是一个 Double 类型。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值为 *true* 或 *false*（没有引号），计算机会认为它是一个 Bool 类型。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值为一个或多个带引号的字符，计算机会认为它是一个 String 类型。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量会被设置为该数据类型，就像你自己声明了数据类型一样。这纯粹是为了方便。你可以在每次声明新的常量或变量时都包含数据类型，这样完全没问题。但为什么不让计算机来推断，并节省时间和减少输入呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-793
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**通过类型转换转换数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换* 是一种临时转换变量或常量数据类型的方法。你可以把它想象成对变量施法——你让它的值表现得像另一种数据类型，但只是短暂的。为此，你需要写一个新的数据类型，后面跟上括号，括号里是你要转换的变量。注意，这*并不会真正改变数据类型*，它只是给你一个在这一行代码中临时使用的值。下面是一些在
    Int 和 Double 之间进行类型转换的示例。看看代码执行的结果。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-795
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![Image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将Int类型的变量months转换为Double类型，并将结果存储在一个名为doubleMonths的新变量中。这样就添加了小数点，类型转换的结果是12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将Double类型转换为Int类型：
- en: '![Image](Image00058.jpg)'
  id: totrans-798
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将Double类型的days转换为Int类型。你可以看到小数部分和其后的所有数字都被去掉了：我们的数字变成了365。这是因为Int类型无法存储小数，它只能保存整数，所以小数点后的部分被舍去。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，类型转换并不会改变数据类型。在我们的示例中，即使进行了类型转换，days *依然*是一个Double类型。我们可以通过打印days来验证这一点：
- en: '![Image](Image00059.jpg)'
  id: totrans-801
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 结果侧边栏显示days的值仍然是365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍一些使用类型转换的示例。所以如果你现在还不清楚为什么需要进行类型转换，请稍等片刻！
- en: '**OPERATORS**'
  id: totrans-804
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中有许多算术运算符可供使用来进行数学运算。你已经见过基本的赋值运算符=。你可能也熟悉加法（+）、减法（-）、乘法（*）和除法（/）。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符对Int、Float和Double数据类型进行运算。被操作的数字称为*操作数*。在你的playground中通过输入类似以下的代码来尝试这些数学运算符：
- en: '![Image](Image00060.jpg)'
  id: totrans-807
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在playground中输入这段代码，你将看到每个数学表达式的结果显示在侧边栏。编写数学表达式的代码与正常书写并没有太大区别。例如，16减去2可以写作16
    – 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数学表达式的结果保存到一个变量或常量中，这样你就可以在代码的其他地方使用它。为了了解如何操作，请在你的playground中输入以下代码：
- en: '![Image](Image00061.jpg)'
  id: totrans-810
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印sum➊时，你会在侧边栏看到7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在数学表达式中只使用了数字，但数学运算符也可以作用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的playground中：
- en: '![Image](Image00062.jpg)'
  id: totrans-814
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你可以像对待数字一样使用数学运算符来操作变量和常量。
- en: '**SPACES MATTER**'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，运算符周围的空格是非常重要的。你可以在数学运算符的两侧写上空格，或者完全不写空格。但你不能只在运算符的一侧加上空格，另一侧不加。这样会导致错误。查看[图
    2-7](text00012.html#ch02fig7)以了解更多。
- en: '![image](Image00063.jpg)'
  id: totrans-818
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：确保运算符两侧的空格数量相同。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件重要的事情需要注意：你只能在相同数据类型的变量或常量上使用数学运算符。在前面的代码中，三和五都是Int数据类型。常量half和quarter是Double数据类型，因为它们是小数。如果你尝试对一个Int和一个Double进行加法或乘法运算，你会遇到像[图2-8](text00012.html#ch02fig8)中所示的错误。
- en: '![image](Image00064.jpg)'
  id: totrans-821
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-8：在Swift中，你不能对混合数据类型进行数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果你真的想对混合数据类型进行数学运算呢？例如，假设你想计算你年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-824
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行会报错，因为我们试图将一个Int类型与一个Double类型相乘。但不用担心！你有几个选项可以确保操作数是相同的数据类型。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是将myAge声明为Double类型，像这样：
- en: '![Image](Image00066.jpg)'
  id: totrans-827
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码能正常工作，因为我们正在对两个Double数据类型进行乘法运算。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是使用类型转换。（我告诉过你我们会回到这个话题！）在这种情况下，类型转换是一个很好的解决方案，因为我们不想永久改变myAge为Double类型，我们只希望能够像操作Double一样进行数学运算。让我们看一个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-830
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们在进行乘法运算之前将myAge转换为Double。这意味着我们不再有混合数据类型，因此代码可以正常工作。但在➋处，我们会遇到错误。因为myAge仍然是Int类型。将它转换为Double类型只是在➊处暂时改变了它，并没有永久性地将它转换为Double。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能将multiplier转换为Int吗？当然可以！这样我们就在进行两个整数的数学运算，效果很好。然而，这会导致计算精度降低，因为我们会丢失小数点。当你将一个Double类型的变量转换为Int时，计算机会简单地去掉小数点后的所有数字，使其变为整数。在这个例子中，你的multiplier值0.1会被转换为Int类型的0。让我们在playground中进行一些变量转换，看看结果：
- en: '![Image](Image00068.jpg)'
  id: totrans-833
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，将我们的Double类型的multiplier转换为Int后，我们得到0。转换后的这个值和原值差别很大，因为我们丢失了小数点：0.1变成了0。如果我们没有预料到这种情况，这在代码中可能会引发严重问题。你必须小心类型转换，确保不会意外地改变你的值。在➋处，又有一个将Double转换为Int的例子，正如你所看到的，1.9没有四舍五入到2，而是其小数部分被移除，剩下了1。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个数学运算符是*取模运算符*（%），你可能对它不太熟悉。取模运算符（也叫*模数*）在除法运算后给出余数。例如，7 % 2 = 1，因为7除以2的余数是1。尝试在你的playground中使用取模运算符，像这样：
- en: '![Image](Image00069.jpg)'
  id: totrans-836
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，取模运算符对于判断一个数字是偶数（evenNumber % 2 等于 0）➊ 还是奇数（oddNumber % 2 等于 1）➋ 非常有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-838
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算顺序**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们每行代码中只做了一个数学运算，但在一行代码中做多个运算是很常见的。让我们看一个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元钞票和两张一美元钞票，你有多少钱？让我们在一行中计算这个：
- en: '![Image](Image00070.jpg)'
  id: totrans-841
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 这将值 17 分配给 myMoney。计算机先将 5 乘以 3，然后加上 2。但是，计算机是如何知道先乘法后加法的呢？它是从左到右计算吗？不是！看看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-843
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移动了数字，但结果仍然是 17。如果计算机只是从左到右运算，它会先加 2 + 5 得到 7。然后它会将 7 乘以 3，得到 21。尽管我们改变了数学表达式中数字的顺序，计算机仍然会先进行乘法（得出
    15），然后加上 2 得到 17。*计算机会始终先进行乘法和除法运算，再进行加法和减法运算。* 这就是所谓的 *运算顺序*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-845
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号的运算顺序**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必像在金钱示例中那样依赖计算机来确定首先做哪个步骤。你，程序员，拥有决定权！你可以使用括号将操作组合在一起。当你将括号放在某个操作周围时，你是在告诉计算机首先执行那个步骤：
- en: '![Image](Image00072.jpg)'
  id: totrans-847
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，括号告诉计算机先将 5 乘以 3，然后加上 2。这将得到 17。在 ➋ 处，括号告诉计算机先将 2 加上 5，再乘以 3，得到 21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在其他括号内部使用括号来使代码更加具体。计算机会首先计算内部括号，然后计算外部括号。试试这个例子：
- en: '![Image](Image00073.jpg)'
  id: totrans-850
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 首先计算机在内层括号中将 2 和 3 相加。然后它将结果乘以 4，因为它在外层括号内。最后，它会加上 1，因为它在两个括号之外。最终结果是 21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-852
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值运算符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的另一类运算符是 *复合赋值运算符*。这些是将数学运算符与赋值运算符（=）结合的“快捷”运算符。例如，这个表达式
- en: '[PRE20]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: becomes
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 变成
- en: '[PRE21]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符通过对变量或常量执行操作来更新其值。通俗地说，像 a += b 这样的表达式意味着“将 b 加到 a 中并将新值存储在 a 中。”[表
    2-1](text00012.html#ch2tab1) 展示了使用复合赋值运算符的数学表达式以及它们的长形式表达式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-1:** 短形式赋值运算符与长形式表达式'
- en: '| **Short form** | **Long form** |'
  id: totrans-859
  prefs: []
  type: TYPE_TB
  zh: '| **短形式** | **长形式** |'
- en: '| --- | --- |'
  id: totrans-860
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-861
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-862
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-863
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-864
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 += 运算符的实际应用。假设我们正在编写一个程序来计算方舟上的动物数量。首先我们创建一个名为 animalsOnArk 的变量，并将其设置为
    0，因为方舟上还没有动物。当不同种类的动物登上方舟时，我们希望增加 animalsOnArk 来统计所有动物的数量。如果两只长颈鹿登上方舟，那么我们需要将
    animalsOnArk 增加 2。如果两只大象登上方舟，我们需要再增加 2。如果四只羚羊登上方舟，我们需要将 animalsOnArk 增加 4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-866
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00074.jpg)![Image](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 在两只长颈鹿、两只大象和四只羚羊登上方舟后，animalsOnArk 的最终值为 8。真是一个动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的一些快速提示**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都提供了在代码中内联写注释的方法。注释是计算机忽略的注释，目的是帮助阅读代码的人理解代码的内容。虽然程序在没有任何注释的情况下也能正常运行，但对于那些可能不太清楚或容易混淆的代码部分，包含注释是个好主意。即使你不会把程序展示给其他人，注释也能帮助你记住你编写那段代码时的思路。甚至有时，你可能会回过头来查看几个月甚至几年前写的代码，完全不记得当时写那段代码时的想法。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中有两种添加注释的方法。第一种方法是在你想添加的文本前面放两个斜杠（//）。这些注释可以单独放在一行，比如这样：
- en: '[PRE22]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它们可以与代码行放在同一行——只要注释*位于*代码之后：
- en: '[PRE23]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法用于长注释，或者*多行*注释，注释的开始和结束由 /* 和 */ 标记。（请注意，在本书中，我们将使用 -- *snip* -- 来表示我们为节省空间而省略的更多代码行。）
- en: '[PRE24]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不想让计算机运行你代码的某部分，因为你正在寻找一个 bug，但你又不想删除所有辛苦工作的代码，你可以使用多行注释暂时*注释掉*代码的某些部分。当你将一段代码格式化为注释时，计算机会像忽略其他注释一样忽略这段代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-877
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何在 Swift playground 中编写代码，这让你可以立即看到结果。你创建了变量和常量，并学习了如何使用基本的数据类型和运算符，这些运算符将在你编写自己的计算机程序时反复出现。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](text00013.html#ch03)，你将使用条件语句，它告诉计算机你希望它走哪条代码路径。代码路径是根据条件的值来选择的。
- en: '![image](Image00033.jpg)'
  id: totrans-880
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00033.jpg)'
- en: '*Figure 2-1: Getting started with a playground*'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：开始使用 Playground*'
- en: You’ll be asked to name your playground ([Figure 2-2](text00012.html#ch02fig2)
    ). In this example, we’ll keep the default name *MyPlayground* . Make sure that
    you choose iOS as the platform to run the playground.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 系统会要求你给你的 Playground 起个名字（见[图 2-2](text00012.html#ch02fig2)）。在这个例子中，我们将保持默认名称*MyPlayground*。确保选择
    iOS 作为运行 Playground 的平台。
- en: '![image](Image00034.jpg)'
  id: totrans-883
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00034.jpg)'
- en: '*Figure 2-2: Naming the playground and selecting the platform*'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：命名 Playground 并选择平台*'
- en: When the playground first opens, you’ll see two panels in the window, just like
    in [Figure 2-3](text00012.html#ch02fig3) . On the left is the playground editor,
    where you’ll write your code. On the right is the results sidebar, which displays
    the results of your code.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Playground 首次打开时，你会看到窗口中有两个面板，就像在[图 2-3](text00012.html#ch02fig3)中一样。左侧是 Playground
    编辑器，你将在这里编写代码；右侧是结果侧边栏，它显示你的代码结果。
- en: The line var str = "Hello, playground" in [Figure 2-3](text00012.html#ch02fig3)
    creates a variable named str . A *variable* is like a container; you can use it
    to hold almost anything—a simple number, a string of letters, or a complex object
    (we’ll explain what that is later). Let’s take a closer look at how variables
    work.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 2-3](text00012.html#ch02fig3)中的`var str = "Hello, playground"`这一行代码创建了一个名为str的变量。*变量*就像一个容器；你可以用它来存放几乎任何东西——一个简单的数字、一串字母，或者一个复杂的对象（我们稍后会解释这个）。让我们仔细看看变量是如何工作的。
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  id: totrans-887
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00035.jpg)![image](Image00036.jpg)'
- en: '*Figure 2-3: Playground editor and results sidebar*'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：Playground 编辑器和结果侧边栏*'
- en: '**CONSTANTS AND VARIABLES**'
  id: totrans-889
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**常量和变量**'
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 这是[图 2-3](text00012.html#ch02fig3)中的代码行：
- en: '![Image](Image00037.jpg)'
  id: totrans-891
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00037.jpg)'
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 它做了两件事。首先，它创建了一个名为str的变量。这叫做*声明*，因为我们在声明我们希望创建一个变量。要创建一个变量，你输入`var`这个关键词，然后给你的变量命名——在这个例子中是str。命名变量时有一些规则，我们稍后会介绍，暂时先使用这个例子。
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行代码使用`=`操作符将“Hello, playground”赋值给变量str。这叫做*赋值*，因为我们正在给新创建的变量赋一个值。记住，你可以把变量看作是一个容器，用来存放某些东西。所以现在我们有一个名为str的容器，里面存放着“Hello,
    playground”。
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把这一行代码理解为“变量str等于Hello, playground”。正如你所看到的，Swift通常非常易读；这一行代码几乎用英文告诉你它在做什么。
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 变量非常方便，因为如果你想打印出“Hello, playground”这句话，你只需要像下面的代码一样使用`print`命令在str上：
- en: '![Image](Image00038.jpg)'
  id: totrans-896
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00038.jpg)'
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在结果侧边栏打印出“Hello, playground\n”。`\n`会自动添加到你打印的内容的末尾。它是一个*换行*字符，告诉计算机换到下一行。
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看你的程序实际运行的结果，打开调试区域，它会出现在两个面板下方，如[图 2-4](text00012.html#ch02fig4)所示。你可以通过在
    Xcode 菜单中选择**视图** ▸ **调试区域** ▸ **显示调试区域**，或者按⌘ -SHIFT -Y来打开调试区域。当str在调试区域的控制台中被打印出来时，你会看到“Hello,
    playground”周围的引号和换行符并没有显示。这就是如果你正式运行这个程序时，str的真实样子！
- en: '![image](Image00039.jpg)'
  id: totrans-899
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：在调试区域查看程序的实际输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以在你的程序中变化（或者*变化*！），所以你可以改变一个变量的值来存储其他内容。让我们现在试试。将以下代码添加到你的playground中。
- en: '![Image](Image00040.jpg)'
  id: totrans-902
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变变量的值，输入变量名并使用=操作符将其设置为新值。我们在➊处做了这件事，将str的值改为“Hello, world”。计算机会丢弃str原本保存的内容，然后说：“好的，老板，str现在是Hello,
    world”（当然，如果它会说话的话！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们改变str的值时，我们没有再次写var。计算机会记住我们之前在代码中声明了str，并知道str已经存在。因此，我们不需要重新创建str，只是想在其中放入不同的内容。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以声明*常量*。像变量一样，常量也可以保存值。常量和变量之间的最大区别是，常量的值永远不能改变，而变量的值可以变化，常量则是，嗯，就是常量！声明常量类似于声明变量，不过我们使用的是let而不是var：
- en: '![Image](Image00041.jpg)'
  id: totrans-906
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为myName的常量，并将其值设置为“Gloria”。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个常量并给它赋值，它将一直保持这个值直到永远。可以把常量想象成一块大岩石，你在上面刻下了一个值。如果你尝试给myName赋另一个值，比如“Matt”，你会看到一个像[图
    2-5](text00012.html#ch02fig5)中的错误信息。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-909
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00042.jpg)![image](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：尝试更改常量的值将不起作用。*'
- en: '**NOTE**'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '*在playground中，错误会以一个红色圆圈显示，里面有一个小白圈。点击错误标志将显示错误信息，并告诉你出了什么问题。如果你显示了调试区域，你应该还会看到描述发生了什么的信息，有时甚至会告诉你如何修复它。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-913
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量——干得不错！但是，什么时候应该使用常量而不是变量呢？在Swift中，最佳实践是使用常量而不是变量，除非你预期值会发生变化。常量有助于让代码变得“更安全”。如果你知道某个值永远不会变化，为什么不把它刻进石头里，避免以后可能的混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想记录你教室里的窗户总数和今天打开的窗户数量。教室里的窗户数量不会变化，所以你应该使用常量来存储这个值。至于今天教室里开着的窗户数量，则会根据天气和时间变化，因此你应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-916
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00044.jpg)![Image](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 numberOfWindows 设置为常量，并将其设为 8，因为窗户的总数将始终是 8。我们将 numberOfWindowsOpen 设置为变量，并将其设为
    3，因为我们在开关窗户时需要更改这个值。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用 var 声明变量，使用 let 声明常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-919
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**命名常量和变量**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以为变量或常量命名任何你想要的名称，但有一些例外。你不能使用 Swift 中已经是关键字的词汇命名变量。例如，你不能将变量命名为 var。写 var
    var 对你和计算机来说都会造成困惑。如果你尝试使用 Swift 的保留字命名变量或常量，编译器会报错。你也不能在同一代码块中有两个具有相同名称的变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则外，还有一些其他良好的编程指导原则，在 Swift 中命名时应遵循。你的变量名应始终以小写字母开头。使用*非常*具有描述性的名称也是一个好主意（名称可以长到你想要的长度）。使用描述性名称时，更容易理解该变量或常量的作用。如果你在看别人写的代码，你更容易理解哪个变量名称：numKids
    还是 numberOfKidsInMyClass？第一个名称含糊不清，但第二个名称则描述性更强。常见的做法是将多个词连在一起构成一个变量或常量的名称，像 numberOfKidsInMyClass。
    这种命名风格，其中多个单词连接起来时，每个单词的首字母都大写，叫做*驼峰命名法*。之所以叫“驼峰”，是因为这种大小写字母的排列方式看起来像骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-922
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-923
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你可以选择希望变量或常量存储的那种数据——*数据类型*。还记得我们之前提到过，你可以把变量想象成一个容器，用来存放某些东西吗？那么，数据类型就像容器的类型。计算机需要知道我们会在每个容器里放什么。
    在 Swift 编程中，一旦你告诉计算机某个变量或常量要存储特定的数据类型，它就不会让你在那个变量或常量中放入除了该数据类型以外的其他内容。如果你有一个专门用来装土豆的篮子，那么把它装满水可就不太合适了——除非你喜欢水漏得到处都是！
- en: '![image](Image00047.jpg)'
  id: totrans-925
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-926
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，可以告诉计算机它将存储哪种数据类型。在我们关于教室窗户的例子中，我们知道这个变量将始终是一个*整数*（也就是一个整数——你不可能有半个窗户），所以我们可以指定一个整数数据类型，像这样：
- en: '![Image](Image00048.jpg)'
  id: totrans-928
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示“是类型”。用通俗的英语来说，这行代码的意思是，“变量`numberOfWindowsOpen`，它是一个整数，等于3。”所以这行代码创建了一个变量，给它命名，告诉计算机它的数据类型，并赋予它一个值。呼！一行代码就做到了这一切？我们有没有提到Swift是一种非常*简洁*的语言？某些语言可能需要几行代码才能完成同样的事情。Swift的设计使得你可以用一行代码做很多事情！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要声明一次数据类型。当我们告诉计算机一个变量将存储整数时，我们不需要再告诉它一次。事实上，如果我们再这么做，Xcode会给我们一个错误。一旦数据类型被声明，变量或常量就会永远存储该类型的数据。一次是整数，永远是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要知道关于数据类型的另一件事：变量或常量不能存储不符合其数据类型的内容。例如，如果你尝试将一个小数值放入`numberOfWindowsOpen`，你会遇到错误，如[图2-6](text00012.html#ch02fig6)所示。
- en: '![image](Image00049.jpg)'
  id: totrans-932
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-6：你不能将一个小数值放入一个应该存储整数的变量中。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 将`numberOfWindowsOpen = 5`和`numberOfWindowsOpen = 0`设置为有效并且可以工作。但你不能设置`numberOfWindowsOpen
    = 1.5`。
- en: '**COMMON DATA TYPES**'
  id: totrans-935
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见的数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚刚学到的，数据类型让计算机知道它正在处理什么*类型*的数据，并如何在内存中存储它。那么，数据类型有哪些呢？一些常见的类型包括Int、Double、Float、Bool和String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下这些数据类型到底是什么！
- en: '**Int (Integers)**'
  id: totrans-938
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Int（整数）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经稍微讨论过整数，但让我们更详细地了解它们。整数，在Swift中叫做Int，是没有小数或分数部分的整数。你可以把它们看作是计数数字。整数是*有符号*的，意味着它们可以是负数、正数（或者零）。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-940
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Double和Float（小数）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: '*小数*是指小数点后有数字的数值，例如3.14。（如果你想将整数3表示为小数，它应该写成3.0。）有两种数据类型可以存储小数：Double和Float（即*浮动点数*的简称）。Double数据类型在Swift中更常见，因为它可以存储更大的数字，因此我们将重点讲解它们。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 当你赋值给一个Double时，必须始终在小数点左边有一个数字，否则会报错。例如，假设香蕉每个19美分：
- en: '![Image](Image00050.jpg)'
  id: totrans-943
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: ➊处的代码会导致错误，因为小数点左边没有数字。➋处的代码没有问题，因为它有一个前导零。（“// 错误”和“// 正确”是*注释*，是程序中的备注，计算机会忽略这些注释。参见“[关于注释的一些简短说明](text00012.html#ch02sb01)”以及[第32页](text00012.html#page_32)）。
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-945
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Bool（布尔值，或真/假）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值*只能是两种情况之一：true或false。在Swift中，布尔数据类型被称为Bool。'
- en: '![Image](Image00051.jpg)'
  id: totrans-947
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值常常用于if-else语句中，告诉计算机程序应该走哪条路径。（我们将在[第3章](text00013.html#ch03)中详细讲解布尔值和if-else语句。）
- en: '**String**'
  id: totrans-949
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**String**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: String数据类型用于存储单词和短语。*字符串*是由用引号括起来的字符集合。例如，"Hello, playground"是一个字符串。字符串可以由各种字符组成：字母、数字、符号等。引号很重要，因为它们告诉计算机引号之间的所有内容是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串拼接在一起来构建句子，这个过程称为字符串*连接*。让我们来看一下它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-952
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用加号（+）将字符串连接在一起，这段代码创建了一个名为specialGreeting的变量，并将字符串"Good Morning Jude"作为其值。注意，我们需要在morningGreeting和friend之间添加一个包含空格字符（"
    "）的字符串，否则specialGreeting会变成"Good MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-954
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-955
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，有时在声明变量时，我们会包括数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-957
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们不包括数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-959
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事？计算机实际上足够聪明，大多数情况下能够推断出数据类型。这叫做*类型推断*——因为计算机会根据我们提供的线索*推断*，或者猜测我们使用的数据类型。当你创建一个变量并给它初始值时，这个值就是计算机的重要线索。以下是一些例子：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个没有小数值的数字（例如3），计算机会认为它是一个Int类型。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个带有小数值的数字（例如3.14），计算机会认为它是一个Double类型。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值为*true*或*false*（没有引号），计算机会认为它是一个Bool类型。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个或多个带引号的字符，计算机会认为它是一个String类型。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量会被设置为该数据类型，就像你自己声明数据类型一样。这完全是为了方便。你可以每次声明一个新的常量或变量时都包含数据类型，这完全没有问题。但为什么不让计算机自己推断出来，节省时间和额外的打字呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-966
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**通过强制转换改变数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换* 是一种暂时改变变量或常量数据类型的方法。你可以把它想象成对变量施加一个魔法——它的值会暂时表现得像不同的数据类型，但只会持续一小段时间。要进行类型转换，你需要写出新的数据类型，后面跟上括号，括号中是你要转换的变量。请注意，这
    *并不会真正改变数据类型*，它只是为这一行代码提供了一个临时的值。这里有几个关于 Int 和 Double 类型转换的示例。查看代码执行后的结果侧边栏。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-968
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![Image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Int 类型的变量 months 转换为 Double，并将其存储在一个名为 doubleMonths 的新变量中。这为数字添加了小数位，转换后的结果是
    12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将 Double 转换为 Int：
- en: '![Image](Image00058.jpg)'
  id: totrans-971
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Double 类型的变量 days 转换为 Int。你可以看到小数点和后面的所有数字被去掉了：我们的数字变成了 365。这是因为 Int
    类型无法保存小数，它只能存储整数，因此小数点后的所有内容都被截断了。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，类型转换实际上并不会改变数据类型。在我们的示例中，即使进行了类型转换，days 仍然是 *Double* 类型。我们可以通过打印 days 来验证这一点：
- en: '![Image](Image00059.jpg)'
  id: totrans-974
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 结果侧边栏显示，days 仍然等于 365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分中，我们将介绍一些使用类型转换的示例。如果现在你还不清楚为什么需要进行类型转换，稍等一下，你会明白的！
- en: '**OPERATORS**'
  id: totrans-977
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中有许多算术运算符可以用于数学运算。你已经见过基本的赋值运算符 =。你可能也很熟悉加法 (+)、减法 (-)、乘法 (*) 和除法 (/）。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符对 Int、Float 和 Double 数据类型进行数学运算。参与运算的数字称为 *操作数*。通过在 Playground 中输入类似下面的代码，来尝试这些数学运算符：
- en: '![Image](Image00060.jpg)'
  id: totrans-980
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Playground 中输入这段代码，你将看到每个数学表达式的结果显示在侧边栏中。编写数学表达式与正常书写并没有太大区别。例如，16 减去 2
    写作 16 – 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数学表达式的结果保存到一个变量或常量中，这样你就可以在代码的其他地方使用它。要查看这是如何工作的，请在你的 Playground 中输入以下代码：
- en: '![Image](Image00061.jpg)'
  id: totrans-983
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印 sum ➊ 时，你将在侧边栏看到 7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在数学表达式中使用了数字，但数学运算符同样适用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的 Playground 中：
- en: '![Image](Image00062.jpg)'
  id: totrans-987
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以像对数字进行操作一样，对变量和常量使用数学运算符。
- en: '**SPACES MATTER**'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，运算符两侧的空格非常重要。你可以在运算符的两边都加上空格，也可以完全不加空格。但你不能只在运算符的一侧加空格，另一侧不加。这会导致错误。请看一下
    [图 2-7](text00012.html#ch02fig7)。
- en: '![image](Image00063.jpg)'
  id: totrans-991
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：确保你的运算符两侧有相同数量的空格。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点很重要：你只能对相同数据类型的变量或常量使用数学运算符。在前面的代码中，3 和 5 都是 Int 数据类型。常量 half 和 quarter 是
    Double 数据类型，因为它们是小数。如果你尝试将 Int 和 Double 相加或相乘，你会遇到像 [图 2-8](text00012.html#ch02fig8)
    中的错误。
- en: '![image](Image00064.jpg)'
  id: totrans-994
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-8：在 Swift 中，你不能对混合数据类型进行数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你真的想对混合数据类型进行数学运算怎么办呢？例如，假设你想计算你年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-997
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行会导致错误，因为我们尝试将一个 Int 和一个 Double 相乘。但别担心！你有几种方法可以确保你的操作数是相同的数据类型。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是将 myAge 声明为 Double 类型，像这样：
- en: '![Image](Image00066.jpg)'
  id: totrans-1000
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以正常工作，因为我们在乘法中使用了两个 Double 数据类型。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是使用类型转换。（我说过我们会回到这个话题的！）类型转换在这种情况下是一个很好的解决方案，因为我们不想永久地将 myAge 改为 Double
    类型，我们只想能够像处理 Double 类型那样进行数学运算。让我们来看一个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-1003
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们在进行乘法运算之前，将 myAge 转换为 Double 类型。这意味着我们不再有混合数据类型，因此代码可以正常工作。但是在 ➋ 处，我们会得到一个错误。因为
    myAge 仍然是 Int 类型。在 ➊ 处将它转换为 Double 类型并没有永久改变它的类型。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将乘数转换为 Int 吗？当然可以！这样我们就可以对两个整数进行运算，这样是可以正常工作的。然而，这会导致计算精度降低，因为我们会丢失小数部分。当你将一个
    Double 类型的变量转换为 Int 类型时，计算机会直接去掉小数点后的数字，使其变为整数。在这种情况下，你的 0.1 乘数会被转换为 Int 类型的 0。让我们在
    Playground 中试试转换变量，看看会得到什么结果：
- en: '![Image](Image00068.jpg)'
  id: totrans-1006
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，将我们的 Double 类型的 multiplier 转换为 Int 类型得到 0。转换后这个值有很大变化，因为我们丢失了小数部分：0.1
    变成了 0。如果我们没有预料到这种情况，这可能会在代码中引发很严重的问题。进行类型转换时，必须小心，确保不会意外改变值。在 ➋ 处，还有一个将 Double
    转换为 Int 的例子，如你所见，1.9 并没有被四舍五入到 2，而是小数部分被直接去掉，结果是 1。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种数学运算符，*取模运算符*（%），它可能对你来说不太熟悉。取模运算符（也叫*模*）返回除法后的余数。例如，7 % 2 = 1，因为7除以2的余数是1。试试在你的操作环境中使用取模运算符，如下所示。
- en: '![Image](Image00069.jpg)'
  id: totrans-1009
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，取模运算符对于确定一个数字是偶数（evenNumber % 2 等于 0）➊ 还是奇数（oddNumber % 2 等于 1）➋ 非常有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-1011
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算优先级**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们每行代码只做了一次数学运算，但在一行代码中做多次运算是很常见的。让我们来看一个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元钞票和两张一美元钞票，你有多少钱？让我们在一行代码中计算这个：
- en: '![Image](Image00070.jpg)'
  id: totrans-1014
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 这为myMoney赋值为17。计算机先将5乘以3，然后再加上2。那么计算机是如何知道先乘法再加法的呢？它是从左到右计算吗？不是！看看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-1016
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调整了数字顺序，结果仍然是17。如果计算机仅仅从左到右计算，它会先加上2 + 5得到7，再将7乘以3得到21。尽管我们改变了数学表达式中数字的顺序，计算机仍然先进行乘法（得到15），然后再加上2得到17。*计算机总是先进行乘法和除法运算，再进行加法和减法。*
    这被称为*运算优先级*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-1018
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号排序运算**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要像我们在钱的例子中那样依赖计算机来决定哪个步骤先做。你，程序员，拥有决定的权力！你可以使用括号将操作分组。当你把括号放在某个操作周围时，你告诉计算机首先执行这一步：
- en: '![Image](Image00072.jpg)'
  id: totrans-1020
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，括号告诉计算机先将5乘以3，然后加上2。这将给你17。在 ➋ 处，括号告诉计算机先加上2加5，然后再乘以3，结果是21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在其他括号内使用括号来使代码更加具体。计算机会先计算内层括号，然后再计算外层括号。试试这个例子：
- en: '![Image](Image00073.jpg)'
  id: totrans-1023
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机首先会在内层括号中加上2和3。然后它会将结果乘以4，因为它在外层括号内。最后，它会加上1，因为它在两个括号外面。最终结果是21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-1025
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值运算符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的另一类运算符是*复合赋值运算符*。这些是“快捷”运算符，它们将数学运算符和赋值运算符（=）结合在一起。例如，这个表达式
- en: '[PRE25]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: becomes
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 变成
- en: '[PRE26]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符通过对变量或常量执行操作来更新它的值。通俗来说，像 a += b 这样的表达式意味着“将 b 加到 a 中并将新值存储在 a 中”。[表
    2-1](text00012.html#ch2tab1) 显示了使用复合赋值运算符的数学表达式及其长形式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-1：** 短形式赋值运算符与长形式表达式'
- en: '| **Short form** | **Long form** |'
  id: totrans-1032
  prefs: []
  type: TYPE_TB
  zh: '| **短形式** | **长形式** |'
- en: '| --- | --- |'
  id: totrans-1033
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-1034
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-1035
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-1036
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-1037
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 += 运算符的实际应用。假设我们正在尝试编写一个程序来计算方舟上的动物数量。首先，我们创建一个名为 animalsOnArk 的变量，并将其设置为
    0，因为方舟上还没有动物。当不同种类的动物登上方舟时，我们希望增加 animalsOnArk 的值来统计所有动物。如果两只长颈鹿登上方舟，我们需要将 2 加到
    animalsOnArk 中。如果两只大象登上方舟，我们需要再加 2。如果四只羚羊登上方舟，我们需要将 animalsOnArk 增加 4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-1039
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00074.jpg)![Image](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 在两只长颈鹿、两只大象和四只羚羊登上方舟后，animalsOnArk 的最终值是 8。真是个动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的一些简短说明**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都有一种将注释放在代码行中的方法。注释是计算机会忽略的备注，目的是帮助阅读代码的人理解发生了什么。虽然没有注释程序也能正常运行，但在可能不清楚或令人困惑的代码段中加上注释是个好主意。即使你不打算将程序展示给别人，注释也会帮助你记住编写代码时的思路或想法。你也许会回头查看几个月或几年前写的代码，发现自己根本不记得当时在想什么。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中有两种添加注释的方法。第一种方法是在你想要添加的文本前面加上两个斜杠（//）。这些注释可以单独占据一行，像这样：
- en: '[PRE27]'
  id: totrans-1044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它们可以与一行代码放在同一行——只要注释*在*代码后面：
- en: '[PRE28]'
  id: totrans-1046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法用于长注释或*多行*注释，其中注释的开始和结束分别用 /* 和 */ 标记。（请注意，本书中我们将使用 -- *snip* -- 来表示由于空间限制省略的其他代码行。）
- en: '[PRE29]'
  id: totrans-1048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不想让计算机运行代码的某一部分，因为你正在寻找 bug，但又不想删除所有工作，你可以使用多行注释临时*注释掉*某些代码段。当你将一段代码格式化为注释时，计算机会像忽略其他注释一样忽略这段代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-1050
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何在Swift playground中编写代码，这样你就可以立即看到结果。你创建了变量和常量，学会了如何使用基本的数据类型和运算符，这些在你编写自己的计算机程序时会反复使用。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](text00013.html#ch03)中，你将使用条件语句，它告诉计算机你希望它执行哪条代码路径。代码路径是基于条件的值来选择的。
- en: '*Figure 2-1: Getting started with a playground*'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：开始使用 Playground*'
- en: You’ll be asked to name your playground ([Figure 2-2](text00012.html#ch02fig2)
    ). In this example, we’ll keep the default name *MyPlayground* . Make sure that
    you choose iOS as the platform to run the playground.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被要求为你的Playground命名（[图 2-2](text00012.html#ch02fig2)）。在这个例子中，我们将保留默认名称*MyPlayground*。确保选择iOS作为运行Playground的平台。
- en: '![image](Image00034.jpg)'
  id: totrans-1055
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00034.jpg)'
- en: '*Figure 2-2: Naming the playground and selecting the platform*'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：命名 Playground 并选择平台*'
- en: When the playground first opens, you’ll see two panels in the window, just like
    in [Figure 2-3](text00012.html#ch02fig3) . On the left is the playground editor,
    where you’ll write your code. On the right is the results sidebar, which displays
    the results of your code.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 当Playground首次打开时，你会看到窗口中有两个面板，就像在[图 2-3](text00012.html#ch02fig3)中一样。左侧是Playground编辑器，你将在这里编写代码。右侧是结果侧边栏，显示你的代码执行结果。
- en: The line var str = "Hello, playground" in [Figure 2-3](text00012.html#ch02fig3)
    creates a variable named str . A *variable* is like a container; you can use it
    to hold almost anything—a simple number, a string of letters, or a complex object
    (we’ll explain what that is later). Let’s take a closer look at how variables
    work.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 2-3](text00012.html#ch02fig3)中的那行代码var str = "Hello, playground"创建了一个名为str的变量。*变量*就像一个容器，你可以用它来存储几乎任何东西——一个简单的数字、一串字母，或者一个复杂的对象（我们稍后会解释那是什么）。让我们仔细看看变量是如何工作的。
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  id: totrans-1059
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00035.jpg)![image](Image00036.jpg)'
- en: '*Figure 2-3: Playground editor and results sidebar*'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：Playground编辑器和结果侧边栏*'
- en: '**CONSTANTS AND VARIABLES**'
  id: totrans-1061
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**常量和变量**'
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 这里再次展示[图 2-3](text00012.html#ch02fig3)中的那行代码：
- en: '![Image](Image00037.jpg)'
  id: totrans-1063
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00037.jpg)'
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 它完成了两件事。首先，它创建了一个名为str的变量。这被称为*声明*，因为我们声明了希望创建一个变量。为了创建一个变量，你输入关键词var，然后为你的变量命名——在这个例子中是str。命名变量时有一些规则，稍后我们会讲解，所以现在先使用这个例子。
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这行代码通过=运算符将"Hello, playground"赋值给str。这被称为*赋值*，因为我们将一个值赋给了我们新创建的变量。记住，你可以把变量看作一个容器，用来存放某些东西。所以现在我们有了一个名为str的容器，里面存放着"Hello,
    playground"。
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把这一行代码读作“变量str等于Hello, playground”。正如你所看到的，Swift通常非常易于阅读；这一行代码几乎用英语告诉你它在做什么。
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 变量非常方便，因为如果你想打印“Hello, playground”这句话，你只需要对str使用print命令，像下面这段代码一样：
- en: '![Image](Image00038.jpg)'
  id: totrans-1068
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00038.jpg)'
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码会在结果侧边栏打印出"Hello, playground\n"。\n会自动添加到你打印的内容末尾。它被称为*换行*字符，指示计算机跳到新的一行。
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看程序实际运行时的结果，打开调试区域，它会出现在两个面板下方，如[图 2-4](text00012.html#ch02fig4)所示。你可以通过在
    Xcode 菜单中选择**视图** ▸ **调试区域** ▸ **显示调试区域**，或者按 ⌘ -SHIFT -Y 来打开调试区域。当 str 在调试区域的控制台中打印时，你会看到
    “Hello, playground” 周围的引号和换行符不再出现。这就是如果你正式运行这个程序时 str 的真实表现！
- en: '![image](Image00039.jpg)'
  id: totrans-1071
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：在调试区域查看程序的真实输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以在你的程序中变化（或 *变化*！），因此你可以更改变量的值以存储其他内容。现在让我们试试。将以下几行代码添加到你的 playground 中。
- en: '![Image](Image00040.jpg)'
  id: totrans-1074
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改变量的值，输入变量名并使用 = 操作符将其设置为新值。我们在 ➊ 处这样做，把 str 的值更改为 "Hello, world"。计算机会丢弃 str
    原本的值，并说：“好的，老板，str 现在是 Hello, world”（也就是说，如果它能说话的话，它会这么说！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们更改 str 的值时，我们并没有再次写 var。计算机会记得我们在之前的代码行中声明了 str，并知道 str 已经存在。所以我们不需要重新创建
    str。我们只需要给它放入不同的值。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以声明 *常量*。像变量一样，常量也存储值。常量和变量之间的最大区别是常量的值永远不能改变。变量可以变化，而常量，嗯，就是常量！声明常量类似于声明变量，但我们使用的是
    let 而不是 var：
- en: '![Image](Image00041.jpg)'
  id: totrans-1078
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 myName 的常量，并赋予它 "Gloria" 的值。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个常量并赋予它一个值，它将一直保持这个值，直到永远。可以把常量看作是你刻上了某个值的大石块。如果你试图给 myName 赋予另一个值，比如
    "Matt" ，你将得到像[图 2-5](text00012.html#ch02fig5)中显示的错误。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-1081
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00042.jpg)![image](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：尝试更改常量的值将不起作用。*'
- en: '**NOTE**'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 playground 中，错误会以一个带有小白点的红色圆圈显示。点击错误标记会显示错误信息，并告诉你问题出在哪里。如果你已经显示了调试区域，你还应该能看到描述发生了什么的详细信息，有时甚至能看到如何修复它。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-1085
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量——干得好！但是什么时候应该使用其中之一呢？在 Swift 中，最好使用常量而不是变量，除非你预期值会发生变化。常量有助于使代码更“安全”。如果你知道某个值永远不会改变，为什么不把它刻在石头上，以避免以后可能的混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想记录你教室里窗户的总数以及今天开着的窗户数量。你教室里的窗户数量不会变化，因此应该使用常量来存储这个值。而今天开着的窗户数量则会根据天气和时间变化，所以应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-1088
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00044.jpg)![Image](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 numberOfWindows 设置为常量并赋值为 8，因为窗户的总数始终是 8。我们将 numberOfWindowsOpen 设置为变量并赋值为
    3，因为当我们开关窗户时，窗户的数量会发生变化。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用 var 来声明变量，使用 let 来声明常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-1091
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**命名常量和变量**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以给变量或常量取几乎任何你想要的名字，但有几个例外。你不能用已经是 Swift 关键词的单词来命名。例如，你不能将一个变量命名为 var。写 var
    var 会让你和计算机都感到困惑。如果你试图用 Swift 的保留字来命名变量或常量，编译器会报错。另外，在同一段代码中，你也不能有两个同名的变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则外，还有一些其他良好的编程准则，适用于在 Swift 中命名事物。你的变量名应始终以小写字母开头。使用*非常*具有描述性的名称也是个好主意（它们可以尽可能长）。当你使用描述性名称时，更容易理解该变量或常量的作用。如果你正在查看别人写的代码，你会觉得哪个变量名更容易理解：numKids
    还是 numberOfKidsInMyClass？第一个名字含糊不清，但第二个名字具有描述性。你会经常看到像 numberOfKidsInMyClass 这样的变量和常量，它们是由多个单词组合而成的。这种将多个单词连接起来时首字母大写的命名风格，叫做*驼峰命名法*（camel
    case）。之所以这么称呼，是因为大小写字母交替的模式就像骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-1094
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-1095
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你可以选择一个变量或常量持有的数据类型—*数据类型*。还记得我们说过可以将变量看作是一个容器，容器里可以装东西吗？那么，数据类型就像是容器的类型。计算机需要知道我们每个容器里将装什么。在
    Swift 编程中，一旦你告诉计算机你希望一个变量或常量持有某种数据类型，它就不会允许你将其他类型的东西放入该变量或常量。如果你有一个用来装土豆的篮子，把这个篮子装满水肯定是不好的主意——除非你喜欢水漏到鞋子上！
- en: '![image](Image00047.jpg)'
  id: totrans-1097
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-1098
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，你可以告诉计算机它将存储什么类型的数据。在我们关于教室窗户的例子中，我们知道这个变量将始终是一个*整数*（也就是一个整数——你不可能有半个窗户），所以我们可以指定整数数据类型，像这样：
- en: '![Image](Image00048.jpg)'
  id: totrans-1100
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示“是某种类型”。用通俗的话来说，这行代码的意思是：“变量 `numberOfWindowsOpen`，它是一个整数，等于 3。”所以这行代码创建了一个变量，给它命名，告诉计算机它的数据类型，并赋予它一个值。呼！一行代码就做了这么多事？我们提到过
    Swift 是一种非常*简洁*的语言吗？有些语言可能需要几行代码才能做同样的事。而 Swift 设计的目标就是让你可以用一行代码完成许多任务！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要声明数据类型一次。当我们告诉计算机一个变量将存储整数时，之后不需要再告诉它。如果我们再这么做，Xcode 会给出错误提示。一旦数据类型被声明，变量或常量将永远存储该类型的数据。一次是整数，永远是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要了解关于数据类型的另一件事：变量或常量不能存储与其数据类型不匹配的内容。例如，如果你尝试将一个小数赋值给 `numberOfWindowsOpen`，你会遇到错误，正如在[图
    2-6](text00012.html#ch02fig6)中所示。
- en: '![image](Image00049.jpg)'
  id: totrans-1104
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：你不能将一个小数赋值给一个本应存储整数的变量。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `numberOfWindowsOpen = 5` 和 `numberOfWindowsOpen = 0` 设置为有效并能正常工作。但你不能将 `numberOfWindowsOpen
    = 1.5` 设置为有效。
- en: '**COMMON DATA TYPES**'
  id: totrans-1107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚刚学到的，数据类型告诉计算机它正在处理什么*类型*的数据，并且如何将其存储在内存中。那么，数据类型到底是什么呢？一些常见的数据类型包括 Int、Double、Float、Bool
    和 String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下这些数据类型到底是什么！
- en: '**Int (Integers)**'
  id: totrans-1110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Int（整数）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经简单讲过整数，但让我们更详细地了解一下它们。整数，在 Swift 中称为 Int，是没有小数或分数部分的整数。你可以把它们看作是计数数字。整数是*有符号的*，意味着它们可以是负数、正数或零。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-1112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**双精度和浮点数（小数）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: '*小数*是指在小数点后有数字的数字，例如 3.14。（如果你想把整数 3 表示为小数，可以写成 3.0。）有两种数据类型可以存储小数：Double 和
    Float（*浮动点数*的缩写）。由于 Double 数据类型能够存储更大的数字，因此在 Swift 中更为常用，我们将重点讨论它们。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 当你赋值给 Double 时，必须在小数点左边有数字，否则会出错。例如，假设香蕉的价格是 19 美分一个：
- en: '![Image](Image00050.jpg)'
  id: totrans-1115
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码会导致错误，因为它在小数点左侧没有数字。➋ 处的代码则运行正常，因为它有一个前导零。（"// ERROR" 和 "// CORRECT" 是
    *注释*，注释是程序中的说明，计算机会忽略它们。详情见 “[关于注释的一些快速说明](text00012.html#ch02sb01)” 以及 [第32页](text00012.html#page_32)。）
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-1117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Bool（布尔值，或 True/False）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值* 只能是两种情况之一：真（true）或假（false）。在 Swift 中，布尔数据类型叫做 Bool。'
- en: '![Image](Image00051.jpg)'
  id: totrans-1119
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值通常在 if-else 语句中使用，用来告诉计算机程序应该走哪条路径。（我们将在[第3章](text00013.html#ch03)中更详细地讲解布尔值和
    if-else 语句。）
- en: '**String**'
  id: totrans-1121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**String（字符串）**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串数据类型用于存储单词和短语。*字符串* 是由双引号括起来的字符集合。例如，"Hello, playground" 就是一个字符串。字符串可以由各种字符组成：字母、数字、符号等。引号非常重要，因为它们告诉计算机，双引号之间的所有内容都是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串连接起来来构建句子，这个过程叫做字符串 *连接*。让我们看看它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-1124
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用加号（+）将字符串连接起来，这段代码创建了一个名为 specialGreeting 的变量，其值为字符串 "Good Morning Jude"。请注意，我们需要在
    morningGreeting 和 friend 之间加上包含空格字符（" "）的字符串，否则 specialGreeting 将会是 "Good MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-1126
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-1127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，有时在声明变量时，我们会包含数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-1129
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们也不会包含数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-1131
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事？实际上，计算机通常足够智能，能够推断出数据类型。这被称为 *类型推断* ——因为计算机会根据我们提供的线索来 *推断* 或猜测我们使用的数据类型。当你创建一个变量并为其赋初始值时，这个值会给计算机提供一个很大的线索。这里有几个例子：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你为一个没有小数部分的数值赋值（如 3），计算机会认为它是一个 Int。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你为一个数值赋值，且这个数值有小数部分（如 3.14），计算机会认为它是一个 Double。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值为 *true* 或 *false*（没有引号），计算机会认为它是一个布尔值（Bool）。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你为一个或多个字符加上引号，计算机会认为它是一个字符串（String）。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量会被设置为该数据类型，就像你自己声明数据类型一样。这完全是为了方便。你可以在每次声明新常量或变量时都包含数据类型，这样做是完全可以的。但为什么不让计算机自己推断出来，省去你时间和额外的打字呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-1138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**通过强制转换转换数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: '*强制类型转换*是临时转换变量或常量数据类型的一种方法。你可以把它想象成对一个变量施了个魔法——你让它的值表现得像另一个数据类型，但仅仅是暂时的。要做到这一点，你需要写一个新的数据类型，后面跟上括号，括号里是你要转换的变量。请注意，这*并不会真正改变数据类型*。它只是为那一行代码提供一个临时值。这里有几个关于在Int和Double之间转换的例子。看看你代码结果中的侧边栏。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-1140
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将Int类型的变量months转换为Double，并存储在一个名为doubleMonths的新变量中。这样就添加了一个小数位，这次转换的结果是12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将Double类型转换为Int：
- en: '![Image](Image00058.jpg)'
  id: totrans-1143
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将Double类型的变量days转换为Int。你会看到小数位和所有后面的数字都被去掉了：我们的数字变成了365。这是因为Int类型无法存储小数，它只能包含整数，所以小数点后的任何部分都会被去掉。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，强制转换并不会真正改变数据类型。在我们的例子中，即使进行了强制转换，days*仍然是Double类型*。我们可以通过打印days来验证这一点：
- en: '![Image](Image00059.jpg)'
  id: totrans-1146
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 结果侧边栏显示，days仍然等于365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将展示一些强制转换的使用场景和时机。所以，如果现在你还不清楚为什么需要转换一个变量，稍等一下！
- en: '**OPERATORS**'
  id: totrans-1149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中有许多算术运算符可供你做数学运算。你已经见过基本的赋值运算符=。你可能也熟悉加法( + )、减法( - )、乘法( * )和除法( / )。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符对Int、Float和Double数据类型进行数学运算。被运算的数字称为*操作数*。通过在你的操作区输入像下面这样的代码，来实验这些数学运算符：
- en: '![Image](Image00060.jpg)'
  id: totrans-1152
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在你的操作区输入这段代码，你将能在侧边栏看到每个数学表达式的结果。在代码中书写数学表达式与正常书写并没有太大区别。例如，16减去2写作16 – 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数学表达式的结果保存到变量或常量中，以便在代码的其他地方使用。要查看这个是如何工作的，请在操作区输入以下代码：
- en: '![Image](Image00061.jpg)'
  id: totrans-1155
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印sum ➊时，你会在侧边栏看到7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在数学表达式中只使用了数字，但数学运算符同样适用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 把以下代码添加到你的Playground中：
- en: '![Image](Image00062.jpg)'
  id: totrans-1159
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你可以像对待数字一样，对变量和常量使用数学运算符。
- en: '**SPACES MATTER**'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，运算符两侧的空格是很重要的。你可以在运算符的两侧各留一个空格，或者完全不留空格。但你不能只在运算符的一侧留空格，而另一侧不留。这样会导致错误。看看[图2-7](text00012.html#ch02fig7)。
- en: '![image](Image00063.jpg)'
  id: totrans-1163
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-7：确保运算符两侧的空格数量相同。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点很重要：你只能对相同数据类型的变量或常量使用数学运算符。在前面的代码中，数字三和五都是Int类型。常量half和quarter是Double类型，因为它们是小数。如果你尝试对Int和Double进行加法或乘法运算，你会得到像[图2-8](text00012.html#ch02fig8)中一样的错误。
- en: '![image](Image00064.jpg)'
  id: totrans-1166
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-8：在Swift中，你不能对混合数据类型进行数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你真的想对混合数据类型进行数学运算呢？例如，假设你想计算你年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-1169
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行会导致错误，因为我们尝试将Int与Double相乘。但别担心！你有几种方法可以确保你的操作数是相同的数据类型。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选项是将myAge声明为Double类型，像这样：
- en: '![Image](Image00066.jpg)'
  id: totrans-1172
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码之所以能工作，是因为我们正在对两个Double数据类型进行相乘。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是使用类型转换。（我说过我们会回到这个话题！）在这种情况下，类型转换是一个不错的解决方案，因为我们不希望永久地把myAge转换成Double，我们只希望能够像对待Double一样进行数学运算。让我们看一个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-1175
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，我们将myAge转换为Double类型，然后进行乘法运算。这样就没有混合数据类型了，因此代码可以正常工作。但在➋，我们会遇到错误。那是因为myAge仍然是Int类型。我们在➊做的类型转换并没有永久改变它的类型。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能把乘数转换为Int吗？当然可以！这样我们就对两个整数进行了数学运算，这样是没问题的。然而，这样的计算结果会不够精确，因为我们会丢失小数点。当你把一个变量从Double转换为Int时，计算机会简单地去掉小数点后的所有数字，使其变成整数。在这种情况下，你的乘数0.1会被转换成Int类型的0。让我们在Playground中试试转换一些变量，看看会得到什么结果：
- en: '![Image](Image00068.jpg)'
  id: totrans-1178
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，将我们的 Double 类型的 multiplier 转换为 Int 后得到 0。这个值在转换后与原值差异很大，因为我们丢失了小数点：0.1
    变成了 0。如果我们没有预料到这种情况，这在代码中可能是个很严重的问题。你必须小心类型转换，确保不会意外地改变值。在 ➋ 处，这是另一个将 Double 转换为
    Int 的例子，如你所见，1.9 并没有四舍五入到 2，它的小数部分只是被去掉了，结果是 1。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个数学运算符，*取模运算符*（%），你可能不太熟悉。取模运算符（也叫*模*）给出除法后的余数。例如，7 % 2 = 1，因为 7 除以 2 的余数是
    1。你可以在你的操作环境中尝试一下取模运算符，示例如下。
- en: '![Image](Image00069.jpg)'
  id: totrans-1181
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，取模运算符对于判断一个数是偶数（evenNumber % 2 等于 0） ➊ 或奇数（oddNumber % 2 等于 1） ➋ 很有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-1183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算顺序**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在每行代码中只进行了一次数学运算，但在一行中进行多个运算是很常见的。让我们来看一个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元的钞票和两张一美元的钞票，你有多少钱呢？让我们在一行中计算：
- en: '![Image](Image00070.jpg)'
  id: totrans-1186
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 这将值 17 赋给 myMoney。计算机先计算 5 乘以 3，再加上 2。那么计算机是如何知道先进行乘法再加 2 的呢？它是按从左到右的顺序执行的吗？不是！看看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-1188
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们改变了数字的顺序，但结果仍然是 17。如果计算机只是从左到右执行，它会先加 2 + 5 得到 7，然后将这个结果 7 乘以 3，得到 21。即使我们改变了数学表达式中数字的顺序，计算机仍然会先进行乘法（得到
    15），然后再加 2 得到 17。*计算机会始终先做乘法和除法，再做加法和减法。* 这就是所谓的*运算顺序*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-1190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号排列运算顺序**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必像我们在钱的例子中那样依赖计算机来确定首先做哪一步。你，程序员，拥有决定的权力！你可以使用括号来将操作分组。当你在某个操作周围加上括号时，你告诉计算机先执行这个步骤：
- en: '![Image](Image00072.jpg)'
  id: totrans-1192
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，括号告诉计算机首先计算 5 乘以 3，然后再加 2。这会给你 17 的结果。在 ➋ 处，括号告诉计算机首先加上 2 加 5，然后再将结果乘以
    3，最终得到 21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在括号内嵌套括号来使代码更加具体。计算机会首先计算内层括号的内容，然后再计算外层的。试试这个例子：
- en: '![Image](Image00073.jpg)'
  id: totrans-1195
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，计算机会在内层括号中加上2和3。然后，它将把结果乘以4，因为这是在外层括号内。最后，它会加上1，因为1在两个括号外面。最终结果是21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-1197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值运算符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的另一类运算符是*复合赋值运算符*。这些是将数学运算符与赋值运算符（=）结合的“快捷”运算符。例如，这个表达式
- en: '[PRE30]'
  id: totrans-1199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: becomes
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 变为
- en: '[PRE31]'
  id: totrans-1201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符通过对变量或常量执行操作来更新其值。用简单的语言来说，像`a += b`这样的表达式表示“将b加到a并将新值存储回a”。[表2-1](text00012.html#ch2tab1)展示了使用复合赋值运算符的数学表达式以及它们的长形式表达式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-1：** 简短形式赋值运算符与长形式表达式'
- en: '| **Short form** | **Long form** |'
  id: totrans-1204
  prefs: []
  type: TYPE_TB
  zh: '| **简短形式** | **长形式** |'
- en: '| --- | --- |'
  id: totrans-1205
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-1206
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-1207
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-1208
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-1209
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`+=`运算符的使用。假设我们正在编写一个程序来计算方舟上动物的数量。首先，我们创建一个名为animalsOnArk的变量并将其设置为0，因为方舟上还没有动物。当不同种类的动物登上方舟时，我们希望增加animalsOnArk的值来计算所有的动物。如果两只长颈鹿登上方舟，那么我们需要将animalsOnArk增加2。如果两只大象登上方舟，我们需要再增加2。如果四只羚羊登上方舟，我们需要将animalsOnArk增加4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-1211
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00074.jpg)![Image](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 在两只长颈鹿、两只大象和四只羚羊登上方舟后，animalsOnArk的最终值是8。真是一个动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的一些快速提示**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都提供了一种方法来在代码中内联写注释。注释是被计算机忽略的备注，目的是帮助阅读代码的人理解代码的含义。虽然程序没有注释也能正常运行，但对于那些可能不清楚或令人困惑的代码部分，添加注释是一个好主意。即使你不打算将程序展示给别人，注释也能帮助你记住当时写代码时的思路。你可能会发现，几个月或几年后回来看自己写的代码时，完全不知道当时写这段代码时的想法。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种在Swift中添加注释的方法。第一种方法是在你想添加的文本前加上两个正斜杠（//）。这些注释可以单独放在一行上，如下所示：
- en: '[PRE32]'
  id: totrans-1216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它们可以和代码行放在同一行——只要注释*位于*代码之后：
- en: '[PRE33]'
  id: totrans-1218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式用于长注释，或*多行*注释，其中注释的开始和结束分别用 /* 和 */ 标记。（请注意，本书中会使用 -- *snip* -- 来表示由于篇幅原因省略的更多代码行。）
- en: '[PRE34]'
  id: totrans-1220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不希望计算机执行代码的某一部分，因为你在查找 bug，但又不想删除所有的工作，你可以使用多行注释来*临时注释掉*代码的某些部分。当你将一段代码格式化为注释时，计算机会忽略这段代码，就像它忽略任何其他注释一样。
- en: '**WHAT YOU LEARNED**'
  id: totrans-1222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在 Swift playground 中编写代码，这让你能够立即看到结果。你创建了变量和常量，并学习了如何使用基本的数据类型和运算符，这些你在编写自己的计算机程序时将会反复使用。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](text00013.html#ch03)中，你将使用条件语句，它会告诉计算机你希望它执行哪条代码路径。代码路径的选择基于条件的值。
- en: You’ll be asked to name your playground ([Figure 2-2](text00012.html#ch02fig2)
    ). In this example, we’ll keep the default name *MyPlayground* . Make sure that
    you choose iOS as the platform to run the playground.
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被要求为你的 playground 命名（见[图 2-2](text00012.html#ch02fig2)）。在这个示例中，我们将保持默认名称 *MyPlayground*。确保选择
    iOS 作为运行 playground 的平台。
- en: '![image](Image00034.jpg)'
  id: totrans-1226
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00034.jpg)'
- en: '*Figure 2-2: Naming the playground and selecting the platform*'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：命名 playground 并选择平台*'
- en: When the playground first opens, you’ll see two panels in the window, just like
    in [Figure 2-3](text00012.html#ch02fig3) . On the left is the playground editor,
    where you’ll write your code. On the right is the results sidebar, which displays
    the results of your code.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 当 playground 第一次打开时，你会看到窗口中有两个面板，就像在[图 2-3](text00012.html#ch02fig3)中一样。左边是
    playground 编辑器，你将在这里编写代码。右边是结果侧边栏，显示你代码的运行结果。
- en: The line var str = "Hello, playground" in [Figure 2-3](text00012.html#ch02fig3)
    creates a variable named str . A *variable* is like a container; you can use it
    to hold almost anything—a simple number, a string of letters, or a complex object
    (we’ll explain what that is later). Let’s take a closer look at how variables
    work.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-3](text00012.html#ch02fig3)中的代码行 `var str = "Hello, playground"` 创建了一个名为
    str 的变量。*变量*就像一个容器，你可以用它来存储几乎任何东西——一个简单的数字、一串字母或一个复杂的对象（稍后我们会解释什么是对象）。让我们更详细地看看变量是如何工作的。'
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  id: totrans-1230
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00035.jpg)![image](Image00036.jpg)'
- en: '*Figure 2-3: Playground editor and results sidebar*'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：Playground 编辑器和结果侧边栏*'
- en: '**CONSTANTS AND VARIABLES**'
  id: totrans-1232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**常量和变量**'
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自[图 2-3](text00012.html#ch02fig3)的代码行：
- en: '![Image](Image00037.jpg)'
  id: totrans-1234
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00037.jpg)'
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 它做了两件事。首先，它创建了一个名为 str 的变量。这叫做*声明*，因为我们在声明我们希望创建一个变量。要创建一个变量，你输入关键字 var，然后输入变量的名称——在这个例子中是
    str。命名变量时有一些规则，我们稍后会介绍，所以现在先按这个例子来命名。
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，这行代码通过 = 运算符给变量 str 赋值为 "Hello, playground"。这叫做*赋值*，因为我们正在为新创建的变量赋一个值。记住，你可以将变量看作是一个容器，用来存放某些东西。所以现在我们有一个名为
    str 的容器，它存放着 "Hello, playground"。
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这行代码读作“变量 str 等于 Hello, playground。”正如你所见，Swift 通常非常易读；这行代码几乎可以用英语告诉你它在做什么。
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 变量非常方便，因为如果你想打印“Hello, playground”这句话，你只需要对 str 使用 print 命令，像下面的代码一样：
- en: '![Image](Image00038.jpg)'
  id: totrans-1239
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00038.jpg)'
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在结果边栏中打印 "Hello, playground\n"。\n 会自动加到你打印的内容末尾。它被称为*换行符*，告诉计算机跳到新的一行。
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看程序实际运行时的结果，打开调试区域，它会出现在两个面板下方，如[图 2-4](text00012.html#ch02fig4)所示。为此，请在 Xcode
    菜单中选择 **视图** ▸ **调试区域** ▸ **显示调试区域**，或者按 ⌘-SHIFT-Y。当 str 在调试区域的控制台中打印时，你可以看到 Hello,
    playground 两侧的引号和换行符不会出现。这就是 str 在你正式运行这个程序时的真实样子！
- en: '![image](Image00039.jpg)'
  id: totrans-1242
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：在调试区域查看程序的真实输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以在程序中改变（或者*变化*！），因此你可以更改变量的值来存储其他内容。现在我们来试试这个。将以下代码添加到你的 playground 中。
- en: '![Image](Image00040.jpg)'
  id: totrans-1245
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变一个变量的值，输入其名称并使用 = 运算符将其设置为新值。我们在 ➊ 处这样做，将 str 的值更改为 "Hello, world"。计算机会丢弃
    str 原先保存的内容，并说：“好的，老板，str 现在是 Hello, world”（当然，如果它能说话的话！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们更改 str 的值时，并没有再次写 var。计算机会记住我们在前一行代码中声明了 str，并知道 str 已经存在。所以我们不需要再次创建
    str。我们只是想给它放入不同的内容。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以声明*常量*。像变量一样，常量也用来存储值。常量和变量之间的最大区别是常量的值永远不能改变。变量是可以变化的，而常量则是，嗯，常量！声明常量的方式与声明变量类似，但我们使用
    let 而不是 var：
- en: '![Image](Image00041.jpg)'
  id: totrans-1249
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 myName 的常量，并将其值设为 "Gloria"。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个常量并赋予它一个值，它将一直保持这个值，直到永远。可以把常量想象成一块大石头，你已经在上面刻下了它的值。如果你尝试给 myName 赋另一个值，比如
    "Matt"，你会得到像[图 2-5](text00012.html#ch02fig5)中那样的错误。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-1252
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00042.jpg)![图片](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：尝试更改常量的值将不起作用。*'
- en: '**NOTE**'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 Playground 中，错误会显示为一个红色圆圈，里面有一个小白点。点击错误标记会显示错误信息并告诉你问题所在。如果你显示了调试区域，你还会看到描述发生了什么情况，有时甚至会告诉你如何修复它。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-1256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量——干得好！但是，什么时候应该使用一个而不是另一个呢？在 Swift 中，除非你预计值会变化，否则最好使用常量而不是变量。常量帮助代码更“安全”。如果你知道某个值永远不会改变，那为什么不把它刻在石头上，避免以后产生任何可能的混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你想记录你教室的窗户总数和今天开着的窗户数量。你教室的窗户数量是固定的，因此你应该使用常量来存储这个值。至于教室里开着的窗户数量，则会随着天气和时间变化，所以你应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-1259
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00044.jpg)![Image](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 numberOfWindows 设置为常量并设置为 8，因为总窗户数始终是 8。我们将 numberOfWindowsOpen 设置为变量并设置为
    3，因为我们需要在开关窗户时更改该值。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用 var 来表示变量，使用 let 来表示常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-1262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**命名常量和变量**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以将变量或常量命名为任何你想要的名字，但有几个例外。你不能将它们命名为 Swift 中已经是关键字的词。例如，你不能命名变量为 var。写 var
    var 会让你和计算机都感到困惑。如果你尝试使用 Swift 的保留字来命名变量或常量，你会遇到错误。同时，你也不能在同一代码块中有两个同名的变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则外，在 Swift 中命名时还有一些其他良好的编程指南。你的名称应始终以小写字母开头。使用*非常*描述性的名称也是个好主意（名称可以尽可能长）。当你使用描述性名称时，更容易理解这个变量或常量的用途。如果你在查看别人写的代码，你更容易理解哪个变量名呢：numKids
    还是 numberOfKidsInMyClass？前者含糊不清，而后者则具有描述性。常见的做法是看到多个词组合在一起的变量和常量，例如 numberOfKidsInMyClass。这种将多个单词首字母大写的命名方式，被称为*驼峰命名法*。之所以这样命名，是因为大小写字母的模式看起来像是骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-1265
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-1266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你可以选择希望一个变量或常量保存什么类型的数据——*数据类型*。还记得我们说过，你可以把一个变量当作一个容器来保存某些东西吗？那么，数据类型就像是容器的类型。计算机需要知道我们会把什么样的东西放进每个容器中。在
    Swift 编程中，一旦你告诉计算机你希望一个变量或常量保存某种数据类型，它就不允许你将其他数据类型放入这个变量或常量中。如果你有一个设计用来装土豆的篮子，把它装满水可就不太合适了——除非你喜欢水漏得到处都是！
- en: '![image](Image00047.jpg)'
  id: totrans-1268
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-1269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，你可以告诉计算机它将保存哪种类型的数据。在我们关于教室窗户的例子中，我们知道这个变量将始终是一个*整数*（也就是说，整数——你不可能真的有半个窗户），所以我们可以指定一个整数数据类型，像这样：
- en: '![Image](Image00048.jpg)'
  id: totrans-1271
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示“是...类型”。通俗来说，这行代码的意思是：“变量 `numberOfWindowsOpen`，它是一个整数，等于 3。”所以，这行代码创建了一个变量，给它命名，告诉计算机它的数据类型，并为它赋值。呼！一行代码完成了这些操作？我们提到过，Swift
    是一种非常*简洁*的语言吗？某些语言可能需要几行代码才能完成同样的事情。Swift 设计的理念就是让你用一行代码做很多事情！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要声明一次数据类型。当我们告诉计算机一个变量将保存整数时，我们不需要再次声明。事实上，如果我们再声明一次，Xcode 会给我们一个错误。一旦数据类型被声明，变量或常量将永远保存该类型的数据。一次是整数，永远是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要了解数据类型的另一件事：一个变量或常量不能保存与其数据类型不符的内容。例如，如果你试图将一个十进制数字放入 `numberOfWindowsOpen`
    中，你会遇到错误，如[图 2-6](text00012.html#ch02fig6)所示。
- en: '![image](Image00049.jpg)'
  id: totrans-1275
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：你不能将一个十进制数字放入一个应该保存整数的变量中。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `numberOfWindowsOpen = 5` 和 `numberOfWindowsOpen = 0` 是有效的并且可以正常工作。但你不能设置
    `numberOfWindowsOpen = 1.5`。
- en: '**COMMON DATA TYPES**'
  id: totrans-1278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所学，数据类型让计算机知道它正在处理什么*类型*的数据，以及如何将其存储在内存中。那么，数据类型有哪些呢？一些常见的包括 Int、Double、Float、Bool
    和 String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下这些类型的实际含义吧！
- en: '**Int (Integers)**'
  id: totrans-1281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**整数（Int）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经简要讨论了整数，但现在让我们更详细地了解它们。整数（在Swift中叫做Int）是没有小数部分或分数部分的整数。你可以把它们看作是计数数字。整数是*有符号*的，这意味着它们可以是负数、正数或零。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-1283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Double和Float（小数）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: '*小数*是指在小数点后有数字的数值，比如3.14。（如果你想将整数3表示为小数，可以写作3.0。）有两种数据类型可以存储小数：Double和Float（浮动小数点数的简写）。在Swift中，Double数据类型更常见，因为它可以存储更大的数字，所以我们将重点讨论它。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为Double赋值时，必须在小数点左侧有一个数字，否则会出现错误。例如，假设每个香蕉的价格是19美分：
- en: '![Image](Image00050.jpg)'
  id: totrans-1286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: ➊处的代码将会导致错误，因为它在小数点左侧没有数字。➋处的代码则没有问题，因为它有一个前导零。（// ERROR和// CORRECT是*注释*，它们是程序中的备注，计算机会忽略这些注释。请参见“[关于注释的一些快速说明](text00012.html#ch02sb01)”在[第32页](text00012.html#page_32)的内容。）
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-1288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**布尔值（Booleans，或真/假）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值*只能是两者之一：真或假。在Swift中，布尔数据类型称为Bool。'
- en: '![Image](Image00051.jpg)'
  id: totrans-1290
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值通常用于if-else语句中，告诉计算机程序应该走哪条路径。（我们将在[第3章](text00013.html#ch03)中更详细地讲解布尔值和if-else语句。）
- en: '**String**'
  id: totrans-1292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符串**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: String数据类型用于存储单词和短语。*字符串*是由引号括起来的字符集合。例如，"Hello, playground"是一个字符串。字符串可以由各种字符组成：字母、数字、符号等。引号非常重要，因为它们告诉计算机，所有引号之间的内容是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串连接起来的方式来构建句子，这个过程称为字符串*连接*。让我们看看它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-1295
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用加号（+）将字符串连接起来，这段代码创建了一个名为specialGreeting的变量，并将"Good Morning Jude"作为其值。注意，这里我们需要在morningGreeting和friend之间添加一个包含空格字符（"
    "）的字符串，否则specialGreeting的值将是"Good MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-1297
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-1298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，当我们声明变量时，有时会包含数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-1300
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们不包括数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-1302
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事？计算机其实足够智能，能够大多数时候推断出数据类型。这叫做*类型推断*——因为计算机会根据我们给出的线索*推测*，或猜测我们正在使用的数据类型。当你创建一个变量并赋一个初始值时，这个值就是给计算机的一个重要线索。以下是一些例子：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个没有小数的数字（如3），计算机会将其视为Int类型。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个带小数的数字（如3.14），计算机会将其视为Double类型。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你给变量赋值为*true*或*false*（没有引号），计算机会将其视为布尔值（Bool）。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个或多个带引号的字符，计算机会将其视为String类型。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量会被自动设置为该数据类型，就好像你自己声明了数据类型一样。这是为了方便。每次声明新常量或变量时，你可以显式地包含数据类型，完全没问题。但为什么不让计算机自动推断出来，从而节省时间和额外的输入呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-1309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**数据类型转换**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换*是一种临时改变变量或常量数据类型的方法。你可以把它想象成对变量施加了一种魔法——它的值像其他数据类型一样表现，但只在那一行代码中有效。为了实现这一点，你需要写出新的数据类型，后面跟上包含要转换的变量的括号。请注意，这*并不会真正改变数据类型*。它只是为那一行代码提供了一个临时值。这里有一些Int和Double之间的类型转换例子。看看你代码运行的结果侧边栏。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-1311
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![Image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将Int类型的变量months转换为Double类型，并将其存储在一个名为doubleMonths的新变量中。这会添加一个小数点，转换的结果是12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将Double类型转换为Int类型：
- en: '![Image](Image00058.jpg)'
  id: totrans-1314
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将Double类型的days转换为Int类型。你可以看到小数部分及其后面的所有数字被去掉：我们的数字变成了365。这是因为Int类型无法保存小数值，它只能包含整数，所以小数点后的部分会被截断。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，类型转换并不会实际改变数据类型。在我们的例子中，即使经过转换，days*仍然*是Double类型。我们可以通过打印days来验证这一点：
- en: '![Image](Image00059.jpg)'
  id: totrans-1317
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 结果侧边栏显示days仍然等于365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将介绍一些使用类型转换的示例。如果你现在还不明白为什么需要进行类型转换，请稍等片刻！
- en: '**OPERATORS**'
  id: totrans-1320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中有许多算术运算符可以用于数学运算。你已经看到基本的赋值运算符=。你可能也熟悉加法（+）、减法（-）、乘法（*）和除法（/）。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符对Int、Float和Double数据类型进行数学运算。正在运算的数字称为*操作数*。在你的游乐场中通过输入如下代码来试验这些数学运算符：
- en: '![Image](Image00060.jpg)'
  id: totrans-1323
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在游乐场中输入这段代码，你将在侧边栏看到每个数学表达式的结果。编写数学表达式与正常编写它们没什么不同。例如，16减去2写作16 – 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数学表达式的结果保存在一个变量或常量中，以便在代码的其他地方使用。要查看这个是如何工作的，请在你的游乐场中输入以下几行：
- en: '![Image](Image00061.jpg)'
  id: totrans-1326
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印sum ➊时，你将在侧边栏看到7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在数学表达式中使用了数字，但数学运算符同样适用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的游乐场：
- en: '![Image](Image00062.jpg)'
  id: totrans-1330
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以像对数字进行运算那样对变量和常量使用数学运算符。
- en: '**SPACES MATTER**'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，运算符两侧的空格很重要。你可以在数学运算符的两侧写上空格，或者完全不留空格。但你不能只在运算符的一侧留空格而另一侧没有空格。这样会导致错误。请看一下[图2-7](text00012.html#ch02fig7)。
- en: '![image](Image00063.jpg)'
  id: totrans-1334
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-7：确保运算符两侧有相同数量的空格。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的事项需要注意：你只能对*相同*数据类型的变量或常量使用数学运算符。在之前的代码中，三和五都是Int数据类型。常量half和quarter是Double数据类型，因为它们是小数。如果你尝试将Int与Double相加或相乘，你将遇到像[图2-8](text00012.html#ch02fig8)中所示的错误。
- en: '![image](Image00064.jpg)'
  id: totrans-1337
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-8：在Swift中，你不能对混合数据类型进行数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你真的想对混合数据类型进行数学运算呢？例如，假设你想计算你年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-1340
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行会导致错误，因为我们试图将一个Int与一个Double相乘。但不用担心！你有几种选择可以确保你的操作数是相同的数据类型。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选项是将myAge声明为Double，如下所示：
- en: '![Image](Image00066.jpg)'
  id: totrans-1343
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有效，因为我们正在相乘两个Double数据类型。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是使用强制类型转换。（我告诉过你我们会回来谈这个！）在这种情况下，强制类型转换是一个很好的解决方案，因为我们不想永久地将 myAge 改为 Double
    类型，我们只是希望能够像操作 Double 类型一样对它进行数学运算。让我们来看一个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-1346
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们在进行乘法运算之前将 myAge 转换为 Double。这意味着我们不再有混合类型，所以代码可以正常工作。但在 ➋ 处，我们会遇到错误。那是因为
    myAge 仍然是一个 Int 类型。即使在 ➊ 处将其转换为 Double，也并没有永久改变它的类型为 Double。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能将 multiplier 强制转换为 Int 吗？当然可以！然后我们就在做两个整数之间的运算，这样是没有问题的。然而，这样会导致计算结果的精度降低，因为我们会丢失小数部分。当你将一个
    Double 类型的变量强制转换为 Int 时，计算机会直接去掉小数点后面的任何数字，使其变为整数。在这种情况下，你的 multiplier 0.1 会被强制转换为
    Int 类型的 0。让我们在 playground 中强制转换一些变量，看看会得到什么结果：
- en: '![Image](Image00068.jpg)'
  id: totrans-1349
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，将我们的 Double 类型的 multiplier 强制转换为 Int 后，得到了 0。这个值在强制转换后有很大不同，因为我们丢失了小数点：0.1
    变成了 0。如果我们没有预料到这一点，这可能会在我们的代码中造成很大的问题。在进行强制类型转换时，必须小心，以确保不会意外地改变你的值。在 ➋ 处，这是另一个将
    Double 转换为 Int 的例子，正如你所看到的，1.9 并没有被四舍五入到 2，而是小数部分被去掉，剩下了 1。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个数学运算符，即 *取余运算符*（%），它可能对你来说比较陌生。取余运算符（也叫 *模* 运算符）返回除法运算后的余数。例如，7 % 2 = 1，因为
    7 除以 2 的余数是 1。你可以在 playground 中尝试一下取余运算符，像这样：
- en: '![Image](Image00069.jpg)'
  id: totrans-1352
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，取余运算符在判断一个数字是偶数（evenNumber % 2 等于 0）➊ 还是奇数（oddNumber % 2 等于 1）➋ 时非常有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-1354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算顺序**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们每行代码只做了一个数学运算，但在一行代码中做多个运算是很常见的。我们来看一个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元的钞票和两张一美元的钞票，你有多少钱？让我们在一行中计算：
- en: '![Image](Image00070.jpg)'
  id: totrans-1357
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 17 赋值给 myMoney。计算机先计算 5 乘以 3，再加上 2。那么，计算机怎么知道先乘法 *再*加法呢？它是按从左到右的顺序吗？不是！看看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-1359
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调整了数字的顺序，但结果仍然是17。如果计算机从左到右进行运算，它会先计算2 + 5得到7，再将7乘以3得到21。尽管我们改变了数学表达式中数字的顺序，计算机仍然会先执行乘法（得到15），然后再加上2得到17。*计算机会总是先做乘法和除法，再做加法和减法。*
    这叫做 *运算顺序*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-1361
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号进行运算顺序控制**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要像我们在金钱示例中那样依赖计算机来判断应该先做哪个步骤。你，作为程序员，拥有决定的权力！你可以使用括号将操作分组。当你在某个操作周围加上括号时，你告诉计算机先执行这个步骤：
- en: '![Image](Image00072.jpg)'
  id: totrans-1363
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，括号告诉计算机先将5乘以3，然后再加2。这将得到17。在 ➋ 处，括号告诉计算机先将2加5，然后再乘以3，得到21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在括号内再使用括号来使代码更具体。计算机会先计算内层括号的内容，然后再计算外层括号。试试这个例子：
- en: '![Image](Image00073.jpg)'
  id: totrans-1366
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，计算机会先计算括号内的2和3的和。然后，它会将结果乘以4，因为这个操作在外层括号内。最后它会加上外面括号之外的1，得到最终结果21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-1368
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值运算符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的另一个运算符类别是*复合赋值运算符*。这些是将数学运算符与赋值运算符（=）结合的“快捷”运算符。例如，这个表达式
- en: '[PRE35]'
  id: totrans-1370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: becomes
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 变成
- en: '[PRE36]'
  id: totrans-1372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符通过对变量或常量执行操作来更新它的值。通俗地说，像a += b这样的表达式表示“将b加到a中，并将新值存储到a中”。[表2-1](text00012.html#ch2tab1)展示了使用复合赋值运算符的数学表达式及其长形式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-1：** 简短形式赋值运算符与长形式表达式'
- en: '| **Short form** | **Long form** |'
  id: totrans-1375
  prefs: []
  type: TYPE_TB
  zh: '| **简短形式** | **长形式** |'
- en: '| --- | --- |'
  id: totrans-1376
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-1377
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-1378
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-1379
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-1380
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看+=运算符的实际应用。假设我们正在编写一个程序来计算方舟上的动物数量。首先，我们创建一个名为animalsOnArk的变量，并将其初始化为0，因为方舟上还没有动物。随着不同种类的动物上船，我们希望增加animalsOnArk，以便计算所有动物。如果两只长颈鹿上了船，我们需要将2加到animalsOnArk。如果两只大象上船，我们需要再加2。如果四只羚羊上船，我们需要将animalsOnArk增加4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-1382
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00074.jpg)![Image](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 在两只长颈鹿、两只大象和四只羚羊登上方舟后，animalsOnArk的最终值为8。真是一个动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的一些简短说明**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都提供了一种方法，允许你将注释写在代码内联的位置。注释是被计算机忽略的笔记，目的是帮助阅读代码的人理解代码的内容。虽然没有注释程序也能正常运行，但在代码中包含注释是个好主意，尤其是当某些代码段可能不清晰或容易混淆时。即使你不打算把程序展示给别人看，注释也能帮助你记住写这段代码时的思路或想法。很多时候，几个月或几年后你回头看自己写的代码时，可能完全记不得当时的想法。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中添加注释有两种方法。第一种方法是在你想要添加的文本前面加上两个斜杠（//）。这些注释可以放在它们自己的行上，像这样：
- en: '[PRE37]'
  id: totrans-1387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它们也可以与一行代码放在同一行——只要注释出现在代码*之后*：
- en: '[PRE38]'
  id: totrans-1389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法适用于长注释，或*多行*注释，注释的开始和结束由/*和*/标记。（注意，在本书中我们会使用-- *snip* --来表示省略的代码行，以节省空间。）
- en: '[PRE39]'
  id: totrans-1391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不想让计算机运行部分代码，因为你在找bug，但又不想删除所有辛苦写的代码，你可以使用多行注释来*暂时注释掉*代码段。当你将一段代码格式化为注释时，计算机会像忽略任何其他注释一样忽略这段代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-1393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，你学会了如何在Swift游乐场中编写代码，并能立即看到结果。你创建了变量和常量，并学习了如何使用基本的数据类型和运算符，这些你在编写自己程序时将会反复遇到。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](text00013.html#ch03)中，你将使用条件语句，这些语句告诉计算机你希望它执行哪条代码路径。代码路径的选择基于条件值的不同。
- en: '![image](Image00034.jpg)'
  id: totrans-1396
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00034.jpg)'
- en: '*Figure 2-2: Naming the playground and selecting the platform*'
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：命名游乐场并选择平台*'
- en: When the playground first opens, you’ll see two panels in the window, just like
    in [Figure 2-3](text00012.html#ch02fig3) . On the left is the playground editor,
    where you’ll write your code. On the right is the results sidebar, which displays
    the results of your code.
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 当游乐场首次打开时，你会看到窗口中有两个面板，就像在[图 2-3](text00012.html#ch02fig3)中一样。左边是游乐场编辑器，在这里你会编写代码。右边是结果侧边栏，显示你的代码结果。
- en: The line var str = "Hello, playground" in [Figure 2-3](text00012.html#ch02fig3)
    creates a variable named str . A *variable* is like a container; you can use it
    to hold almost anything—a simple number, a string of letters, or a complex object
    (we’ll explain what that is later). Let’s take a closer look at how variables
    work.
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 2-3](text00012.html#ch02fig3)中的那行代码`var str = "Hello, playground"`创建了一个名为str的变量。*变量*就像一个容器，你可以用它来保存几乎任何东西——一个简单的数字、一串字母，或者一个复杂的对象（我们稍后会解释这个是什么）。让我们更仔细地看看变量是如何工作的。
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  id: totrans-1400
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00035.jpg)![image](Image00036.jpg)'
- en: '*Figure 2-3: Playground editor and results sidebar*'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-3：Playground编辑器和结果侧边栏*'
- en: '**CONSTANTS AND VARIABLES**'
  id: totrans-1402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**常量和变量**'
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是[图2-3](text00012.html#ch02fig3)中的代码行：
- en: '![Image](Image00037.jpg)'
  id: totrans-1404
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00037.jpg)'
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 它做了两件事。首先，它创建了一个名为str的变量。这叫做*声明*，因为我们声明了我们想创建一个变量。要创建一个变量，你输入关键词var，然后输入变量的名字——在这个例子中是str。命名变量时有一些规则，我们稍后会讲到，所以现在先按照这个例子进行。
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这行代码使用=操作符给str赋值“Hello, playground”。这叫做*赋值*，因为我们正在给新创建的变量赋值。记住，你可以把变量看作一个容器，它保存着某些东西。所以现在我们有一个名为str的容器，它保存着"Hello,
    playground"。
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把这行代码读作“变量str等于Hello, playground”。正如你所见，Swift通常非常易读；这行代码几乎用英语告诉你它在做什么。
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 变量非常方便，因为如果你想打印“Hello, playground”，你只需要在str上使用命令print，像下面的代码一样：
- en: '![Image](Image00038.jpg)'
  id: totrans-1409
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00038.jpg)'
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在结果侧边栏中打印“Hello, playground\n”。\n会自动添加到你打印的内容末尾。它被称为*换行*字符，告诉计算机换行。
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看程序实际运行时的结果，请打开调试区域，它将出现在两个面板下方，如[图2-4](text00012.html#ch02fig4)所示。操作方法是，在Xcode菜单中选择**视图**
    ▸ **调试区域** ▸ **显示调试区域**，或者按⌘ -SHIFT -Y。当str在调试区域的控制台中打印出来时，你可以看到Hello, playground周围的引号和换行符不会出现。这就是str在你正式运行程序时的样子！
- en: '![image](Image00039.jpg)'
  id: totrans-1412
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-4：在调试区域查看程序的实际输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在程序中可以改变（或*变化*！），因此你可以更改变量的值以存储其他内容。现在让我们试一下。将以下代码行添加到你的Playground中。
- en: '![Image](Image00040.jpg)'
  id: totrans-1415
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改变量的值，输入它的名字，并使用=操作符将其设置为新值。我们在➊处这样做，将str的值改为"Hello, world"。计算机会丢弃str之前保存的内容，并说：“好的，老板，str现在是Hello,
    world”（也就是，如果它会说话的话！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们更改str的值时，我们并没有再次写var。计算机会记住我们在之前的代码行中声明了str，并知道str已经存在。所以我们不需要重新创建str，我们只需要给它赋予不同的值。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以声明*常量*。像变量一样，常量也可以存储值。常量与变量之间的最大区别在于，常量的值一旦设置就永远无法改变。变量的值可以变化，而常量的值是固定的！声明常量与声明变量类似，但我们使用`let`而不是`var`：
- en: '![Image](Image00041.jpg)'
  id: totrans-1419
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们创建了一个名为`myName`的常量，并将其赋值为"Gloria"。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个常量并给它赋值，它将一直保持这个值直到时间的尽头。可以把常量想象成一块大石头，你在上面刻下了你的值。如果你试图给`myName`赋另一个值，比如"Matt"，你会看到像[图
    2-5](text00012.html#ch02fig5)中那样的错误。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-1422
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00042.jpg)![image](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：尝试更改常量的值将不起作用。*'
- en: '**NOTE**'
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: '*在操场上，错误会以一个红色圆圈和其中的一个小白色圆圈的形式显示。点击错误标记会显示错误信息，并告诉你哪里出错。如果你有调试区域显示，你应该还能看到描述发生了什么的信息，有时甚至会告诉你如何修复它。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-1426
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量——做得好！但是何时使用其中之一呢？在 Swift 中，最佳实践是使用常量而非变量，除非你预期该值会发生变化。常量有助于使代码“更安全”。如果你知道某个值永远不会改变，为什么不将其刻入石头，以避免将来可能的混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你想跟踪教室里窗户的总数和今天开着的窗户数。教室里窗户的总数是不会变化的，所以你应该使用常量来存储这个值。教室里开着的窗户数会根据天气和时间变化，因此你应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-1429
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00044.jpg)![image](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`numberOfWindows`设为常量并将其设为8，因为窗户的总数永远是8。我们将`numberOfWindowsOpen`设为变量并将其设为3，因为我们需要根据开关窗户来更改这个值。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：用`var`来声明变量，用`let`来声明常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-1432
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**命名常量和变量**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为变量或常量起几乎任何你想要的名字，但有一些例外。你不能将它们命名为已经在 Swift 中是关键字的词。例如，你不能将变量命名为`var`。写`var
    var`只会让你和计算机都感到困惑。如果你尝试使用 Swift 的保留字命名变量或常量，会出现错误。你也不能在同一代码块中有两个名称相同的变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则外，在 Swift 中命名时还有一些其他的编程准则。你的变量名应该始终以小写字母开头。给变量起*非常*具有描述性的名字也是个好主意（名字可以尽量长）。当你使用描述性名字时，理解这个变量或常量的用途会容易很多。如果你在看别人的代码，你觉得哪个变量名更容易理解：numKids
    还是 numberOfKidsInMyClass？第一个变量名模糊不清，但第二个变量名具有描述性。我们常看到像 numberOfKidsInMyClass
    这样的变量名，它是由多个词拼接而成的。这种命名风格，即每个单词的首字母大写，将多个单词连接成一个变量名，被称为*驼峰命名法*。之所以叫驼峰命名法，是因为小写字母和大写字母的交替排列看起来像是骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-1435
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-1436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你可以选择变量或常量保存什么样的数据——*数据类型*。还记得我们说过，变量就像一个容器，用来装东西吗？那么，数据类型就像容器的类型。计算机需要知道我们将把什么样的东西放进每个容器里。在
    Swift 编程中，一旦你告诉计算机你希望变量或常量保存某种数据类型，它就不会允许你将其他类型的数据放入该变量或常量中。如果你有一个专门用来装土豆的篮子，把篮子装满水就不好了——除非你喜欢水漏到鞋子里！
- en: '![image](Image00047.jpg)'
  id: totrans-1438
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-1439
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，可以告诉计算机它将保存什么类型的数据。在我们关于教室窗户的例子中，我们知道这个变量将始终是一个*整数*（即一个整数——你不可能有半个窗户），所以我们可以指定一个整数数据类型，像这样：
- en: '![Image](Image00048.jpg)'
  id: totrans-1441
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示“是……类型”。用简单的话来说，这行代码的意思是：“变量 numberOfWindowsOpen，它是一个整数，等于 3。”所以这行代码创建了一个变量，给它命名，告诉计算机它的数据类型，并赋予它一个值。哇！一行代码就做了这么多事情？我们是不是提到过，Swift
    是一种非常*简洁*的语言？有些语言可能需要几行代码才能做到相同的事情。Swift 的设计让你只用一行代码就能完成许多操作！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要声明数据类型一次。当我们告诉计算机一个变量将存储整数时，我们不需要再次告诉它。事实上，如果我们再这样做，Xcode 会给我们一个错误。一旦声明了数据类型，变量或常量将永远保存该类型的数据。一旦是整数，永远都是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要了解数据类型的另一件事：变量或常量不能存储与其数据类型不匹配的内容。例如，如果你尝试将一个小数赋值给 `numberOfWindowsOpen`，你将会遇到错误，如[图
    2-6](text00012.html#ch02fig6)所示。
- en: '![image](Image00049.jpg)'
  id: totrans-1445
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：你不能将小数赋值给应该存储整数的变量。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `numberOfWindowsOpen = 5` 和 `numberOfWindowsOpen = 0` 是有效的并且可以正常工作。但你不能设置
    `numberOfWindowsOpen = 1.5`。
- en: '**COMMON DATA TYPES**'
  id: totrans-1448
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见的数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚刚学到的，数据类型让计算机知道它正在处理的数据*类型*是什么，以及如何将其存储在内存中。那么，数据类型有哪些呢？一些常见的数据类型包括 Int、Double、Float、Bool
    和 String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下这些数据类型到底是什么！
- en: '**Int (Integers)**'
  id: totrans-1451
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Int（整数）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经简单讨论过整数，现在让我们更详细地讲解它们。整数，在 Swift 中称为 Int，是没有小数或分数部分的整数。你可以把它们当作计数数字。整数是*有符号*的，意味着它们可以是负数、正数或零。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-1453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**双精度和浮点数（小数）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: '*小数* 是在小数点后面有数字的数字，比如 3.14。（如果你想将整数 3 写成小数，它会被写成 3.0。）有两种数据类型可以存储小数：Double
    和 Float（即*浮动点数*）。在 Swift 中，Double 数据类型更常见，因为它能存储更大的数字，所以我们将重点介绍它。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 当你赋值一个 Double 时，你必须在小数点左侧有一个数字，否则会出现错误。例如，假设香蕉每个售价 19 美分：
- en: '![Image](Image00050.jpg)'
  id: totrans-1456
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码会导致错误，因为小数点左侧没有数字。➋ 处的代码可以正常工作，因为它有一个前导零。（// ERROR 和 // CORRECT 是*注释*，是程序中的备注，计算机会忽略它们。请参见“[关于注释的一些快速说明](text00012.html#ch02sb01)”在[第32页](text00012.html#page_32)的内容。）
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-1458
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**布尔值（布尔类型，或真/假）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值* 只能是两种状态之一：true 或 false。在 Swift 中，布尔数据类型被称为 Bool。'
- en: '![Image](Image00051.jpg)'
  id: totrans-1460
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值常用于 if-else 语句中，告诉计算机程序应该走哪条路径。（我们将在[第3章](text00013.html#ch03)中更详细地讨论布尔值和
    if-else 语句。）
- en: '**String**'
  id: totrans-1462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符串**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串数据类型用于存储单词和短语。*字符串* 是一组被引号括起来的字符。例如，"Hello, playground" 是一个字符串。字符串可以由各种字符组成：字母、数字、符号等等。引号非常重要，因为它们告诉计算机，引号之间的所有内容都是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串连接起来的方式来构建句子，这个过程叫做字符串 *连接*。让我们来看一下它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-1465
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用加号（+）将字符串连接起来，这段代码创建了一个名为 specialGreeting 的变量，它的值是字符串 "Good Morning Jude"。请注意，在
    morningGreeting 和 friend 之间我们需要加上一个包含空格字符（" "）的字符串，否则 specialGreeting 的值将是 "Good
    MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-1467
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-1468
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，在我们声明变量时，有时会包括数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-1470
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们并没有包含数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-1472
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事？计算机实际上足够聪明，能够大多数时候推断出数据类型。这就是所谓的 *类型推断* ——因为计算机会 *推断* 或猜测我们使用的数据类型，这取决于我们给它的线索。当你创建一个变量并赋予初值时，这个值就是计算机的重要线索。以下是一些例子：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你为没有小数值的数字（比如 3）赋值，计算机会认为它是一个 Int 类型。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你为一个带小数值的数字（比如 3.14）赋值，计算机会认为它是一个 Double 类型。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你为单词 *true* 或 *false* 赋值（没有引号），计算机会认为它是一个 Bool 类型。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你为一个或多个字符加上引号，计算机会认为它是一个 String 类型。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量会被设置为那个数据类型，就像你自己声明了数据类型一样。这完全是为了方便。你可以在每次声明新常量或变量时都包含数据类型，这也是完全可以的。但为什么不让计算机自己推断出来，省去时间和额外的输入呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-1479
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用类型转换改变数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换* 是一种临时转换变量或常量数据类型的方法。你可以把它当作是对一个变量施法——你让它的值像不同的数据类型一样表现，但仅仅是暂时的。要做到这一点，你需要写上一个新的数据类型，并用括号包裹你正在转换的变量。请注意，这
    *并不会真正改变数据类型*，它只是为这一行代码提供一个临时的值。下面是一些在 Int 和 Double 之间进行类型转换的例子。你可以看看代码执行结果侧边栏中的输出。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-1481
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![Image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Int 类型的变量 months 转换为 Double 类型，并将结果存储在一个名为 doubleMonths 的新变量中。这时就添加了一个小数点，转换结果是
    12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将一个 Double 转换为 Int 类型：
- en: '![Image](Image00058.jpg)'
  id: totrans-1484
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将我们的Double类型的days转换为Int类型。你可以看到小数点和其后的所有数字都被去掉了：我们的数字变成了365。这是因为Int类型无法存储小数，它只能包含整数，因此小数点后的部分被舍去。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，类型转换实际上并不会改变数据类型。在我们的示例中，即使进行了类型转换，days*仍然*是Double类型。我们可以通过打印days来验证这一点：
- en: '![Image](Image00059.jpg)'
  id: totrans-1487
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: 结果侧边栏显示days仍然等于365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍一些类型转换的使用实例。如果现在还不清楚为什么要进行类型转换，稍等一下，我们会解释清楚的！
- en: '**OPERATORS**'
  id: totrans-1490
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中有许多算术运算符，你可以用来做数学运算。你已经看到了基本的赋值运算符=。你可能也很熟悉加法（+）、减法（-）、乘法（*）和除法（/）。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符对Int、Float和Double数据类型进行数学运算。被操作的数字叫做*操作数*。通过输入像以下这样的代码，在Playground中实验这些数学运算符：
- en: '![Image](Image00060.jpg)'
  id: totrans-1493
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Playground中输入这段代码，你将会在侧边栏看到每个数学表达式的结果。编写数学表达式与正常编写它们没有太大区别。例如，16减去2就写作16
    – 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数学表达式的结果保存在变量或常量中，以便在代码的其他地方使用。为了查看这一点，请在你的Playground中输入以下代码：
- en: '![Image](Image00061.jpg)'
  id: totrans-1496
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印sum➊时，侧边栏会显示7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在数学表达式中使用了数字，但数学运算符同样适用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的Playground：
- en: '![Image](Image00062.jpg)'
  id: totrans-1500
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以像对待数字一样对变量和常量使用数学运算符。
- en: '**SPACES MATTER**'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，运算符两边的空格是很重要的。你可以在数学运算符两边都写空格，或者完全不写空格。但你不能只在运算符的一边加空格，而另一边不加。这会导致错误。看看[图2-7](text00012.html#ch02fig7)。
- en: '![image](Image00063.jpg)'
  id: totrans-1504
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-7：确保在运算符两边有相同数量的空格。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的事项需要注意：你只能对相同数据类型的变量或常量使用数学运算符。在前面的代码中，三和五都是Int类型。常量half和quarter是Double类型，因为它们是小数。如果你尝试对Int和Double进行加法或乘法运算，你将会遇到像[图2-8](text00012.html#ch02fig8)中的错误。
- en: '![image](Image00064.jpg)'
  id: totrans-1507
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-8：在Swift中，你不能对混合数据类型做数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你真的想在混合数据类型上进行运算呢？例如，假设你想计算你年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-1510
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行会出现错误，因为我们尝试将一个 Int 类型与一个 Double 类型相乘。但别担心！你有几种方法可以确保操作数的类型一致。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是将 myAge 声明为 Double 类型，像这样：
- en: '![Image](Image00066.jpg)'
  id: totrans-1513
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码能正常工作，因为我们正在对两个 Double 类型的数据进行乘法运算。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是使用类型转换。（我告诉过你我们会回到这个问题！）类型转换在这种情况下是一个很好的解决方案，因为我们不想永久性地将 myAge 转换为 Double
    类型，我们只是想能够像操作 Double 类型一样对它进行数学运算。让我们来看一个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-1516
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们在乘法运算前将 myAge 转换为 Double 类型。这意味着我们不再有混合类型，所以代码可以正常工作。但是在 ➋ 处，我们会遇到一个错误。原因是
    myAge 仍然是 Int 类型。在 ➊ 处将其转换为 Double 类型并没有永久改变其类型。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能把乘数转换为整型（Int）吗？当然可以！然后我们就在两个整数上进行数学运算，这样是可以正常工作的。然而，这会导致计算精度下降，因为我们会丢失小数部分。当你将一个变量从
    Double 类型转换为 Int 类型时，计算机会简单地去掉小数点后的数字，变成一个整数。在这种情况下，你的 0.1 乘数会被转换成 Int 类型的 0。让我们在游乐场中尝试转换一些变量，看看会得到什么：
- en: '![Image](Image00068.jpg)'
  id: totrans-1519
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，将我们的 Double 类型的乘数转换为 Int 会得到 0。这个值在转换后发生了很大变化，因为我们丢失了小数部分：0.1 变成了 0。如果我们没有预料到这一点，这可能会在代码中引发严重问题。你在进行类型转换时必须小心，确保不会意外地改变你的值。在
    ➋ 处，我们又一次将 Double 转换为 Int，正如你所看到的，1.9 并没有被四舍五入为 2。它的小数部分只是被去掉了，我们最终得到了 1。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个数学运算符——*取模运算符*（%），可能你不太熟悉。取模运算符（也叫做 *模* 运算符）给出除法后的余数。例如，7 % 2 = 1，因为 7 除以
    2 的余数是 1。尝试在你的游乐场中使用取模运算符，如下所示。
- en: '![Image](Image00069.jpg)'
  id: totrans-1522
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，取模运算符在判断一个数字是偶数（evenNumber % 2 等于 0）➊ 还是奇数（oddNumber % 2 等于 1）➋ 时非常有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-1524
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算顺序**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们每行代码只做了一次数学运算，但在一行代码中进行多次运算是很常见的。让我们来看一个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元钞票和两张一美元钞票，你有多少钱？让我们用一行代码来计算：
- en: '![Image](Image00070.jpg)'
  id: totrans-1527
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将值17赋给myMoney。计算机会先计算5乘以3，然后加上2。那么，计算机是如何知道要先进行乘法，再加上2的呢？它是从左到右操作的吗？不是！看看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-1529
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调整了数字的顺序，结果依然是17。如果计算机只是从左到右执行，它将先计算2 + 5，得到7。然后，它会将这个结果7乘以3，得到21。即使我们改变了数学表达式中数字的顺序，计算机仍然会先进行乘法运算（得到15），然后加上2，得到17。*计算机总是先进行乘法和除法运算，然后才进行加法和减法。*这就是所谓的*运算顺序*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-1531
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号排列运算顺序**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必像我们在金钱示例中那样依赖计算机来确定应该先做哪个步骤。你，作为程序员，有权决定！你可以使用括号将运算组合在一起。当你将括号放在某个操作周围时，你告诉计算机首先执行那一步：
- en: '![Image](Image00072.jpg)'
  id: totrans-1533
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，括号告诉计算机先计算5乘以3，然后再加2。这将给你17。在➋处，括号告诉计算机先计算2加5，然后将结果乘以3，得到21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在其他括号内使用括号来使代码更加具体。计算机会首先计算内部的括号，然后再计算外部的括号。试试这个例子：
- en: '![Image](Image00073.jpg)'
  id: totrans-1536
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，计算机计算内部括号中的2加3。然后，它将结果乘以4，因为这个操作在外部括号内。最后，它会加上1，因为1位于两个括号之外。最终结果是21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-1538
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值运算符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的另一个运算符类别是*复合赋值运算符*。这些是将数学运算符与赋值运算符（=）结合的“快捷方式”运算符。例如，这个表达式：
- en: '[PRE40]'
  id: totrans-1540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: becomes
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 变成：
- en: '[PRE41]'
  id: totrans-1542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符，通过对变量或常量执行运算来更新其值。用简单的语言来说，像a += b这样的表达式表示“将b加到a上，并将新值存储在a中。”[表2-1](text00012.html#ch2tab1)显示了使用复合赋值运算符的数学表达式以及其长形式的表达式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-1：** 简短形式赋值运算符与长形式表达式'
- en: '| **Short form** | **Long form** |'
  id: totrans-1545
  prefs: []
  type: TYPE_TB
  zh: '| **简短形式** | **长形式** |'
- en: '| --- | --- |'
  id: totrans-1546
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-1547
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-1548
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-1549
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-1550
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 += 操作符的应用。假设我们正在编写一个程序来计算方舟上动物的数量。首先，我们创建一个名为 animalsOnArk 的变量，并将其设置为
    0，因为方舟上还没有动物。随着不同种类的动物登上方舟，我们希望增加 animalsOnArk 来统计所有的动物。如果两只长颈鹿登上方舟，那么我们需要将 animalsOnArk
    增加 2。如果两只大象登上方舟，我们需要再次增加 2。如果四只羚羊登上方舟，我们需要将 animalsOnArk 增加 4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-1552
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00074.jpg)![image](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 当两只长颈鹿、两只大象和四只羚羊登上方舟时，animalsOnArk 的最终值是 8。真是一座动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的一些快速提示**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都提供了与代码行内的注释书写方式。注释是计算机忽略的注解，目的是帮助阅读代码的人理解代码的作用。尽管没有注释程序仍然能正常运行，但最好为那些可能不清楚或令人困惑的代码部分添加注释。即使你不会把你的程序展示给其他人，注释也能帮助你记住你在编写代码时的思路或想法。回头看几个月甚至几年之前写的代码时，完全不知道自己当时在想什么，这种情况并不罕见。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中有两种方式可以添加注释。第一种方式是在你想要添加注释的文本前面放两个正斜杠（//）。这些注释可以单独放在一行上，如下所示：
- en: '[PRE42]'
  id: totrans-1557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它们也可以放在与代码同行的同一行上——只要注释在代码之后*即可*：
- en: '[PRE43]'
  id: totrans-1559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式用于长注释或*多行*注释，注释的开始和结束由 /* 和 */ 标记。（请注意，在本书中，我们将使用 -- *snip* -- 来表示省略的代码行，以节省空间。）
- en: '[PRE44]'
  id: totrans-1561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不希望计算机运行你代码的一部分，因为你正在尝试找出 bug，但你又不想删除所有辛苦写的代码，你可以使用多行注释来*暂时注释掉*部分代码。当你将一段代码格式化为注释时，计算机将忽略这些代码，就像忽略任何其他注释一样。
- en: '**WHAT YOU LEARNED**'
  id: totrans-1563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何在 Swift Playground 中编写代码，Swift Playground 允许你立即看到结果。你创建了变量和常量，并学习了如何使用基本的数据类型和操作符，这些在你编写自己的程序时将反复出现。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](text00013.html#ch03)中，你将使用条件语句，这告诉计算机你希望它走哪一条代码路径。代码路径的选择基于条件的值。
- en: '*Figure 2-2: Naming the playground and selecting the platform*'
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：命名 Playground 并选择平台*'
- en: When the playground first opens, you’ll see two panels in the window, just like
    in [Figure 2-3](text00012.html#ch02fig3) . On the left is the playground editor,
    where you’ll write your code. On the right is the results sidebar, which displays
    the results of your code.
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: 当游乐场首次打开时，你会看到窗口中有两个面板，就像在[图 2-3](text00012.html#ch02fig3)中那样。左边是游乐场编辑器，你将在这里编写代码。右边是结果侧边栏，它显示你代码的执行结果。
- en: The line var str = "Hello, playground" in [Figure 2-3](text00012.html#ch02fig3)
    creates a variable named str . A *variable* is like a container; you can use it
    to hold almost anything—a simple number, a string of letters, or a complex object
    (we’ll explain what that is later). Let’s take a closer look at how variables
    work.
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-3](text00012.html#ch02fig3)中的那行代码 var str = "Hello, playground" 创建了一个名为
    str 的变量。*变量*就像一个容器；你可以用它来存储几乎任何东西——一个简单的数字、一串字母，或是一个复杂的对象（我们稍后会解释这是什么）。让我们仔细看看变量是如何工作的。'
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  id: totrans-1569
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00035.jpg)![图片](Image00036.jpg)'
- en: '*Figure 2-3: Playground editor and results sidebar*'
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：游乐场编辑器和结果侧边栏*'
- en: '**CONSTANTS AND VARIABLES**'
  id: totrans-1571
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**常量和变量**'
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: 这是[图 2-3](text00012.html#ch02fig3)中的代码行：
- en: '![Image](Image00037.jpg)'
  id: totrans-1573
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00037.jpg)'
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: 它做了两件事。首先，它创建了一个名为 str 的变量。这被称为*声明*，因为我们在声明我们想创建一个变量。要创建一个变量，你输入单词 var，然后输入变量的名称——在这个例子中是
    str。命名变量时有一些规则，我们稍后会讲解，所以现在先使用这个例子。
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这一行代码使用 = 运算符将值 "Hello, playground" 赋给了 str。这被称为*赋值*，因为我们正在将一个值赋给我们新创建的变量。记住，你可以把变量看作一个容器，用来存储某些东西。所以现在我们有了一个名为
    str 的容器，里面存储的是 "Hello, playground"。
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这一行代码读作“变量 str 等于 Hello, playground”。正如你所见，Swift 语言通常非常易读；这一行代码几乎用英文告诉你它在做什么。
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: 变量非常方便，因为如果你想打印“Hello, playground”这句话，你只需要在字符串（str）上使用print命令，就像下面的代码：
- en: '![Image](Image00038.jpg)'
  id: totrans-1578
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00038.jpg)'
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在结果侧边栏打印出 "Hello, playground\n"。其中的 \n 会自动加到你打印内容的结尾。它被称为*换行*字符，告诉计算机跳到新的一行。
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看程序实际运行时的结果，打开调试区域，该区域会出现在两个面板下方，如[图 2-4](text00012.html#ch02fig4)所示。为此，请在
    Xcode 菜单中选择 **视图** ▸ **调试区域** ▸ **显示调试区域**，或按 ⌘ -SHIFT -Y。当 str 在调试区域的控制台中打印时，你会看到
    "Hello, playground" 周围的引号和换行符都不显示。这就是如果你正式运行这个程序时，str 的真实样子！
- en: '![image](Image00039.jpg)'
  id: totrans-1581
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：在调试区域查看程序的实际输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的程序中，变量可以改变（或*变化*！），因此你可以更改变量的值来存储其他内容。现在我们就来试一下。将以下几行代码添加到你的游乐场中。
- en: '![Image](Image00040.jpg)'
  id: totrans-1584
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改变量的值，输入其名称并使用 = 运算符将其设置为新值。我们在 ➊ 处执行此操作，将 str 的值更改为 "Hello, world"。计算机会丢弃
    str 原本存储的内容，并说：“好的，老板，str 现在是 Hello, world”（也就是说，如果它会说话的话！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们更改 str 的值时，我们不会再次写 var。计算机会记住我们之前在代码中声明了 str，并知道 str 已经存在。所以我们不需要再次创建
    str。我们只是想在其中放入不同的内容。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以声明 *常量*。与变量类似，常量也保存值。常量和变量的最大区别在于常量的值永远无法更改。变量是可变的，而常量则是常量！声明常量类似于声明变量，但我们使用的是
    let 而不是 var：
- en: '![Image](Image00041.jpg)'
  id: totrans-1588
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 myName 的常量，并将其值设置为 "Gloria"。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个常量并赋予它一个值，它将永远保持这个值。把常量想象成一块大岩石，你已经在上面刻下了你的值。如果你尝试给 myName 另一个值，例如 "Matt"，你将遇到如
    [图 2-5](text00012.html#ch02fig5) 中所示的错误。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-1591
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00042.jpg)![图片](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：尝试更改常量的值是行不通的。*'
- en: '**NOTE**'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 Playground 中，错误会以一个红色圆圈和一个小白圈的形式出现。点击错误标记会显示错误信息，并告诉你问题所在。如果你显示了调试区域，你还应该能看到描述发生了什么的信息，有时甚至会告诉你如何修复它。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-1595
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量——做得好！但是，什么时候应该使用常量而不是变量呢？在 Swift 中，除非你预期值会发生变化，否则最好使用常量而不是变量。常量有助于使代码更加“安全”。如果你知道某个值永远不会改变，为什么不把它刻在石头上，避免以后可能的混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想跟踪教室里窗户的总数和今天开着的窗户数。教室里的窗户数不会变化，所以你应该使用常量来存储这个值。然而，教室里开着的窗户数量会根据天气和时间的不同而变化，因此你应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-1598
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00044.jpg)![图片](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 numberOfWindows 设为常量，并将其值设置为 8，因为窗户的总数始终是 8。我们将 numberOfWindowsOpen 设为变量，并将其值设置为
    3，因为当我们开关窗户时，我们希望更改这个值。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用 var 来声明变量，使用 let 来声明常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-1601
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**命名常量和变量**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以为变量或常量起任何你想要的名字，但有一些例外情况。你不能将它们命名为 Swift 中已经存在的关键字。例如，你不能将变量命名为 var。写 var
    var 会让你和计算机都感到困惑。如果你尝试使用 Swift 的保留字来命名变量或常量，你会遇到错误。你还不能在同一代码块中有两个名字相同的变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则外，在 Swift 中命名时还有一些其他良好的编程指导原则。你的变量名应该始终以小写字母开头。使用*非常*具有描述性的名称也是个好主意（它们可以尽可能长）。当你使用描述性名称时，理解该变量或常量的用途要容易得多。如果你正在查看别人写的代码，你会发现哪个变量名更容易理解：numKids
    还是 numberOfKidsInMyClass？第一个变量名模糊不清，而第二个则很具描述性。我们常见到的变量和常量名称通常是几个单词连接起来的形式，比如
    numberOfKidsInMyClass。这种命名方式，其中每个单词的首字母大写，通常用于将多个单词组成一个变量名，这种命名风格叫做*驼峰式命名法*。之所以这样命名，是因为小写字母和大写字母交替出现的样式看起来像骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-1604
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-1605
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你可以选择一个变量或常量存储的*数据类型*。还记得我们说过，变量就像是一个容器，里面可以存放东西吗？那么，数据类型就像是容器的类型。计算机需要知道我们每个容器里会放些什么内容。在
    Swift 编程中，一旦你告诉计算机某个变量或常量要存储某种数据类型，计算机就不会允许你把其他类型的数据放进去。如果你有一个专门用来装土豆的篮子，最好不要把水倒进去——除非你喜欢水洒得到处都是！
- en: '![image](Image00047.jpg)'
  id: totrans-1607
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-1608
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，你可以告诉计算机它将存储什么类型的数据。在我们关于教室窗户的示例中，我们知道这个变量将始终是一个*整数*（也就是说，一个整数——你不可能有半个窗户），所以我们可以指定一个整数数据类型，像这样：
- en: '![Image](Image00048.jpg)'
  id: totrans-1610
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示“是……的类型”。用简单的语言来说，这行代码的意思是，“变量 numberOfWindowsOpen 是整数类型，它的值等于 3。”所以这一行代码创建了一个变量，给它起了个名字，告诉计算机它的数据类型，并为它赋了一个值。呼！一行代码就做了这些事？我们是不是提到过
    Swift 是一种非常*简洁*的语言？有些语言可能需要几行代码才能完成同样的操作。而 Swift 设计得非常高效，你只需一行代码就能完成很多事情！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要声明一次数据类型。当我们告诉计算机某个变量将存储整数时，之后就不需要再次告诉它。事实上，如果你这样做，Xcode 会给你一个错误。一旦数据类型声明，变量或常量将永远存储该类型的数据。一旦是整数，永远是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件关于数据类型的事你需要了解：变量或常量不能存储不符合其数据类型的内容。例如，如果你试图把一个小数赋值给 `numberOfWindowsOpen`，你会得到一个错误，正如[图
    2-6](text00012.html#ch02fig6)所示。
- en: '![image](Image00049.jpg)'
  id: totrans-1614
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：你不能将小数赋给一个本应存储整数的变量。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `numberOfWindowsOpen = 5` 和 `numberOfWindowsOpen = 0` 是有效且可行的。但你不能设置 `numberOfWindowsOpen
    = 1.5`。
- en: '**COMMON DATA TYPES**'
  id: totrans-1617
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚刚学到的，数据类型让计算机知道它正在处理什么*类型*的数据，以及如何将其存储在内存中。那么，数据类型到底有哪些呢？一些常见的数据类型包括 Int、Double、Float、Bool
    和 String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入看看这些数据类型究竟是什么！
- en: '**Int (Integers)**'
  id: totrans-1620
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Int（整数）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经稍微谈过了整数，但让我们更详细地了解它们。整数，在 Swift 中称为 Int，是没有小数或分数部分的整数。你可以把它们当作计数数字。整数是*有符号的*，意味着它们可以是负数、正数（或零）。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-1622
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Double 和 Float（小数）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: '*小数*是指小数点后有数字的数字，比如 3.14。（如果你想把整数 3 作为小数使用，它将写作 3.0。）有两种数据类型可以存储小数：Double 和
    Float（即*浮动点数*的简称）。在 Swift 中，Double 数据类型更为常见，因为它能存储更大的数字，因此我们将重点讨论它们。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: 当你赋值给一个 Double 时，必须确保小数点左边有数字，否则会报错。例如，假设每根香蕉的价格是 19 美分：
- en: '![Image](Image00050.jpg)'
  id: totrans-1625
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码会导致错误，因为小数点左边没有数字。➋ 处的代码是正确的，因为它有一个前导零。（“// ERROR”和“// CORRECT”是*注释*，即程序中的备注，计算机会忽略它们。请参见
    “[关于注释的一些简要说明](text00012.html#ch02sb01)” 在[第32页](text00012.html#page_32)）。
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-1627
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Bool（布尔值，或真/假）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值*只能是两者之一：true 或 false。在 Swift 中，布尔数据类型被称为 Bool。'
- en: '![Image](Image00051.jpg)'
  id: totrans-1629
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值通常用于 if-else 语句中，告诉计算机程序应该走哪条路径。（我们将在[第3章](text00013.html#ch03)中更详细地讨论布尔值和
    if-else 语句。）
- en: '**String**'
  id: totrans-1631
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**String（字符串）**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: String数据类型用于存储单词和短语。*字符串*是由引号括起来的字符集合。例如，"Hello, playground"是一个字符串。字符串可以由各种字符组成：字母、数字、符号等。引号很重要，因为它们告诉计算机，引号之间的所有内容都是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串连接在一起来构建句子，这个过程叫做字符串*拼接*。让我们看看它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-1634
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用加号（+）将字符串连接在一起，这段代码创建了一个名为specialGreeting的变量，其值为字符串"Good Morning Jude"。请注意，我们需要在`morningGreeting`和`friend`之间添加一个包含空格字符（"
    "）的字符串，否则specialGreeting的值将变成"Good MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-1636
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-1637
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，有时在我们声明变量时，我们会包括数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-1639
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们并不包含数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-1641
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事？计算机实际上足够智能，大多数时候可以推断出数据类型。这叫做*类型推断*——因为计算机会根据我们提供的线索来*推断*，或者猜测，我们使用的数据类型。当你创建一个变量并为其赋予初始值时，这个值就是给计算机的一个重要线索。以下是一些示例：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个没有小数值的数字（例如3），计算机会认为它是一个Int类型。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个带有小数值的数字（例如3.14），计算机会认为它是一个Double类型。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值为*true*或*false*（没有引号），计算机会认为它是一个Bool类型。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值为一个或多个带引号的字符，计算机会认为它是一个String类型。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量会被设置为该数据类型，就像你自己声明了数据类型一样。这完全是为了方便。你可以在每次声明新常量或变量时都包括数据类型，这样也完全没问题。但为什么不让计算机自己推断出来，节省时间并减少额外的输入呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-1648
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**通过类型转换转换数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换*是一种暂时转换变量或常量数据类型的方法。你可以把它想象成给变量施下了一个魔法——它的值表现得像另一种数据类型，但仅仅是暂时的。要做到这一点，你需要写上新的数据类型，后面跟上括号，括号中是你正在转换的变量。请注意，这*并不会实际改变数据类型*。它只是为你在该行代码中提供了一个临时值。以下是一些Int和Double之间的转换示例。看看你的代码结果栏中的结果。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-1650
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![Image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Int 类型的变量 months 转换为 Double 类型，并将其存储在一个名为 doubleMonths 的新变量中。这会增加一个小数位，转换后的结果是
    12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将一个 Double 类型转换为 Int 类型：
- en: '![Image](Image00058.jpg)'
  id: totrans-1653
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Double 类型的 days 转换为 Int 类型。你可以看到小数点和所有后面的数字都被移除了：我们的数字变成了 365。这是因为
    Int 类型不能保存小数数字——它只能包含整数，因此小数点后的任何内容都会被删除。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，类型转换并不会实际改变数据类型。在我们的例子中，即使经过类型转换，days *仍然*是一个 Double 类型。我们可以通过打印 days 来验证这一点：
- en: '![Image](Image00059.jpg)'
  id: totrans-1656
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: 结果侧边栏显示，days 仍然等于 365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将展示一些使用类型转换的实例。所以，如果现在你还不清楚为什么要转换一个变量，稍等片刻！
- en: '**OPERATORS**'
  id: totrans-1659
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中有多种算术运算符可供你执行数学运算。你已经看到过基本的赋值运算符 = 。你可能也熟悉加法（+）、减法（-）、乘法（*）和除法（/）。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符对 Int 、Float 和 Double 数据类型执行数学运算。被操作的数字称为 *操作数*。在 playground 中尝试这些数学运算符，输入如下代码：
- en: '![Image](Image00060.jpg)'
  id: totrans-1662
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 playground 中输入这段代码，你会看到每个数学表达式的结果在侧边栏中显示。编写数学表达式的方式与正常书写时并没有太大不同。例如，16
    减 2 被写作 16 – 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数学表达式的结果保存在变量或常量中，以便在代码的其他地方使用。要查看这一点如何工作，可以在你的 playground 中输入以下行：
- en: '![Image](Image00061.jpg)'
  id: totrans-1665
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印 sum ➊ 时，你将在侧边栏看到 7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在数学表达式中使用了数字，但数学运算符也可以作用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的 playground 中：
- en: '![Image](Image00062.jpg)'
  id: totrans-1669
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以像对数字一样，使用数学运算符对变量和常量进行运算。
- en: '**SPACES MATTER**'
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，运算符两边的空格很重要。你可以在数学运算符的两边写一个空格，或者完全不写空格。但是，你不能只在运算符的一边加空格而另一边不加，这会导致错误。看看
    [图 2-7](text00012.html#ch02fig7)。
- en: '![image](Image00063.jpg)'
  id: totrans-1673
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：确保运算符两边的空格数量相等。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点很重要需要注意：你只能对*相同*数据类型的变量或常量使用数学运算符。在之前的代码中，数字三和五都是Int类型。常量half和quarter是Double类型，因为它们是小数。如果你尝试将一个Int和一个Double相加或相乘，你会得到一个像[图2-8](text00012.html#ch02fig8)那样的错误。
- en: '![image](Image00064.jpg)'
  id: totrans-1676
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-8：在Swift中，不能对混合数据类型进行数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果你真的想在不同数据类型之间进行数学运算呢？比如说，你想计算自己年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-1679
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行将会导致错误，因为我们尝试将Int类型与Double类型相乘。但不用担心！你有几个选择来确保操作数的数据类型一致。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是将myAge声明为Double类型，像这样：
- en: '![Image](Image00066.jpg)'
  id: totrans-1682
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有效，因为我们在乘以两个Double类型的数据。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是使用类型转换。（我告诉过你我们会回到这个话题的！）在这种情况下，类型转换是一个很好的解决方案，因为我们不想将myAge永久更改为Double类型，我们只是希望能够像对待Double类型一样对它进行数学运算。让我们看一个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-1685
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们在乘法运算之前将myAge转换为Double类型。这意味着我们不再有混合数据类型，因此代码可以正常工作。但在➋处，我们将会得到错误。那是因为myAge仍然是Int类型。在➊处将其转换为Double并没有永久地将其更改为Double类型。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能将乘数转换为Int类型吗？当然可以！这样我们就可以对两个整数进行数学运算，效果很好。然而，这会导致计算结果不够精确，因为我们会丢失小数位。当你将一个变量从Double类型转换为Int类型时，计算机会简单地去除小数点后的任何数字，将其转化为整数。在这种情况下，你的0.1乘数会被转换为Int类型的0。让我们在Playground中转换一些变量，看看会得到什么结果：
- en: '![Image](Image00068.jpg)'
  id: totrans-1688
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，将我们的Double类型变量multiplier转换为Int类型得到0。这个值在转换后与原来的值差别很大，因为我们丢失了小数位：0.1变成了0。如果我们没有预料到这种情况，这可能会在代码中造成很大的问题。在进行类型转换时，你必须小心，确保不会意外改变值。在➋处，我们有另一个Double转换为Int的例子，正如你所看到的，1.9并没有四舍五入到2，而是小数部分被去掉，剩下了1。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个数学运算符——*取模运算符*（%），它可能对你来说不太熟悉。取模运算符（也叫*模数*）在除法运算后返回余数。例如，7 % 2 = 1，因为7除以2的余数是1。你可以在Playground中尝试一下取模运算符，像这样。
- en: '![Image](Image00069.jpg)'
  id: totrans-1691
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，模运算符在判断一个数字是偶数（evenNumber % 2 等于 0）➊还是奇数（oddNumber % 2 等于 1）➋时非常有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-1693
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算顺序**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们每一行代码只进行了一个数学运算，但在一行中做多个运算是很常见的。我们来看一个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元钞票和两张一美元钞票，你有多少钱？我们来一行计算：
- en: '![Image](Image00070.jpg)'
  id: totrans-1696
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把17的值赋给myMoney。计算机首先将5乘以3，然后加上2。但计算机怎么知道先乘法然后*再*加法呢？它是不是只是从左到右计算？不是的！看看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-1698
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: 我们把数字换了一下位置，结果仍然是17。如果计算机只是从左到右操作，它会先加上2 + 5得到7，然后再将这个结果7乘以3，得到21。即使我们改变了数学表达式中的数字顺序，计算机仍然先进行乘法运算（得到15），然后加上2得到17。*计算机总是先进行乘法和除法运算，然后进行加法和减法运算。*这就是*运算顺序*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-1700
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号排序运算**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必像我们在钱的例子中那样依赖计算机来决定首先做哪个步骤。你，作为程序员，拥有决定的权力！你可以使用括号将操作组合在一起。当你把括号放在某个操作周围时，你告诉计算机首先执行这个步骤：
- en: '![Image](Image00072.jpg)'
  id: totrans-1702
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，括号告诉计算机首先将5乘以3，再加上2。这将给你17。在➋，括号告诉计算机首先将2加上5，然后再乘以3，得到21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过在其他括号内使用括号来使代码更加具体。计算机会首先计算内层的括号，然后是外层的括号。试试这个例子：
- en: '![Image](Image00073.jpg)'
  id: totrans-1705
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，计算机会先在内层括号中加上2和3。然后，它将结果乘以4，因为这个运算在外层括号内。最后，它会加上1，因为1在外层括号之外。最终结果是21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-1707
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值运算符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的另一类运算符是*复合赋值运算符*。这些是将数学运算符与赋值运算符（=）结合在一起的“快捷方式”运算符。例如，这个表达式
- en: '[PRE45]'
  id: totrans-1709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: becomes
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: 变成
- en: '[PRE46]'
  id: totrans-1711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符通过对变量或常量进行运算来更新其值。简单来说，像a += b这样的表达式意味着“将b加到a，并将新值存储回a。”[表2-1](text00012.html#ch2tab1)展示了使用复合赋值运算符的数学表达式及其长形式表达式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-1：** 简短形式赋值运算符与长形式表达式'
- en: '| **Short form** | **Long form** |'
  id: totrans-1714
  prefs: []
  type: TYPE_TB
  zh: '| **简短形式** | **长形式** |'
- en: '| --- | --- |'
  id: totrans-1715
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-1716
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-1717
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-1718
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-1719
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 += 运算符的实际应用。假设我们正在编写一个程序来计算方舟上的动物数量。首先，我们创建一个名为 animalsOnArk 的变量，并将其设置为
    0，因为方舟上还没有动物。当不同种类的动物登上方舟时，我们希望增加 animalsOnArk 来计算所有的动物。如果两只长颈鹿登上方舟，那么我们需要将 animalsOnArk
    增加 2。如果两只大象登上方舟，那么我们需要再增加 2。如果四只羚羊登上方舟，那么我们需要将 animalsOnArk 增加 4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-1721
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00074.jpg)![Image](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: 在两只长颈鹿、两只大象和四只羚羊登上方舟后，animalsOnArk 的最终值为 8 。真是一个动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的几个简短说明**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都有一种方式，可以在代码中内联注释。注释是计算机忽略的备注，目的是帮助阅读代码的人理解发生了什么。虽然程序在没有任何注释的情况下也能正常运行，但在那些可能不清晰或令人困惑的代码部分添加注释是一个好主意。即使你不打算将程序展示给别人，注释也能帮助你记住在编写代码时的思路或意图。几个月或几年后回到一段自己曾经写的代码时，完全不记得当时的想法并不罕见。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中有两种添加注释的方式。第一种方法是在你要添加的文本前面放两个斜杠（//）。这些注释可以放在单独的一行中，如下所示：
- en: '[PRE47]'
  id: totrans-1726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它们可以与代码行放在同一行——只要注释出现在代码*之后*：
- en: '[PRE48]'
  id: totrans-1728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法用于长注释，或者*多行*注释，其中注释的开始和结束由 /* 和 */ 标记。（注意，我们将在本书中使用 -- *snip* -- 来表示我们因篇幅问题省略了更多的代码行。）
- en: '[PRE49]'
  id: totrans-1730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不想让计算机执行代码中的某一部分，因为你正在找 bug，但又不想删除所有辛苦的工作，你可以使用多行注释来*暂时注释掉*代码的某些部分。当你将一段代码格式化为注释时，计算机会像忽略其他注释一样忽略这段代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-1732
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在 Swift Playground 中编写代码，这样你可以立即看到结果。你创建了变量和常量，并学习了如何使用你在编写自己计算机程序时将一再遇到的基本数据类型和运算符。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](text00013.html#ch03)中，你将使用条件语句，这些语句告诉计算机你希望它执行哪条代码路径。代码路径是根据条件的值来选择的。
- en: When the playground first opens, you’ll see two panels in the window, just like
    in [Figure 2-3](text00012.html#ch02fig3) . On the left is the playground editor,
    where you’ll write your code. On the right is the results sidebar, which displays
    the results of your code.
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: 当Playground首次打开时，你会看到窗口中有两个面板，就像[图 2-3](text00012.html#ch02fig3)所示。左侧是Playground编辑器，你将在这里编写代码。右侧是结果侧边栏，显示你的代码结果。
- en: The line var str = "Hello, playground" in [Figure 2-3](text00012.html#ch02fig3)
    creates a variable named str . A *variable* is like a container; you can use it
    to hold almost anything—a simple number, a string of letters, or a complex object
    (we’ll explain what that is later). Let’s take a closer look at how variables
    work.
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-3](text00012.html#ch02fig3)中的那行代码var str = "Hello, playground"创建了一个名为str的变量。一个*变量*就像一个容器；你可以用它来存储几乎任何东西——一个简单的数字、一串字母，或者一个复杂的对象（我们稍后会解释这是什么意思）。让我们更仔细地看看变量是如何工作的。'
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  id: totrans-1737
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00035.jpg)![image](Image00036.jpg)'
- en: '*Figure 2-3: Playground editor and results sidebar*'
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：Playground编辑器和结果侧边栏*'
- en: '**CONSTANTS AND VARIABLES**'
  id: totrans-1739
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**常量与变量**'
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是[图 2-3](text00012.html#ch02fig3)中的那行代码：
- en: '![Image](Image00037.jpg)'
  id: totrans-1741
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00037.jpg)'
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码做了两件事。首先，它创建了一个名为str的变量。这叫做*声明*，因为我们在声明我们想要创建一个变量。要创建变量，你输入关键词var，然后输入变量名——在这个例子中是str。命名变量时有一些规则，我们稍后会讲解，所以现在先使用这个例子。
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这行代码通过=运算符将“Hello, playground”的值赋给str。这叫做*赋值*，因为我们将一个值赋给了我们新创建的变量。记住，你可以把变量看作是一个容器，它可以存放一些东西。所以现在我们有一个名为str的容器，存放着“Hello,
    playground”。
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这一行代码理解为“变量str等于Hello, playground”。如你所见，Swift通常非常易读；这一行代码几乎用英语告诉你它在做什么。
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: 变量非常方便，因为如果你想打印“Hello, playground”这句话，你只需要在str上使用print命令，如下代码所示：
- en: '![Image](Image00038.jpg)'
  id: totrans-1746
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00038.jpg)'
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在结果侧边栏中打印“Hello, playground\n”。\n会自动添加到你打印的内容的末尾。它被称为*换行符*，告诉计算机跳到下一行。
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看程序实际运行的结果，请打开调试区域，它将出现在两个面板下方，如[图 2-4](text00012.html#ch02fig4)所示。为此，请在Xcode菜单中选择**View**
    ▸ **Debug Area** ▸ **Show Debug Area**，或按⌘ -SHIFT -Y。当str在调试区域的控制台中打印出来时，你会看到“Hello,
    playground”周围的引号和换行符都没有显示出来。这就是如果你正式运行该程序时，str的实际样子！
- en: '![image](Image00039.jpg)'
  id: totrans-1749
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：在调试区域查看程序的真实输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以在你的程序中变化（或*变化*！），所以你可以更改变量的值以保存其他内容。让我们现在试试。将以下代码行添加到你的Playground中。
- en: '![Image](Image00040.jpg)'
  id: totrans-1752
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变变量的值，输入其名称并使用=运算符将其设置为一个新值。我们在➊处这样做，改变了str的值为"Hello, world"。计算机会丢弃str之前保存的任何值，并说：“好的，老板，str现在是Hello,
    world”（当然，如果计算机能说话，它会这么说！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们改变str的值时，我们不需要再次写var。计算机会记得我们在前一行代码中声明了str，并知道str已经存在。所以我们不需要重新创建str，我们只需要给它赋予不同的值。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以声明*常量*。像变量一样，常量也存储值。常量与变量的最大区别在于常量的值永远不能改变，而变量的值是可以变化的，常量就是——常量！声明常量与声明变量类似，但我们使用的是let而不是var：
- en: '![Image](Image00041.jpg)'
  id: totrans-1756
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为myName的常量，并将其值设置为"Gloria"。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个常量并赋予它一个值，它将一直保持这个值，直到永远。你可以把常量想象成一块大石头，你在上面刻下了这个值。如果你试图给myName赋予另一个值，比如"Matt"，你会遇到像[图
    2-5](text00012.html#ch02fig5)那样的错误。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-1759
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00042.jpg)![image](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：尝试更改常量的值是行不通的。*'
- en: '**NOTE**'
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 playground 中，错误会以一个红色圆圈和一个小白圆圈的形式出现。点击错误标志会显示错误信息，并告诉你哪里出了问题。如果你显示了调试区域，你也应该能看到描述发生了什么的相关信息，有时甚至能看到如何修复它。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-1763
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量——做得好！但是什么时候应该使用其中之一而不是另一个呢？在Swift中，最好在没有预期值会改变的情况下使用常量，而不是变量。常量有助于让代码更加“安全”。如果你知道某个值永远不会改变，为什么不把它刻入石中，以避免以后可能的混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想跟踪教室里窗户的总数和今天打开的窗户数量。教室里的窗户数量是不会改变的，所以你应该使用常量来存储这个值。而教室里打开的窗户数量会根据天气和一天中的时间变化，因此你应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-1766
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00044.jpg)![Image](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将numberOfWindows设为常量，并设置为8，因为窗户的总数永远是8。我们将numberOfWindowsOpen设为变量，并设置为3，因为我们希望在打开或关闭窗户时更改这个值。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用var来声明变量，使用let来声明常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-1769
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常量和变量的命名**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以给变量或常量起任何名字，但有一些例外。你不能将变量命名为 Swift 中已有的关键字。例如，你不能将变量命名为 var。写 var var 会让你和计算机都感到困惑。如果你尝试使用
    Swift 的保留字作为变量或常量名称，你会遇到错误。此外，你在同一段代码块中不能有两个相同名称的变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则外，在 Swift 中命名时还有一些其他好的编程规范需要遵循。你的变量名应该始终以小写字母开头。使用*非常*具描述性的名称也是一个好主意（名称可以尽可能长）。当你使用描述性名称时，理解该变量或常量的用途会更容易。如果你在查看别人写的代码，你更容易理解哪个变量名：numKids
    还是 numberOfKidsInMyClass？第一个变量名很模糊，但第二个变量名描述性更强。常见的情况是，看到变量和常量由多个词拼接在一起，比如 numberOfKidsInMyClass。这个命名风格，其中多个单词连接在一起，且每个单词的首字母大写，称为*驼峰命名法*。这是因为小写字母和大写字母的交替模式看起来像骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-1772
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-1773
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你可以选择你希望变量或常量存储的数据类型——即*数据类型*。还记得我们说过，你可以将变量看作是一个容器，用来存储某些东西吗？那么，数据类型就像是容器的类型。计算机需要知道你将在每个容器中放入什么类型的东西。在
    Swift 编程中，一旦你告诉计算机变量或常量要存储某种数据类型，它就不会允许你在该变量或常量中放入其他数据类型的内容。如果你有一个专门用来装土豆的篮子，把它装满水肯定不是个好主意——除非你喜欢水洒到鞋子上！
- en: '![image](Image00047.jpg)'
  id: totrans-1775
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-1776
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，你可以告诉计算机它将存储哪种数据类型。在我们关于教室窗户的例子中，我们知道这个变量将始终是一个*整数*（也就是一个整数——你不可能有半个窗户），所以我们可以指定一个整数数据类型，像这样：
- en: '![Image](Image00048.jpg)'
  id: totrans-1778
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示“是某种类型”。用通俗的语言来说，这行代码的意思是：“变量 numberOfWindowsOpen，它是一个整数，等于 3。”所以这一行代码创建了一个变量，给它命名，告诉计算机它的数据类型，并赋予它一个值。呼！一行代码完成了所有这些？我们是不是提到过
    Swift 是一种*简洁*的语言？有些语言可能需要多行代码才能完成同样的操作。Swift 的设计是让你可以用一行代码做很多事情！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需声明一次数据类型。当我们告诉计算机某个变量将存储整数时，不需要再次声明。事实上，如果再次声明，Xcode 会给出错误提示。一旦声明了数据类型，变量或常量将永远保持该数据类型。一旦是整数，永远是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件关于数据类型的重要事需要了解：变量或常量不能存储与其数据类型不匹配的内容。例如，如果你尝试将一个十进制数字放入 numberOfWindowsOpen
    变量中，你将会遇到错误，如 [图 2-6](text00012.html#ch02fig6) 所示。
- en: '![image](Image00049.jpg)'
  id: totrans-1782
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：你不能将一个十进制数字放入一个本应存储整数的变量中。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 numberOfWindowsOpen = 5 和 numberOfWindowsOpen = 0 是有效的，并且能正常工作。但你不能将 numberOfWindowsOpen
    设置为 1.5。
- en: '**COMMON DATA TYPES**'
  id: totrans-1785
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚刚学到的，数据类型告诉计算机它正在处理哪种*类型*的数据，并且如何将其存储在内存中。那么，数据类型有哪些呢？一些常见的类型包括 Int、Double、Float、Bool
    和 String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下这些数据类型到底是什么！
- en: '**Int (Integers)**'
  id: totrans-1788
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**整数（Int）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经稍微讨论过整数，但让我们更详细地了解它们。整数，在 Swift 中称为 Int，是没有小数部分或分数部分的整数。你可以把它们看作是计数数字。整数是*有符号的*，意味着它们可以是负数、正数或零。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-1790
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**双精度和浮点数（十进制数字）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: '*十进制数字*是指小数点后有数字的数字，例如 3.14。 （如果你希望一个整数变成十进制数字，可以将它写成 3.0。）有两种数据类型可以存储十进制数字：Double
    和 Float（浮点数的缩写）。由于 Double 数据类型能存储更大的数字，它在 Swift 中更常用，因此我们将重点介绍 Double。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: 当你赋值给一个 Double 时，必须始终确保小数点左侧有数字，否则会发生错误。例如，假设香蕉每个 19 美分：
- en: '![Image](Image00050.jpg)'
  id: totrans-1793
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码会导致错误，因为小数点左侧没有数字。➋ 处的代码运行正常，因为它有一个前导零。（“// ERROR”和“// CORRECT”是*注释*，是程序中的注释，计算机会忽略它们。请参见
    “[关于注释的一些快速说明](text00012.html#ch02sb01)” 在 [第 32 页](text00012.html#page_32) 。）
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-1795
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**布尔值（Bool，真/假）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值*只能是两种情况之一：真（true）或假（false）。在 Swift 中，布尔数据类型称为 Bool。'
- en: '![Image](Image00051.jpg)'
  id: totrans-1797
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值常用于 if-else 语句中，用于告诉计算机程序应采取哪条路径。（我们将在 [第 3 章](text00013.html#ch03) 中更详细地讨论布尔值和
    if-else 语句。）
- en: '**String**'
  id: totrans-1799
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符串（String）**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串数据类型用于存储单词和短语。*字符串*是由一组字符组成的，这些字符被引号括起来。例如，“Hello, playground”就是一个字符串。字符串可以由各种字符组成：字母、数字、符号等等。引号很重要，因为它告诉计算机引号中的所有内容都是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串连接在一起来构建句子，这个过程叫做字符串*拼接*。让我们来看看它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-1802
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用加号（+）将字符串连接在一起，这段代码创建了一个名为specialGreeting的变量，它的值是字符串“Good Morning Jude”。注意，在这里，我们需要在morningGreeting和friend之间添加一个包含空格字符（"
    "）的字符串，否则specialGreeting的值就会是“Good MorningJude”。
- en: '![Image](Image00053.jpg)'
  id: totrans-1804
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-1805
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，当我们声明一个变量时，有时我们会包含数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-1807
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们并不包含数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-1809
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？其实，计算机足够智能，能够在大多数情况下推断出数据类型。这种机制叫做*类型推断*——因为计算机会根据我们提供的线索*推断*，或者说猜测我们使用的数据类型。当你创建一个变量并给它一个初始值时，这个值就是给计算机的一个重要线索。以下是一些例子：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值给一个没有小数的数字（比如3），计算机会认为它是一个整数（Int）。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值给一个带小数的数字（比如3.14），计算机会认为它是一个双精度浮点数（Double）。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值给单词*true*或*false*（没有引号），计算机会认为它是一个布尔值（Bool）。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值给一个或多个带引号的字符，计算机会认为它是一个字符串（String）。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量就像你自己声明数据类型一样被设定为该数据类型。这是为了方便起见。当然，你也可以每次声明一个新的常量或变量时都包括数据类型，这样做完全没有问题。但为什么不让计算机来推断出来，从而节省时间和减少多余的输入呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-1816
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**通过类型转换改变数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换*是一种临时转换变量或常量数据类型的方法。你可以把它想象成对变量施下的一个魔法——你让它的值表现得像是另一种数据类型，但仅仅是暂时的。为此，你需要写一个新的数据类型，后面跟上括号，括号内包含你要转换的变量。请注意，这*并不会真正改变数据类型*。它只是给你一个临时值，仅在那一行代码中有效。下面是几个在Int和Double之间进行转换的例子。你可以查看代码结果栏中的结果。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-1818
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![Image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Int 类型的变量 months 转换为 Double 类型，并将其存储在一个名为 doubleMonths 的新变量中。这添加了一个小数位，转换的结果是
    12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将一个 Double 转换为 Int：
- en: '![Image](Image00058.jpg)'
  id: totrans-1821
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将我们的 Double 类型的 days 转换为 Int 类型。你可以看到小数点和它后面的所有数字被去掉了：我们的数字变成了 365。这是因为
    Int 类型无法保存小数，它只能包含整数，因此小数点后面的部分被截断了。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，类型转换并不会真正改变数据类型。在我们的例子中，即使进行了类型转换，days 仍然是一个 *Double* 类型。我们可以通过打印 days
    来验证这一点：
- en: '![Image](Image00059.jpg)'
  id: totrans-1824
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
  zh: 结果侧边栏显示，days 仍然等于 365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍一些关于何时以及如何使用类型转换的示例。所以，如果现在你还不清楚为什么要进行变量转换，稍等片刻，我们很快会解释！
- en: '**OPERATORS**'
  id: totrans-1827
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，有许多算术运算符可以用于数学计算。你已经看到了基本的赋值运算符 =。你可能也很熟悉加法（+）、减法（-）、乘法（*）和除法（/）。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符对 Int、Float 和 Double 数据类型进行数学计算。进行运算的数字被称为 *操作数*。在 Playground 中尝试使用这些数学运算符，输入如下代码：
- en: '![Image](Image00060.jpg)'
  id: totrans-1830
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Playground 中输入这段代码，你将会在侧边栏看到每个数学表达式的结果。编写数学表达式在代码中与通常的写法并没有太大区别。例如，16 减去
    2 写作 16 – 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数学表达式的结果保存在变量或常量中，以便在代码的其他地方使用。要查看其效果，可以在你的 Playground 中输入以下代码：
- en: '![Image](Image00061.jpg)'
  id: totrans-1833
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印 sum ➊ 时，你会在侧边栏看到 7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的数学表达式中只使用了数字，但数学运算符同样适用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的 Playground：
- en: '![Image](Image00062.jpg)'
  id: totrans-1837
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你可以像对待数字一样，在变量和常量上使用数学运算符。
- en: '**SPACES MATTER**'
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，运算符两边的空格非常重要。你可以在数学运算符的两边加上空格，或者完全不加空格。但不能只在运算符的一边加空格而另一边不加空格。这会导致错误。请查看
    [图 2-7](text00012.html#ch02fig7)。
- en: '![image](Image00063.jpg)'
  id: totrans-1841
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：确保在运算符的两边都有相同数量的空格。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的事情需要注意：你只能对*相同*数据类型的变量或常量使用数学运算符。在前面的代码中，三和五都是 Int 数据类型。常量 half 和 quarter
    是 Double 数据类型，因为它们是小数。如果你尝试将 Int 和 Double 相加或相乘，你会遇到像 [图 2-8](text00012.html#ch02fig8)
    中那样的错误。
- en: '![image](Image00064.jpg)'
  id: totrans-1844
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-8：在 Swift 中，你不能对混合数据类型进行数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你真的想对混合数据类型进行数学运算呢？例如，假设你想计算你年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-1847
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行会导致错误，因为我们尝试将一个 Int 与一个 Double 相乘。但是别担心！你有几个选项可以确保你的操作数是相同的数据类型。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是将 myAge 声明为 Double 类型，像这样：
- en: '![Image](Image00066.jpg)'
  id: totrans-1850
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码能正常工作，因为我们对两个 Double 数据类型进行了相乘。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是使用强制转换。（我告诉过你我们会回到这个话题！）在这种情况下，强制转换是一个很好的解决方案，因为我们不想永久性地将 myAge 转换为 Double
    类型，我们只希望能够像使用 Double 类型一样对其进行数学运算。让我们看一个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-1853
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 myAge 强制转换为 Double 类型，然后再进行相乘。这意味着我们不再有混合数据类型，因此代码能够正常工作。但是在 ➋ 处，我们会遇到错误。那是因为
    myAge 仍然是 Int 类型。在 ➊ 处将它强制转换为 Double 并不会永久改变它的数据类型。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能将 multiplier 强制转换为 Int 吗？当然可以！这样我们就对两个整数进行运算，这样是可以的。不过，这样做会导致计算结果精度降低，因为我们会丢失小数点。当你将一个
    Double 类型的变量强制转换为 Int 类型时，计算机会直接去掉小数点后面的数字，将其转为整数。在这种情况下，你的 multiplier 0.1 会被强制转换为
    0。让我们在 Playground 中强制转换一些变量，看看结果：
- en: '![Image](Image00068.jpg)'
  id: totrans-1856
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，将我们的 Double 类型变量 multiplier 强制转换为 Int 后得到 0。这个值在强制转换后发生了很大的变化，因为我们丢失了小数部分：0.1
    变成了 0。如果我们没有预料到这种情况，这可能在代码中引发严重问题。你在进行强制转换时必须小心，确保不会意外改变值。在 ➋ 处，另一个将 Double 强制转换为
    Int 的例子，如你所见，1.9 并没有四舍五入为 2，它的小数部分被移除，剩下的是 1。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个数学运算符，即*取模运算符*（%），它可能对你来说不太熟悉。取模运算符（也叫*模*）在除法后给出余数。例如，7 % 2 = 1，因为 7 除以
    2 的余数是 1。试着在你的 Playground 中使用取模运算符，像这样。
- en: '![Image](Image00069.jpg)'
  id: totrans-1859
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，取模运算符对于确定一个数字是偶数（evenNumber % 2 等于 0） ➊ 还是奇数（oddNumber % 2 等于 1） ➋ 很有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-1861
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算顺序**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们每行代码只执行了一次数学运算，但在一行中做多次运算是常见的。让我们看一个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元钞票和两张一美元钞票，你有多少钱？让我们在一行中计算这个：
- en: '![Image](Image00070.jpg)'
  id: totrans-1864
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
  zh: 这将值 17 赋给 myMoney。计算机先将 5 乘以 3，然后加上 2\。但计算机怎么知道先乘法再加法呢？它是从左到右做的吗？不是！看看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-1866
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: 我们改变了数字的位置，结果仍然是 17\。如果计算机仅仅从左到右执行，它会先加上 2 + 5，得到 7\。然后它会将 7 乘以 3，得到 21\。即使我们改变了数学表达式中数字的顺序，计算机仍然会先做乘法（得到
    15），然后再加上 2 得到 17\。*计算机总是先进行乘法和除法，再进行加法和减法。*这就是所谓的 *运算顺序*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-1868
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号的运算顺序**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必像在金钱示例中那样依赖计算机来判断先做哪个步骤。你，作为程序员，有权决定！你可以使用括号来将运算组合在一起。当你把括号加在某个步骤周围时，你告诉计算机先执行那个步骤：
- en: '![Image](Image00072.jpg)'
  id: totrans-1870
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ ，括号告诉计算机先将 5 乘以 3，再加 2\。这样得到的结果是 17\。在 ➋ ，括号告诉计算机先将 2 和 5 相加，再将结果乘以 3，得到的结果是
    21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在其他括号内使用括号来使代码更具特定性。计算机会先计算内层括号中的内容，再计算外层的括号。试试这个例子：
- en: '![Image](Image00073.jpg)'
  id: totrans-1873
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
  zh: 首先计算机在内层括号中将 2 和 3 相加。然后，它将结果乘以 4，因为它在外层括号内。它会最后加上 1，因为它在两个括号外面。最终的结果是 21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-1875
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值运算符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的另一类运算符是 *复合赋值运算符*。这些是将数学运算符和赋值运算符（=）结合的“快捷”运算符。例如，这个表达式
- en: '[PRE50]'
  id: totrans-1877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: becomes
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
  zh: 变成
- en: '[PRE51]'
  id: totrans-1879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符通过对变量或常量执行运算来更新它们的值。简单来说，像 a += b 这样的表达式意味着“将 b 加到 a 并把新值存储到 a 中。”[表
    2-1](text00012.html#ch2tab1) 显示了使用复合赋值运算符的数学表达式及其长形式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-1：** 简写赋值运算符与长表达式'
- en: '| **Short form** | **Long form** |'
  id: totrans-1882
  prefs: []
  type: TYPE_TB
  zh: '| **简写形式** | **长形式** |'
- en: '| --- | --- |'
  id: totrans-1883
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-1884
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-1885
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-1886
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-1887
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 += 运算符的实际应用。假设我们正在编写一个程序来计算方舟上的动物数量。首先我们创建一个名为 animalsOnArk 的变量，并将其设置为
    0，因为方舟上还没有动物。当不同种类的动物登上方舟时，我们希望增加 animalsOnArk 的值来计算所有的动物。如果两只长颈鹿登上了方舟，那么我们需要将
    animalsOnArk 增加 2。如果两只大象登上了方舟，我们需要再次增加 2。如果四只羚羊登上方舟，那么我们需要将 animalsOnArk 增加 4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-1889
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00074.jpg)![Image](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: 在两只长颈鹿、两只大象和四只羚羊登上方舟后，animalsOnArk 的最终值为 8。真是个动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的一些简短说明**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都有一种在代码中内联写注释的方式。注释是被计算机忽略的备注，目的是帮助阅读代码的人理解代码的功能。尽管没有注释程序仍然能够正常运行，但在代码中有些不清楚或令人困惑的部分添加注释是个好主意。即使你不会把程序展示给别人，注释也能帮助你记住在编写代码时的思路和目的。很多时候，当你回头查看几个月或几年前写的代码时，可能完全不记得当时的想法。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中有两种添加注释的方法。第一种方法是在你想要添加注释的文本前面加上两个正斜杠（//）。这些注释可以单独占一行，像这样：
- en: '[PRE52]'
  id: totrans-1894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-1895
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它们可以与一行代码放在同一行——只要注释位于代码*之后*：
- en: '[PRE53]'
  id: totrans-1896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-1897
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法用于长注释或*多行*注释，其中注释的开始和结束由 /* 和 */ 标记。（请注意，在本书中，我们将使用 -- *snip* -- 来表示我们因空间原因省略了更多的代码行。）
- en: '[PRE54]'
  id: totrans-1898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-1899
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不想让计算机运行代码的一部分，因为你正在尝试找出一个错误，但又不想删除所有的工作，你可以使用多行注释暂时*注释掉*部分代码。当你将一段代码格式化为注释时，计算机会像忽略其他注释一样忽略那段代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-1900
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何在 Swift playground 中编写代码，这样你可以立即看到结果。你创建了变量和常量，并学习了如何使用基本的数据类型和运算符，这些内容在你编写自己程序时会反复出现。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-1902
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第三章](text00013.html#ch03)中，你将学习如何使用条件语句，它们告诉计算机选择你希望它执行的代码路径。代码路径的选择取决于条件的值。
- en: The line var str = "Hello, playground" in [Figure 2-3](text00012.html#ch02fig3)
    creates a variable named str . A *variable* is like a container; you can use it
    to hold almost anything—a simple number, a string of letters, or a complex object
    (we’ll explain what that is later). Let’s take a closer look at how variables
    work.
  id: totrans-1903
  prefs: []
  type: TYPE_NORMAL
  zh: 代码行 var str = "Hello, playground" 在 [图 2-3](text00012.html#ch02fig3) 中创建了一个名为
    str 的变量。*变量*就像一个容器；你可以用它来存储几乎任何东西——一个简单的数字、一串字母，或者一个复杂的对象（我们稍后会解释这是什么）。让我们仔细看看变量是如何工作的。
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  id: totrans-1904
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00035.jpg)![image](Image00036.jpg)'
- en: '*Figure 2-3: Playground editor and results sidebar*'
  id: totrans-1905
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：Playground 编辑器和结果侧边栏*'
- en: '**CONSTANTS AND VARIABLES**'
  id: totrans-1906
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**常量与变量**'
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  id: totrans-1907
  prefs: []
  type: TYPE_NORMAL
  zh: 这里再次是 [图 2-3](text00012.html#ch02fig3) 中的那行代码：
- en: '![Image](Image00037.jpg)'
  id: totrans-1908
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00037.jpg)'
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
  zh: 它做了两件事。首先，它创建了一个名为 str 的变量。这被称为*声明*，因为我们声明了希望创建一个变量。要创建变量，你输入关键字 var，然后输入变量的名称——在本例中是
    str。命名变量时有一些规则，我们稍后会介绍，所以现在先用这个例子。
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  id: totrans-1910
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这行代码使用 = 操作符将 "Hello, playground" 的值赋给 str。这称为*赋值*，因为我们正在给新创建的变量赋一个值。记住，你可以将变量看作一个容器，用来存储某些东西。所以现在我们有一个名为
    str 的容器，它存储了 "Hello, playground"。
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把这行代码读作“变量 str 等于 Hello, playground。”如你所见，Swift 通常是非常易读的；这行代码几乎用英语告诉你它在做什么。
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  id: totrans-1912
  prefs: []
  type: TYPE_NORMAL
  zh: 变量非常有用，因为如果你想打印 “Hello, playground” 这句话，你只需对 str 使用 print 命令，就像下面的代码一样：
- en: '![Image](Image00038.jpg)'
  id: totrans-1913
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00038.jpg)'
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在结果侧边栏中打印 "Hello, playground\n"。\n 会自动添加到你打印内容的末尾。它被称为*换行符*，告诉计算机换到新的一行。
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  id: totrans-1915
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看程序实际运行时的结果，打开调试区域，它将出现在两个面板下方，如 [图 2-4](text00012.html#ch02fig4) 所示。为此，打开
    Xcode 菜单中的 **视图** ▸ **调试区域** ▸ **显示调试区域**，或者按 ⌘ -SHIFT -Y。当 str 在调试区域的控制台中打印时，你可以看到
    "Hello, playground" 周围的引号和换行符不会出现。这就是如果你正式运行这个程序时 str 的真实样子！
- en: '![image](Image00039.jpg)'
  id: totrans-1916
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-1917
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：在调试区域查看程序的实际输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-1918
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以在你的程序中发生变化（或*变化*！），因此你可以更改变量的值以存储其他内容。现在让我们尝试一下。将以下几行添加到你的 Playground 中。
- en: '![Image](Image00040.jpg)'
  id: totrans-1919
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-1920
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改变量的值，输入它的名称并使用 = 操作符将其设置为新值。我们在 ➊ 处执行此操作，将 str 的值更改为 "Hello, world"。计算机会丢弃
    str 原本存储的内容，并说：“好的，老板，str 现在是 Hello, world”（如果它能说话的话！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-1921
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们更改`str`的值时，我们不会再写`var`。计算机会记住我们在前面的代码行中声明了`str`，并知道`str`已经存在。所以我们不需要再次创建`str`，我们只需要给它赋一个不同的值。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-1922
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以声明*常量*。像变量一样，常量也保存值。常量与变量的最大区别在于，常量的值永远无法更改。变量可以变化，而常量则是恒定的！声明常量与声明变量类似，但我们使用的是`let`而不是`var`：
- en: '![Image](Image00041.jpg)'
  id: totrans-1923
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-1924
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个常量`myName`并给它赋值为“Gloria”。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-1925
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个常量并给它赋值，它的值将一直保持到永远。可以将常量看作是一块巨石，你已经在上面刻下了你的值。如果你试图给`myName`赋另一个值，比如“Matt”，你将会遇到像[图2-5](text00012.html#ch02fig5)所示的错误。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-1926
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00042.jpg)![image](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-5：试图更改常量的值是行不通的。*'
- en: '**NOTE**'
  id: totrans-1928
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-1929
  prefs: []
  type: TYPE_NORMAL
  zh: '*在游乐场中，错误会以一个红色圆圈和里面的小白点的形式出现。点击错误标记会显示错误信息，并告诉你问题出在哪里。如果你显示了调试区域，你还应该看到描述发生了什么的详细信息，有时甚至能告诉你如何修复它。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-1930
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-1931
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量——做得好！但是什么时候该使用一个而不是另一个呢？在Swift中，最佳实践是使用常量而不是变量，除非你预期这个值会发生变化。常量帮助使代码更“安全”。如果你知道某个值永远不会改变，为什么不把它刻在石头上，避免以后可能出现的混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-1932
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，你想跟踪你教室里窗户的总数和今天开着的窗户数量。你教室里的窗户数量是不会变的，所以应该使用常量来存储这个值。然而，教室里开着的窗户数量会根据天气和一天中的时间而变化，所以应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-1933
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00044.jpg)![image](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-1934
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`numberOfWindows`设为常量并将其值设为8，因为窗户的总数始终为8。我们将`numberOfWindowsOpen`设为变量并将其值设为3，因为在打开或关闭窗户时，我们需要改变这个值。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-1935
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用`var`声明变量，使用`let`声明常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-1936
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常量与变量的命名**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-1937
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以将变量或常量命名为任何你想要的名字，只有少数几个例外。你不能将它们命名为已经是 Swift 关键字的词。例如，你不能命名一个变量为 var。写
    var var 会让你和计算机都感到困惑。如果你试图使用 Swift 的保留字命名变量或常量，你将会遇到错误。你也不能在同一代码块中有两个名称相同的变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-1938
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则之外，在 Swift 中命名时还有一些其他良好的编程规范。你的变量名应始终以小写字母开头。使用*非常*具描述性的名称也是一个好主意（它们可以尽可能长）。当你使用描述性名称时，更容易理解该变量或常量的用途。如果你在查看别人写的代码，你更容易理解哪个变量名？是
    numKids 还是 numberOfKidsInMyClass？前者模糊不清，而后者更具描述性。我们常常看到变量和常量由一堆词组合在一起，比如 numberOfKidsInMyClass。这种将多个单词组合成一个变量名时，首字母大写的命名风格称为*驼峰命名法*。因为小写字母和大写字母交替的模式看起来像骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-1939
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-1940
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-1941
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你可以选择变量或常量要保存的数据类型。记得我们曾说过你可以把变量当作一个容器，里面装东西吗？那么，数据类型就像容器的类型。计算机需要知道我们会将什么样的东西放入每个容器中。在
    Swift 编程中，一旦你告诉计算机某个变量或常量要保存某种数据类型，它就不会允许你放入任何其他类型的数据。如果你有一个专门用来装土豆的篮子，把它装满水肯定是个糟糕的主意——除非你喜欢水浸透鞋子！
- en: '![image](Image00047.jpg)'
  id: totrans-1942
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-1943
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-1944
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，你可以告诉计算机它将保存什么类型的数据。在我们关于教室窗户的例子中，我们知道这个变量将始终是一个*整数*（也就是一个整数——你不可能有半个窗户），因此我们可以像这样指定一个整数数据类型：
- en: '![Image](Image00048.jpg)'
  id: totrans-1945
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-1946
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示“是某种类型”。用通俗的语言来说，这行代码表示：“变量 numberOfWindowsOpen 是一个整数，值为 3。”因此，这行代码创建了一个变量，给它命名，告诉计算机它的数据类型，并为它赋值。呼！一行代码做了这么多事情？我们提到过
    Swift 是一种*简洁*的语言吗？有些语言可能需要多行代码才能完成同样的事情。Swift 被设计成可以用一行代码完成许多任务！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-1947
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要声明一次数据类型。当我们告诉计算机某个变量将保存整数时，我们不需要再次告诉它。事实上，如果我们这么做，Xcode 会给我们一个错误。一旦声明了数据类型，变量或常量将永远保存这种类型的数据。一个整数，一直是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-1948
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要了解一件事：一个变量或常量不能保存不符合其数据类型的内容。例如，如果你尝试将小数数字放入 `numberOfWindowsOpen`，你会遇到错误，正如
    [图 2-6](text00012.html#ch02fig6) 所示。
- en: '![image](Image00049.jpg)'
  id: totrans-1949
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：你不能将小数数字放入应该存储整数的变量中。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-1951
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `numberOfWindowsOpen = 5` 和 `numberOfWindowsOpen = 0` 设置是有效的并且可以正常工作。但你不能将
    `numberOfWindowsOpen = 1.5` 设置为有效值。
- en: '**COMMON DATA TYPES**'
  id: totrans-1952
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-1953
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚刚学到的，数据类型让计算机知道它正在处理的是哪种*类型*的数据，并且如何将其存储在内存中。那么，数据类型有哪些呢？一些常见的包括 Int、Double、Float、Bool
    和 String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-1954
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下这些数据类型到底是什么！
- en: '**Int (Integers)**'
  id: totrans-1955
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Int（整数）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-1956
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经简要谈过整数，现在让我们更详细地了解它们。整数，在 Swift 中称为 Int，是没有小数或分数部分的整数。你可以把它们看作是计数数字。整数是*有符号*的，这意味着它们可以是负数、正数或零。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-1957
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Double 和 Float（小数数字）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-1958
  prefs: []
  type: TYPE_NORMAL
  zh: '*小数*是指在小数点后有数字的数字，像 3.14。（如果你希望它是一个小数数字，像 3 这样的整数应写成 3.0。）有两种数据类型可以存储小数：Double
    和 Float（即*浮动点数*）。在 Swift 中，Double 数据类型更为常见，因为它可以存储更大的数字，所以我们将重点讲解它。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-1959
  prefs: []
  type: TYPE_NORMAL
  zh: 当你分配一个 Double 值时，必须始终确保小数点左侧有一个数字，否则会出现错误。例如，假设香蕉的价格是 19 分每个：
- en: '![Image](Image00050.jpg)'
  id: totrans-1960
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-1961
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码会导致错误，因为它的小数点左侧没有数字。➋ 处的代码正常工作，因为它有一个前导零。（“// ERROR”和“// CORRECT”是*注释*，它们是程序中的备注，计算机会忽略它们。请参阅
    [“关于注释的一些快速说明”](text00012.html#ch02sb01) ，见 [第32页](text00012.html#page_32)。）
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-1962
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Bool（布尔值，或者说真/假）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-1963
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值*只能是两种情况之一：真（true）或假（false）。在 Swift 中，布尔数据类型叫做 Bool。'
- en: '![Image](Image00051.jpg)'
  id: totrans-1964
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-1965
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值通常在 if-else 语句中使用，告诉计算机程序应该采取哪个路径。（我们将在 [第3章](text00013.html#ch03) 中更详细地讲解布尔值和
    if-else 语句。）
- en: '**String**'
  id: totrans-1966
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符串**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-1967
  prefs: []
  type: TYPE_NORMAL
  zh: String 数据类型用于存储单词和短语。*字符串*是由引号括起来的字符集合。例如，"Hello, playground" 是一个字符串。字符串可以由各种字符组成：字母、数字、符号等。引号非常重要，因为它告诉计算机，所有在引号之间的内容都是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-1968
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串连接起来来构建句子，这个过程叫做字符串*连接*。让我们看看它是怎么工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-1969
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-1970
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用加号 (+) 将字符串连接起来，这段代码创建了一个名为 specialGreeting 的变量，它的值是字符串 "Good Morning Jude"。请注意，我们需要在
    morningGreeting 和 friend 之间加上一个包含空格字符（" "）的字符串，否则 specialGreeting 就会变成 "Good MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-1971
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-1972
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-1973
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，当我们声明一个变量时，有时会包含数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-1974
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-1975
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们不会包含数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-1976
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事？计算机实际上足够聪明，大多数情况下可以推断出数据类型。这就是所谓的*类型推断*——因为计算机会根据我们提供的线索*推断*或猜测我们使用的数据类型。当你创建一个变量并给它一个初始值时，这个值就是给计算机的一个重要线索。下面是一些示例：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-1978
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值为一个没有小数点的数字（比如 3），计算机会认为它是一个 Int 类型。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-1979
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值为一个带有小数点的数字（比如 3.14），计算机会认为它是一个 Double 类型。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-1980
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值为单词*true* 或 *false*（没有引号），计算机会认为它是一个 Bool 类型。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值为一个或多个带引号的字符，计算机会认为它是一个 String 类型。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-1982
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量会被设置为该数据类型，就好像你自己声明了数据类型一样。这纯粹是为了方便。每次声明新的常量或变量时，你可以包含数据类型，这完全没问题。但为什么不让计算机自动推断出来，从而节省时间和减少输入呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-1983
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**通过类型转换来改变数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-1984
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换*是一种临时改变变量或常量数据类型的方式。你可以把它看作是对一个变量施下魔法——你让它的值表现得像是另一种数据类型，但仅仅是暂时的。要做到这一点，你写出一个新的数据类型，后面跟着括号，括号中是你要转换的变量。注意，这*并不会真正改变数据类型*。它只是为那一行代码提供一个临时的值。这里是一些在
    Int 和 Double 之间进行类型转换的例子。看看你代码的结果边栏。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-1985
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![Image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-1986
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Int 类型的变量 months 转换为 Double 类型，并将结果存储在一个名为 doubleMonths 的新变量中。这样就添加了一个小数位，转换的结果是
    12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-1987
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将 Double 转换为 Int：
- en: '![Image](Image00058.jpg)'
  id: totrans-1988
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-1989
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Double 类型的 days 强制转换为 Int 类型。你可以看到小数位及其后的所有数字被去除了：我们的数字变成了 365。这是因为
    Int 类型无法保存小数，它只能保存整数，因此小数点后的部分被截断了。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，强制转换并不会实际改变数据类型。在我们的例子中，即使进行了强制转换，days *仍然*是一个 Double 类型。我们可以通过打印 days
    来验证这一点：
- en: '![Image](Image00059.jpg)'
  id: totrans-1991
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-1992
  prefs: []
  type: TYPE_NORMAL
  zh: 结果侧边栏显示 days 仍然等于 365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-1993
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍一些使用强制转换的实例和场景。所以如果你现在不明白为什么要强制转换变量，稍等片刻，我们会讲解清楚！
- en: '**OPERATORS**'
  id: totrans-1994
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-1995
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，有许多算术运算符可以用于数学运算。你已经看过基本的赋值运算符 = 。你可能也熟悉加法 (+)、减法 (-)、乘法 (*) 和除法 (/
    )。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-1996
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符对 Int、Float 和 Double 数据类型进行运算。正在操作的数字称为 *操作数*。在 Playground 中尝试使用这些数学运算符，输入类似以下的代码：
- en: '![Image](Image00060.jpg)'
  id: totrans-1997
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-1998
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Playground 中输入这段代码，你会在侧边栏看到每个数学表达式的结果。在代码中写数学表达式与平常书写它们并没有太大不同。例如，16 减去
    2 写作 16 – 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-1999
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数学表达式的结果保存在一个变量或常量中，这样你就可以在代码的其他地方使用它。要了解这是如何工作的，在 Playground 中输入以下几行代码：
- en: '![Image](Image00061.jpg)'
  id: totrans-2000
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-2001
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印 sum ➊ 时，你会在侧边栏看到 7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-2002
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在数学表达式中只使用了数字，但数学运算符也可以应用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-2003
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的 Playground：
- en: '![Image](Image00062.jpg)'
  id: totrans-2004
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-2005
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以像对待数字一样，在变量和常量上使用数学运算符。
- en: '**SPACES MATTER**'
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-2007
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，运算符两边的空格非常重要。你可以在数学运算符的两边写一个空格，或者完全不写空格。但不能只在运算符的一侧加空格，另一侧不加。那样会导致错误。请查看
    [图 2-7](text00012.html#ch02fig7)。
- en: '![image](Image00063.jpg)'
  id: totrans-2008
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-2009
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：确保运算符两侧的空格数目相同。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-2010
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点非常重要：你只能在相同数据类型的变量或常量之间使用数学运算符。在之前的代码中，三和五都是 Int 数据类型。常量 half 和 quarter 是
    Double 数据类型，因为它们是小数。如果你尝试将 Int 和 Double 相加或相乘，你将会遇到类似 [图 2-8](text00012.html#ch02fig8)
    中的错误。
- en: '![image](Image00064.jpg)'
  id: totrans-2011
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-2012
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-8：在 Swift 中，你不能在混合数据类型之间进行数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-2013
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你真的想在混合数据类型上进行数学运算呢？例如，假设你想计算你年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-2014
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-2015
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行会出现错误，因为我们尝试将 Int 类型和 Double 类型相乘。但别担心！你有几种方法可以确保操作数是相同的数据类型。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-2016
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是将 myAge 声明为 Double 类型，像这样：
- en: '![Image](Image00066.jpg)'
  id: totrans-2017
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-2018
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以正常工作，因为我们在乘法运算中使用了两个 Double 数据类型。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-2019
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是使用类型转换。（我告诉过你我们会回到这个问题的！）类型转换在这种情况下是一个很好的解决方案，因为我们不想永久地将 myAge 转换为 Double
    类型，我们只是想像对待 Double 类型一样使用它进行数学运算。让我们看一个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-2020
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-2021
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们在进行乘法前将 myAge 转换为 Double 类型。这意味着我们不再有混合类型，因此代码可以正常运行。但在 ➋ 处，我们会遇到错误。那是因为
    myAge 仍然是 Int 类型。在 ➊ 处将其转换为 Double 并没有永久改变它的类型为 Double。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-2022
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否将 multiplier 转换为 Int 类型？当然可以！这样我们就在对两个整数进行数学运算，结果也能正常工作。然而，这样做会导致计算精度降低，因为我们会丢失小数部分。当你将
    Double 类型的变量转换为 Int 类型时，计算机会简单地去掉小数点后面的数字，将其转换为整数。在这个例子中，0.1 会被转换为 0。让我们在 playground
    中进行一些变量转换，看看会得到什么结果：
- en: '![Image](Image00068.jpg)'
  id: totrans-2023
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-2024
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，将我们的 Double 类型变量 multiplier 转换为 Int 类型后，它变成了 0。这个值在转换后发生了显著变化，因为我们丢失了小数部分：0.1
    变成了 0。如果我们没有预料到这种情况，这在代码中可能会造成很大的问题。在 ➋ 处，还有另一个例子，展示了将 Double 类型转换为 Int 类型，如你所见，1.9
    并没有四舍五入为 2，而是小数部分被去掉，最终结果是 1。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-2025
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个数学运算符，*取模运算符*（%），它可能不太为你所熟悉。取模运算符（也叫 *模* 运算符）返回除法运算后的余数。例如，7 % 2 = 1，因为
    7 除以 2 的余数是 1。试试看在你的 playground 中使用取模运算符，像这样：
- en: '![Image](Image00069.jpg)'
  id: totrans-2026
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-2027
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，取模运算符对于判断一个数是偶数（evenNumber % 2 等于 0）➊ 还是奇数（oddNumber % 2 等于 1）➋ 很有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-2028
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算顺序**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-2029
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们每行代码只做了一个数学运算，但通常会在一行代码中进行多个运算。让我们看一个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-2030
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元钞票和两张一美元钞票，你有多少钱？让我们在一行中计算这个：
- en: '![Image](Image00070.jpg)'
  id: totrans-2031
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-2032
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给 `myMoney` 赋值为 17。计算机会先进行 5 乘 3 然后加上 2。但是计算机怎么知道先乘法后加法呢？它是从左到右工作吗？不是！看看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-2033
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-2034
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调整了数字顺序，结果仍然是 17。如果计算机只是从左到右执行，它会先加上 2 + 5 得到 7，然后将 7 乘以 3 得到 21。尽管我们更改了数学表达式中数字的顺序，计算机仍然首先执行乘法（得到
    15），然后加上 2 得到 17。*计算机会始终先进行乘法和除法，然后进行加法和减法。* 这叫做 *运算顺序*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-2035
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号排序运算**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-2036
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要像我们在货币示例中那样依赖计算机来判断该先执行哪个步骤。你，程序员，拥有决定的权力！你可以使用括号将操作组合在一起。当你在某个操作周围加上括号时，你就是在告诉计算机先执行这一部分：
- en: '![Image](Image00072.jpg)'
  id: totrans-2037
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-2038
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，括号告诉计算机先执行 5 乘 3，再加上 2。这将得到 17。在 ➋ 处，括号告诉计算机先将 2 加 5，然后再乘以 3，结果是 21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-2039
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过在另一个括号内使用括号来使代码更具特定性。计算机会先计算内层的括号，再计算外层的括号。尝试这个示例：
- en: '![Image](Image00073.jpg)'
  id: totrans-2040
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-2041
  prefs: []
  type: TYPE_NORMAL
  zh: 首先计算机会将内层括号中的 2 和 3 相加，然后将结果乘以 4，因为它在外层括号内。最后，它会将 1 加到外面，因为它位于两个括号外面。最终结果是 21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-2042
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值运算符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-2043
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的另一个类别的运算符是 *复合赋值运算符*。这些是将数学运算符与赋值运算符（=）结合的“快捷”运算符。例如，这个表达式
- en: '[PRE55]'
  id: totrans-2044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: becomes
  id: totrans-2045
  prefs: []
  type: TYPE_NORMAL
  zh: 变为
- en: '[PRE56]'
  id: totrans-2046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-2047
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符通过对变量或常量执行操作来更新其值。通俗地说，像 `a += b` 这样的表达式表示“将 b 加到 a 中并将新值存储在 a 中。”[表
    2-1](text00012.html#ch2tab1) 展示了使用复合赋值运算符的数学表达式及其长形式表达式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-2048
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-1：** 短形式赋值运算符与长形式表达式'
- en: '| **Short form** | **Long form** |'
  id: totrans-2049
  prefs: []
  type: TYPE_TB
  zh: '| **短形式** | **长形式** |'
- en: '| --- | --- |'
  id: totrans-2050
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-2051
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-2052
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-2053
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-2054
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-2055
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 += 运算符的实际应用。假设我们正在尝试编写一个程序来计算方舟上的动物数量。首先，我们创建一个名为 animalsOnArk 的变量，并将其设置为
    0，因为方舟上还没有动物。当不同种类的动物登上方舟时，我们希望增加 animalsOnArk 的值，以便计算所有动物的数量。如果两只长颈鹿登上了方舟，那么我们需要将
    animalsOnArk 增加 2。如果两只大象登上了方舟，我们也需要再加 2。如果四只羚羊登上了方舟，我们需要将 animalsOnArk 增加 4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-2056
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00074.jpg)![Image](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-2057
  prefs: []
  type: TYPE_NORMAL
  zh: 在两只长颈鹿、两只大象和四只羚羊登上方舟后，animalsOnArk 的最终值为 8。真是一个动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-2058
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的一些快速说明**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-2059
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都提供了一种在代码中添加内联注释的方法。注释是被计算机忽略的备注，旨在帮助阅读代码的人理解代码的执行过程。虽然没有注释程序也能正常运行，但对于那些可能不清晰或令人困惑的代码部分，添加注释是个好主意。即使你不打算把程序展示给别人看，注释也能帮助你记住当初编写代码时的思路。回头看几个月或几年前写的代码时，完全想不起来自己当时是怎么想的，这种情况并不少见。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-2060
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 有两种方式可以添加注释。第一种方式是在你想要添加的文本前面加上两个正斜杠（//）。这些注释可以单独放在一行，就像这样：
- en: '[PRE57]'
  id: totrans-2061
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-2062
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它们也可以与一行代码放在同一行—只要注释位于代码的*后面*：
- en: '[PRE58]'
  id: totrans-2063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-2064
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式用于长注释，或*多行*注释，其中注释的开始和结束由 /* 和 */ 标记。（请注意，我们将在本书中使用 -- *snip* -- 来表示我们为节省空间而省略的更多代码行。）
- en: '[PRE59]'
  id: totrans-2065
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-2066
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不希望计算机运行某部分代码，因为你正在寻找一个 bug，但你又不想删除你所有的辛苦工作，你可以使用多行注释暂时*注释掉*部分代码。当你将一段代码格式化为注释时，计算机将像忽略其他注释一样忽略这些代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-2067
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-2068
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在 Swift playground 中编写代码，这让你能够立即看到结果。你创建了变量和常量，并学习了如何使用基本的数据类型和运算符，这些你将在编写自己的计算机程序时反复使用。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-2069
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](text00013.html#ch03)中，你将使用条件语句，告诉计算机你希望它执行的代码路径。代码路径的选择取决于条件的值。
- en: '![Image](Image00035.jpg)![image](Image00036.jpg)'
  id: totrans-2070
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00035.jpg)![image](Image00036.jpg)'
- en: '*Figure 2-3: Playground editor and results sidebar*'
  id: totrans-2071
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：Playground 编辑器和结果侧边栏*'
- en: '**CONSTANTS AND VARIABLES**'
  id: totrans-2072
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**常量和变量**'
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  id: totrans-2073
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是[图 2-3](text00012.html#ch02fig3)中的代码行：
- en: '![Image](Image00037.jpg)'
  id: totrans-2074
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00037.jpg)'
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  id: totrans-2075
  prefs: []
  type: TYPE_NORMAL
  zh: 它做了两件事。首先，它创建了一个名为 str 的变量。这被称为*声明*，因为我们在声明我们想创建一个变量。要创建一个变量，你输入关键字 var，然后输入一个变量名称——在这个例子中是
    str。命名变量时有一些规则，我们稍后会介绍，所以现在先使用这个例子。
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这行代码使用 = 运算符将 "Hello, playground" 的值赋给 str。这被称为*赋值*，因为我们正在为我们新创建的变量赋值。记住，你可以将变量视为一个容器，用来保存某些东西。所以现在我们有一个名为
    str 的容器，里面保存着 "Hello, playground"。
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  id: totrans-2077
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这行代码理解为“变量 str 等于 Hello, playground。”如你所见，Swift 通常非常易读；这一行代码几乎用英语告诉你它在做什么。
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  id: totrans-2078
  prefs: []
  type: TYPE_NORMAL
  zh: 变量很有用，因为如果你想打印“Hello, playground”，你只需对 str 使用 print 命令，就像以下代码一样：
- en: '![Image](Image00038.jpg)'
  id: totrans-2079
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00038.jpg)'
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  id: totrans-2080
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码会在结果侧边栏中打印 "Hello, playground\n"。\n 会自动添加到你打印的任何内容的末尾。它被称为*换行*字符，告诉计算机跳到新的一行。
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  id: totrans-2081
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看程序实际运行时的结果，可以打开调试区域，它将出现在两个面板下方，如[图 2-4](text00012.html#ch02fig4)所示。要这样做，可以在
    Xcode 菜单中选择**视图** ▸ **调试区域** ▸ **显示调试区域**，或者按下 ⌘ -SHIFT -Y。当 str 在调试区域的控制台中打印时，你会发现
    Hello, playground 周围的引号和换行符不会出现。这就是如果你正式运行这个程序时，str 的真实显示方式！
- en: '![image](Image00039.jpg)'
  id: totrans-2082
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-2083
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：在调试区域查看程序的真实输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-2084
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在你的程序中可以改变（或者*变化*！），所以你可以改变一个变量的值来保存其他内容。现在我们来尝试一下。将以下代码添加到你的 playground 中。
- en: '![Image](Image00040.jpg)'
  id: totrans-2085
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-2086
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变一个变量的值，输入它的名称并使用 = 运算符将其设置为新值。我们在 ➊ 处这样做，将 str 的值改为 "Hello, world"。计算机会丢弃
    str 原来保存的内容，并说：“好的，老板，str 现在是 Hello, world”（如果它能说话的话！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-2087
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们改变 str 的值时，我们不需要再写 var。计算机记得我们在之前的代码行中声明了 str，并知道 str 已经存在。所以我们不需要再次创建
    str。我们只是想给它赋予不同的内容。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-2088
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以声明 *常量*。像变量一样，常量也可以存储值。常量和变量之间的最大区别是，常量的值永远不能改变。变量的值是可以变化的，而常量则是固定的！声明一个常量和声明一个变量类似，但我们使用的是
    `let` 而不是 `var`：
- en: '![Image](Image00041.jpg)'
  id: totrans-2089
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-2090
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 `myName` 的常量，并将其赋值为 "Gloria"。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-2091
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个常量并为其赋值，它的值将一直保持到永远。你可以把常量想象成一块大石头，在上面刻下了你的值。如果你尝试给 `myName` 赋予另一个值，例如
    "Matt" ，你会看到像 [图 2-5](text00012.html#ch02fig5) 中那样的错误。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-2092
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00042.jpg)![image](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-2093
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：尝试更改常量的值是行不通的。*'
- en: '**NOTE**'
  id: totrans-2094
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-2095
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 Playground 中，错误会以一个红色圆圈显示，里面有一个小白点。点击这个错误标记会显示错误信息，告诉你出了什么问题。如果你已经显示了调试区域，你还应该能看到描述发生了什么的信息，有时甚至能看到如何修复它。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-2096
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-2097
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量——做得好！但是你应该在什么时候选择使用其中之一呢？在 Swift 中，最佳实践是使用常量而不是变量，除非你预计这个值会改变。常量有助于让代码“更安全”。如果你知道某个值永远不会改变，为什么不把它固定下来，避免以后出现任何可能的混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-2098
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想记录教室里窗户的总数以及今天打开的窗户数量。教室里的窗户数量不会改变，所以你应该使用常量来存储这个值。而今天打开的窗户数量会根据天气和时间变化，因此你应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-2099
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00044.jpg)![Image](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-2100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `numberOfWindows` 设置为常量并赋值为 8，因为窗户的总数始终是 8。我们将 `numberOfWindowsOpen` 设置为变量并赋值为
    3，因为当我们打开或关闭窗户时，这个值会发生变化。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-2101
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用 `var` 来定义变量，使用 `let` 来定义常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-2102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**命名常量和变量**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-2103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为变量或常量命名几乎任何你想要的名字，但有一些例外。你不能将它们命名为 Swift 中已经存在的关键字。例如，你不能将一个变量命名为 `var`。写
    `var var` 会让你和计算机都感到困惑。如果你尝试使用 Swift 的保留字来命名变量或常量，程序会报错。你也不能在同一个代码块中有两个相同名称的变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-2104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则外，在 Swift 中命名时，还有一些其他好的编程指南可以遵循。你的名称应该始终以小写字母开头。使用*非常*具有描述性的名称也是一个好主意（它们可以尽可能长）。当你使用描述性名称时，更容易理解该变量或常量的作用。如果你在查看别人的代码，你会觉得哪个变量名更容易理解：numKids
    还是 numberOfKidsInMyClass？第一个名称模糊不清，而第二个则很具描述性。常见的做法是看到一些由多个单词组合起来的变量或常量名称，比如 numberOfKidsInMyClass。这种命名风格，其中多个单词组合成一个变量名，每个单词的首字母大写，叫做*驼峰命名法*。之所以这么叫，是因为小写字母和大写字母交替的模式看起来像骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-2105
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-2106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-2107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你可以选择变量或常量要保存什么类型的数据——*数据类型*。记得我们之前说过，你可以把变量当作一个容器来存放某些东西吗？数据类型就像是容器的类型。计算机需要知道我们将把什么类型的东西放入每个容器中。在
    Swift 编程中，一旦你告诉计算机某个变量或常量将保存某种数据类型，它就不会允许你在该变量或常量中放入除该数据类型之外的其他内容。如果你有一个专门用来装土豆的篮子，把水放进去是个坏主意——除非你喜欢水洒得到处都是！
- en: '![image](Image00047.jpg)'
  id: totrans-2108
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-2109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-2110
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，你可以告诉计算机它将保存什么类型的数据。在我们关于教室窗户的例子中，我们知道这个变量将始终是一个*整数*（即一个整数——你不可能有半个窗户），所以我们可以像这样指定整数数据类型：
- en: '![Image](Image00048.jpg)'
  id: totrans-2111
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-2112
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示“是某种类型”。用通俗的语言来说，这行代码的意思是：“变量 numberOfWindowsOpen 是一个整数，它等于 3。”所以这行代码创建了一个变量，给它命名，告诉计算机它的数据类型，并赋予它一个值。呼，这一行代码完成了这一切？我们有提到过
    Swift 是一种*简洁*的语言吗？有些语言可能需要几行代码才能做到这一点。而 Swift 的设计是让你只用一行代码就能做很多事情！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-2113
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要声明一次数据类型。当我们告诉计算机一个变量将保存整数时，我们不需要再告诉它。如果我们重复声明，Xcode 会给我们一个错误。一旦数据类型被声明，变量或常量将永远保存该类型的数据。一次整数，永远整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-2114
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点你需要了解关于数据类型的知识：变量或常量不能存储不属于其数据类型的东西。例如，如果你尝试将小数数字赋给 numberOfWindowsOpen，你会得到一个错误，如
    [图 2-6](text00012.html#ch02fig6) 所示。
- en: '![image](Image00049.jpg)'
  id: totrans-2115
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-2116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：你不能将一个小数数字放入一个应该存储整数的变量中。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-2117
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 numberOfWindowsOpen = 5 和 numberOfWindowsOpen = 0 是有效的并且能正常工作。但你不能设置 numberOfWindowsOpen
    = 1.5。
- en: '**COMMON DATA TYPES**'
  id: totrans-2118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见的数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-2119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚刚学到的，数据类型让计算机知道它正在处理的数据是 *什么类型*，以及如何将其存储在内存中。那么，数据类型有哪些呢？一些常见的包括 Int、Double、Float、Bool
    和 String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-2120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下每种数据类型究竟是什么！
- en: '**Int (Integers)**'
  id: totrans-2121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Int（整数）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-2122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经稍微谈过整数了，但让我们更详细地了解一下它们。在 Swift 中，整数（Int）是没有小数部分或分数部分的整数。你可以把它们当作计数数字来理解。整数是
    *有符号* 的，意味着它们可以是负数、正数或零。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-2123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Double 和 Float（小数数字）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-2124
  prefs: []
  type: TYPE_NORMAL
  zh: '*小数* 是小数点后有数字的数字，比如 3.14。（如果你想将整数 3 表示为小数数字，它应写为 3.0。）有两种数据类型可以存储小数：Double
    和 Float（即 *浮点数*）。由于 Double 数据类型能够存储更大的数字，因此在 Swift 中更常见，我们将重点讨论它。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-2125
  prefs: []
  type: TYPE_NORMAL
  zh: 当你赋值给一个 Double 类型时，必须在小数点左边有一个数字，否则会出现错误。例如，假设每个香蕉的价格是 19 美分：
- en: '![Image](Image00050.jpg)'
  id: totrans-2126
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-2127
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码会导致错误，因为小数点左边没有数字。➋ 处的代码是正确的，因为它有一个前导零。（// ERROR 和 // CORRECT 是 *注释*，它们是程序中的注释，计算机会忽略它们。请参阅
    “[关于注释的一些快速说明](text00012.html#ch02sb01)” 和 [第 32 页](text00012.html#page_32) 。）
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-2128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Bool（布尔值，或真/假）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *布尔值* 只能是两种情况之一：true 或 false。在 Swift 中，布尔值数据类型称为 Bool。
- en: '![Image](Image00051.jpg)'
  id: totrans-2130
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-2131
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值通常用于 if-else 语句中，告诉计算机程序应该走哪条路径。（我们将在 [第 3 章](text00013.html#ch03) 中详细讲解布尔值和
    if-else 语句。）
- en: '**String**'
  id: totrans-2132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**String（字符串）**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-2133
  prefs: []
  type: TYPE_NORMAL
  zh: String 数据类型用于存储单词和短语。一个 *字符串* 是由引号括起来的字符集合。例如，“Hello, playground”是一个字符串。字符串可以由各种字符组成：字母、数字、符号等等。引号很重要，因为它们告诉计算机，所有引号之间的内容都是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-2134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串拼接在一起的方式来构建句子，这个过程叫做字符串 *连接*。让我们来看一下它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-2135
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-2136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将字符串用加号（+）连接起来，这段代码创建了一个名为 specialGreeting 的变量，值为字符串 "Good Morning Jude"。注意，在
    morningGreeting 和 friend 之间需要加一个包含空格字符（" "）的字符串，否则 specialGreeting 的值会是 "Good
    MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-2137
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-2138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-2139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，有时我们在声明变量时会包含数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-2140
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-2141
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们不包括数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-2142
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-2143
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事？计算机其实足够聪明，能够在大多数情况下推断出数据类型。这就是所谓的 *类型推断* ——因为计算机会根据我们提供的线索来*推断*（或猜测）我们使用的数据类型。当你创建一个变量并给它一个初始值时，这个值对于计算机来说就是一个重要的线索。以下是一些例子：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-2144
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个没有小数点的数字（比如 3），计算机会假设它是一个 Int 类型。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-2145
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个带小数点的数字（比如 3.14），计算机会假设它是一个 Double 类型。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-2146
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个没有引号的 *true* 或 *false*，计算机会假设它是一个 Bool 类型。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-2147
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个带引号的字符（如 "hello"），计算机会假设它是一个 String 类型。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-2148
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型是由计算机推断出来时，变量或常量会被设置为那个数据类型，就好像你自己声明了数据类型一样。这完全是为了方便。你每次声明新常量或变量时都可以包含数据类型，这也是完全可以的。但为什么不让计算机自己推断出来，省去你多余的时间和输入呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-2149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用类型转换来转换数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-2150
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换* 是一种暂时改变变量或常量数据类型的方式。你可以把它想象成对一个变量施了个魔法——让它的值暂时表现得像另一种数据类型。要做到这一点，你写上新的数据类型，然后用括号括住你要转换的变量。注意，这*并不会真正改变数据类型*。它只是在这一行代码中给你一个临时的值。以下是一些
    Int 和 Double 之间的类型转换例子。查看代码运行结果的侧边栏。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-2151
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![Image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-2152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Int 类型的变量 months 转换为 Double 类型，并将其存储在一个名为 doubleMonths 的新变量中。这会添加一个小数点，类型转换的结果是
    12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-2153
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将 Double 转换为 Int 类型：
- en: '![Image](Image00058.jpg)'
  id: totrans-2154
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-2155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将我们的 Double 类型变量 days 转换成了 Int。你可以看到小数点和后面的所有数字都被去掉了：我们的数字变成了 365。这是因为
    Int 类型不能保存小数，它只能存储整数，所以小数点后面的部分会被截断。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-2156
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，类型转换并不会实际改变数据类型。在我们的示例中，即使经过类型转换，days*仍然*是一个 Double。我们可以通过打印 days 来验证这一点：
- en: '![Image](Image00059.jpg)'
  id: totrans-2157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-2158
  prefs: []
  type: TYPE_NORMAL
  zh: 结果侧边栏显示，days 仍然等于 365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-2159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍一些使用类型转换的示例。所以如果你现在不清楚为什么要进行类型转换，稍等一下就明白了！
- en: '**OPERATORS**'
  id: totrans-2160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-2161
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中有许多算术运算符可用于进行数学运算。你已经见过基本的赋值运算符 =。你可能也熟悉加法（+）、减法（-）、乘法（*）和除法（/）。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-2162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符对 Int、Float 和 Double 数据类型进行数学运算。正在运算的数字称为*操作数*。通过在你的游乐场中输入以下代码来试验这些数学运算符：
- en: '![Image](Image00060.jpg)'
  id: totrans-2163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-2164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在游乐场中输入这段代码，你将看到每个数学表达式的结果在侧边栏中显示。编写数学表达式的方式与正常书写差别不大。例如，16 减去 2 可以写作 16
    – 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-2165
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数学表达式的结果保存在变量或常量中，以便在代码的其他地方使用。要查看这如何工作，请在你的游乐场中输入以下几行：
- en: '![Image](Image00061.jpg)'
  id: totrans-2166
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-2167
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印 sum ➊ 时，你将在侧边栏中看到 7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-2168
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在数学表达式中使用了数字，但数学运算符也适用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-2169
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的游乐场中：
- en: '![Image](Image00062.jpg)'
  id: totrans-2170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-2171
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以像对待数字一样对变量和常量使用数学运算符。
- en: '**SPACES MATTER**'
  id: totrans-2172
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-2173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，运算符两边的空格非常重要。你可以在运算符的两边都写一个空格，或者完全不留空格。但你不能只在运算符的一边留空格，另一边不留空格，这样会导致错误。请查看[图
    2-7](text00012.html#ch02fig7)。
- en: '![image](Image00063.jpg)'
  id: totrans-2174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-2175
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：确保运算符两边的空格数量相同。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点非常重要：你只能对*相同*数据类型的变量或常量使用数学运算符。在之前的代码中，三和五都是 Int 数据类型。常量 half 和 quarter 是
    Double 数据类型，因为它们是小数。如果你尝试将 Int 和 Double 相加或相乘，你会得到像[图 2-8](text00012.html#ch02fig8)中那样的错误。
- en: '![image](Image00064.jpg)'
  id: totrans-2177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-2178
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-8：在 Swift 中，你不能对不同数据类型进行数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-2179
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果你真的想对混合数据类型进行运算呢？比如，假设你想计算你年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-2180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-2181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行会导致错误，因为我们尝试将一个 Int 和一个 Double 相乘。但别担心！你有几个选择来确保操作数的数据类型一致。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-2182
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是将 myAge 声明为 Double 类型，像这样：
- en: '![Image](Image00066.jpg)'
  id: totrans-2183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-2184
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码能正常工作，因为我们正在对两个 Double 数据类型进行乘法运算。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-2185
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是使用类型转换。（我说过我们会回到这个话题！）在这种情况下，类型转换是一个很好的解决方案，因为我们不想永久将 myAge 改为 Double
    类型，我们只是希望能够像操作 Double 类型一样进行数学运算。让我们来看个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-2186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-2187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 myAge 强制转换为 Double 类型后再进行乘法运算。这意味着我们不再有混合类型，因此代码能够正常工作。但在 ➋ 处，我们会得到一个错误。因为
    myAge 仍然是 Int 类型。虽然在 ➊ 处将它转换成了 Double，但并没有永久改变其类型。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-2188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能将 multiplier 强制转换为 Int 吗？当然可以！那样我们就在对两个整数进行运算，完全没问题。然而，这会导致计算精度下降，因为我们会丢失小数部分。当你将一个
    Double 类型的变量转换为 Int 时，计算机会简单地去掉小数点后的所有数字，使其变成一个整数。在这个例子中，你的 multiplier 0.1 会被转换为
    Int 类型的 0。让我们在 playground 中强制转换一些变量，看看会得到什么结果：
- en: '![Image](Image00068.jpg)'
  id: totrans-2189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，将我们的 Double 类型变量 multiplier 强制转换为 Int 后得到 0。这个值在转换后变化很大，因为我们丢失了小数点：0.1
    变成了 0。如果我们没有预料到这种情况，这可能会在代码中引起严重问题。你必须小心进行类型转换，确保不会意外更改值。在 ➋ 处，我们又有了另一个将 Double
    强制转换为 Int 的例子，正如你所看到的，1.9 没有被四舍五入到 2。它的小数部分被去掉，我们得到了 1。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-2191
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个数学运算符——*取余运算符*（%），它可能对你来说不太熟悉。取余运算符（也叫做*模运算*）会给出除法后的余数。例如，7 % 2 = 1，因为 7
    除以 2 的余数是 1。你可以在 playground 中试试取余运算符，如下所示。
- en: '![Image](Image00069.jpg)'
  id: totrans-2192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-2193
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，取余运算符对于判断一个数是否为偶数（evenNumber % 2 等于 0）➊ 或奇数（oddNumber % 2 等于 1）➋ 非常有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-2194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算顺序**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-2195
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们每行代码只做了一个数学运算，但通常在一行代码中会做多个运算。让我们看个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-2196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元的纸币和两张一美元的纸币，你有多少钱？我们可以在一行内进行计算：
- en: '![Image](Image00070.jpg)'
  id: totrans-2197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-2198
  prefs: []
  type: TYPE_NORMAL
  zh: 这将17赋值给myMoney。计算机先计算5乘以3，然后加上2。那么计算机是怎么知道先乘法再加2的呢？它仅仅是从左到右操作吗？不是的！看看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-2199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-2200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重新排列了数字，结果仍然是17。如果计算机只是从左到右操作，它会先加2 + 5得到7，然后将结果7乘以3得到21。即使我们改变了数学表达式中数字的顺序，计算机仍然会先进行乘法（得到15），然后再加上2得到17。*计算机会始终先进行乘法和除法，再进行加法和减法。*
    这被称为*运算顺序*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-2201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号排列操作**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-2202
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必像我们在金钱示例中那样依赖计算机来决定先做哪一步。你，程序员，拥有决定的权力！你可以使用括号将操作组合在一起。当你将括号放在某个操作周围时，你告诉计算机先执行那个步骤：
- en: '![Image](Image00072.jpg)'
  id: totrans-2203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-2204
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，括号告诉计算机先计算5乘以3，再加2，这将得到17。在➋，括号告诉计算机先加2和5，再将其乘以3，结果是21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-2205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在其他括号内使用括号来使代码更加具体。计算机会首先计算内层括号，然后计算外层括号。试试这个例子：
- en: '![Image](Image00073.jpg)'
  id: totrans-2206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-2207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，计算机在内层括号中加上2和3。然后它将结果乘以4，因为它位于外层括号内。最后，它会加上1，因为它位于两个括号之外。最终结果是21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-2208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值运算符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-2209
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的另一个运算符类别是*复合赋值运算符*。这些是将数学运算符与赋值运算符（=）结合的“快捷”运算符。例如，以下表达式：
- en: '[PRE60]'
  id: totrans-2210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: becomes
  id: totrans-2211
  prefs: []
  type: TYPE_NORMAL
  zh: 变成
- en: '[PRE61]'
  id: totrans-2212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-2213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符通过对变量或常量执行操作来更新它的值。通俗地说，像a += b这样的表达式表示“将b加到a中并将新值存储到a中。”[表2-1](text00012.html#ch2tab1)展示了使用复合赋值运算符的数学表达式以及它们的长形式表达式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-2214
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-1：** 简短形式赋值运算符与长形式表达式'
- en: '| **Short form** | **Long form** |'
  id: totrans-2215
  prefs: []
  type: TYPE_TB
  zh: '| **简短形式** | **长形式** |'
- en: '| --- | --- |'
  id: totrans-2216
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-2217
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-2218
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-2219
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-2220
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-2221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 += 运算符的实际应用。假设我们正在编写一个程序来计算方舟上的动物数量。首先，我们创建一个名为 animalsOnArk 的变量，并将其设置为
    0，因为方舟上还没有动物。当不同种类的动物登上方舟时，我们希望增加 animalsOnArk 以计算所有动物的数量。如果两只长颈鹿登上方舟，那么我们需要将
    animalsOnArk 加 2。如果两只大象登上方舟，那么我们需要再加 2。如果四只羚羊登上方舟，我们就需要将 animalsOnArk 增加 4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-2222
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00074.jpg)![Image](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-2223
  prefs: []
  type: TYPE_NORMAL
  zh: 在两只长颈鹿、两只大象和四只羚羊登上方舟之后，animalsOnArk 的最终值是 8。真是个动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-2224
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的一些快速说明**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-2225
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都提供了一种与代码行内注释的方式。注释是计算机会忽略的注解，用来帮助阅读代码的程序员理解代码的意图。虽然程序没有注释也能正常运行，但对于可能不清晰或令人困惑的代码部分，添加注释是一个好主意。即使你不打算将程序展示给其他人，注释也有助于你记住写代码时的思路或做法。很多时候，几个月或几年后，你会重新查看自己写过的代码，却完全不知道当时的思路是什么。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-2226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中有两种添加注释的方法。第一种是在线前面加上两个正斜杠（//），然后添加你想加入的文本。这些注释可以单独占一行，像这样：
- en: '[PRE62]'
  id: totrans-2227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-2228
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它们可以和代码行放在同一行——只要注释位于代码的*后面*：
- en: '[PRE63]'
  id: totrans-2229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-2230
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式用于长注释或*多行*注释，其中注释的开始和结束分别由 /* 和 */ 标记。（请注意，在本书中，我们将使用 -- *snip* -- 来表示由于篇幅原因省略的更多代码行。）
- en: '[PRE64]'
  id: totrans-2231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-2232
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不希望计算机运行代码中的某一部分，因为你正在尝试找出一个 bug，但又不想删除所有的辛苦工作，你可以使用多行注释暂时*注释掉*代码段。当你将一段代码格式化为注释时，计算机会像忽略任何其他注释一样忽略这段代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-2233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-2234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何在 Swift playground 中编写代码，Swift playground 让你可以立即看到结果。你创建了变量和常量，并学习了如何使用你在编写自己的计算机程序时将反复使用的基本数据类型和运算符。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-2235
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](text00013.html#ch03)中，你将使用条件语句，它告诉计算机你希望它走哪条代码路径。代码路径的选择基于条件值。
- en: '![image](Image00036.jpg)'
  id: totrans-2236
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00036.jpg)'
- en: '*Figure 2-3: Playground editor and results sidebar*'
  id: totrans-2237
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-3：Playground 编辑器和结果侧边栏*'
- en: '**CONSTANTS AND VARIABLES**'
  id: totrans-2238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**常量和变量**'
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  id: totrans-2239
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是[图2-3](text00012.html#ch02fig3)中的那行代码：
- en: '![Image](Image00037.jpg)'
  id: totrans-2240
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00037.jpg)'
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  id: totrans-2241
  prefs: []
  type: TYPE_NORMAL
  zh: 它做了两件事。首先，它创建了一个名为str的变量。这叫做*声明*，因为我们声明了希望创建一个变量。要创建一个变量，你输入关键字`var`，然后为变量命名——在这个例子中是str。命名变量时有一些规则，我们稍后会讲到，所以现在就按照这个例子来。
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  id: totrans-2242
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这行代码使用`=`运算符将“Hello, playground”赋值给str。这被称为*赋值*，因为我们将一个值赋给了我们新创建的变量。记住，你可以把变量当作一个容器，用来存储东西。所以现在我们有一个名为str的容器，它保存着“Hello,
    playground”。
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  id: totrans-2243
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这一行代码理解为“变量str等于Hello, playground”。正如你所看到的，Swift通常是非常易读的，这一行代码几乎用英语告诉你它在做什么。
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  id: totrans-2244
  prefs: []
  type: TYPE_NORMAL
  zh: 变量很方便，因为如果你想打印“Hello, playground”这句话，你只需要对str使用print命令，像下面的代码一样：
- en: '![Image](Image00038.jpg)'
  id: totrans-2245
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00038.jpg)'
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  id: totrans-2246
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会在结果侧边栏中打印“Hello, playground\n”。`\n` 会自动添加到你打印内容的末尾。它被称为*换行*字符，告诉计算机换到新的一行。
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  id: totrans-2247
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看程序运行时的实际结果，请打开调试区域，调试区域会出现在两个面板下方，如[图2-4](text00012.html#ch02fig4)所示。要打开它，可以在Xcode菜单中选择**视图**
    ▸ **调试区域** ▸ **显示调试区域**，或者按下⌘ -SHIFT -Y。当str在调试区域的控制台中打印时，你会发现“Hello, playground”周围的引号和换行符不会出现。这就是如果你正式运行这个程序时，str的真实样子！
- en: '![image](Image00039.jpg)'
  id: totrans-2248
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-2249
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-4：查看程序在调试区域的实际输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-2250
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在程序中可以变化（或者说*变化*！），因此你可以更改变量的值来保存其他内容。现在我们就来尝试一下。将以下代码行添加到你的playground中。
- en: '![Image](Image00040.jpg)'
  id: totrans-2251
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-2252
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改变量的值，输入它的名字并使用`=`运算符将其设置为新值。我们在➊这里做了这个操作，将str的值更改为“Hello, world”。计算机会丢掉str之前保存的内容，然后说：“好的，老板，str现在是Hello,
    world”（当然，如果计算机能说话的话，它会这么说！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-2253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们更改str的值时，并没有再次写`var`。计算机会记得我们在之前的代码行中声明了str，并知道str已经存在。因此，我们不需要重新创建str，只需将不同的东西放入其中。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-2254
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以声明*常量*。像变量一样，常量也保存值。常量与变量的最大区别是常量的值永远不能改变。变量可以变化，而常量是恒定的！声明常量类似于声明变量，但我们使用let而不是var：
- en: '![Image](Image00041.jpg)'
  id: totrans-2255
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-2256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为myName的常量，并将其赋值为“Gloria”。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-2257
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了常量并赋予它一个值，它将一直保持这个值，直到永远。可以把常量想象成一块大石头，上面刻有你设置的值。如果你试图将myName赋值为另一个值，比如“Matt”，你将会看到像[图
    2-5](text00012.html#ch02fig5)那样的错误。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-2258
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00042.jpg)![image](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-2259
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：尝试改变常量的值是行不通的。*'
- en: '**NOTE**'
  id: totrans-2260
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-2261
  prefs: []
  type: TYPE_NORMAL
  zh: '*在playground中，错误会以一个红色圆圈表示，里面有一个小小的白色圆圈。点击错误标记将显示错误信息并告诉你出了什么问题。如果你显示了调试区域，你还应该能看到描述发生了什么的详细信息，有时甚至会告诉你如何修复它。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-2262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-2263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量——做得好！那么，什么时候应该使用常量，什么时候应该使用变量呢？在Swift中，除非你预期某个值会发生变化，否则最好使用常量而不是变量。常量有助于使代码“更安全”。如果你知道某个值永远不会改变，为什么不将它刻在石头上，避免以后可能的混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-2264
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想跟踪你教室里的窗户总数以及今天打开的窗户数量。你教室里的窗户总数是不会变化的，因此应该使用常量来存储这个值。而打开的窗户数量会根据天气和时间的不同而变化，因此应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-2265
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00044.jpg)![image](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-2266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将numberOfWindows设置为常量并赋值为8，因为窗户的总数始终是8。我们将numberOfWindowsOpen设置为变量并赋值为3，因为当我们开关窗户时，我们需要更改这个值。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-2267
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用var来声明变量，使用let来声明常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-2268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常量和变量的命名**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-2269
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以给变量或常量命名几乎任何你想要的名字，但有一些例外。你不能使用Swift中的保留字作为名称。例如，不能命名变量为var。写成var var会让你和计算机都感到困惑。如果你尝试使用Swift的保留字命名变量或常量，编译器会报错。你还不能在同一代码块中有两个同名的变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-2270
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则之外，在 Swift 中命名时还有一些其他好的编程指南。你的命名应该总是以小写字母开头。使用*非常*具描述性的名称也是个好主意（它们可以尽可能长）。当你使用描述性名称时，更容易理解这个变量或常量应该是什么。如果你在看别人写的代码，你会发现哪个变量名更容易理解：numKids
    还是 numberOfKidsInMyClass？第一个很模糊，但第二个很具描述性。常见的情况是，变量和常量是由一堆单词连接起来的，比如 numberOfKidsInMyClass。这种命名风格，即每个单词的首字母都大写，多个单词拼接起来形成变量名，被称为*驼峰命名法*。因为小写字母和大写字母的模式看起来像骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-2271
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-2272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-2273
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你可以选择变量或常量要保存的数据类型。记得我们之前说过，变量就像一个容器，里面装着某些东西吗？那数据类型就像是容器的类型。计算机需要知道我们会把什么东西放进每个容器里。在
    Swift 编程中，一旦你告诉计算机你想让某个变量或常量保存某种数据类型，它就不会让你把其他类型的数据放进那个变量或常量里。如果你有一个专门用来装土豆的篮子，把水装进去可就不太好——除非你喜欢水洒得到处都是！
- en: '![image](Image00047.jpg)'
  id: totrans-2274
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-2275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-2276
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建变量或常量时，可以告诉计算机它将保存什么类型的数据。在我们关于教室窗户的例子中，我们知道这个变量将始终是一个*整数*（也就是说，整数——你不可能有半个窗户），所以我们可以像这样指定一个整数数据类型：
- en: '![Image](Image00048.jpg)'
  id: totrans-2277
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-2278
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号意味着“是某种类型”。用简单的英语来说，这行代码表示：“变量 numberOfWindowsOpen，它是一个整数，等于 3。”所以这一行代码创建了一个变量，给它命名，告诉计算机它的数据类型，并赋值。呼！一行代码就做到了这一切？我们有提到过
    Swift 是一门*简洁*的语言吗？一些语言可能需要多行代码才能做同样的事。Swift 的设计使得你可以通过一行代码做很多事情！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-2279
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要声明一次数据类型。当我们告诉计算机一个变量将保存整数时，就不需要再次告诉它。事实上，如果我们再告诉它，Xcode 会给我们报错。一旦数据类型被声明，变量或常量将永远保存该类型的数据。一旦是整数，永远是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-2280
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要了解关于数据类型的一件事：一个变量或常量不能存储不属于其数据类型的值。例如，如果你试图将一个小数存入 `numberOfWindowsOpen`，你会收到错误提示，如[图
    2-6](text00012.html#ch02fig6)所示。
- en: '![image](Image00049.jpg)'
  id: totrans-2281
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-2282
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：你不能将小数存入本应存储整数的变量中。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-2283
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `numberOfWindowsOpen = 5` 和 `numberOfWindowsOpen = 0` 是有效的并且能正常工作。但你不能将 `numberOfWindowsOpen
    = 1.5` 设置为有效值。
- en: '**COMMON DATA TYPES**'
  id: totrans-2284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-2285
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所学，数据类型让计算机知道它正在处理的*是什么类型*的数据，以及如何在内存中存储它。那么，数据类型有哪些呢？一些常见的数据类型包括 Int、Double、Float、Bool
    和 String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-2286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下这些数据类型到底是什么！
- en: '**Int (Integers)**'
  id: totrans-2287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**整数（Int）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-2288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经稍微讲了一些整数的知识，但让我们更详细地讨论一下它们。整数，在 Swift 中称为 Int，是没有小数或分数部分的整数。你可以把它们看作是计数数字。整数是*有符号的*，意味着它们可以是负数、正数或零。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-2289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Double 和 Float（小数）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-2290
  prefs: []
  type: TYPE_NORMAL
  zh: '*小数*是小数点后有数字的数字，比如 3.14（如果你想将整数 3 表示为小数，则应写作 3.0）。有两种数据类型可以存储小数：Double 和 Float（即*浮点数*）。在
    Swift 中，Double 数据类型更常见，因为它可以存储更大的数字，所以我们将重点讨论它。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-2291
  prefs: []
  type: TYPE_NORMAL
  zh: 当你分配一个 Double 时，必须始终在小数点左边有一个数字，否则会出现错误。例如，假设香蕉每个价格 19 美分：
- en: '![Image](Image00050.jpg)'
  id: totrans-2292
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-2293
  prefs: []
  type: TYPE_NORMAL
  zh: ➊处的代码会导致错误，因为小数点左侧没有数字。➋处的代码正常工作，因为它有一个前导零。（// ERROR 和 // CORRECT 是*注释*，是程序中的备注，计算机会忽略这些注释。请参见
    “[关于注释的一些简短说明](text00012.html#ch02sb01)” [第32页](text00012.html#page_32) 。）
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-2294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**布尔值（Booleans，或 真/假）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-2295
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值*只能是两种值之一：真或假。在 Swift 中，布尔数据类型叫做 Bool。'
- en: '![Image](Image00051.jpg)'
  id: totrans-2296
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-2297
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值通常用于 if-else 语句中，用来告诉计算机程序应选择哪条路径。（我们将在[第 3 章](text00013.html#ch03)中更详细地讲解布尔值和
    if-else 语句。）
- en: '**String**'
  id: totrans-2298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符串**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-2299
  prefs: []
  type: TYPE_NORMAL
  zh: String 数据类型用于存储单词和短语。*字符串*是用引号括起来的字符集合。例如，"Hello, playground" 就是一个字符串。字符串可以由各种字符组成：字母、数字、符号等等。引号很重要，因为它们告诉计算机，所有在引号之间的内容都是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-2300
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串连接在一起，使用一种叫做字符串 *连接* 的方式来构建句子。让我们看看它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-2301
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-2302
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将字符串用加号（+）连接起来，这段代码创建了一个名为 specialGreeting 的变量，值为字符串 "Good Morning Jude"。注意，这里我们需要在
    morningGreeting 和 friend 之间添加一个包含空格字符（" "）的字符串，否则 specialGreeting 的值就会变成 "Good
    MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-2303
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-2304
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-2305
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在某些情况下，我们声明一个变量时会包括数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-2306
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-2307
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们并不包含数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-2308
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-2309
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事？计算机实际上足够聪明，通常能够推断出数据类型。这就是所谓的 *类型推断* ——因为计算机会根据我们给出的线索来 *推断* 或猜测我们使用的数据类型。当你创建一个变量并给它一个初始值时，这个值是计算机的重要线索。以下是一些示例：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-2310
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值给一个没有小数部分的数字（如 3），计算机会假设它是一个 Int 类型。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-2311
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值给一个带有小数部分的数字（如 3.14），计算机会假设它是一个 Double 类型。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-2312
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值给 *true* 或 *false*（没有引号），计算机会假设它是一个 Bool 类型。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-2313
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值给一个包含引号的字符，计算机会假设它是一个 String 类型。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-2314
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量会被设置为该数据类型，就像你自己声明了数据类型一样。这完全是为了方便。每次声明一个新的常量或变量时，你都可以包含数据类型，这样做也完全没问题。但是，为什么不让计算机自动推断出来，省下时间和不必要的输入呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-2315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用类型转换转换数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-2316
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换* 是一种临时改变变量或常量数据类型的方法。你可以把它想象成对变量施下了一个咒语——它的值在短时间内表现得像不同的数据类型。要做到这一点，你需要在变量后面写上一个新的数据类型，并加上括号，括号内是你要转换的变量。注意，这*并不会实际改变数据类型*。它只是为这一行代码提供一个临时值。以下是一些在
    Int 和 Double 之间进行类型转换的示例。查看一下代码结果侧边栏中的结果。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-2317
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![Image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-2318
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Int 类型的变量 months 转换为 Double 类型，并将其存储在一个名为 doubleMonths 的新变量中。这就增加了一个小数位，转换后的结果是
    12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-2319
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将 Double 类型转换为 Int 类型：
- en: '![Image](Image00058.jpg)'
  id: totrans-2320
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-2321
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Double 类型的 days 转换为 Int 类型。你可以看到小数点和其后的所有数字都被去除了：我们的数字变成了 365。这是因为
    Int 类型无法存储小数，它只能包含整数，因此小数点后的部分被截断。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-2322
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，类型转换实际上并不会改变数据类型。在我们的例子中，即使进行类型转换后，days 依然是 *Double* 类型。我们可以通过打印 days 来验证这一点：
- en: '![Image](Image00059.jpg)'
  id: totrans-2323
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-2324
  prefs: []
  type: TYPE_NORMAL
  zh: 结果侧边栏显示，days 仍然等于 365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-2325
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍一些关于何时和如何使用类型转换的例子。所以如果现在还不清楚为什么要进行类型转换，请再耐心等待一下！
- en: '**OPERATORS**'
  id: totrans-2326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-2327
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，有许多算术运算符可以用来进行数学运算。你已经见过基本的赋值运算符 = 。你可能也熟悉加法（+）、减法（-）、乘法（*）和除法（/）运算符。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-2328
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符对 Int、Float 和 Double 数据类型进行数学运算。进行运算的数字被称为 *操作数*。通过在 playground 中输入以下代码来实验这些数学运算符：
- en: '![Image](Image00060.jpg)'
  id: totrans-2329
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-2330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 playground 中输入这段代码，你将会看到每个数学表达式的结果显示在侧边栏。编写数学表达式和正常书写并没有太大区别。例如，16 减去 2
    写作 16 – 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-2331
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数学表达式的结果保存在变量或常量中，以便在代码的其他地方使用。要了解如何操作，请在 playground 中输入以下几行：
- en: '![Image](Image00061.jpg)'
  id: totrans-2332
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-2333
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印 sum ➊ 时，你会在侧边栏看到 7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-2334
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在数学表达式中使用了数字，但数学运算符同样适用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-2335
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的 playground 中：
- en: '![Image](Image00062.jpg)'
  id: totrans-2336
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-2337
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以像对待数字一样对变量和常量使用数学运算符。
- en: '**SPACES MATTER**'
  id: totrans-2338
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-2339
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，运算符两边的空格很重要。你可以在数学运算符的两边都写上空格，或者完全不留空格。但你不能只在运算符的一边加空格，另一边不加。这样会导致错误。请参考
    [图 2-7](text00012.html#ch02fig7)。
- en: '![image](Image00063.jpg)'
  id: totrans-2340
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-2341
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：确保运算符两边的空格数量相同。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-2342
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点很重要：你只能对相同数据类型的变量或常量使用数学运算符。在前面的代码中，three 和 five 都是 Int 数据类型。常量 half 和 quarter
    是 Double 数据类型，因为它们是小数。如果你尝试将 Int 和 Double 相加或相乘，你将得到像 [图 2-8](text00012.html#ch02fig8)
    中的错误。
- en: '![image](Image00064.jpg)'
  id: totrans-2343
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-2344
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-8：在 Swift 中，不能对混合数据类型进行数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-2345
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你真的想在不同数据类型之间做数学运算呢？比如说，假设你想计算你年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-2346
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-2347
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行会报错，因为我们试图将一个 Int 与一个 Double 相乘。但别担心！你有几个选项，可以确保你的操作数是相同的数据类型。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-2348
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是将 myAge 声明为 Double 类型，如下所示：
- en: '![Image](Image00066.jpg)'
  id: totrans-2349
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-2350
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码能正常工作，因为我们在进行两个 Double 类型的数据相乘。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-2351
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是使用类型转换。（我说过我们会回到这个问题的！）在这种情况下，类型转换是一个很好的解决方案，因为我们不想永久性地将 myAge 改为 Double
    类型，我们只是想能够像处理 Double 类型一样进行数学运算。让我们看一个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-2352
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-2353
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们在乘法之前将 myAge 转换为 Double 类型。这意味着我们不再有不同的数据类型，因此代码能够正常运行。但在 ➋ 处我们会出错。这是因为
    myAge 仍然是 Int 类型。在 ➊ 处将其转换为 Double 类型并不会永久性地将它转换成 Double。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-2354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将乘数转换为整型（Int）吗？当然可以！这样我们就在进行两个整数的数学运算，这样是可以正常工作的。然而，这会导致计算结果精度下降，因为我们会丢失小数位。当你将一个变量从
    Double 转换为 Int 时，计算机会简单地去掉小数点后面的数字，使其成为一个整数。在这种情况下，你的乘数 0.1 会被转换为 0 的 Int。我们在
    Playground 中转换一些变量，看看会得到什么：
- en: '![Image](Image00068.jpg)'
  id: totrans-2355
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-2356
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Double 类型的乘数转换为 Int，结果是 0。转换后的值与原值差异很大，因为我们丢失了小数位：0.1 变成了 0。如果我们没有预料到这种情况，这可能会在代码中造成很大的问题。进行类型转换时，你必须小心，确保不会意外地改变你的值。在
    ➋ 处，这是另一个将 Double 转换为 Int 的例子，正如你所看到的，1.9 没有四舍五入到 2，而是去掉了小数部分，结果变成了 1。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-2357
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个数学运算符，*取余运算符*（%），可能对你来说比较陌生。取余运算符（也叫做*模*）表示除法后的余数。例如，7 % 2 = 1，因为 7 除以
    2 的余数是 1。你可以在 Playground 中尝试一下取余运算符，如下所示。
- en: '![Image](Image00069.jpg)'
  id: totrans-2358
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-2359
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，取余运算符对于判断一个数字是偶数（evenNumber % 2 等于 0） ➊ 还是奇数（oddNumber % 2 等于 1） ➋ 非常有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-2360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算顺序**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-2361
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们每行代码只进行了一次数学运算，但通常我们会在一行中进行多次运算。让我们看一个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-2362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元的钞票和两张一美元的钞票，你有多少钱？我们在一行中计算这个：
- en: '![Image](Image00070.jpg)'
  id: totrans-2363
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-2364
  prefs: []
  type: TYPE_NORMAL
  zh: 这将值 17 赋给 myMoney。计算机会先将 5 乘以 3，再加上 2。但计算机怎么知道先乘法再加法呢？它只是从左到右运算吗？不是！看看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-2365
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-2366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调整了数字的位置，结果仍然是 17。如果计算机仅仅从左到右进行运算，它将先加上 2 + 5 得到 7，然后将结果 7 乘以 3，得到 21。即使我们改变了数学表达式中的数字顺序，计算机依然会先进行乘法（得到
    15），然后加上 2 得到 17。*计算机总是先进行乘法和除法运算，再进行加法和减法运算。* 这就是所谓的*运算顺序*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-2367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号排序操作**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-2368
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要像在金钱示例中那样依赖计算机来判断应该先做哪一步。你，程序员，拥有决定的权力！你可以使用括号将操作分组。当你在某个操作周围加上括号时，你告诉计算机先执行这一步：
- en: '![Image](Image00072.jpg)'
  id: totrans-2369
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-2370
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，括号告诉计算机先将 5 乘以 3，再加上 2。结果是 17。在 ➋ 处，括号告诉计算机先将 2 与 5 相加，再乘以 3，结果是 21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-2371
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过在一个括号内再使用括号来使你的代码更具特定性。计算机会先计算内层括号，再计算外层括号。试试这个例子：
- en: '![Image](Image00073.jpg)'
  id: totrans-2372
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-2373
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，计算机在内层括号中加上 2 和 3。然后，它将结果乘以 4，因为它位于外层括号中。最后，它会将 1 相加，因为它位于两个括号外面。最终结果是 21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-2374
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值运算符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-2375
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会使用的另一个运算符类别是*复合赋值运算符*。这些是将数学运算符与赋值运算符（=）结合的“快捷方式”运算符。例如，这个表达式
- en: '[PRE65]'
  id: totrans-2376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: becomes
  id: totrans-2377
  prefs: []
  type: TYPE_NORMAL
  zh: 变成
- en: '[PRE66]'
  id: totrans-2378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-2379
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符通过对变量或常量进行运算来更新它的值。简单来说，像 a += b 这样的表达式表示“将 b 加到 a 中，并将新值存储到 a 中。”[表
    2-1](text00012.html#ch2tab1) 展示了使用复合赋值运算符的数学表达式及其长格式表达式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-2380
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-1：** 短格式赋值运算符与长格式表达式'
- en: '| **Short form** | **Long form** |'
  id: totrans-2381
  prefs: []
  type: TYPE_TB
  zh: '| **短格式** | **长格式** |'
- en: '| --- | --- |'
  id: totrans-2382
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-2383
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-2384
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-2385
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-2386
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-2387
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 += 运算符的实际应用。假设我们要编写一个程序来计算方舟上的动物数量。首先，我们创建一个名为 animalsOnArk 的变量，并将其设置为
    0，因为方舟上还没有动物。当不同种类的动物登上方舟时，我们希望增加 animalsOnArk 来统计所有的动物。如果两只长颈鹿登上了方舟，我们需要将 animalsOnArk
    加 2。如果两只大象登上了方舟，我们还需要再加 2。如果四只羚羊登上了方舟，我们需要将 animalsOnArk 增加 4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-2388
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00074.jpg)![Image](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-2389
  prefs: []
  type: TYPE_NORMAL
  zh: 在两只长颈鹿、两只大象和四只羚羊登上方舟后，animalsOnArk 的最终值为 8。真是一个动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-2390
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的一些简短说明**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-2391
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都提供了一种与代码行内嵌写注释的方式。注释是计算机会忽略的备注，目的是帮助阅读代码的人理解代码的含义。虽然没有注释程序也能正常运行，但为那些可能不清晰或容易混淆的代码部分添加注释是个好主意。即使你不打算将你的程序展示给别人，注释也会帮助你记住你在编写代码时的思路或想法。很多时候，你可能会回头查看几个月或几年前写的代码，却完全不知道当时的想法。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-2392
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中有两种添加注释的方法。第一种方法是在你想添加注释的文本前面加上两个斜杠（//）。这些注释可以单独占一行，像这样：
- en: '[PRE67]'
  id: totrans-2393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-2394
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它们也可以放在与代码同行的同一行上——只要注释在代码 *之后*：
- en: '[PRE68]'
  id: totrans-2395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-2396
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法用于长注释，或者 *多行* 注释，其中注释的开始和结束分别用 /* 和 */ 来标记。（注意，在本书中，我们将使用 -- *snip* --
    来表示我们省略了为了节省空间而删减的其他代码行。）
- en: '[PRE69]'
  id: totrans-2397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-2398
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不希望计算机执行代码中的某部分，因为你正在寻找一个 bug，但你又不想删除所有的辛勤工作，你可以使用多行注释来
    *临时注释掉* 代码的部分内容。当你将一段代码格式化为注释时，计算机会像忽略其他注释一样忽略该代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-2399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-2400
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在 Swift playground 中编写代码，这样你可以立即看到结果。你创建了变量和常量，并学习了如何使用基本数据类型和运算符，这些内容你在编写自己的计算机程序时会反复使用。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-2401
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](text00013.html#ch03)中，你将使用条件语句，它告诉计算机你希望它走哪条代码路径。代码路径是根据条件的值来选择的。
- en: '*Figure 2-3: Playground editor and results sidebar*'
  id: totrans-2402
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-3：Playground 编辑器和结果侧边栏*'
- en: '**CONSTANTS AND VARIABLES**'
  id: totrans-2403
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**常量和变量**'
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  id: totrans-2404
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自[图 2-3](text00012.html#ch02fig3)的代码行：
- en: '![Image](Image00037.jpg)'
  id: totrans-2405
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00037.jpg)'
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  id: totrans-2406
  prefs: []
  type: TYPE_NORMAL
  zh: 它做了两件事。首先，它创建了一个名为str的变量。这叫做*声明*，因为我们正在声明希望创建一个变量。要创建变量，你输入var这个词，然后为你的变量命名——在这个例子中是str。命名变量时有一些规则，我们稍后会讲到，所以现在先使用这个例子。
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  id: totrans-2407
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，这行代码使用=操作符给str赋值“Hello, playground”。这叫做*赋值*，因为我们正在给新创建的变量赋值。记住，你可以把变量看作是一个容器，里面装着某些东西。所以现在我们有一个名为str的容器，里面装着“Hello,
    playground”。
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  id: totrans-2408
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这行代码读作“变量str等于Hello, playground”。如你所见，Swift通常非常易读；这行代码几乎用英语告诉你它在做什么。
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  id: totrans-2409
  prefs: []
  type: TYPE_NORMAL
  zh: 变量非常有用，因为如果你想打印“Hello, playground”这句话，你只需对str使用print命令，就像下面的代码一样：
- en: '![Image](Image00038.jpg)'
  id: totrans-2410
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00038.jpg)'
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  id: totrans-2411
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在结果侧边栏中打印“Hello, playground\n”。\n会自动添加到你打印的任何内容的末尾。它被称为*换行符*，告诉计算机跳到新的一行。
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  id: totrans-2412
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看程序实际运行时的结果，请调出调试区域，它会显示在两个面板下方，如[图 2-4](text00012.html#ch02fig4)所示。为此，请在
    Xcode 菜单中选择 **视图** ▸ **调试区域** ▸ **显示调试区域**，或者按下⌘ -SHIFT -Y。当在调试区域的控制台中打印出str时，你可以看到Hello,
    playground周围的引号和换行符并未显示出来。这就是如果你正式运行该程序时str的真实样子！
- en: '![image](Image00039.jpg)'
  id: totrans-2413
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-2414
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：在调试区域查看程序的真实输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-2415
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在你的程序中可以改变（或者*变化*！），所以你可以更改变量的值来保存其他内容。现在我们来试试这个。将以下代码行添加到你的playground中。
- en: '![Image](Image00040.jpg)'
  id: totrans-2416
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-2417
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变变量的值，输入变量名并使用=操作符将其设置为新值。我们在➊处这样做，将str的值改为“Hello, world”。计算机会抛弃str原来保存的内容，然后说：“好的，老板，str现在是Hello,
    world”（如果它能说话的话！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-2418
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们改变str的值时，我们并没有再次写var。计算机记得我们在之前的代码行中声明了str，并且知道str已经存在。所以我们不需要重新创建str。我们只是想往里面放入不同的内容。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-2419
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以声明*常量*。像变量一样，常量也保存值。常量和变量之间的主要区别在于，常量的值永远不能改变。变量是可以变化的，而常量，嗯，就是常量！声明常量类似于声明变量，但我们使用的是let而不是var：
- en: '![Image](Image00041.jpg)'
  id: totrans-2420
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-2421
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们创建了一个名为myName的常量，并将它的值设置为"Gloria"。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-2422
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个常量并给它赋了值，它就会一直保持这个值，直到永远。把常量想象成一块大石头，你把值刻在其中。如果你尝试给myName赋予另一个值，比如"Matt"，你会得到一个错误，就像[图2-5](text00012.html#ch02fig5)中所示的那样。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-2423
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00042.jpg)![image](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-2424
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-5：尝试更改常量的值是行不通的。*'
- en: '**NOTE**'
  id: totrans-2425
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-2426
  prefs: []
  type: TYPE_NORMAL
  zh: '*在Playground中，错误会显示为一个带有小白圈的红色圆圈。点击错误标记会显示错误信息，并告诉你出了什么问题。如果你有调试区域显示，你还应该能看到描述发生了什么的相关信息，有时甚至告诉你如何修复它。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-2427
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-2428
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量—干得好！但是，什么时候该使用一个而不是另一个呢？在Swift中，最佳实践是，除非你预期值会变化，否则应该使用常量而不是变量。常量帮助使代码更“安全”。如果你知道某个值永远不会变化，为什么不把它刻在石头上，避免以后可能的混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-2429
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，你想记录教室里窗户的总数，以及今天打开的窗户数量。教室里的窗户数量不会变化，所以你应该使用常量来存储这个值。而今天打开的窗户数量会根据天气和时间的变化而变化，因此你应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-2430
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00044.jpg)![image](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-2431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将numberOfWindows设为常量，并将其值设置为8，因为窗户的总数永远是8。我们将numberOfWindowsOpen设为变量，并将其值设置为3，因为当我们打开或关闭窗户时，我们需要更改这个值。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-2432
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：用var表示变量，用let表示常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-2433
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常量和变量的命名**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-2434
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以给变量或常量取几乎任何名字，但有一些例外。你不能给它们取已经是Swift中关键词的名字。例如，你不能命名一个变量为var。写成var var会让你和计算机都感到困惑。如果你尝试使用Swift的保留字作为变量或常量的名字，你会遇到错误。你也不能在同一段代码中有两个名字相同的变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-2435
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则外，还有一些良好的编程规范，当你在 Swift 中命名变量时应遵循。你的变量名应该始终以小写字母开头。使用*非常*具有描述性的名称也是个好主意（名称可以尽量长）。当你使用描述性名称时，理解该变量或常量的用途会容易得多。如果你正在查看别人的代码，你会发现哪个变量名更容易理解：`numKids`
    还是 `numberOfKidsInMyClass`？第一个名称比较模糊，而第二个则非常具有描述性。通常可以看到很多变量和常量是多个单词组合在一起的，比如
    `numberOfKidsInMyClass`。这种每个单词的首字母大写的命名风格，叫做*驼峰命名法*。这是因为大小写字母的排列方式像骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-2436
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-2437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-2438
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你可以选择你希望变量或常量保存的数据类型——*数据类型*。还记得我们说过，变量可以看作是一个容器，用来装某些东西吗？那么，数据类型就像是容器的类型。计算机需要知道我们将把什么样的东西放进每个容器里。在
    Swift 编程中，一旦你告诉计算机某个变量或常量要保存某种数据类型，它就不会允许你在该变量或常量中放入除该数据类型之外的任何东西。如果你有一个设计用来装土豆的篮子，把水装进去就不太合适——除非你喜欢水洒满鞋子！
- en: '![image](Image00047.jpg)'
  id: totrans-2439
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-2440
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-2441
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，你可以告诉计算机它将保存什么类型的数据。在我们关于教室窗户的例子中，我们知道这个变量将始终是一个*整数*（即一个完整的数字——你不能有半个窗户），所以我们可以这样指定整数数据类型：
- en: '![Image](Image00048.jpg)'
  id: totrans-2442
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-2443
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示“是某种类型”。用通俗的话来说，这行代码的意思是：“变量 `numberOfWindowsOpen`，它是一个整数，等于 3。”所以，这行代码创建了一个变量，给它命名，告诉计算机它的数据类型，并为其赋值。呼！一行代码就完成了所有这些？我们有没有提到
    Swift 是一种非常*简洁*的语言？某些语言可能需要几行代码才能完成相同的操作。而 Swift 设计得让你只用一行代码就能做很多事！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-2444
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需声明数据类型一次。当我们告诉计算机某个变量将保存整数时，我们不需要再次告诉它。事实上，如果我们这样做，Xcode 会给我们报错。一旦数据类型被声明，变量或常量将永远保存该数据类型。一旦是整数，永远是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-2445
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要知道关于数据类型的一件事：变量或常量不能存储不是其数据类型的内容。例如，如果你尝试将十进制数放入numberOfWindowsOpen中，你会遇到错误，如[图2-6](text00012.html#ch02fig6)所示。
- en: '![image](Image00049.jpg)'
  id: totrans-2446
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-2447
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-6：你不能将十进制数赋给一个应该存储整数的变量。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-2448
  prefs: []
  type: TYPE_NORMAL
  zh: 将numberOfWindowsOpen = 5和numberOfWindowsOpen = 0是有效的，并且可以正常工作。但你不能将numberOfWindowsOpen
    = 1.5。
- en: '**COMMON DATA TYPES**'
  id: totrans-2449
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-2450
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所学，数据类型告诉计算机它正在处理哪种*类型*的数据，以及如何将其存储在内存中。那么，数据类型有哪些呢？一些常见的包括Int、Double、Float、Bool和String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-2451
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解每种数据类型到底是什么吧！
- en: '**Int (Integers)**'
  id: totrans-2452
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Int（整数）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-2453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经稍微提到过整数，但让我们更详细地讲解一下它们。整数，在Swift中称为Int，是没有小数或分数部分的整数。你可以把它们看作是计数数值。整数是*有符号的*，意味着它们可以是负数、正数或零。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-2454
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Double和Float（十进制数）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-2455
  prefs: []
  type: TYPE_NORMAL
  zh: '*十进制数*是指小数点后有数字的数，例如3.14（如果你希望3成为十进制数，可以写成3.0）。有两种数据类型可以存储十进制数：Double和Float（即*浮动小数点数*）。在Swift中，Double数据类型更为常见，因为它可以存储更大的数字，因此我们将重点讨论Double。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-2456
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为Double赋值时，必须始终在小数点左边有数字，否则会出错。例如，假设香蕉每个售价19美分：
- en: '![Image](Image00050.jpg)'
  id: totrans-2457
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-2458
  prefs: []
  type: TYPE_NORMAL
  zh: ➊处的代码会出错，因为它的小数点左边没有数字。➋处的代码可以正常工作，因为它有一个前导零。（// ERROR和// CORRECT是*注释*，它们是程序中的备注，计算机会忽略它们。有关更多信息，请参见"[关于注释的一些快速说明](text00012.html#ch02sb01)"，见[第32页](text00012.html#page_32)。）
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-2459
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Bool（布尔值，或真/假）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-2460
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*布尔值*只能是两种值之一：true或false。在Swift中，布尔数据类型叫做Bool。
- en: '![Image](Image00051.jpg)'
  id: totrans-2461
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-2462
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值常用于if-else语句中，告诉计算机程序应该走哪条路径。（我们将在[第3章](text00013.html#ch03)中更详细地讲解布尔值和if-else语句。）
- en: '**String**'
  id: totrans-2463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符串**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-2464
  prefs: []
  type: TYPE_NORMAL
  zh: String数据类型用于存储单词和短语。一个*字符串*是由引号括起来的一组字符。例如，"Hello, playground"是一个字符串。字符串可以由各种字符组成：字母、数字、符号等。引号很重要，因为它们告诉计算机，引号中的所有内容都是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-2465
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串连接起来来构建句子，这个过程叫做字符串*连接*。让我们来看看它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-2466
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-2467
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用加号（+）将字符串连接起来，这段代码创建了一个名为specialGreeting的变量，其值为字符串"Good Morning Jude"。请注意，我们需要在`morningGreeting`和`friend`之间加入一个包含空格字符（"
    "）的字符串，否则specialGreeting的值将是"Good MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-2468
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-2469
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-2470
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，有时当我们声明一个变量时，我们会包含数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-2471
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-2472
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们不会包含数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-2473
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-2474
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事？计算机实际上足够聪明，通常能够推断出数据类型。这叫做*类型推断*——因为计算机会根据我们提供的线索*推断*，或者说猜测，我们使用的数据类型。当你创建一个变量并给它一个初始值时，这个值就是给计算机的重要线索。这里有几个示例：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-2475
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个没有小数的数字（如3），计算机会认为它是一个Int类型。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-2476
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个带小数的数字（如3.14），计算机会认为它是一个Double类型。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-2477
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值给*true*或*false*（没有引号），计算机会认为它是一个Bool类型。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-2478
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个或多个带引号的字符，计算机会认为它是一个String类型。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-2479
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量将被设置为该数据类型，就像你自己声明了数据类型一样。这完全是为了方便。你可以在每次声明新常量或变量时都包括数据类型，这样也完全没问题。但为什么不让计算机自己推断出来，节省时间并减少额外的输入呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-2480
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**通过类型转换改变数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-2481
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换*是一种暂时改变变量或常量数据类型的方法。你可以把它看作是对变量施加一个魔法——让它的值暂时表现得像不同的数据类型。要做到这一点，你需要写一个新的数据类型，后跟包含你正在转换的变量的括号。请注意，这*并不会真正改变数据类型*。它只是为这一行代码提供一个临时值。以下是Int与Double之间转换的几个示例。请查看代码结果侧边栏中的输出。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-2482
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![Image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-2483
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将Int类型的变量`months`转换为Double类型，并将其存储在一个名为`doubleMonths`的新变量中。这为数字添加了小数位，转换的结果是12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-2484
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将一个Double类型转换为Int类型：
- en: '![Image](Image00058.jpg)'
  id: totrans-2485
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-2486
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将Double类型的days转换为Int类型。您可以看到小数点及其后的所有数字都被移除了：我们的数字变成了365。这是因为Int类型不能存储小数——它只能包含整数，所以小数点后的任何部分都会被删除。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-2487
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，类型转换实际上并不会改变数据类型。在我们的示例中，即使进行了类型转换，days *仍然*是一个Double类型。我们可以通过打印days来验证这一点：
- en: '![Image](Image00059.jpg)'
  id: totrans-2488
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-2489
  prefs: []
  type: TYPE_NORMAL
  zh: 结果侧边栏显示days仍然等于365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-2490
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍一些使用类型转换的例子。如果现在还不清楚为什么要进行变量转换，请再耐心等一会儿！
- en: '**OPERATORS**'
  id: totrans-2491
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-2492
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中有许多算术运算符供您使用。您已经见过基本的赋值运算符=。您可能还熟悉加法(+) 、减法(-) 、乘法(*) 和除法(/)。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-2493
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这些运算符对Int、Float和Double数据类型进行数学运算。参与运算的数字称为*操作数*。您可以在游乐场中通过输入如下代码来尝试这些数学运算符：
- en: '![Image](Image00060.jpg)'
  id: totrans-2494
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-2495
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在游乐场中输入这段代码，您将看到每个数学表达式的结果显示在侧边栏中。编写数学表达式的代码与正常书写并没有太大区别。例如，16减去2写作16 – 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-2496
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以将数学表达式的结果保存在一个变量或常量中，以便在代码的其他地方使用。要了解这一点，请在您的游乐场中输入以下几行代码：
- en: '![Image](Image00061.jpg)'
  id: totrans-2497
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-2498
  prefs: []
  type: TYPE_NORMAL
  zh: 当您打印sum ➊时，您将在侧边栏中看到7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-2499
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在数学表达式中只使用了数字，但数学运算符同样适用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-2500
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到您的游乐场中：
- en: '![Image](Image00062.jpg)'
  id: totrans-2501
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-2502
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您可以像对数字进行运算一样，对变量和常量使用数学运算符。
- en: '**SPACES MATTER**'
  id: totrans-2503
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-2504
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，运算符周围的空格非常重要。您可以在数学运算符的两边都写空格，或者完全不加空格。但不能只在运算符的一侧加空格，另一侧不加，这会导致错误。请参见[图2-7](text00012.html#ch02fig7)。
- en: '![image](Image00063.jpg)'
  id: totrans-2505
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-2506
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-7：确保运算符两边的空格数量相同。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-2507
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点非常重要：您只能对相同数据类型的变量或常量使用数学运算符。在前面的代码中，三和五都是Int类型。常量half和quarter是Double类型，因为它们是小数。如果您尝试对一个Int和一个Double进行加法或乘法运算，您将得到像[图2-8](text00012.html#ch02fig8)中那样的错误。
- en: '![image](Image00064.jpg)'
  id: totrans-2508
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-2509
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-8：在Swift中，您不能对不同数据类型做数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-2510
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你真的想对混合数据类型做数学运算呢？例如，假设你想计算你年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-2511
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-2512
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行会导致错误，因为我们尝试将一个 Int 与一个 Double 相乘。但别担心！你有几个选项可以确保操作数的数据类型一致。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-2513
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选项是将 myAge 声明为 Double ，像这样：
- en: '![Image](Image00066.jpg)'
  id: totrans-2514
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-2515
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码能正常工作，因为我们在操作两个 Double 数据类型。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-2516
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是使用强制类型转换。（我告诉过你我们会回到这个问题！）强制类型转换在这种情况下是一个很好的解决方案，因为我们不想永久地将 myAge 改为 Double
    类型，我们只是希望能够像对待 Double 类型一样对它进行数学运算。让我们来看一个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-2517
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-2518
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们在乘法之前将 myAge 强制转换为 Double 。这意味着我们不再有混合类型，所以代码能正常工作。但在 ➋ 处，我们将会遇到错误。这是因为
    myAge 仍然是 Int 类型。将其在 ➊ 处转换为 Double 并没有永久改变它的类型。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-2519
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将乘数转换为 Int 吗？当然可以！这样我们就是在对两个整数做数学运算，结果是没问题的。然而，这样会导致计算精度较低，因为我们会丢失小数部分。当你将一个变量从
    Double 转换为 Int 时，计算机会简单地去掉小数点后的数字，保留整数部分。在这种情况下，你的 0.1 乘数会转换为 Int 类型的 0 。让我们在
    playground 中尝试一些变量转换，看看会得到什么结果：
- en: '![Image](Image00068.jpg)'
  id: totrans-2520
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-2521
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，将我们的 Double 类型的乘数强制转换为 Int 给我们带来了 0 。转换后的值有很大不同，因为我们丢失了小数部分：0.1 变成了 0
    。如果我们没有预料到这种情况，这在代码中可能是一个非常糟糕的事情。你必须小心转换，以确保你不会无意中改变你的值。在 ➋ 处，这是另一个将 Double 强制转换为
    Int 的例子，正如你所看到的，1.9 并没有四舍五入成 2 。它的小数部分仅被移除，结果是 1 。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-2522
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个数学运算符，*模运算符*（%），你可能不太熟悉。模运算符（也叫 *余数运算符*）给出的是除法后的余数。例如，7 % 2 = 1，因为 7 除以
    2 的余数是 1。试着在你的 playground 中使用模运算符，如下所示。
- en: '![Image](Image00069.jpg)'
  id: totrans-2523
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-2524
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，模运算符对判断一个数是否为偶数（evenNumber % 2 等于 0） ➊ 或奇数（oddNumber % 2 等于 1） ➋ 很有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-2525
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算顺序**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-2526
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们每一行代码只进行了一个数学操作，但在一行代码上执行多个操作是很常见的。让我们看一个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-2527
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元纸币和两张一美元纸币，你有多少钱？我们来用一行代码计算一下：
- en: '![Image](Image00070.jpg)'
  id: totrans-2528
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-2529
  prefs: []
  type: TYPE_NORMAL
  zh: 这将17的值赋给myMoney。计算机先将5乘以3，再加上2。那么，计算机如何知道先乘法再加法呢？它只是从左到右工作吗？不！看看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-2530
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-2531
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重新排列了数字，结果仍然是17。如果计算机只是从左到右处理，它会先加上2 + 5得到7。然后它会将结果7乘以3，得到21。尽管我们改变了数学表达式中数字的顺序，计算机仍然会先进行乘法运算（得出15），然后再加上2得到17。*计算机总是先进行乘法和除法运算，再进行加法和减法运算。*
    这叫做*运算顺序*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-2532
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号的运算顺序**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-2533
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要像我们在金钱示例中那样依赖计算机来决定首先执行哪个步骤。你，作为程序员，有能力决定！你可以使用括号来将运算组合在一起。当你在某个操作周围加上括号时，你是在告诉计算机首先执行这个操作：
- en: '![Image](Image00072.jpg)'
  id: totrans-2534
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-2535
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，括号告诉计算机先将5乘以3，然后加上2。这样会得到17。在➋，括号告诉计算机先将2加上5，再乘以3，结果是21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-2536
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在其他括号内使用括号来使你的代码更具特定性。计算机会首先计算内层括号中的内容，然后再计算外层括号中的内容。试试这个例子：
- en: '![Image](Image00073.jpg)'
  id: totrans-2537
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-2538
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，计算机会在内层括号中加上2和3。然后它将结果乘以4，因为这在外层括号内。最后它会加上1，因为1在两个括号外面。最终结果是21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-2539
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值运算符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-2540
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的另一个类别的运算符是*复合赋值运算符*。这些是将数学运算符与赋值运算符（=）结合的“快捷方式”运算符。例如，这个表达式
- en: '[PRE70]'
  id: totrans-2541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: becomes
  id: totrans-2542
  prefs: []
  type: TYPE_NORMAL
  zh: 变成
- en: '[PRE71]'
  id: totrans-2543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-2544
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符通过对变量或常量执行某个操作来更新其值。用简单的语言来说，像a += b这样的表达式意味着“将b加到a中，并将新值存储在a中”。[表2-1](text00012.html#ch2tab1)展示了使用复合赋值运算符的数学表达式，以及它们的长写形式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-2545
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-1：** 简写赋值运算符与长写表达式'
- en: '| **Short form** | **Long form** |'
  id: totrans-2546
  prefs: []
  type: TYPE_TB
  zh: '| **简写形式** | **长写形式** |'
- en: '| --- | --- |'
  id: totrans-2547
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-2548
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-2549
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-2550
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-2551
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-2552
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下+=运算符的实际应用。假设我们正在编写一个程序来计算方舟上的动物数量。首先，我们创建一个名为animalsOnArk的变量并将其设置为0，因为方舟上还没有动物。当不同种类的动物登上方舟时，我们希望增加animalsOnArk来计算所有的动物。如果两只长颈鹿登上方舟，那么我们需要将animalsOnArk增加2。如果两只大象登上方舟，我们再次需要增加2。如果四只羚羊登上方舟，我们需要将animalsOnArk增加4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-2553
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00074.jpg)![Image](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-2554
  prefs: []
  type: TYPE_NORMAL
  zh: 在两只长颈鹿、两只大象和四只羚羊登上方舟之后，animalsOnArk的最终值是8。真是一个动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-2555
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的一些简要说明**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-2556
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都提供了一种在代码中添加行内注释的方法。注释是计算机会忽略的说明，用来帮助阅读代码的人理解代码的含义。虽然程序可以在没有注释的情况下正常运行，但在那些可能不太清晰或容易混淆的代码段中加入注释是个好主意。即使你不打算将程序展示给别人，注释也能帮助你记住编写这段代码时的想法或目的。即使是几个月或几年前写的代码，你也可能会在回顾时不记得当时的思路。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-2557
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中有两种添加注释的方法。第一种方法是在你要添加注释的文本前面加上两个斜杠（//）。这些注释可以单独放在一行，例如：
- en: '[PRE72]'
  id: totrans-2558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-2559
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它们也可以和代码行放在同一行——只要注释位于代码*之后*：
- en: '[PRE73]'
  id: totrans-2560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-2561
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法用于长注释或*多行*注释，其中注释的开始和结束由/*和*/标记。（注意，本书中我们将使用-- *snip* --来表示由于篇幅限制省略了的代码行。）
- en: '[PRE74]'
  id: totrans-2562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-2563
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不希望计算机运行代码的某一部分，因为你正在尝试找出一个错误，但你又不想删除所有的辛勤工作，你可以使用多行注释将代码部分临时“注释掉”。当你将一块代码格式化为注释时，计算机会像忽略其他注释一样忽略这段代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-2564
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-2565
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在Swift Playground中编写代码，这样你可以立即看到结果。你创建了变量和常量，并学习了如何使用基本的数据类型和运算符，这些将会在你编写自己的计算机程序时反复使用。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-2566
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](text00013.html#ch03)中，你将使用条件语句，这些语句告诉计算机你希望它执行哪条代码路径。代码路径的选择是基于条件值的。
- en: '**CONSTANTS AND VARIABLES**'
  id: totrans-2567
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**常量和变量**'
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  id: totrans-2568
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是[图2-3](text00012.html#ch02fig3)中的一行代码：
- en: '![Image](Image00037.jpg)'
  id: totrans-2569
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00037.jpg)'
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  id: totrans-2570
  prefs: []
  type: TYPE_NORMAL
  zh: 它做了两件事。首先，它创建了一个名为str的变量。这被称为*声明*，因为我们正在声明希望创建一个变量。创建变量时，先输入关键字var，然后为你的变量命名——在这个例子中是str。命名变量时有一些规则，我们稍后会讲到，所以现在就使用这个例子。
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  id: totrans-2571
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，这行代码使用=操作符将“Hello, playground”赋值给str。这被称为*赋值*，因为我们正在为新创建的变量赋值。记住，你可以把变量想象成一个容器，用来存储某些东西。所以现在我们有一个名为str的容器，存储着“Hello,
    playground”。
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  id: totrans-2572
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这行代码理解为“变量str等于Hello, playground。”正如你所看到的，Swift通常非常易读；这一行代码几乎直接告诉你它在做什么。
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  id: totrans-2573
  prefs: []
  type: TYPE_NORMAL
  zh: 变量非常方便，因为如果你想打印“Hello, playground”这句话，你只需对str使用print命令，像以下代码一样：
- en: '![Image](Image00038.jpg)'
  id: totrans-2574
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00038.jpg)'
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  id: totrans-2575
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码会在结果侧边栏打印出“Hello, playground\n”。\n会自动添加到你打印内容的末尾。它被称为*换行符*，告诉计算机跳到新的一行。
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  id: totrans-2576
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看程序实际运行时的结果，请调出调试区域，它会出现在两个面板下方，如[图2-4](text00012.html#ch02fig4)所示。为此，请在Xcode菜单中选择**视图**
    ▸ **调试区域** ▸ **显示调试区域**，或按⌘ -SHIFT -Y。当str在调试区域的控制台中打印时，你会发现围绕“Hello, playground”的引号和换行符不会显示出来。这就是如果你正式运行这个程序时，str的真实样子！
- en: '![image](Image00039.jpg)'
  id: totrans-2577
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-2578
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-4：在调试区域查看程序的实际输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-2579
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以在你的程序中发生变化（或*变化*！），因此你可以改变变量的值来存储其他内容。现在让我们试试这个。将以下几行代码添加到你的播放区域。
- en: '![Image](Image00040.jpg)'
  id: totrans-2580
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-2581
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变变量的值，只需输入它的名称并使用=操作符为其设置新值。我们在➊处这样做，将str的值更改为“Hello, world”。计算机会丢弃str原来的内容，并说：“好的，老板，str现在是Hello,
    world”（如果它会说话的话！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-2582
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们更改str的值时，我们不会再写var。计算机会记住我们之前在代码中声明了str，并知道str已经存在。因此，我们不需要重新创建str。我们只是想给它放入不同的内容。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-2583
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以声明*常量*。像变量一样，常量也保存值。常量与变量之间的主要区别在于，常量的值永远不能改变。变量的值可以变化，而常量的值是恒定不变的！声明常量类似于声明变量，不过我们使用let而不是var：
- en: '![Image](Image00041.jpg)'
  id: totrans-2584
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-2585
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为myName的常量，并赋予它值"Gloria"。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-2586
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个常量并赋予它一个值，它将一直保持这个值，直到永远。你可以把常量想象成一块大石头，你把值刻在上面。如果你试图将myName赋值为另一个值，比如"Matt"，你会得到像[图2-5](text00012.html#ch02fig5)中的错误。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-2587
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00042.jpg)![image](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-2588
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-5：试图改变常量的值是行不通的。*'
- en: '**NOTE**'
  id: totrans-2589
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-2590
  prefs: []
  type: TYPE_NORMAL
  zh: '*在播放区，错误会以一个红色圆圈显示，圆圈里有一个小白点。点击错误标记将显示错误信息，并告诉你哪里出了问题。如果你显示了调试区域，你也应该能看到描述发生了什么的相关信息，有时甚至会告诉你如何修复它。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-2591
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-2592
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量——做得好！但是，什么时候应该使用一个而不是另一个呢？在Swift中，最佳实践是使用常量而不是变量，除非你预期该值会发生变化。常量帮助使代码更加“安全”。如果你知道某个值永远不会改变，为什么不把它刻在石头上，避免将来可能出现的任何混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-2593
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，假设你想追踪教室里窗户的总数以及今天打开的窗户数量。教室里窗户的总数不会改变，因此你应该使用常量来存储这个值。而教室里打开的窗户数量会根据天气和时间变化，所以你应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-2594
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00044.jpg)![Image](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-2595
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将numberOfWindows设为常量，并将其值设置为8，因为总窗户数量始终是8。我们将numberOfWindowsOpen设为变量，并将其值设置为3，因为我们在开关窗户时需要改变这个值。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-2596
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用var声明变量，使用let声明常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-2597
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常量和变量的命名**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-2598
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以给变量或常量命名几乎任何你想要的名字，但有一些例外。你不能将它们命名为已经是Swift关键字的词。例如，你不能将变量命名为var。写var var会让你和计算机都感到困惑。如果你试图用Swift的保留字给变量或常量命名，你将会收到错误。你也不能在同一段代码中有两个相同名字的变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-2599
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则之外，在 Swift 中命名时，还有一些其他好的编程指南。你的变量名应该始终以小写字母开头。使用*非常*具有描述性的名字也是一个好主意（名字可以长得随便你）。当你使用描述性名称时，更容易理解这个变量或常量的用途。如果你在看别人的代码，哪个变量名会让你更容易理解呢：`numKids`
    还是 `numberOfKidsInMyClass`？第一个名字模糊不清，但第二个则具有描述性。常见的做法是使用一堆词拼接在一起作为变量或常量名，例如 `numberOfKidsInMyClass`。这种风格，多个单词拼接成一个变量名时每个单词的首字母大写，叫做*驼峰命名法*（camel
    case）。这是因为小写字母和大写字母的交替模式看起来像骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-2600
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-2601
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-2602
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你可以选择你希望变量或常量保存的数据类型——即*数据类型*。记得我们之前说过，你可以把变量看作一个容器，用来装某些东西吗？那么，数据类型就像是容器的类型。计算机需要知道我们会在每个容器中放什么东西。在
    Swift 编程中，一旦你告诉计算机你希望一个变量或常量保存某种数据类型，它就不会让你在该变量或常量中放入除了该数据类型以外的其他东西。如果你有一个用来装土豆的篮子，最好不要往里面放水——除非你喜欢水漏得到处都是！
- en: '![image](Image00047.jpg)'
  id: totrans-2603
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-2604
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-2605
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，你可以告诉计算机它将保存什么类型的数据。在我们关于教室窗户的例子中，我们知道这个变量将始终是一个*整数*（也就是说，一个整数——你不能真的拥有半个窗户），所以我们可以指定一个整数数据类型，像这样：
- en: '![Image](Image00048.jpg)'
  id: totrans-2606
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-2607
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示“是类型”。用简单的话来说，这行代码的意思是，“变量 `numberOfWindowsOpen`，它是一个整数，等于 3。”所以这一行代码创建了一个变量，给它命名，告诉计算机它的数据类型，并赋予它一个值。哇！一行代码做了所有这些事？我们有没有提到
    Swift 是一个非常*简洁*的语言？某些语言可能需要几行代码才能完成同样的事情。Swift 的设计就是让你可以通过一行代码做很多事情！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-2608
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要声明一次数据类型。当我们告诉计算机某个变量将保存整数时，就不需要再告诉它一次。事实上，如果我们再告诉它，Xcode 会给我们一个错误。一旦数据类型被声明，变量或常量将永远保存该类型的数据。一旦是整数，就永远是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-2609
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要知道一件事：变量或常量不能存储与其数据类型不匹配的内容。例如，如果你尝试把十进制数放入 numberOfWindowsOpen，你将会得到一个错误，正如
    [图 2-6](text00012.html#ch02fig6) 所示。
- en: '![image](Image00049.jpg)'
  id: totrans-2610
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-2611
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：你不能把十进制数放入一个本应存储整数的变量中。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-2612
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 numberOfWindowsOpen = 5 和 numberOfWindowsOpen = 0 是有效的并且可以工作。但你不能设置 numberOfWindowsOpen
    = 1.5。
- en: '**COMMON DATA TYPES**'
  id: totrans-2613
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见的数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-2614
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所学，数据类型让计算机知道它正在处理的数据是 *什么类型*，并且如何将其存储在内存中。那么，数据类型是什么呢？一些常见的数据类型包括 Int、Double、Float、Bool
    和 String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-2615
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下，看看这些到底是什么！
- en: '**Int (Integers)**'
  id: totrans-2616
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Int（整数）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-2617
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经稍微谈了一下整数，但让我们再详细讲讲它们。整数，在 Swift 中称为 Int，是没有小数部分或分数部分的整数。你可以把它们看作是计数数字。整数是
    *有符号的*，意味着它们可以是负数、正数或零。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-2618
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Double 和 Float（十进制数）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-2619
  prefs: []
  type: TYPE_NORMAL
  zh: '*十进制数*是小数点后有数字的数字，例如 3.14。 （像 3 这样的整数，如果你想把它写成十进制数，可以写成 3.0。）有两种数据类型可以存储十进制数：Double
    和 Float（*浮动小数点数* 的简写）。Double 数据类型在 Swift 中更常见，因为它可以存储更大的数字，所以我们将重点介绍它们。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-2620
  prefs: []
  type: TYPE_NORMAL
  zh: 当你赋值给一个 Double 时，必须在小数点左边有一个数字，否则会出现错误。例如，假设香蕉的价格是每个 19 分：
- en: '![Image](Image00050.jpg)'
  id: totrans-2621
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-2622
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码会导致错误，因为它的小数点左边没有数字。➋ 处的代码没有问题，因为它有一个前导零。（// ERROR 和 // CORRECT 是 *注释*，是程序中的说明，计算机会忽略这些内容。请参阅
    “[关于注释的一些快速说明](text00012.html#ch02sb01)” 以及 [第 32 页](text00012.html#page_32)）
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-2623
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Bool（布尔值，或真/假）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-2624
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值* 只能是两者之一：真或假。在 Swift 中，布尔数据类型称为 Bool。'
- en: '![Image](Image00051.jpg)'
  id: totrans-2625
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-2626
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值常用于 if-else 语句中，用于告诉计算机程序应该选择哪条路径。（我们将在 [第 3 章](text00013.html#ch03) 中更详细地讲解布尔值和
    if-else 语句。）
- en: '**String**'
  id: totrans-2627
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**String**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-2628
  prefs: []
  type: TYPE_NORMAL
  zh: String 数据类型用于存储单词和短语。*字符串*是由字符组成的集合，并且这些字符被引号括起来。例如，"Hello, playground" 就是一个字符串。字符串可以由各种各样的字符组成：字母、数字、符号等等。引号非常重要，因为它告诉计算机，所有引号之间的内容都是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-2629
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串拼接在一起来构建句子，这个过程叫做字符串*连接*。让我们看看它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-2630
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-2631
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用加号（+）将字符串连接起来，这段代码创建了一个名为 specialGreeting 的变量，其值为字符串 "Good Morning Jude"。请注意，在
    morningGreeting 和 friend 之间我们需要添加一个包含空格字符（" "）的字符串，否则 specialGreeting 的值将是 "Good
    MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-2632
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-2633
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-2634
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，有时在声明变量时，我们会包含数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-2635
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-2636
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们不会包含数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-2637
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-2638
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事？计算机实际上足够聪明，能够在大多数情况下推断出数据类型。这叫做*类型推断*——因为计算机会*推断*，或者猜测，我们使用的数据类型，基于我们给它的线索。当你创建一个变量并给它一个初始值时，这个值就是给计算机的一个重要线索。这里有一些例子：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-2639
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个没有小数值的数字（比如 3），计算机会认为它是一个整数（Int）。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-2640
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个带有小数值的数字（比如 3.14），计算机会认为它是一个浮点数（Double）。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-2641
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值*true* 或 *false*（没有引号），计算机会认为它是一个布尔值（Bool）。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-2642
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你用引号括起一个或多个字符，计算机会认为它是一个字符串（String）。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-2643
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量会被设置为该数据类型，就像你自己声明了数据类型一样。这纯粹是为了方便。你每次声明新常量或变量时都可以包含数据类型，这完全没问题。但是，为什么不让计算机自动推断出来，这样可以节省时间，减少输入呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-2644
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**通过类型转换转换数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-2645
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换* 是一种临时转换变量或常量数据类型的方法。你可以把它想象成对变量施下一个咒语——你让它的值表现得像是另一种数据类型，但只是暂时的。要做到这一点，你需要写一个新的数据类型，后面跟着括号，括号里是你要转换的变量。注意，这*并不会真正改变数据类型*，它只是为这一行代码提供了一个临时值。这里有一些整数（Int）和浮点数（Double）之间类型转换的示例。你可以查看代码结果边栏中的结果。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-2646
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![Image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-2647
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Int 类型的变量 months 转换为 Double，并将其存储在一个名为 doubleMonths 的新变量中。这会添加一个小数位，转换后的结果是
    12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-2648
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将浮点数（Double）转换为整数（Int）：
- en: '![Image](Image00058.jpg)'
  id: totrans-2649
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-2650
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Double 类型的 days 转换为 Int 类型。你可以看到小数点和它后面的所有数字都被去掉了：我们的数字变成了 365。这是因为
    Int 类型无法存储小数，它只能包含整数，所以小数点后面的部分被截断了。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-2651
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，类型转换并不会真正改变数据类型。在我们的示例中，即使进行了类型转换，days 依然是 *Double* 类型。我们可以通过打印 days 来验证这一点：
- en: '![Image](Image00059.jpg)'
  id: totrans-2652
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-2653
  prefs: []
  type: TYPE_NORMAL
  zh: 结果侧边栏显示，days 仍然等于 365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-2654
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍一些你使用类型转换的例子。如果现在还不清楚为什么要转换变量，稍等一下，马上就会明白！
- en: '**OPERATORS**'
  id: totrans-2655
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-2656
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中有许多算术运算符可以用来进行数学运算。你已经见过基本的赋值运算符 = 。你可能也熟悉加法 (+)、减法 (-)、乘法 (*) 和除法
    (/)。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-2657
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符对 Int、Float 和 Double 数据类型进行数学运算。参与运算的数字叫做 *操作数*。通过在 playground 中输入类似以下的代码来尝试这些数学运算符：
- en: '![Image](Image00060.jpg)'
  id: totrans-2658
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-2659
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 playground 中输入这段代码，你会在侧边栏看到每个数学表达式的结果。写数学表达式的代码与平常写法差别不大。例如，16 减去 2 就写作
    16 - 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-2660
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数学表达式的结果保存在一个变量或常量中，以便在代码的其他地方使用。要了解如何做到这一点，请在你的 playground 中输入以下几行代码：
- en: '![Image](Image00061.jpg)'
  id: totrans-2661
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-2662
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印 sum ➊ 时，你会在侧边栏看到 7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-2663
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在数学表达式中只使用了数字，但数学运算符同样适用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-2664
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的 playground 中：
- en: '![Image](Image00062.jpg)'
  id: totrans-2665
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-2666
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以像对数字进行操作一样，对变量和常量使用数学运算符。
- en: '**SPACES MATTER**'
  id: totrans-2667
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-2668
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，运算符两侧的空格是很重要的。你可以在数学运算符的两侧写一个空格，或者完全不写空格。但是，你不能只在运算符的一侧加空格，另一侧不加。这样会导致错误。请查看[图
    2-7](text00012.html#ch02fig7)。
- en: '![image](Image00063.jpg)'
  id: totrans-2669
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-2670
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：确保运算符两侧的空格数量相同。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-2671
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件重要的事情需要注意：你只能对相同数据类型的变量或常量使用数学运算符。在前面的代码中，三和五都是 Int 类型。常量 half 和 quarter
    是 Double 类型，因为它们是小数。如果你尝试将 Int 和 Double 相加或相乘，就会像在[图 2-8](text00012.html#ch02fig8)中那样遇到错误。
- en: '![image](Image00064.jpg)'
  id: totrans-2672
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-2673
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-8：在 Swift 中，无法对混合数据类型进行数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-2674
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你真的想对混合数据类型进行数学运算呢？例如，假设你想计算你年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-2675
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-2676
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行会导致错误，因为我们正在尝试将一个Int与一个Double相乘。但别担心！你有几个选项来确保操作数是相同的数据类型。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-2677
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是将myAge声明为一个Double类型，如下所示：
- en: '![Image](Image00066.jpg)'
  id: totrans-2678
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-2679
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码能正常运行，因为我们正在对两个Double类型的数据进行乘法运算。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-2680
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是使用类型转换。（我告诉过你我们会回到这个话题！）在这种情况下，类型转换是一个很好的解决方案，因为我们不想永久地将myAge改为Double类型，我们只想能像Double类型一样进行数学运算。让我们看一个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-2681
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-2682
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们在乘法之前将myAge转换为Double。这意味着我们不再有混合类型，所以代码可以正常运行。但是在➋处，我们会遇到错误。那是因为myAge仍然是Int类型。在➊处将其转换为Double并没有永久改变它的类型。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-2683
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能将multiplier转换为Int类型吗？当然可以！这样我们就可以对两个整数进行运算，这没有问题。然而，这会导致计算精度降低，因为我们会丢失小数位。当你将一个变量从Double转换为Int时，计算机会简单地删除小数点后的所有数字，使其变为整数。在这种情况下，你的0.1会被转换为Int类型的0。让我们在实验环境中转换一些变量，看看会得到什么：
- en: '![Image](Image00068.jpg)'
  id: totrans-2684
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-2685
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将Double类型的multiplier转换为Int，得到0。这个值在转换后发生了很大的变化，因为我们丢失了小数位：0.1变成了0。如果我们没有预料到这一点，这在我们的代码中可能会造成非常严重的问题。你必须小心转换，以确保不会意外地改变值。在➋处，还有一个将Double转换为Int的例子，如你所见，1.9没有四舍五入到2，它的小数部分只是被去掉了，我们剩下的是1。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-2686
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个数学运算符，*取模运算符*（%），可能对你来说不太熟悉。取模运算符（也叫*模*）返回除法后的余数。例如，7 % 2 = 1，因为7除以2的余数是1。你可以在你的实验环境中试试取模运算符，代码如下。
- en: '![Image](Image00069.jpg)'
  id: totrans-2687
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-2688
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，取模运算符对于判断一个数字是偶数（evenNumber % 2等于0）➊还是奇数（oddNumber % 2等于1）➋很有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-2689
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算优先级**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-2690
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们每行代码只做了一次数学运算，但通常我们会在一行中做多个运算。我们来看一个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-2691
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元的钞票和两张一美元的钞票，你有多少钱？让我们在一行代码中计算这个：
- en: '![Image](Image00070.jpg)'
  id: totrans-2692
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-2693
  prefs: []
  type: TYPE_NORMAL
  zh: 这将17赋值给myMoney。计算机先乘以5和3，再加上2。那么计算机怎么知道先进行乘法，再加上2呢？它是按从左到右的顺序来做吗？不是的！看看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-2694
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-2695
  prefs: []
  type: TYPE_NORMAL
  zh: 我们改变了数字的位置，结果仍然是17。如果计算机只是从左到右执行，它会先加上2 + 5，得到7。然后，它会把这个结果7乘以3，得到21。即使我们改变了数学表达式中数字的顺序，计算机仍然是先进行乘法（得到15），然后再加上2，得到17。*计算机总是先进行乘法和除法，再进行加法和减法。*
    这就是所谓的*运算顺序*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-2696
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号排序操作**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-2697
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必像在金钱示例中那样依赖计算机来判断该先做哪个步骤。你，程序员，拥有决定的权力！你可以使用括号将操作组合在一起。当你把括号放在某个操作周围时，你告诉计算机先做这一步：
- en: '![Image](Image00072.jpg)'
  id: totrans-2698
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-2699
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，括号告诉计算机先进行5乘3的运算，再加2。这样得到的结果是17。在➋处，括号告诉计算机先将2与5相加，再乘以3，得到的结果是21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-2700
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在其他括号内使用括号来使代码更加具体。计算机会先计算内层括号，然后计算外层括号。试试这个例子：
- en: '![Image](Image00073.jpg)'
  id: totrans-2701
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-2702
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机首先在内层括号中进行2和3的加法。然后，它会将结果乘以4，因为这是在外层括号内的操作。最后，它会加上外部括号中的1。最终结果是21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-2703
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值运算符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-2704
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的另一个操作符类别是*复合赋值运算符*。这些是将数学运算符与赋值运算符（=）结合的“快捷”运算符。例如，这个表达式
- en: '[PRE75]'
  id: totrans-2705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: becomes
  id: totrans-2706
  prefs: []
  type: TYPE_NORMAL
  zh: becomes
- en: '[PRE76]'
  id: totrans-2707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-2708
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符通过对变量或常量进行操作来更新它的值。用通俗的话来说，像a += b这样的表达式表示“将b加到a中，并将新值存储在a中”。[表 2-1](text00012.html#ch2tab1)显示了使用复合赋值运算符的数学表达式及其长形式的表达式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-2709
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-1：** 简短形式赋值运算符与长形式表达式'
- en: '| **Short form** | **Long form** |'
  id: totrans-2710
  prefs: []
  type: TYPE_TB
  zh: '| **简短形式** | **长形式** |'
- en: '| --- | --- |'
  id: totrans-2711
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-2712
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-2713
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-2714
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-2715
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-2716
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`+=`操作符的实际应用。假设我们正在编写一个程序来计算方舟上的动物数量。首先，我们创建一个名为animalsOnArk的变量，并将其设置为0，因为方舟上还没有动物。当不同种类的动物登上方舟时，我们希望增加animalsOnArk的值，以计算所有动物。如果两只长颈鹿登上方舟，我们需要将2加到animalsOnArk上。如果两只大象登上方舟，我们也需要再加2。如果四只羚羊登上方舟，我们需要将animalsOnArk增加4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-2717
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00074.jpg)![Image](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-2718
  prefs: []
  type: TYPE_NORMAL
  zh: 在两只长颈鹿、两只大象和四只羚羊登上方舟之后，animalsOnArk的最终值是8。真是一个动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-2719
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的一些简短说明**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-2720
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都提供了一种方式来在代码内添加注释。注释是计算机忽略的说明，它们的作用是帮助阅读代码的人理解代码的含义。尽管程序没有注释也能正常运行，但在那些可能不太清晰或容易混淆的代码部分加上注释是个好主意。即使你不打算将程序展示给别人，注释也能帮助你记住当初编写那段代码时的思路。几个月甚至几年后回顾你写的代码时，完全忘记自己当时在想什么，这种情况并不罕见。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-2721
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中有两种添加注释的方法。第一种方法是在你想添加注释的文本前面加上两个斜杠（//）。这些注释可以单独放在一行上，就像这样：
- en: '[PRE77]'
  id: totrans-2722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-2723
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它们也可以和代码行放在同一行——只要注释出现在代码的*后面*：
- en: '[PRE78]'
  id: totrans-2724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-2725
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法用于长注释或*多行*注释，其注释的开始和结束由/*和*/标记。（请注意，在本书中，我们将使用-- *snip* --来表示为了节省空间我们省略了更多的代码行。）
- en: '[PRE79]'
  id: totrans-2726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-2727
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不希望计算机运行部分代码，因为你正在寻找一个bug，但你又不想删除所有的工作，你可以使用多行注释来*暂时注释掉*代码的某些部分。当你将一块代码格式化为注释时，计算机会像忽略其他注释一样忽略这部分代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-2728
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-2729
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在Swift Playground中编写代码，这样你可以立刻看到结果。你创建了变量和常量，并学习了如何使用基本的数据类型和操作符，这些在你编写自己程序时会反复遇到。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-2730
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](text00013.html#ch03)中，你将使用条件语句，告诉计算机你希望它执行哪条代码路径。代码路径的选择是基于条件值的。
- en: 'Here’s the line of code from [Figure 2-3](text00012.html#ch02fig3) again:'
  id: totrans-2731
  prefs: []
  type: TYPE_NORMAL
  zh: 这是[图2-3](text00012.html#ch02fig3)中的代码行：
- en: '![Image](Image00037.jpg)'
  id: totrans-2732
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00037.jpg)'
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  id: totrans-2733
  prefs: []
  type: TYPE_NORMAL
  zh: 它做了两件事。首先，它创建了一个名为str的变量。这被称为*声明*，因为我们正在声明我们想要创建一个变量。要创建变量，您输入“var”这个词，然后为变量命名——在这个例子中是str。命名变量时有一些规则，我们稍后会讨论，所以现在就使用这个例子。
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  id: totrans-2734
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这行代码使用=运算符将“Hello, playground”赋值给str。这被称为*赋值*，因为我们正在将一个值赋给我们新创建的变量。记住，您可以将变量看作是一个容器，用来存放某些东西。所以现在我们有一个名为str的容器，里面存放着"Hello,
    playground"。
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  id: totrans-2735
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将这一行代码理解为“变量str等于Hello, playground。”如您所见，Swift通常非常易读；这一行代码几乎以英语告诉你它在做什么。
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  id: totrans-2736
  prefs: []
  type: TYPE_NORMAL
  zh: 变量很有用，因为如果您想打印“Hello, playground”这句话，您只需要使用命令print和str，如下代码所示：
- en: '![Image](Image00038.jpg)'
  id: totrans-2737
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00038.jpg)'
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  id: totrans-2738
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在结果侧边栏中打印"Hello, playground\n"。\n会自动添加到您打印的内容的末尾。它被称为*换行符*，它告诉计算机换到新的一行。
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  id: totrans-2739
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看程序实际运行时的结果，请打开调试区域，该区域将出现在两个面板下方，如[图 2-4](text00012.html#ch02fig4)所示。为此，请在
    Xcode 菜单中选择**视图** ▸ **调试区域** ▸ **显示调试区域**，或按下⌘ -SHIFT -Y。当在调试区域的控制台中打印str时，您会发现围绕“Hello,
    playground”的引号和换行符不会显示。这就是如果您正式运行该程序时，str的真实样子！
- en: '![image](Image00039.jpg)'
  id: totrans-2740
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-2741
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：在调试区域查看程序的真实输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-2742
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以在程序中更改（或*变化*！），因此您可以更改变量的值以保存其他内容。现在我们来试试这个。将以下行添加到您的playground中。
- en: '![Image](Image00040.jpg)'
  id: totrans-2743
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-2744
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改变量的值，只需键入变量名并使用=运算符将其设置为新值。我们在➊处执行此操作，将str的值更改为"Hello, world"。计算机会丢弃str之前保存的任何值，并且会说：“好的，老板，str现在是Hello,
    world”（如果它能说话的话！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-2745
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们改变str的值时，我们并没有再次写var。计算机会记住我们在之前的代码行中声明了str，并且知道str已经存在。所以我们不需要再次创建str。我们只需要给它赋不同的值。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-2746
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以声明*常量*。像变量一样，常量也保存值。常量和变量之间的主要区别是常量的值永远不能改变。变量是可变的，而常量是固定的！声明常量与声明变量类似，但我们使用let而不是var：
- en: '![Image](Image00041.jpg)'
  id: totrans-2747
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-2748
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们创建了一个名为 myName 的常量，并将其赋值为 "Gloria"。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-2749
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个常量并赋值，它将保持该值直到永远。把常量想象成一块大石头，你已经在上面刻上了你的值。如果你试图给 myName 赋另一个值，比如 "Matt"，你会得到像
    [图 2-5](text00012.html#ch02fig5) 中那样的错误。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-2750
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00042.jpg)![image](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-2751
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：试图改变常量的值是行不通的。*'
- en: '**NOTE**'
  id: totrans-2752
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-2753
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 playground 中，错误会以一个红色圆圈和一个小白点的形式显示。点击错误标记会显示错误信息，并告诉你哪里出了问题。如果你有显示调试区域，你还应该能看到描述发生了什么的相关信息，有时甚至会告诉你如何修复它。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-2754
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-2755
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量—做得好！但是，什么时候应该使用其中一个，而不是另一个呢？在 Swift 中，最佳实践是使用常量而不是变量，除非你预期值会发生变化。常量有助于让代码变得“更安全”。如果你知道某个值永远不会改变，为什么不把它刻入石中，避免以后可能的混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-2756
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，假设你想追踪你教室中的窗户总数和今天打开的窗户数。你教室中的窗户数量不会改变，因此你应该使用常量来存储这个值。而今天打开的窗户数会根据天气和时间变化，因此你应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-2757
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00044.jpg)![Image](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-2758
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 numberOfWindows 设置为常量并赋值为 8，因为窗户的总数永远是 8。我们将 numberOfWindowsOpen 设置为变量并赋值为
    3，因为我们希望在开窗或关窗时能改变这个值。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-2759
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用 var 来声明变量，使用 let 来声明常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-2760
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常量和变量的命名**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-2761
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以为变量或常量取任何名字，但有一些例外。你不能将它们命名为已经是 Swift 中的保留字。例如，你不能将变量命名为 var。写 var var
    会让你和计算机都感到困惑。如果你尝试使用 Swift 的保留字来命名变量或常量，会得到一个错误。你也不能在同一块代码中使用相同名字的两个变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-2762
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则之外，Swift 在命名时还有一些其他好的编程指南。你的变量名应该始终以小写字母开头。使用*非常*描述性的名字也是个好主意（它们可以长得很长）。使用描述性名字时，理解这个变量或常量的作用会更容易。如果你在看别人的代码，哪一个变量名你会更容易理解：`numKids`
    还是 `numberOfKidsInMyClass`？第一个变量名含糊不清，而第二个则非常描述性。常见的做法是将多个单词组合在一起作为变量或常量的名字，比如
    `numberOfKidsInMyClass`。这种将多个单词的首字母大写的命名风格，称为 *驼峰命名法*。因为小写字母和大写字母交替的样式像是骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-2763
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-2764
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-2765
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你可以选择变量或常量要持有什么类型的数据——即 *数据类型*。还记得我们说过，你可以把变量看作一个容器，里面存放某些东西吗？那么，数据类型就像是容器的类型。计算机需要知道我们将把什么类型的东西放进每个容器中。在
    Swift 编程中，一旦你告诉计算机某个变量或常量要持有特定的数据类型，它就不会让你把除了该数据类型的其他东西放入这个变量或常量中。如果你有一个专门用来装土豆的篮子，把篮子装满水可不是什么好主意——除非你喜欢水漏得到处都是！
- en: '![image](Image00047.jpg)'
  id: totrans-2766
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-2767
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-2768
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，你可以告诉计算机它将持有什么类型的数据。在我们关于教室窗户的例子中，我们知道这个变量将始终是一个 *整数*（即一个整数——你不可能有半个窗户），因此我们可以指定一个整数数据类型，如下所示：
- en: '![Image](Image00048.jpg)'
  id: totrans-2769
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-2770
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示“是……的类型”。用通俗的英语来说，这行代码表示：“变量 `numberOfWindowsOpen` 是一个整数，等于 3。”所以这行代码创建了一个变量，给它命名，告诉计算机它的数据类型，并为其赋值。呼！一行代码完成了这一切？我们有提到过
    Swift 是一种非常*简洁*的语言吗？一些语言可能需要几行代码才能完成相同的操作，而 Swift 的设计让你可以用一行代码完成很多事情！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-2771
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需声明一次数据类型。当我们告诉计算机某个变量将存储整数时，我们不需要再告诉它一次。事实上，如果我们再告诉它，Xcode 会给出错误。一旦声明了数据类型，变量或常量将永远持有这种类型的数据。一次整数，永远是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-2772
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件关于数据类型的事你需要知道：一个变量或常量不能存储与其数据类型不匹配的内容。例如，如果你尝试将小数赋值给 `numberOfWindowsOpen`，你将会遇到错误，正如[图
    2-6](text00012.html#ch02fig6)所示。
- en: '![image](Image00049.jpg)'
  id: totrans-2773
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-2774
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：你不能将小数赋值给一个本应存储整数的变量。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-2775
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `numberOfWindowsOpen = 5` 和 `numberOfWindowsOpen = 0` 是有效的并且能够正常工作。但是，你不能设置
    `numberOfWindowsOpen = 1.5`。
- en: '**COMMON DATA TYPES**'
  id: totrans-2776
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-2777
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚刚学到的，数据类型让计算机知道它正在处理的是什么*类型*的数据，以及如何在内存中存储这些数据。那么，数据类型有哪些呢？一些常见的数据类型包括整型
    (Int)、双精度浮点数 (Double)、浮点数 (Float)、布尔型 (Bool) 和字符串 (String)。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-2778
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下这些数据类型到底是什么吧！
- en: '**Int (Integers)**'
  id: totrans-2779
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**整型 (Integers)**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-2780
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经稍微讲了一下整数，接下来我们将更详细地讲解它们。在 Swift 中，整数（称为 Int）是没有小数部分或分数部分的整数。你可以把它们看作是计数数字。整数是*有符号*的，这意味着它们可以是负数、正数或零。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-2781
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**双精度浮点数和浮点数 (Decimal Numbers)**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-2782
  prefs: []
  type: TYPE_NORMAL
  zh: '*小数*是指在小数点后有数字的数字，比如 3.14。 (如果你希望将整数 3 视为小数，它将写成 3.0)。有两种数据类型可以存储小数：双精度浮点数
    (Double) 和浮点数 (Float，简称 *浮动点数*)。在 Swift 中，双精度浮点数更常见，因为它能够存储更大的数字，所以我们将重点讲解这个类型。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-2783
  prefs: []
  type: TYPE_NORMAL
  zh: 当你赋值一个双精度浮点数时，必须始终保证小数点左边有数字，否则会报错。例如，假设香蕉每个价格 19 美分：
- en: '![Image](Image00050.jpg)'
  id: totrans-2784
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-2785
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码将会报错，因为它没有小数点左侧的数字。而 ➋ 处的代码则没有问题，因为它有一个前导零。（“// 错误”和“// 正确”是*注释*，它们是程序中的说明，计算机会忽略这些内容。请参见
    “[关于注释的一些快速说明](text00012.html#ch02sb01)” ，详见[第 32 页](text00012.html#page_32)）。
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-2786
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**布尔型 (Booleans, 或者 True/False)**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-2787
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值*只能是两个值中的一个：真（true）或假（false）。在 Swift 中，布尔数据类型叫做 Bool。'
- en: '![Image](Image00051.jpg)'
  id: totrans-2788
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-2789
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔型通常用于 if-else 语句中，用来告诉计算机程序应该走哪条路径。（我们将在[第 3 章](text00013.html#ch03)中详细讲解布尔型和
    if-else 语句。）
- en: '**String**'
  id: totrans-2790
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符串 (String)**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-2791
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串数据类型用于存储单词和短语。*字符串*是由引号括起来的字符集合。例如，"Hello, playground" 是一个字符串。字符串可以由各种各样的字符组成：字母、数字、符号等。引号非常重要，因为它告诉计算机，所有引号之间的内容都是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-2792
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串连接起来来构建句子，这个过程叫做字符串 *连接*。让我们来看看它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-2793
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-2794
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用加号（+）将字符串连接在一起，这段代码创建了一个名为 specialGreeting 的变量，其值为字符串 "Good Morning Jude"。请注意，我们需要在
    morningGreeting 和 friend 之间添加一个包含空格字符（" "）的字符串，否则 specialGreeting 的值将是 "Good MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-2795
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-2796
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-2797
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，当我们声明一个变量时，有时会包括数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-2798
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-2799
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们并不包括数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-2800
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-2801
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事？计算机实际上足够聪明，能够大部分时候推断出数据类型。这就是所谓的 *类型推断*——因为计算机会 *推断*，或猜测我们正在使用的数据类型，基于我们提供的线索。当你创建一个变量并赋予它初始值时，这个值对计算机来说是一个重要的线索。以下是一些例子：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-2802
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个没有小数值的数字（如 3），计算机会假设它是一个 Int 类型。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-2803
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个带小数值的数字（如 3.14），计算机会假设它是一个 Double 类型。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-2804
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值 *true* 或 *false*（没有引号），计算机会假设它是一个 Bool 类型。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-2805
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个或多个带引号的字符，计算机会假设它是一个 String 类型。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-2806
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量会被设置为该数据类型，就像你自己声明数据类型一样。这纯粹是为了方便。每次声明新的常量或变量时，你可以包括数据类型，这完全没问题。但为什么不让计算机来推断出来，节省时间并减少额外的输入呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-2807
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**通过类型转换变换数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-2808
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换* 是一种临时转换变量或常量数据类型的方法。你可以把它想象成对变量施法——你让它的值像不同的数据类型一样表现，但仅仅是短时间内。要做到这一点，你写一个新的数据类型，后跟括号，括号中包含你正在转换的变量。请注意，这
    *并不会真正改变数据类型*。它只是给你一个临时的值，仅在这一行代码中有效。以下是一些在 Int 和 Double 之间转换的例子。请查看代码结果侧边栏中的输出。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-2809
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00056.jpg)![图片](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-2810
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ ，我们将 Int 类型的变量 months 转换为 Double 类型，并将结果存储在名为 doubleMonths 的新变量中。这添加了一个小数点，因此转换后的结果是
    12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-2811
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将一个 Double 转换为 Int：
- en: '![Image](Image00058.jpg)'
  id: totrans-2812
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-2813
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将Double类型的days转换为Int类型。你可以看到小数点和后面的所有数字都被去掉了：我们的数字变成了365。这是因为Int类型无法保存小数，它只能存储整数，所以小数点后面的部分会被舍去。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-2814
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，类型转换并不会改变数据类型。在我们的例子中，即使进行了类型转换，days *仍然*是一个Double类型。我们可以通过打印days来验证这一点：
- en: '![Image](Image00059.jpg)'
  id: totrans-2815
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-2816
  prefs: []
  type: TYPE_NORMAL
  zh: 侧边栏的结果显示，days仍然等于365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-2817
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论一些使用类型转换的例子。如果你现在不明白为什么要进行类型转换，稍等一下，我们很快就会解释！
- en: '**OPERATORS**'
  id: totrans-2818
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-2819
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中有许多算术运算符，你可以用来进行数学运算。你已经见过基本的赋值运算符=。你可能还熟悉加法(+) 、减法(-) 、乘法(*) 和除法(/)。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-2820
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符对Int、Float和Double数据类型进行数学运算。参与运算的数字被称为*操作数*。你可以在playground中尝试这些数学运算符，输入如下代码进行实验：
- en: '![Image](Image00060.jpg)'
  id: totrans-2821
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-2822
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在你的playground中输入这段代码，你会看到每个数学表达式的结果显示在侧边栏中。将数学表达式写入代码与正常书写并没有太大不同。例如，16减去2可以写成16
    – 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-2823
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数学表达式的结果保存到一个变量或常量中，以便在代码的其他地方使用。要了解这如何工作，请在你的playground中输入以下代码：
- en: '![Image](Image00061.jpg)'
  id: totrans-2824
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-2825
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印sum ➊时，侧边栏会显示7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-2826
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的数学表达式中只使用了数字，但数学运算符同样适用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-2827
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的playground中：
- en: '![Image](Image00062.jpg)'
  id: totrans-2828
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-2829
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你可以像对数字一样对变量和常量使用数学运算符。
- en: '**SPACES MATTER**'
  id: totrans-2830
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-2831
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，运算符两边的空格非常重要。你可以在数学运算符的两边各写一个空格，或者完全不写空格。但是你不能只在运算符的一边加空格，另一边不加。这会导致错误。请查看[图
    2-7](text00012.html#ch02fig7)。
- en: '![image](Image00063.jpg)'
  id: totrans-2832
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-2833
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：确保在运算符的两边有相同数量的空格。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-2834
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点很重要：你只能对相同数据类型的变量或常量使用数学运算符。在前面的代码中，three和five都是Int类型。常量half和quarter是Double类型，因为它们是小数。如果你尝试对Int和Double进行加法或乘法运算，你将遇到像[图
    2-8](text00012.html#ch02fig8)中那样的错误。
- en: '![image](Image00064.jpg)'
  id: totrans-2835
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-2836
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-8：在Swift中，你不能对混合数据类型进行数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-2837
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你真的想对混合数据类型进行数学运算呢？比如，假设你想计算自己年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-2838
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-2839
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行会导致错误，因为我们尝试将一个 Int 与一个 Double 相乘。但别担心！你有几种方法可以确保操作数是相同的数据类型。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-2840
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是将 myAge 声明为 Double 类型，像这样：
- en: '![Image](Image00066.jpg)'
  id: totrans-2841
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-2842
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有效，因为我们在进行两个 Double 数据类型的相乘。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-2843
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是使用类型转换。（我之前说过我们会回到这个问题！）在这种情况下，类型转换是一个很好的解决方案，因为我们不想永久地将 myAge 转换为 Double
    类型，我们只是希望能像对待 Double 一样进行数学运算。让我们来看一个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-2844
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-2845
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 myAge 转换为 Double 类型后再进行乘法运算。这意味着我们不再有混合类型，因此代码可以正常工作。但在 ➋ 处，我们会遇到错误。因为
    myAge 仍然是 Int 类型，虽然在 ➊ 处我们将其转换为 Double，但并没有永久改变它的类型。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-2846
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将乘数转换为整数吗？当然可以！这样我们就在对两个整数进行运算，结果是可以正常工作的。然而，这样会导致计算不那么精确，因为我们会丢失小数点。当你将一个变量从
    Double 转换为 Int 时，计算机会简单地去掉小数点后面的任何数字，使其变为整数。在这种情况下，乘数 0.1 会被转换为 Int 值 0。我们可以在编程环境中转换一些变量，看看会得到什么结果：
- en: '![Image](Image00068.jpg)'
  id: totrans-2847
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-2848
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，将我们的 Double 类型的乘数转换为 Int 后得到 0。这个值在转换后差异很大，因为我们丢失了小数点：0.1 变成了 0。如果我们没有预料到这种情况，这可能在我们的代码中会带来很糟糕的结果。你必须小心类型转换，确保不会意外地改变值。在
    ➋ 处，另一个将 Double 转换为 Int 的例子，如你所见，1.9 并没有四舍五入到 2，而是其小数部分被去掉，剩下 1。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-2849
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个数学运算符，*取余运算符*（%），可能对你来说不太熟悉。取余运算符（也叫*模*）是指除法后的余数。例如，7 % 2 = 1，因为7除以2的余数是1。试试在你的编程环境中使用取余运算符，操作如下。
- en: '![Image](Image00069.jpg)'
  id: totrans-2850
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-2851
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，取余运算符对判断一个数字是偶数（evenNumber % 2 等于 0）➊ 还是奇数（oddNumber % 2 等于 1）➋ 很有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-2852
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算顺序**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-2853
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们每行代码只进行了一次数学运算，但在一行代码中做多个运算是很常见的。我们来看一个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-2854
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元钞票和两张一美元钞票，你有多少钱？我们来在一行中计算一下：
- en: '![Image](Image00070.jpg)'
  id: totrans-2855
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-2856
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给myMoney赋值17。计算机会先进行5乘以3，然后再加2。那么计算机是如何知道先乘法再加法的呢？它只是从左到右工作吗？不是的！看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-2857
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-2858
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调整了数字的位置，结果仍然是17。如果计算机只是从左到右执行，它将先加2 + 5得到7，然后将这个结果7乘以3得到21。即使我们改变了数学表达式中数字的顺序，计算机仍然先进行乘法（得到15），然后再加2得到17。*计算机总是先进行乘法和除法运算，然后才是加法和减法。*
    这被称为*运算顺序*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-2859
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号排列运算顺序**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-2860
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要像我们在货币示例中那样依赖计算机来决定先做哪个步骤。你，作为程序员，有决定权！你可以使用括号来将操作组合在一起。当你把括号放在某个操作周围时，你是在告诉计算机先执行这个步骤：
- en: '![Image](Image00072.jpg)'
  id: totrans-2861
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-2862
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，括号告诉计算机先进行5乘以3，然后再加2。这样会得到17。在➋处，括号告诉计算机先进行2加5，然后再将结果乘以3，这样得到21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-2863
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在其他括号内使用括号使代码更加具体。计算机会首先计算内层括号的内容，然后再计算外层的。试试这个示例：
- en: '![Image](Image00073.jpg)'
  id: totrans-2864
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-2865
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机首先会在内层括号中进行2加3的运算。然后，它会将结果乘以4，因为这是在外层括号内。最后，它会加上1，因为1在外层括号之外。最终结果是21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-2866
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值运算符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-2867
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的另一类运算符是*复合赋值运算符*。这些是将数学运算符与赋值运算符（=）结合起来的“快捷方式”运算符。例如，这个表达式
- en: '[PRE80]'
  id: totrans-2868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: becomes
  id: totrans-2869
  prefs: []
  type: TYPE_NORMAL
  zh: 变成
- en: '[PRE81]'
  id: totrans-2870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-2871
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符通过对变量或常量进行运算来更新它们的值。用简单的话说，像a += b这样的表达式表示“将b加到a并把新值存储在a中。”[表2-1](text00012.html#ch2tab1)展示了使用复合赋值运算符的数学表达式，以及它们的长形式表达式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-2872
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-1：** 简短形式赋值运算符与长形式表达式对比'
- en: '| **Short form** | **Long form** |'
  id: totrans-2873
  prefs: []
  type: TYPE_TB
  zh: '| **简短形式** | **长形式** |'
- en: '| --- | --- |'
  id: totrans-2874
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-2875
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-2876
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-2877
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-2878
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-2879
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看+=运算符的实际操作。假设我们正在编写一个程序来计算方舟上动物的数量。首先，我们创建一个名为animalsOnArk的变量，并将其设置为0，因为方舟上还没有动物。当不同种类的动物登上方舟时，我们希望增加animalsOnArk的值，以便计算所有动物的数量。如果两只长颈鹿登上方舟，那么我们需要将2加到animalsOnArk上。如果两只大象登上方舟，那么我们需要再加2。如果四只羚羊登上方舟，那么我们需要将animalsOnArk增加4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-2880
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00074.jpg)![图片](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-2881
  prefs: []
  type: TYPE_NORMAL
  zh: 在两只长颈鹿、两只大象和四只羚羊登上方舟后，animalsOnArk的最终值是8。真是个动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-2882
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的几点快速说明**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-2883
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都有一种方法可以将注释与代码内联写入。注释是计算机会忽略的备注，目的是帮助阅读代码的人理解发生了什么。虽然程序在没有任何注释的情况下也能正常运行，但最好为那些可能不清楚或令人困惑的代码部分添加注释。即使你不打算将程序展示给其他人，注释也会帮助你记住你写这段代码时的思路或想法。很常见的是，几个月或几年后你回来看自己写的代码，却完全不记得当时在想什么。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-2884
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中有两种添加注释的方式。第一种方法是在你想添加的文本前面加上两个正斜杠（//）。这些注释可以单独放在一行，就像这样：
- en: '[PRE82]'
  id: totrans-2885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-2886
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它们可以和一行代码放在同一行—只要注释*在*代码之后：
- en: '[PRE83]'
  id: totrans-2887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-2888
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法用于长注释或*多行*注释，其中注释的开始和结束由/*和*/标记。（注意，在本书中，我们将使用-- *snip* --来表示由于空间原因我们省略的更多代码行。）
- en: '[PRE84]'
  id: totrans-2889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-2890
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不想让计算机执行部分代码，因为你正在寻找一个bug，但又不想删除你所有的辛苦工作，你可以使用多行注释暂时将部分代码*注释掉*。当你将一段代码格式化为注释时，计算机会忽略这段代码，就像它忽略任何其他注释一样。
- en: '**WHAT YOU LEARNED**'
  id: totrans-2891
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-2892
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何在Swift playground中编写代码，它让你可以立刻看到结果。你创建了变量和常量，并学习了如何使用基本的数据类型和运算符，这些在你编写自己的计算机程序时会不断遇到。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-2893
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第三章](text00013.html#ch03)中，你将使用条件语句，这告诉计算机你希望它执行哪条代码路径。代码路径的选择是基于条件的值。
- en: '![Image](Image00037.jpg)'
  id: totrans-2894
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00037.jpg)'
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  id: totrans-2895
  prefs: []
  type: TYPE_NORMAL
  zh: 它做了两件事。首先，它创建了一个名为 str 的变量。这叫做*声明*，因为我们声明了我们想创建一个变量。要创建变量，你需要输入 var 这个词，然后输入变量的名称——在这个例子中是
    str。命名变量时有一些规则，我们稍后会讲到，现在先按照这个例子来做。
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  id: totrans-2896
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，这行代码使用 = 运算符将“Hello, playground”的值赋给 str。这叫做*赋值*，因为我们正在为新创建的变量赋值。记住，你可以把变量想象成一个容器，用来存放某些东西。所以现在我们有一个名为
    str 的容器，它保存着“Hello, playground”。
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  id: totrans-2897
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把这一行代码理解为“变量 str 等于 Hello, playground”。如你所见，Swift 通常是非常易读的；这行代码几乎用英语告诉你它在做什么。
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  id: totrans-2898
  prefs: []
  type: TYPE_NORMAL
  zh: 变量很有用，因为如果你想打印“Hello, playground”这句话，你只需要对 str 使用 print 命令，就像下面的代码那样：
- en: '![Image](Image00038.jpg)'
  id: totrans-2899
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00038.jpg)'
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  id: totrans-2900
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在结果侧边栏打印出“Hello, playground\n”。\n 会自动添加到你打印的内容末尾。它被称为*换行*字符，告诉计算机跳到新的一行。
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  id: totrans-2901
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看程序的实际运行结果，打开调试区域，它会出现在下方两个面板之间，如[图 2-4](text00012.html#ch02fig4)所示。你可以通过
    Xcode 菜单中的 **View** ▸ **Debug Area** ▸ **Show Debug Area** 或按 ⌘ -SHIFT -Y 来实现。当
    str 在调试区域的控制台中打印时，你会看到“Hello, playground”周围的引号和换行符不会出现。这就是如果你正式运行这个程序时，str 真实的样子！
- en: '![image](Image00039.jpg)'
  id: totrans-2902
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-2903
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：在调试区域查看程序的实际输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-2904
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以在你的程序中改变（或*变化*！），因此你可以更改变量的值来保存其他内容。我们现在就来试试。将以下几行代码添加到你的 playground 中。
- en: '![Image](Image00040.jpg)'
  id: totrans-2905
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-2906
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改变量的值，输入变量的名称并使用 = 运算符将其设置为新值。我们在 ➊ 这样做，目的是将 str 的值更改为“Hello, world”。计算机会丢弃
    str 之前存储的任何内容，然后说：“好的，老板，str 现在是 Hello, world”（当然，如果它能说话的话，它会这么说！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-2907
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们更改 str 的值时，我们不需要再次写 var。计算机会记住我们在前一行代码中声明了 str，并知道 str 已经存在。所以我们不需要再次创建
    str，我们只是想给它赋予不同的内容。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-2908
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以声明*常量*。和变量一样，常量也用来保存值。常量和变量之间的最大区别是常量的值永远不能改变。变量可以变化，而常量则是恒定的！声明常量与声明变量类似，但我们使用
    let 而不是 var：
- en: '![Image](Image00041.jpg)'
  id: totrans-2909
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-2910
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们创建了一个名为 `myName` 的常量，并将其赋值为 "Gloria"。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-2911
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个常量并赋值，它将一直保持这个值，直到永远。可以将常量想象成一块大石头，你已经把值刻入其中。如果你尝试给 `myName` 赋另一个值，比如
    "Matt"，你将会收到像 [图 2-5](text00012.html#ch02fig5) 中的错误提示。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-2912
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00042.jpg)![image](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-2913
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：尝试更改常量的值是行不通的。*'
- en: '**NOTE**'
  id: totrans-2914
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-2915
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 playground 中，错误会以一个带有小白圈的红色圆圈形式出现。点击错误标记会显示错误消息，并告诉你问题出在哪里。如果你打开了调试区域，还会看到描述发生了什么以及有时如何修复它的信息。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-2916
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-2917
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量——做得好！但是，什么时候应该使用其中一个而不是另一个呢？在 Swift 中，最佳实践是使用常量而不是变量，除非你预计该值会发生变化。常量有助于让代码变得“更安全”。如果你知道某个值永远不会改变，为什么不将它刻进石头里，避免以后可能的混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-2918
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你想记录教室中窗户的总数以及今天开着的窗户数量。教室中的窗户数量不会改变，所以你应该使用常量来存储这个值。然而，今天开着的窗户数量会根据天气和时间变化，因此你应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-2919
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00044.jpg)![Image](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-2920
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `numberOfWindows` 设置为常量并赋值为 8，因为窗户总数永远是 8。我们将 `numberOfWindowsOpen` 设置为变量并赋值为
    3，因为我们希望在开关窗户时更改这个值。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-2921
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用 `var` 来声明变量，使用 `let` 来声明常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-2922
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常量和变量命名**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-2923
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为变量或常量命名几乎任何你想要的名称，但有几个例外。你不能将它们命名为 Swift 中已存在的关键字。例如，你不能将变量命名为 `var`。写 `var
    var` 会让你和计算机都感到困惑。如果你尝试使用 Swift 的保留字来命名变量或常量，你会遇到错误。同时，你也不能在同一代码块中使用相同名称的两个变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-2924
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则外，在 Swift 中为事物命名时，还有一些其他好的编程指导原则。你的名称应该始终以小写字母开头。使用*非常*具有描述性的名称也是个好主意（它们可以根据需要很长）。当你使用一个描述性名称时，理解这个变量或常量的含义就容易多了。如果你在看别人的代码，你会觉得哪个变量名更容易理解：numKids
    还是 numberOfKidsInMyClass？第一个很模糊，但第二个很有描述性。我们常常看到像 numberOfKidsInMyClass 这样的变量和常量，它们由一串单词组成。这种命名风格，即每个单词的首字母大写，多个单词组合成一个变量名时，叫做*驼峰命名法*。这是因为大小写字母的排列看起来像骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-2925
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-2926
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-2927
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你可以选择一个变量或常量所要存储的数据类型（*数据类型*）。还记得我们说过，可以把变量看作是一个容器吗？数据类型就像是容器的类型。计算机需要知道我们将把什么样的东西放进每个容器里。在
    Swift 编程中，一旦你告诉计算机某个变量或常量将存储某种数据类型，它就不会允许你将其他类型的数据放入该变量或常量中。如果你有一个专门用来装土豆的篮子，把水放进这个篮子里就不太合适了——除非你喜欢水漏得到处都是！
- en: '![image](Image00047.jpg)'
  id: totrans-2928
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-2929
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-2930
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，你可以告诉计算机它将持有什么类型的数据。在我们关于教室窗户的例子中，我们知道这个变量将始终是一个*整数*（也就是一个整数——你不可能有半个窗户），所以我们可以像这样指定一个整数数据类型：
- en: '![Image](Image00048.jpg)'
  id: totrans-2931
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-2932
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示“是某种类型”。通俗来说，这行代码的意思是：“变量 numberOfWindowsOpen，类型为整数，等于 3。”所以这行代码创建了一个变量，给它命名，告诉计算机它的数据类型，并为它赋值。哇！一行代码完成了这一切？我们提到过
    Swift 是一个*简洁*的语言吗？有些语言可能需要好几行代码才能做同样的事情。Swift 被设计得让你能用一行代码做很多事情！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-2933
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要声明数据类型一次。当我们告诉计算机某个变量将存储整数时，就不需要再重复告诉它。在事实上，如果我们重复声明，Xcode 会报错。一旦数据类型被声明，变量或常量将永远持有这种类型的数据。一次是整数，永远是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-2934
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要知道一件事：一个变量或常量不能存储它数据类型之外的内容。例如，如果你试图将一个十进制数放入 numberOfWindowsOpen 中，你会得到一个错误，正如
    [图 2-6](text00012.html#ch02fig6) 所示。
- en: '![image](Image00049.jpg)'
  id: totrans-2935
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-2936
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：你不能将十进制数字放入一个应该存储整数的变量中。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-2937
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 numberOfWindowsOpen = 5 和 numberOfWindowsOpen = 0 是有效的，并且能正常工作。但是你不能将 numberOfWindowsOpen
    设置为 1.5。
- en: '**COMMON DATA TYPES**'
  id: totrans-2938
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-2939
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚刚学到的，数据类型让计算机知道它正在处理的数据是什么类型，并且知道如何将其存储在内存中。那么，数据类型有哪些呢？一些常见的数据类型包括 Int、Double、Float、Bool
    和 String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-2940
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下，看看这些数据类型究竟是什么！
- en: '**Int (Integers)**'
  id: totrans-2941
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Int（整数）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-2942
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经稍微谈过整数了，但让我们更详细地讨论一下它们。整数，在 Swift 中称为 Int，是没有小数或分数部分的整数。你可以把它们看作是计数数字。整数是*有符号*的，意味着它们可以是负数、正数或零。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-2943
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Double 和 Float（十进制数字）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-2944
  prefs: []
  type: TYPE_NORMAL
  zh: '*十进制数字* 是小数点后有数字的数字，如 3.14。（如果你想将整数 3 表示为十进制数字，它会写作 3.0。）有两种数据类型可以存储十进制数字：Double
    和 Float（即 *浮点数*）。Double 数据类型在 Swift 中更为常见，因为它可以存储更大的数字，因此我们将重点讨论 Double。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-2945
  prefs: []
  type: TYPE_NORMAL
  zh: 当你赋值给一个 Double 时，必须始终在小数点左侧有一个数字，否则会出现错误。例如，假设香蕉每个 19 美分：
- en: '![Image](Image00050.jpg)'
  id: totrans-2946
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-2947
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码会导致错误，因为它的小数点左侧没有数字。➋ 处的代码没有问题，因为它有一个前导零。（// ERROR 和 // CORRECT 是*注释*，它们是程序中的说明，计算机会忽略它们。参见
    “[关于注释的一些快速说明](text00012.html#ch02sb01)” 在 [第 32 页](text00012.html#page_32)。）
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-2948
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Bool（布尔值，或真/假）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-2949
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值* 只能是两种状态之一：真或假。在 Swift 中，布尔数据类型被称为 Bool。'
- en: '![Image](Image00051.jpg)'
  id: totrans-2950
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-2951
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值常常用于 if-else 语句中，告诉计算机程序应该走哪条路径。（我们将在 [第 3 章](text00013.html#ch03) 中更详细地讨论布尔值和
    if-else 语句。）
- en: '**String**'
  id: totrans-2952
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**String（字符串）**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-2953
  prefs: []
  type: TYPE_NORMAL
  zh: String 数据类型用于存储单词和短语。*字符串* 是一系列被引号括起来的字符。例如，"Hello, playground" 是一个字符串。字符串可以由各种字符组成：字母、数字、符号等等。引号很重要，因为它们告诉计算机，所有引号之间的内容都是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-2954
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串拼接在一起来构建句子，这个过程叫做字符串*连接*。让我们看看它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-2955
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-2956
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用加号（+）将字符串连接起来，这段代码创建了一个名为 specialGreeting 的变量，其值为 "Good Morning Jude"。注意，我们需要在
    morningGreeting 和 friend 之间加上一个包含空格字符（" "）的字符串，否则 specialGreeting 将是 "Good MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-2957
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-2958
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-2959
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到有时在声明变量时，我们会指定数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-2960
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-2961
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们不会指定数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-2962
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-2963
  prefs: []
  type: TYPE_NORMAL
  zh: 这是怎么回事？其实计算机足够聪明，大多数时候能自动判断数据类型。这被称为*类型推断*——因为计算机会根据我们提供的线索*推测*或猜测我们使用的数据类型。当你创建一个变量并给它赋初值时，这个初始值就是计算机的重要线索。下面是一些示例：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-2964
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个没有小数点的数字（如 3），计算机会默认它是一个 Int 类型。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-2965
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个带小数点的数字（如 3.14），计算机会默认它是一个 Double 类型。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-2966
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值单词*true*或*false*（没有引号），计算机会默认它是一个 Bool 类型。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-2967
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个或多个带引号的字符，计算机会默认它是一个 String 类型。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-2968
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量会被设置为该数据类型，就像你自己声明数据类型一样。这完全是为了方便。你可以在每次声明新常量或变量时都指定数据类型，完全没问题。但为什么不让计算机自己推断出来，省下时间和输入呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-2969
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**通过转换数据类型进行转换**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-2970
  prefs: []
  type: TYPE_NORMAL
  zh: '*转换* 是一种临时转换变量或常量的数据类型的方法。你可以把它想象成对变量施了一个魔法——让它的值表现得像另一个数据类型，但仅仅是短暂的。要做到这一点，你需要在变量后面写上新的数据类型，并将要转换的变量放在括号里。请注意，这*并不会真正改变数据类型*。它只是给你一个该行代码的临时值。这里有一些
    Int 和 Double 之间转换的示例。查看代码运行结果的侧边栏。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-2971
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![Image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-2972
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Int 类型的变量 months 转换为 Double 类型，并将其存储在一个新变量 doubleMonths 中。这添加了一个小数位，转换后的结果是
    12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-2973
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将一个 Double 类型转换为 Int 类型：
- en: '![Image](Image00058.jpg)'
  id: totrans-2974
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-2975
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-2976
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-2977
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-2978
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-2979
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-2980
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-2981
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-2982
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-2983
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-2984
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-2985
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-2986
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-2987
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-2988
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-2989
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-2990
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-2991
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-2992
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-2993
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-2994
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-2995
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-2996
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-2997
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-2998
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-2999
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你真的想对混合数据类型进行数学运算怎么办？例如，假设你想计算自己年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-3000
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-3001
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行会导致错误，因为我们尝试将一个Int与一个Double相乘。但别担心！你有几个选项可以确保你的操作数是相同的数据类型。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-3002
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是将myAge声明为Double类型，像这样：
- en: '![Image](Image00066.jpg)'
  id: totrans-3003
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-3004
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码能正常工作，因为我们正在对两个Double数据类型进行相乘。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-3005
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是使用类型转换。（我告诉过你我们会回到这个问题！）在这种情况下，类型转换是一个很好的解决方案，因为我们不想永久地将myAge变为Double类型，我们只是想把它当作Double来进行数学运算。让我们看看一个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-3006
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-3007
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们在进行乘法运算前将myAge转换为Double类型。这样，我们就不再有混合类型，因此代码能正常工作。但在➋处，我们会遇到错误。这是因为myAge仍然是Int类型。虽然在➊处将它转换为Double类型，但它并没有永久变为Double。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-3008
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将multiplier转换为Int吗？当然可以！这样我们就在对两个整数进行数学运算，这没有问题。然而，这样会导致计算精度降低，因为我们会丢失小数部分。当你将一个变量从Double转换为Int时，计算机会简单地去除小数点后的任何数字，使其成为整数。在这种情况下，你的0.1的multiplier会被转换为0的Int类型。让我们在Playground中尝试转换一些变量，看看会得到什么结果：
- en: '![Image](Image00068.jpg)'
  id: totrans-3009
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-3010
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，将我们的Double类型的multiplier转换为Int后，得到的结果是0。这个值在转换后与原始值相差很大，因为我们丢失了小数部分：0.1变成了0。如果我们没有预料到这种情况，这可能会在代码中造成很大的问题。在进行类型转换时，你必须小心，确保不会意外地改变你的值。
    在➋处，又有一个将Double转换为Int的例子，正如你所看到的，1.9没有四舍五入成2，它的小数部分直接被移除，结果是1。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-3011
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个数学运算符，*取模运算符*（%），可能你不太熟悉。取模运算符（也叫*模数*）在除法后返回余数。例如，7 % 2 = 1，因为7除以2的余数是1。试着在你的Playground中使用取模运算符，像这样：
- en: '![Image](Image00069.jpg)'
  id: totrans-3012
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-3013
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，取模运算符对于判断一个数字是偶数（evenNumber % 2 等于0）➊还是奇数（oddNumber % 2 等于1）➋非常有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-3014
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算顺序**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-3015
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们每行代码只做了一个数学运算，但在一行代码中进行多个运算是很常见的。让我们看看一个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-3016
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元钞票和两张一美元钞票，你有多少钱？让我们在一行代码中计算一下：
- en: '![Image](Image00070.jpg)'
  id: totrans-3017
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-3018
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把17赋值给myMoney。计算机先计算5乘3，然后加上2。但计算机怎么知道先乘法*再*加法呢？它只是从左到右计算吗？不是！看看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-3019
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-3020
  prefs: []
  type: TYPE_NORMAL
  zh: 我们改变了数字的顺序，结果仍然是17。如果计算机从左到右计算，它会先加2 + 5，得到7。然后它会将结果7乘以3，得到21。尽管我们改变了数学表达式中数字的顺序，计算机仍然先进行乘法运算（得出15），然后再加上2，得到17。*计算机总是先进行乘法和除法运算，然后再进行加法和减法运算。*
    这被称为*运算顺序*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-3021
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号排序运算**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-3022
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必像我们在金钱示例中那样依赖计算机来决定先做哪个步骤。你，作为程序员，有决定权！你可以使用括号将运算组合在一起。当你将括号放在某个操作周围时，你告诉计算机先做这个步骤：
- en: '![Image](Image00072.jpg)'
  id: totrans-3023
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-3024
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，括号告诉计算机先计算5乘以3，再加上2。这将给你17。在➋处，括号告诉计算机先计算2加5，再乘以3，得到21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-3025
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在其他括号内使用括号来使代码更加具体。计算机会先计算内层的括号，然后再计算外层括号。试试这个例子：
- en: '![Image](Image00073.jpg)'
  id: totrans-3026
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-3027
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，计算机在内层括号中加2和3。然后它将结果乘以4，因为这在外层括号中。最后它加上1，因为1在两个括号外面。最终结果是21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-3028
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值运算符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-3029
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的另一类运算符是*复合赋值运算符*。这些是将数学运算符与赋值运算符（=）结合起来的“快捷方式”运算符。例如，这个表达式
- en: '[PRE85]'
  id: totrans-3030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: becomes
  id: totrans-3031
  prefs: []
  type: TYPE_NORMAL
  zh: 变为
- en: '[PRE86]'
  id: totrans-3032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-3033
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符通过对变量或常量进行运算来更新其值。用简单的话来说，像a += b这样的表达式表示“将b加到a并将新值存储在a中。”[表2-1](text00012.html#ch2tab1)显示了使用复合赋值运算符的数学表达式以及它们的长形式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-3034
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-1：** 短格式赋值运算符与长格式表达式'
- en: '| **Short form** | **Long form** |'
  id: totrans-3035
  prefs: []
  type: TYPE_TB
  zh: '| **短格式** | **长格式** |'
- en: '| --- | --- |'
  id: totrans-3036
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-3037
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-3038
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-3039
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-3040
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-3041
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`+=`操作符的实际应用。假设我们正在编写一个程序来计算方舟上的动物数量。首先，我们创建一个名为animalsOnArk的变量，并将其设置为0，因为方舟上还没有动物。当不同种类的动物登上方舟时，我们希望增加animalsOnArk的值，以便计算所有动物的数量。如果两只长颈鹿登上方舟，那么我们需要将animalsOnArk加2。如果两只大象登上方舟，我们需要再次加2。如果四只羚羊登上方舟，我们需要将animalsOnArk增加4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-3042
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00074.jpg)![Image](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-3043
  prefs: []
  type: TYPE_NORMAL
  zh: 在两只长颈鹿、两只大象和四只羚羊登上方舟之后，animalsOnArk的最终值是8。真是个动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-3044
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的一些简短评论**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-3045
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都提供了一种与代码内联写注释的方法。注释是计算机忽略的文本，用来帮助阅读代码的人理解代码的内容。尽管没有注释程序也能正常运行，但在代码不清晰或容易混淆的部分添加注释是个好主意。即使你不打算让别人看到你的程序，注释也能帮助你记住在编写那段代码时的思路或想法。回过头来看几个月甚至几年前写的代码时，常常不知道当时在想什么。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-3046
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中有两种添加注释的方式。第一种方式是在线前加上两个斜杠（//）。这些注释可以单独放在一行，就像这样：
- en: '[PRE87]'
  id: totrans-3047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-3048
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它们也可以放在代码行的同一行——只要注释位于代码*之后*：
- en: '[PRE88]'
  id: totrans-3049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-3050
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法用于长注释，或者*多行*注释，其开始和结束由/*和*/标记。（注意，本书中我们会使用-- *snip* --来表示省略的更多代码行，以节省空间。）
- en: '[PRE89]'
  id: totrans-3051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-3052
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不希望计算机执行代码的某部分，因为你正在寻找一个bug，但又不想删除所有辛苦写的代码，你可以使用多行注释来*临时注释掉*某些代码段。当你将一段代码格式化为注释时，计算机会像忽略其他任何注释一样忽略这段代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3053
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-3054
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在Swift playground中编写代码，这样你可以立即看到结果。你创建了变量和常量，并学习了如何使用基本数据类型和操作符，这些将是你编写自己程序时反复遇到的内容。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-3055
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](text00013.html#ch03)中，你将使用条件语句，它告诉计算机你希望它执行哪条代码路径。代码路径是根据条件的值来选择的。
- en: It does two things. First, it creates a variable named str . This is called
    a *declaration* because we are declaring that we would like to create a variable.
    To create a variable, you type the word var and then type a name for your variable—this
    case, str . There are some rules when naming variables, which we’ll go over later,
    so for now stick with this example.
  id: totrans-3056
  prefs: []
  type: TYPE_NORMAL
  zh: 它做了两件事。首先，它创建了一个名为str的变量。这被称为*声明*，因为我们在声明我们想要创建一个变量。要创建一个变量，首先输入关键词var，然后输入变量的名称——在这个例子中是str。命名变量时有一些规则，我们稍后会讨论，现在先遵循这个示例。
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  id: totrans-3057
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这行代码使用=运算符给str赋值"Hello, playground"。这被称为*赋值*，因为我们正在给新创建的变量赋一个值。记住，你可以把变量看作一个容器，用来存储东西。所以现在我们有了一个名为str的容器，它存储着"Hello,
    playground"。
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  id: totrans-3058
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把这一行代码理解为“变量str等于Hello, playground”。正如你所看到的，Swift通常非常易读；这行代码几乎用英语告诉你它在做什么。
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  id: totrans-3059
  prefs: []
  type: TYPE_NORMAL
  zh: 变量非常方便，因为如果你想打印“Hello, playground”，你只需对str使用print命令，就像以下代码一样：
- en: '![Image](Image00038.jpg)'
  id: totrans-3060
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00038.jpg)'
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  id: totrans-3061
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在结果侧边栏中打印出"Hello, playground\n"。\n会自动添加到你打印的内容末尾。它被称为*换行*符，告诉计算机跳到新的一行。
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  id: totrans-3062
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看程序实际运行时的结果，打开调试区域，它会出现在两个面板下方，如[图 2-4](text00012.html#ch02fig4)所示。你可以通过在Xcode菜单中选择**视图**
    ▸ **调试区域** ▸ **显示调试区域**，或者按⌘ -SHIFT -Y来做到这一点。当str在调试区域的控制台中打印出来时，你会看到“Hello, playground”周围的引号和换行符不会出现。如果你正式运行这个程序，str的输出就是这样！
- en: '![image](Image00039.jpg)'
  id: totrans-3063
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-3064
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：在调试区域查看程序的真实输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-3065
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在程序中是可以变化的（或者说是*变化*的！），所以你可以改变变量的值来存储其他内容。现在让我们尝试一下。将以下几行添加到你的playground中。
- en: '![Image](Image00040.jpg)'
  id: totrans-3066
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-3067
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变变量的值，输入它的名称并使用=运算符将其设置为新值。我们在➊处这样做，将str的值改变为"Hello, world"。计算机会丢弃str原来的值，并说：“好的，老板，str现在是Hello,
    world”（当然，如果它能说话的话！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-3068
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们改变str的值时，我们并没有再次写var。计算机会记住我们在之前的代码行中声明了str，并知道str已经存在。所以我们不需要重新创建str，我们只是想给它赋一个不同的值。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-3069
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以声明*常量*。和变量一样，常量也存储值。常量和变量的最大区别在于常量的值永远不能改变，而变量的值是可以变化的，常量则是，嗯，常量！声明常量的方式和声明变量类似，但我们使用的是let而不是var：
- en: '![Image](Image00041.jpg)'
  id: totrans-3070
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-3071
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为myName的常量，并将其赋值为"Gloria"。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-3072
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个常量并给它赋值，它将一直保持这个值，直到永远。你可以把常量想象成一块大石头，你把值刻在上面。如果你试图为myName赋予另一个值，比如"Matt"，你将得到一个类似于[图2-5](text00012.html#ch02fig5)中的错误。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-3073
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00042.jpg)![image](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-3074
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-5：尝试修改常量的值是无效的。*'
- en: '**NOTE**'
  id: totrans-3075
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-3076
  prefs: []
  type: TYPE_NORMAL
  zh: '*在playground中，错误会以一个红色圆圈和一个小白色圆圈的形式显示。点击错误标记将显示错误信息并告诉你哪里出错。如果你有调试区域打开，你还应该看到描述发生了什么的信息，有时甚至会告诉你如何修复它。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-3077
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-3078
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量——干得不错！但什么时候应该使用其中一个而不是另一个呢？在Swift中，除非你预期某个值会变化，否则最好使用常量而不是变量。常量有助于使代码“更安全”。如果你知道某个值永远不会改变，为什么不将其刻入石板，避免以后可能产生的混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-3079
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想跟踪教室里窗户的总数和今天打开的窗户数。教室里窗户的数量不会改变，因此你应该使用常量来存储这个值。而今天打开的窗户数量则会根据天气和时间变化，因此你应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-3080
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00044.jpg)![image](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-3081
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将numberOfWindows设置为常量并赋值为8，因为窗户的总数将始终是8。我们将numberOfWindowsOpen设置为变量并赋值为3，因为我们在打开或关闭窗户时需要更改这个值。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-3082
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用var表示变量，使用let表示常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-3083
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**命名常量和变量**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-3084
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以随意为变量或常量命名，但有几个例外。你不能将其命名为Swift中已有的关键字。例如，你不能将变量命名为var。写成var var会让你和计算机都感到困惑。如果你尝试使用Swift的保留字作为变量或常量的名称，你将会收到错误提示。此外，你还不能在同一个代码块中使用两个相同名称的变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-3085
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则，Swift 中还有一些其他好的编程指南，尤其是在命名时。你的变量名应始终以小写字母开头。使用*非常*具有描述性的名称也是一个好主意（它们可以任意长）。当你使用一个描述性名称时，更容易理解这个变量或常量的用途。如果你在查看别人的代码，你会觉得哪个变量名更容易理解：numKids
    还是 numberOfKidsInMyClass？第一个比较模糊，而第二个则更具描述性。常见的做法是将多个词拼接在一起作为变量名，比如 numberOfKidsInMyClass。这个命名方式，其中每个单词的首字母大写，叫做*驼峰式命名*（camel
    case）。之所以叫驼峰式命名，是因为大小写字母的排列方式看起来像骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-3086
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-3087
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-3088
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你可以选择你希望变量或常量持有的数据类型——*数据类型*。记得我们说过，变量就像一个容器，用来存放某些东西吗？那么，数据类型就像容器的类型。计算机需要知道我们将放入每个容器中的是什么类型的东西。在
    Swift 编程中，一旦你告诉计算机一个变量或常量要持有某种数据类型，它就不会允许你放入除该数据类型之外的任何东西。如果你有一个专门用来装土豆的篮子，把水放进去显然是个糟糕的主意——除非你喜欢水漏得到处都是！
- en: '![image](Image00047.jpg)'
  id: totrans-3089
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-3090
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-3091
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，你可以告诉计算机它将持有的数据类型。在我们关于教室窗户的例子中，我们知道这个变量将始终是一个*整数*（即一个整数——你不可能有半个窗户），所以我们可以指定一个整数数据类型，像这样：
- en: '![Image](Image00048.jpg)'
  id: totrans-3092
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-3093
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示“是类型”。通俗来说，这行代码的意思是：“变量 numberOfWindowsOpen，它是一个整数，等于 3。”所以，这行代码创建了一个变量，给它命名，告诉计算机它的数据类型，并为它赋值。哇！一行代码做到了这一切？我们提到过
    Swift 是一门*简洁*的语言吗？有些语言可能需要几行代码才能做到同样的事。Swift 设计得非常精简，让你可以用一行代码做很多事！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-3094
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要声明数据类型一次。当我们告诉计算机一个变量将存储整数时，我们不需要再次声明。事实上，如果我们再声明，Xcode 会给我们报错。一旦数据类型被声明，变量或常量就会永久保持该数据类型。一次整数，永远是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-3095
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要知道一件关于数据类型的事情：变量或常量不能存储与其数据类型不匹配的值。例如，如果你尝试将小数值放入numberOfWindowsOpen中，你会得到一个错误，如[图2-6](text00012.html#ch02fig6)所示。
- en: '![image](Image00049.jpg)'
  id: totrans-3096
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-3097
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-6：你不能将小数值放入一个本应保存整数的变量中。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-3098
  prefs: []
  type: TYPE_NORMAL
  zh: 将numberOfWindowsOpen设置为5或0是有效的并且能够正常工作。但是，你不能将numberOfWindowsOpen设置为1.5。
- en: '**COMMON DATA TYPES**'
  id: totrans-3099
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-3100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚才学到的，数据类型让计算机知道它正在处理什么*类型*的数据，以及如何将其存储在内存中。那么，数据类型有哪些呢？一些常见的数据类型包括Int、Double、Float、Bool和String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-3101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下这些数据类型究竟是什么！
- en: '**Int (Integers)**'
  id: totrans-3102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**整数（Int）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-3103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经稍微讨论过整数了，但让我们更详细地了解一下它们。整数，在Swift中称为Int，是没有小数或分数部分的整数。你可以把它们当作计数数字。整数是*有符号*的，意味着它们可以是负数、正数或零。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-3104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Double和Float（小数）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-3105
  prefs: []
  type: TYPE_NORMAL
  zh: '*小数*是指小数点后有数字的数字，比如3.14。（像3这样的整数如果你希望它成为小数，也会写成3.0。）有两种数据类型可以存储小数：Double和Float（即*浮动点数*）。Double数据类型在Swift中更常见，因为它可以存储更大的数字，因此我们将重点介绍它。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-3106
  prefs: []
  type: TYPE_NORMAL
  zh: 当你赋值给一个Double时，你必须在小数点左边有一个数字，否则会出现错误。例如，假设香蕉每个19美分：
- en: '![Image](Image00050.jpg)'
  id: totrans-3107
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-3108
  prefs: []
  type: TYPE_NORMAL
  zh: ➊的代码会导致错误，因为它的小数点左边没有数字。➋的代码能正常工作，因为它有一个前导零。（短语// ERROR和// CORRECT是*注释*，是程序中的备注，计算机会忽略它们。详情请参阅“[关于注释的一些简要说明](text00012.html#ch02sb01)”第32页[链接](text00012.html#page_32)。）
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-3109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**布尔值（Bool，真/假）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-3110
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值*只能是两种情况之一：真或假。在Swift中，布尔数据类型称为Bool。'
- en: '![Image](Image00051.jpg)'
  id: totrans-3111
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-3112
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值通常用于if-else语句中，告诉计算机程序应选择哪条路径。（我们将在[第3章](text00013.html#ch03)中更详细地讨论布尔值和if-else语句。）
- en: '**String**'
  id: totrans-3113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符串**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-3114
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串数据类型用于存储单词和短语。*字符串*是由引号括起来的一系列字符。例如，"Hello, playground"是一个字符串。字符串可以由各种字符组成：字母、数字、符号等。引号非常重要，因为它们告诉计算机，引号之间的内容是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-3115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串连接起来的方式来构建句子，这个过程叫做字符串*拼接*。让我们来看看它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-3116
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-3117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用加号（+）将字符串连接在一起，这段代码创建了一个名为 `specialGreeting` 的变量，其值是字符串 "Good Morning Jude"。请注意，我们需要在
    `morningGreeting` 和 `friend` 之间添加一个包含空格字符（" "）的字符串，否则 `specialGreeting` 的值将是 "Good
    MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-3118
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-3119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-3120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，当我们声明一个变量时，有时会包括数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-3121
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-3122
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们也不会包括数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-3123
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-3124
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事？其实计算机足够聪明，大多数情况下可以自动推断出数据类型。这叫做*类型推断*——因为计算机会根据我们提供的线索来*推测*我们使用的数据类型。当你创建一个变量并给它一个初始值时，这个值就是给计算机的一个重要线索。以下是一些示例：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-3125
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个没有小数部分的数字（例如 3），计算机会假设它是 `Int` 类型。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-3126
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个带有小数的数字（例如 3.14），计算机会假设它是 `Double` 类型。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-3127
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个没有引号的单词 *true* 或 *false*，计算机会假设它是 `Bool` 类型。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-3128
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个或多个带引号的字符，计算机会假设它是 `String` 类型。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-3129
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量会被设定为该数据类型，就像你自己声明数据类型一样。这纯粹是为了方便。你可以在每次声明一个新常量或变量时都包括数据类型，这完全没问题。但为什么不让计算机自己推断出来，省下你的一些时间和额外的输入呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-3130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用类型转换转换数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-3131
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换* 是一种临时改变变量或常量数据类型的方式。你可以把它想象成对变量施加魔法——让它的值暂时表现得像另一种数据类型，但只是短时间内。为了实现这一点，你写一个新的数据类型，后面跟上括号，括号内是你要转换类型的变量。请注意，这*并不会真正改变数据类型*。它只是给你一个在那一行代码中临时的值。以下是一些
    `Int` 和 `Double` 类型之间转换的示例。看看代码结果侧边栏中的结果吧。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-3132
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![Image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-3133
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊，我们将整数类型的变量 `months` 转换为双精度浮点数类型 `Double` 并存储在一个名为 `doubleMonths` 的新变量中。这会增加一个小数点，转换结果是
    12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-3134
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将一个 `Double` 类型转换为 `Int` 类型：
- en: '![Image](Image00058.jpg)'
  id: totrans-3135
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-3136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Double 类型的变量 days 转换为 Int 类型。你可以看到，小数点和其后的所有数字都被去掉了：我们的数字变成了 365。这是因为
    Int 类型无法存储小数，它只能存储整数，所以小数点后面的部分被截断了。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-3137
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，类型转换并不会真正改变数据类型。在我们的例子中，即使经过类型转换，days *依然*是一个 Double 类型。我们可以通过打印 days 来验证这一点：
- en: '![Image](Image00059.jpg)'
  id: totrans-3138
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-3139
  prefs: []
  type: TYPE_NORMAL
  zh: 结果侧边栏显示，days 仍然等于 365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-3140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍一些使用类型转换的例子。所以如果你现在还不清楚为什么要进行类型转换，请稍等一下！
- en: '**OPERATORS**'
  id: totrans-3141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-3142
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中有许多算术运算符可以用来进行数学运算。你已经见过基本的赋值运算符 = 。你可能也很熟悉加法 (+)、减法 (-)、乘法 (*) 和除法 (/
    )。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-3143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符对 Int、Float 和 Double 数据类型进行数学运算。参与运算的数字被称为 *操作数*。你可以通过在 Playground
    中输入以下代码来实验这些数学运算符：
- en: '![Image](Image00060.jpg)'
  id: totrans-3144
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-3145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Playground 中输入这段代码，你将在侧边栏看到每个数学表达式的结果。在代码中写数学表达式与正常书写的差别不大。例如，16 减去 2 写作
    16 – 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-3146
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数学表达式的结果保存在变量或常量中，以便在代码的其他地方使用。要了解它是如何工作的，可以在 Playground 中输入以下几行：
- en: '![Image](Image00061.jpg)'
  id: totrans-3147
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-3148
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印 sum ➊ 时，你会在侧边栏看到 7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-3149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在数学表达式中只使用了数字，但数学运算符同样适用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-3150
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的 Playground 中：
- en: '![Image](Image00062.jpg)'
  id: totrans-3151
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-3152
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以像对数字进行运算一样，对变量和常量使用数学运算符。
- en: '**SPACES MATTER**'
  id: totrans-3153
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-3154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，运算符两边的空格很重要。你可以在数学运算符的两边都加上空格，或者完全不加空格。但你不能只在运算符的一边加空格，而另一边不加，这样会导致错误。请查看[图
    2-7](text00012.html#ch02fig7)。
- en: '![image](Image00063.jpg)'
  id: totrans-3155
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-3156
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：确保在运算符两边有相同数量的空格。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-3157
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件重要的事情需要注意：你只能对相同数据类型的变量或常量使用数学运算符。在之前的代码中，三和五都是 Int 数据类型。常量 half 和 quarter
    是 Double 数据类型，因为它们是小数。如果你尝试对一个 Int 和一个 Double 进行加法或乘法运算，你会遇到类似于[图 2-8](text00012.html#ch02fig8)中的错误。
- en: '![image](Image00064.jpg)'
  id: totrans-3158
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-3159
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-8：在 Swift 中，你不能对不同数据类型进行数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-3160
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你真的想对混合数据类型做数学运算怎么办？比如，假设你想计算你年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-3161
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-3162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行会报错，因为我们试图将`Int`类型与`Double`类型相乘。但不用担心！你有几个选择，可以确保你的操作数是相同的数据类型。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-3163
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是将`myAge`声明为`Double`类型，如下所示：
- en: '![Image](Image00066.jpg)'
  id: totrans-3164
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-3165
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码能够正常工作，因为我们在乘法运算中使用的是两个`Double`类型的数据。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-3166
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是使用类型转换。（我告诉过你我们会回到这个话题！）类型转换在这种情况下是一个很好的解决方案，因为我们不想永久地将`myAge`改为`Double`类型，我们只想能够像`Double`类型一样进行数学运算。让我们看一个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-3167
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-3168
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将`myAge`转换为`Double`类型后再进行乘法运算。这意味着我们不再有混合类型，所以代码能够正常工作。但在➋处，我们会得到一个错误。因为`myAge`仍然是`Int`类型。在➊处将它转换为`Double`并不会永久地将它更改为`Double`类型。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-3169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能将`multiplier`转换为`Int`类型吗？当然可以！这样我们就能对两个整数进行运算，这没问题。然而，这会导致计算的精度降低，因为我们会丢失小数部分。当你将一个`Double`类型的变量转换为`Int`类型时，计算机会简单地去掉小数点后的数字，保留整数部分。在这种情况下，`0.1`会被转换为`Int`类型的`0`。我们可以在playground中转换一些变量，看看结果：
- en: '![Image](Image00068.jpg)'
  id: totrans-3170
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-3171
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，将`Double`类型的`multiplier`转换为`Int`类型会得到`0`。转换后的值发生了很大变化，因为我们失去了小数部分：`0.1`变成了`0`。如果我们没有预料到这一点，这在我们的代码中可能会是一个非常糟糕的事情。你在进行类型转换时必须小心，确保不会意外地改变你的值。在➋处，另一个将`Double`转换为`Int`的例子，如你所见，`1.9`并没有四舍五入到`2`，它的小数部分只是被去掉了，我们留下了`1`。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-3172
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个数学运算符，*取模运算符*（%），你可能不太熟悉。取模运算符（也叫做*模*运算）会给出除法后的余数。例如，`7 % 2 = 1`，因为7除以2的余数是1。尝试在playground中使用取模运算符，如下所示。
- en: '![Image](Image00069.jpg)'
  id: totrans-3173
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-3174
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，取模运算符对判断一个数字是偶数（`evenNumber % 2`等于0）➊还是奇数（`oddNumber % 2`等于1）➋非常有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-3175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算顺序**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-3176
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们每行代码只做了一次数学运算，但通常在一行中会做多个运算。我们来看一个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-3177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元钞票和两张一美元钞票，你有多少钱？让我们在一行中计算这个：
- en: '![Image](Image00070.jpg)'
  id: totrans-3178
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-3179
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把值 17 赋给 myMoney。计算机会先计算 5 乘 3，再加 2。但是，计算机是如何知道先乘法再加法的呢？它只是从左到右吗？不是！看看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-3180
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-3181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们改变了数字的顺序，但结果仍然是 17。如果计算机仅仅是从左到右执行，它会先计算 2 + 5 得到 7，然后把这个结果 7 乘以 3 得到 21。尽管我们改变了数学表达式中的数字顺序，计算机依然先做乘法（得到
    15），然后加上 2 得到 17。*计算机会总是先进行乘法和除法，再进行加法和减法。* 这就是所谓的*运算优先级*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-3182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号排列操作**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-3183
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必像在金钱示例中那样依赖计算机来判断先做哪一步。作为程序员，你有决定的权力！你可以使用括号来将操作分组。当你在某个操作周围加上括号时，你告诉计算机首先执行这一步：
- en: '![Image](Image00072.jpg)'
  id: totrans-3184
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-3185
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，括号告诉计算机先计算 5 乘 3，再加 2。这样结果是 17。在➋处，括号告诉计算机先加 2 加 5，再将结果乘以 3，结果是 21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-3186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在括号内使用其他括号来使代码更加具体。计算机会先计算内层括号，再计算外层括号。试试这个例子：
- en: '![Image](Image00073.jpg)'
  id: totrans-3187
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-3188
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机首先在内层括号中加上 2 和 3，然后将结果乘以 4，因为它在外层括号内。最后它会加上 1，因为它位于两个括号之外。最终结果是 21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-3189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值运算符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-3190
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的另一类运算符是*复合赋值运算符*。这些是将数学运算符与赋值运算符（=）结合的“快捷方式”运算符。例如，这个表达式
- en: '[PRE90]'
  id: totrans-3191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: becomes
  id: totrans-3192
  prefs: []
  type: TYPE_NORMAL
  zh: 变成
- en: '[PRE91]'
  id: totrans-3193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-3194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符通过对变量或常量执行运算来更新其值。简单来说，像 a += b 这样的表达式意味着“将 b 加到 a 上，并将新值存储在 a 中。”[表
    2-1](text00012.html#ch2tab1)展示了使用复合赋值运算符的数学表达式以及它们的长写形式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-3195
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-1：** 简写赋值运算符与长写表达式对比'
- en: '| **Short form** | **Long form** |'
  id: totrans-3196
  prefs: []
  type: TYPE_TB
  zh: '| **简写形式** | **长写形式** |'
- en: '| --- | --- |'
  id: totrans-3197
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-3198
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-3199
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-3200
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-3201
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-3202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看+=操作符的应用。假设我们正在编写一个程序来计算方舟上动物的数量。首先，我们创建一个名为animalsOnArk的变量并将其设置为0，因为方舟上还没有动物。当不同种类的动物登上方舟时，我们希望增加animalsOnArk，以便计算所有动物。如果两只长颈鹿登上方舟，我们需要将animalsOnArk增加2。如果两只大象登上方舟，我们需要再次增加2。如果四只羚羊登上方舟，我们需要将animalsOnArk增加4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-3203
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00074.jpg)![Image](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-3204
  prefs: []
  type: TYPE_NORMAL
  zh: 在两只长颈鹿、两只大象和四只羚羊登上方舟后，animalsOnArk的最终值是8。真是个动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-3205
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的一些快速提示**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-3206
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都提供了一种将注释放在代码中的方式。注释是计算机忽略的说明，目的是帮助阅读代码的人理解代码的作用。尽管程序在没有注释的情况下也能正常运行，但在代码中可能不太清楚或令人困惑的部分加上注释是一个好主意。即使你不打算将程序展示给别人，注释也会帮助你记住写这段代码时的想法或目的。将来你回看几个月或几年前写的代码时，很可能会忘记当时的思路。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-3207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中有两种添加注释的方法。第一种方法是在你想要添加注释的文本前面加上两个正斜杠（//）。这些注释可以单独放在一行，例如这样：
- en: '[PRE92]'
  id: totrans-3208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-3209
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它们也可以和代码行放在同一行，只要注释在代码*之后*：
- en: '[PRE93]'
  id: totrans-3210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-3211
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式用于长注释或*多行*注释，注释的开始和结束由/*和*/标记。（请注意，在本书中，我们将使用-- *snip* --来表示为了节省空间而省略的更多代码行。）
- en: '[PRE94]'
  id: totrans-3212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-3213
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不想让计算机运行代码的某一部分，因为你正在尝试找出一个 bug，但又不想删除所有辛苦编写的代码，你可以使用多行注释来*临时注释掉*代码块。当你将一段代码格式化为注释时，计算机会忽略那部分代码，就像它忽略任何其他注释一样。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-3215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何在 Swift playground 中编写代码，它允许你立即看到结果。你创建了变量和常量，学习了如何使用基本的数据类型和运算符，这些你在编写自己的计算机程序时会反复遇到。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-3216
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](text00013.html#ch03)，你将使用条件语句，它告诉计算机你希望它执行的代码路径。代码路径的选择是基于条件的值。
- en: Second, this line of code gives a value of "Hello, playground" to str using
    the = operator. This is called an *assignment* because we are assigning a value
    to our newly created variable. Remember, you can think of a variable as a container
    that holds something. So now we have a container named str that holds "Hello,
    playground" .
  id: totrans-3217
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，这行代码使用=运算符将“Hello, playground”赋值给str。这被称为*赋值*，因为我们正在为新创建的变量赋值。记住，你可以把变量想象成一个容器，用来存放某些东西。所以现在我们有一个名为str的容器，里面存放的是“Hello,
    playground”。
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  id: totrans-3218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把这行代码理解为“变量str等于Hello, playground”。正如你所见，Swift通常是非常可读的；这行代码几乎用英语告诉你它在做什么。
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  id: totrans-3219
  prefs: []
  type: TYPE_NORMAL
  zh: 变量非常方便，因为如果你想打印“Hello, playground”这句话，你只需要在str上使用print命令，如以下代码所示：
- en: '![Image](Image00038.jpg)'
  id: totrans-3220
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00038.jpg)'
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  id: totrans-3221
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在结果侧边栏中打印“Hello, playground\n”。\n会自动添加到你打印的内容的末尾。它被称为*换行*符，告诉计算机换到新的一行。
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  id: totrans-3222
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看程序的实际运行结果，请打开调试区域，该区域会出现在两个面板下方，如[图 2-4](text00012.html#ch02fig4)所示。为此，请在Xcode菜单中选择**视图**
    ▸ **调试区域** ▸ **显示调试区域**，或按⌘-SHIFT-Y。当str在调试区域的控制台中打印时，你会看到Hello, playground周围的引号和换行符不会显示。这就是如果你正式运行这个程序时str的真实表现！
- en: '![image](Image00039.jpg)'
  id: totrans-3223
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-3224
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：在调试区域查看程序的真实输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-3225
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在你的程序中可以变化（或者*变化*！），所以你可以改变变量的值来保存其他内容。现在让我们试试看。将以下代码行添加到你的Playground中。
- en: '![Image](Image00040.jpg)'
  id: totrans-3226
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-3227
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改变量的值，输入其名称并使用=运算符将其设置为新值。我们在➊处执行此操作，将str的值更改为“Hello, world”。计算机会丢弃str原来的值，并说：“好的，老板，str现在是Hello,
    world”（当然，它要是能说话的话，会这么说！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-3228
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们更改str的值时，我们没有再次写var。计算机会记住我们在之前的代码行中声明了str，并知道str已经存在。所以我们不需要重新创建str，只需要给它赋予不同的值。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-3229
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以声明*常量*。像变量一样，常量也保存值。常量和变量之间的最大区别在于，常量的值永远不能改变。而变量可以变化，常量则是，嗯，常量！声明常量与声明变量类似，但我们使用let而不是var：
- en: '![Image](Image00041.jpg)'
  id: totrans-3230
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-3231
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们创建了一个名为myName的常量，并赋予它“Gloria”的值。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-3232
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个常量并赋值，它将永远保持这个值。你可以把常量想象成一块大石头，你把值刻在上面。如果你尝试给 myName 赋一个新值，比如 "Matt"，你将看到像
    [图 2-5](text00012.html#ch02fig5) 中所示的错误。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-3233
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00042.jpg)![image](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-3234
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：尝试改变常量的值会失败。*'
- en: '**NOTE**'
  id: totrans-3235
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-3236
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 playground 中，错误会显示为一个红色圆圈，里面有一个小白圆圈。点击错误标志会显示错误信息，并告诉你哪里出了问题。如果你开启了调试区域，你还应该能够看到描述发生了什么的相关信息，有时甚至会告诉你如何修复它。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-3237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-3238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量—做得好！但是，什么时候应该使用常量，什么时候使用变量呢？在 Swift 中，除非你预期值会发生变化，否则最好使用常量而不是变量。常量有助于使代码更“安全”。如果你知道某个值永远不会变化，为什么不把它“刻”在石头上，避免以后可能的混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-3239
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想追踪教室中窗户的总数以及今天打开的窗户数量。教室中的窗户数量不会变化，因此你应该使用常量来存储这个值。然而，今天打开的窗户数量会根据天气和时间的不同而变化，所以你应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-3240
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00044.jpg)![Image](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-3241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 numberOfWindows 设为常量，并赋值为 8，因为窗户的总数始终为 8。我们将 numberOfWindowsOpen 设为变量，并赋值为
    3，因为我们希望在打开或关闭窗户时修改这个值。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-3242
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：用 var 来定义变量，使用 let 来定义常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-3243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**命名常量和变量**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-3244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以给变量或常量起几乎任何你想要的名字，当然有一些例外。你不能将它们命名为 Swift 中已经存在的保留字。例如，你不能将变量命名为 var。写成 var
    var 会让你和计算机都感到困惑。如果你尝试使用 Swift 的保留字命名变量或常量，系统会报错。你也不能在同一个代码块中定义两个同名的变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-3245
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则之外，在 Swift 中为事物命名时，还需要遵循一些其他好的编程指南。你的变量名应始终以小写字母开头。使用*非常*描述性的名字也是个好主意（它们可以尽量长）。当你使用描述性名字时，理解这个变量或常量的意义就容易多了。如果你在看别人写的代码，你更容易理解哪个变量名：numKids
    还是 numberOfKidsInMyClass？第一个不清晰，而第二个描述性强。你常常会看到一些变量和常量，像 numberOfKidsInMyClass
    这样的多个词连接在一起。这种将多个单词组合成变量名时，每个单词的首字母大写的命名方式叫做*驼峰命名法*。因为这种大小写字母的模式看起来就像骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-3246
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-3247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-3248
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你可以选择一个变量或常量要存储的数据类型。还记得我们之前说过，变量就像一个容器，用来装东西吗？好吧，数据类型就像容器的类型。计算机需要知道我们将把什么样的东西放入每个容器中。在
    Swift 编程中，一旦你告诉计算机某个变量或常量将持有特定的数据类型，它就不允许你放入其他类型的数据。如果你有一个用来装土豆的篮子，把水装进去可就不太好——除非你喜欢水洒得到处都是！
- en: '![image](Image00047.jpg)'
  id: totrans-3249
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-3250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-3251
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，你可以告诉计算机它将存储的数据类型。在我们关于教室窗户的例子中，我们知道这个变量将始终是一个*整数*（也就是说，一个整数——你不可能有半个窗户），所以我们可以指定一个整数数据类型，像这样：
- en: '![Image](Image00048.jpg)'
  id: totrans-3252
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-3253
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示“是某种类型”。通俗来说，这行代码表示“变量 numberOfWindowsOpen，类型是整数，值等于 3。”所以这一行代码创建了一个变量，给它命名，告诉计算机它的数据类型，并为其赋值。呼！一行代码就做到了这一切？我们是不是提到过
    Swift 是一门非常*简洁*的语言？一些其他语言可能需要几行代码才能完成同样的操作。Swift 的设计就是让你可以通过一行代码做很多事情！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-3254
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要声明一次数据类型。当我们告诉计算机某个变量将存储整数时，我们不需要再次声明。事实上，如果我们重复声明，Xcode 会报错。一旦数据类型被声明，变量或常量将永远持有该类型的数据。一次整数，永远是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-3255
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件关于数据类型的事情需要了解：一个变量或常量不能存储不属于其数据类型的内容。例如，如果你尝试将十进制数放入numberOfWindowsOpen，你将得到一个错误，如[图2-6](text00012.html#ch02fig6)所示。
- en: '![image](Image00049.jpg)'
  id: totrans-3256
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-3257
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-6：你不能将十进制数放入本应保存整数的变量中。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-3258
  prefs: []
  type: TYPE_NORMAL
  zh: 将numberOfWindowsOpen = 5和numberOfWindowsOpen = 0是有效且可行的。但你不能将numberOfWindowsOpen
    = 1.5。
- en: '**COMMON DATA TYPES**'
  id: totrans-3259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-3260
  prefs: []
  type: TYPE_NORMAL
  zh: 如你刚刚所学，数据类型让计算机知道它正在处理什么*类型*的数据，并且如何将其存储在内存中。那么，数据类型有哪些呢？一些常见的包括Int、Double、Float、Bool和String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-3261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解每一种数据类型到底是什么！
- en: '**Int (Integers)**'
  id: totrans-3262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Int（整数）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-3263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经稍微讨论过整数，但让我们更详细地了解它们。整数，在Swift中称为Int，是没有小数部分或分数部分的整数。你可以把它们看作是计数数字。整数是*有符号的*，意味着它们可以是负数、正数或零。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-3264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Double和Float（十进制数）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-3265
  prefs: []
  type: TYPE_NORMAL
  zh: '*十进制数*是指小数点后有数字的数值，例如3.14（如果你想让整数3成为十进制数，则应写成3.0）。有两种数据类型可以存储十进制数：Double和Float（即*浮点数*）。Double数据类型在Swift中更为常见，因为它可以存储更大的数字，因此我们将重点讲解Double。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-3266
  prefs: []
  type: TYPE_NORMAL
  zh: 当你分配一个Double时，必须始终在小数点左侧有一个数字，否则会报错。例如，假设香蕉的价格是19美分一个：
- en: '![Image](Image00050.jpg)'
  id: totrans-3267
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-3268
  prefs: []
  type: TYPE_NORMAL
  zh: ➊处的代码会导致错误，因为它的十进制点左侧没有数字。➋处的代码正常工作，因为它有一个前导零。（短语// ERROR和// CORRECT是*注释*，是程序中的备注，计算机会忽略它们。请参见“[关于注释的一些快速说明](text00012.html#ch02sb01)”，[第32页](text00012.html#page_32)。）
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-3269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Bool（布尔值，或真/假）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-3270
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值*只能是两个值之一：true或false。在Swift中，布尔数据类型称为Bool。'
- en: '![Image](Image00051.jpg)'
  id: totrans-3271
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-3272
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值常用于if-else语句中，告诉计算机程序应执行的路径。（我们将在[第3章](text00013.html#ch03)中更详细地讲解布尔值和if-else语句。）
- en: '**String**'
  id: totrans-3273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**String**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-3274
  prefs: []
  type: TYPE_NORMAL
  zh: String数据类型用于存储单词和短语。*字符串*是由字符组成的集合，字符之间用引号括起来。例如，“Hello, playground”是一个字符串。字符串可以由各种字符组成：字母、数字、符号等等。引号很重要，因为它告诉计算机，所有引号之间的内容都是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-3275
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串连接在一起来构建句子，这个过程叫做字符串 *连接*。让我们看看它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-3276
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-3277
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用加号（+）将字符串连接在一起，这段代码创建了一个名为 specialGreeting 的变量，其值为字符串 "Good Morning Jude"。注意，这里我们需要在
    morningGreeting 和 friend 之间添加一个包含空格字符（" "）的字符串，否则 specialGreeting 的值会是 "Good MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-3278
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-3279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-3280
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，有时当我们声明一个变量时，我们会包括数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-3281
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-3282
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们不包括数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-3283
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-3284
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事？计算机实际上足够聪明，通常能够推断出数据类型。这被称为 *类型推断* ——因为计算机会 *推断*，或者根据我们提供的线索猜测我们使用的数据类型。当你创建一个变量并给它一个初始值时，这个值对计算机来说是一个重要的线索。下面是一些例子：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-3285
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值为没有小数的数字（如 3），计算机会假设它是一个 Int 类型。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-3286
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值为一个带小数的数字（如 3.14），计算机会假设它是一个 Double 类型。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-3287
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值为 *true* 或 *false*（不带引号），计算机会假设它是一个 Bool 类型。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-3288
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值为一个或多个带引号的字符，计算机会假设它是一个 String 类型。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-3289
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量被设置为该数据类型，就像你自己声明了数据类型一样。这纯粹是为了方便。你可以在每次声明新常量或变量时都包括数据类型，这也是完全可以的。但为什么不让计算机自动推断，从而节省时间和输入呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-3290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**通过转换改变数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-3291
  prefs: []
  type: TYPE_NORMAL
  zh: '*转换* 是一种暂时改变变量或常量数据类型的方法。你可以把它想象成对变量施了个魔法——让它的值像其他数据类型那样表现，但仅仅是短暂的。要做到这一点，你写下新的数据类型，后面跟着括号，括号中放置你正在转换的变量。请注意，这
    *并不会真正改变数据类型*。它只是为那一行代码提供一个临时值。下面是一些在 Int 和 Double 之间转换的示例。看看你代码的结果显示栏。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-3292
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![Image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-3293
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Int 类型的变量 months 转换为 Double 类型，并将其存储在一个名为 doubleMonths 的新变量中。这添加了一个小数点，转换的结果是
    12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-3294
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将一个 Double 转换为 Int：
- en: '![Image](Image00058.jpg)'
  id: totrans-3295
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-3296
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Double 类型的 days 转换为 Int 类型。你可以看到小数点和后面的所有数字被去掉了：我们的数字变成了 365。这是因为
    Int 类型不能保存小数，它只能包含整数，所以小数点后面的部分会被截断。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-3297
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，类型转换并不会真正改变数据类型。在我们的例子中，即使进行了类型转换，days*仍然*是 Double 类型。我们可以通过打印 days 来验证这一点：
- en: '![Image](Image00059.jpg)'
  id: totrans-3298
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-3299
  prefs: []
  type: TYPE_NORMAL
  zh: 结果侧边栏显示，days 仍然等于 365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-3300
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将展示一些使用类型转换的示例。所以，如果现在还不清楚为什么需要进行类型转换，稍等一下！
- en: '**OPERATORS**'
  id: totrans-3301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-3302
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，有许多算术运算符可供使用。你已经见过基本的赋值运算符 = 。你可能也熟悉加法（+）、减法（-）、乘法（*）和除法（/）。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-3303
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符对 Int、Float 和 Double 数据类型进行数学运算。进行运算的数字被称为*操作数*。在 Playground 中尝试使用这些数学运算符，输入以下代码：
- en: '![Image](Image00060.jpg)'
  id: totrans-3304
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-3305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Playground 中输入这段代码，你会在侧边栏看到每个数学表达式的结果。编写数学表达式与正常书写并没有太大区别。例如，16 减 2 可以写作
    16 – 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-3306
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数学表达式的结果保存到变量或常量中，以便在代码的其他地方使用。要了解这一点，输入以下代码：
- en: '![Image](Image00061.jpg)'
  id: totrans-3307
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-3308
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印 sum ➊ 时，你会在侧边栏看到 7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-3309
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在数学表达式中只使用了数字，但数学运算符也可以用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-3310
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的 Playground 中：
- en: '![Image](Image00062.jpg)'
  id: totrans-3311
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-3312
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以像对待数字一样，在变量和常量上使用数学运算符。
- en: '**SPACES MATTER**'
  id: totrans-3313
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-3314
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，运算符两侧的空格非常重要。你可以在数学运算符的两侧写上空格，或者完全不写空格。但是，你不能只在运算符的一侧加空格，另一侧不加。这会导致错误。请看[图
    2-7](text00012.html#ch02fig7)。
- en: '![image](Image00063.jpg)'
  id: totrans-3315
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-3316
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：确保运算符两侧的空格数量相同。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-3317
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点需要注意：你只能对*相同*数据类型的变量或常量使用数学运算符。在之前的代码中，三和五都是 Int 数据类型。常量 half 和 quarter 是
    Double 数据类型，因为它们是小数。如果你尝试对 Int 和 Double 进行加法或乘法操作，你会得到像[图 2-8](text00012.html#ch02fig8)那样的错误。
- en: '![image](Image00064.jpg)'
  id: totrans-3318
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-3319
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-8：在 Swift 中，不能对混合数据类型进行数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-3320
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你真的想对混合数据类型进行数学运算怎么办？例如，假设你想计算你年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-3321
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-3322
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行会导致错误，因为我们试图将一个 Int 类型与一个 Double 类型相乘。但别担心！你有几种选择可以确保你的操作数是相同的数据类型。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-3323
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是将 myAge 声明为 Double 类型，像这样：
- en: '![Image](Image00066.jpg)'
  id: totrans-3324
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-3325
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码能正常工作，因为我们正在对两个 Double 数据类型进行乘法运算。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-3326
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是使用类型转换。（我告诉过你我们会回到这个问题的！）类型转换在这种情况下是一个很好的解决方案，因为我们不想将 myAge 永久转换为 Double
    类型，我们只是想像 Double 类型一样对它进行数学运算。让我们看一个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-3327
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-3328
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 myAge 转换为 Double 后再进行乘法运算。这意味着我们不再有混合类型，因此代码可以正常运行。但是在 ➋ 处，我们会遇到一个错误。这是因为
    myAge 仍然是 Int 类型。在 ➊ 处将其转换为 Double 并没有永久性地将其更改为 Double 类型。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-3329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将乘数转换为整数（Int）吗？当然可以！这样我们就能对两个整数进行数学运算，这样是可以正常工作的。然而，这会导致计算精度下降，因为我们会丢失小数部分。当你将一个变量从
    Double 转换为 Int 时，计算机会简单地去除小数点后的任何数字，使其变成一个整数。在这种情况下，0.1 的乘数会被转换为 0 的整数。让我们在 playground
    中转换一些变量，看看会得到什么结果：
- en: '![Image](Image00068.jpg)'
  id: totrans-3330
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-3331
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，将我们的 Double 类型的乘数转换为 Int 给我们得到了 0。这个值在转换后变化很大，因为我们丢失了小数部分：0.1 变成了 0。如果我们没有预料到这种情况，这可能会在代码中引发很严重的问题。你必须小心转换，确保不会意外地改变值。在
    ➋ 处，这是另一个将 Double 转换为 Int 的例子，正如你所看到的，1.9 并没有四舍五入为 2。它的小数部分只是被去掉了，我们剩下的是 1。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-3332
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个数学运算符，*取模运算符*（%），你可能不太熟悉。取模运算符（也叫 *模*）返回除法后的余数。例如，7 % 2 = 1，因为7除以2的余数是1。请在
    playground 中试试取模运算符，示例如下：
- en: '![Image](Image00069.jpg)'
  id: totrans-3333
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-3334
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，取模运算符对于判断一个数字是否为偶数（evenNumber % 2 等于 0） ➊ 或奇数（oddNumber % 2 等于 1） ➋ 非常有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-3335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算顺序**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-3336
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在每一行代码中进行了一次数学运算，但通常在一行代码中会进行多个运算。我们来看一个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-3337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元钞票和两张一美元钞票，你有多少钱？让我们在一行代码中计算一下：
- en: '![Image](Image00070.jpg)'
  id: totrans-3338
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-3339
  prefs: []
  type: TYPE_NORMAL
  zh: 这将17的值赋给myMoney。计算机先计算5乘以3，然后再加2。但是计算机怎么知道先乘法*然后*加2呢？它只是从左到右计算吗？不是！看一下这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-3340
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-3341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们把数字顺序调整了一下，结果仍然是17。如果计算机只是从左到右进行计算，它会先加2 + 5得到7。然后，它会将这个结果7乘以3，得到21。尽管我们改变了数学表达式中数字的顺序，计算机仍然是先进行乘法（得出15），然后加上2得到17。*计算机总是先做乘法和除法，再做加法和减法。*
    这就是所谓的*运算顺序*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-3342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号排序运算**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-3343
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要像我们在金钱例子中那样依赖计算机来决定先做哪一步。你，作为程序员，拥有决定的权力！你可以使用括号将操作组合在一起。当你把括号放在某个操作周围时，你告诉计算机先做那一步：
- en: '![Image](Image00072.jpg)'
  id: totrans-3344
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-3345
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，括号告诉计算机先计算5乘以3，再加2。这样得到的结果是17。在➋处，括号告诉计算机先加2和5，再将结果乘以3，这样得到的是21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-3346
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在其他括号内使用括号来让代码更加具体。计算机会先计算内层括号，再计算外层括号。试试这个例子：
- en: '![Image](Image00073.jpg)'
  id: totrans-3347
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-3348
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机首先会在内层括号中计算2和3的和。然后，它会将结果乘以4，因为它在外层括号内。最后，它会加上1，因为1在两个括号外面。最终结果是21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-3349
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值运算符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-3350
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会使用的另一类运算符是*复合赋值运算符*。这些是将数学运算符与赋值运算符（=）结合的“快捷”运算符。例如，下面这个表达式
- en: '[PRE95]'
  id: totrans-3351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: becomes
  id: totrans-3352
  prefs: []
  type: TYPE_NORMAL
  zh: 变成
- en: '[PRE96]'
  id: totrans-3353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-3354
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符来更新变量或常量的值，通过对其进行运算。用简单的英语来说，像a += b这样的表达式表示“将b加到a上，并将新值存储在a中。” [表2-1](text00012.html#ch2tab1)展示了使用复合赋值运算符的数学表达式以及其长格式表达式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-3355
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-1：** 短格式赋值运算符与长格式表达式'
- en: '| **Short form** | **Long form** |'
  id: totrans-3356
  prefs: []
  type: TYPE_TB
  zh: '| **短格式** | **长格式** |'
- en: '| --- | --- |'
  id: totrans-3357
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-3358
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-3359
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-3360
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-3361
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-3362
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 += 运算符的实际应用。假设我们正在编写一个程序来计算方舟上的动物数量。首先，我们创建一个名为 animalsOnArk 的变量并将其设置为
    0，因为方舟上还没有动物。当不同种类的动物登上方舟时，我们想要增加 animalsOnArk 来统计所有动物。如果两只长颈鹿登上了方舟，那么我们需要在 animalsOnArk
    上加 2。如果两只大象登上了方舟，那么我们还需要再加 2。如果四只羚羊登上了方舟，那么我们需要将 animalsOnArk 增加 4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-3363
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00074.jpg)![Image](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-3364
  prefs: []
  type: TYPE_NORMAL
  zh: 在两只长颈鹿、两只大象和四只羚羊登上方舟之后，animalsOnArk 的最终值是 8。真是一个动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-3365
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的一些快速评论**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-3366
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都提供了在代码中插入内联注释的方法。注释是被计算机忽略的备注，它们的目的是帮助阅读代码的人理解正在发生的事情。虽然没有注释程序也能正常运行，但对于那些可能不清楚或令人困惑的代码部分，添加注释是一个好主意。即使你不打算把程序展示给其他人，注释也会帮助你记住在编写代码时的思路或想法。你可能会遇到这样的问题：几个月或几年后再回来看自己写的代码，完全不知道当时在想什么。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-3367
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中有两种方法添加注释。第一种方法是在你想要添加的文本前面加上两个正斜杠（//）。这些注释可以单独占一行，就像这样：
- en: '[PRE97]'
  id: totrans-3368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-3369
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它们可以与代码行放在同一行——只要注释*位于*代码之后：
- en: '[PRE98]'
  id: totrans-3370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-3371
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法用于长注释或*多行*注释，其开始和结束分别由 /* 和 */ 标记。（请注意，在本书中我们将使用 -- *snip* -- 来表示由于篇幅问题省略的更多代码行。）
- en: '[PRE99]'
  id: totrans-3372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-3373
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不希望计算机执行某部分代码，因为你正在尝试找出 bug，但又不想删除你辛苦写的代码，你可以使用多行注释来临时*注释掉*代码部分。当你把一段代码格式化为注释时，计算机会像忽略其他注释一样忽略这些代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-3375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在 Swift playground 中编写代码，这样你可以立即看到结果。你创建了变量和常量，并学习了如何使用基本的数据类型和运算符，这些你在编写自己的计算机程序时将一再使用。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-3376
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](text00013.html#ch03)，你将使用条件语句，条件语句告诉计算机你希望它执行哪条代码路径。代码路径是根据条件的值来选择的。
- en: You can read this line of code as “the variable str equals Hello, playground
    .” As you can see, Swift is often very readable; this line of code practically
    tells you in English what it’s doing.
  id: totrans-3377
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这一行代码理解为“变量str等于Hello, playground”。如你所见，Swift通常非常易读；这一行代码几乎直接用英语告诉你它在做什么。
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  id: totrans-3378
  prefs: []
  type: TYPE_NORMAL
  zh: 变量很方便，因为如果你想打印出“Hello, playground”，你只需要在str上使用print命令，如以下代码所示：
- en: '![Image](Image00038.jpg)'
  id: totrans-3379
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00038.jpg)'
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  id: totrans-3380
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在结果侧边栏中打印出"Hello, playground\n"。\n 会自动添加到你打印内容的末尾。它被称为*换行符*，告诉计算机跳到下一行。
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  id: totrans-3381
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看程序的实际运行结果，打开调试区域，它会出现在两个面板下方，如[图2-4](text00012.html#ch02fig4)所示。为此，请在Xcode菜单中选择**视图**
    ▸ **调试区域** ▸ **显示调试区域**，或者按⌘-SHIFT-Y。当str在调试区域的控制台中打印时，你会看到"Hello, playground"的引号和换行符不会出现。这就是如果你正式运行这个程序时str的真实样子！
- en: '![image](Image00039.jpg)'
  id: totrans-3382
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-3383
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-4：在调试区域查看程序的实际输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-3384
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以在你的程序中改变（或*变化*！），所以你可以改变一个变量的值来存储不同的内容。现在我们来试试。将以下几行代码添加到你的playground中。
- en: '![Image](Image00040.jpg)'
  id: totrans-3385
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-3386
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变变量的值，输入它的名称并使用=运算符将其设置为一个新值。我们在➊处这样做，将str的值改为"Hello, world"。计算机会丢掉str原来的内容，并说：“好的，老板，str现在是Hello,
    world”（当然，如果它能说话的话，它会这么说！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-3387
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们改变str的值时，我们不再写var。计算机记得我们之前在代码的某一行声明了str，并知道str已经存在。所以我们不需要重新创建str，我们只需要给它赋一个不同的值。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-3388
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以声明*常量*。像变量一样，常量也存储值。常量与变量之间的主要区别在于，常量的值永远不能更改，而变量的值是可以变化的，常量就是，嗯，常量！声明常量的方法与声明变量类似，但我们使用关键字let而不是var：
- en: '![Image](Image00041.jpg)'
  id: totrans-3389
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-3390
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为myName的常量，并将其赋值为"Gloria"。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-3391
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个常量并赋予它一个值，它就会保持这个值直到永远。可以把常量想象成一块大石头，上面刻着你的值。如果你尝试给myName赋予另一个值，比如"Matt"，你会遇到像[图2-5](text00012.html#ch02fig5)中那样的错误。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-3392
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00042.jpg)![image](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-3393
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-5：试图改变常量的值是行不通的。*'
- en: '**NOTE**'
  id: totrans-3394
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-3395
  prefs: []
  type: TYPE_NORMAL
  zh: '*在Playground中，错误会显示为一个红色圆圈，里面有一个小白圈。点击错误标记会显示错误信息，并告诉你问题所在。如果你有显示调试区域，你还应该能看到描述发生了什么以及有时如何修复的相关信息。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-3396
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-3397
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量——做得好！但什么时候应该使用一个而不是另一个呢？在Swift中，除非你预计值会发生变化，否则最好使用常量而不是变量。常量有助于使代码“更安全”。如果你知道某个值永远不会改变，为什么不把它固定下来，避免以后可能的混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-3398
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想跟踪教室中窗户的总数和今天打开的窗户数量。教室中的窗户数量不会改变，因此你应该使用常量来存储该值。教室中打开的窗户数量会根据天气和一天中的时间而变化，因此你应该使用变量来存储该值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-3399
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00044.jpg)![Image](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-3400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`numberOfWindows`设为常量并将其设置为8，因为窗户的总数始终为8。我们将`numberOfWindowsOpen`设为变量并将其设置为3，因为在打开或关闭窗户时，我们需要更改该值。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-3401
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用`var`来声明变量，使用`let`来声明常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-3402
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**命名常量和变量**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-3403
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将变量或常量命名为几乎任何你想要的名字，但有一些例外。你不能将它们命名为Swift中已经是关键字的词。例如，你不能命名一个变量为`var`。写`var
    var`会让你和计算机都感到困惑。如果你试图使用Swift的保留字之一命名变量或常量，系统会报错。你也不能在同一代码块中有两个相同名称的变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-3404
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则外，还有一些好的编程准则在Swift中命名时需要遵循。你的名字应该总是以小写字母开头。使用*非常*具描述性的名字也是一个好主意（它们可以尽量长）。当你使用描述性名字时，更容易理解这个变量或常量的作用。如果你在看别人写的代码，你会发现哪个变量名更容易理解：`numKids`还是`numberOfKidsInMyClass`？前者含糊不清，而后者则很有描述性。常见的做法是将多个单词连接在一起作为变量或常量名，例如`numberOfKidsInMyClass`。这种命名方式中每个单词的首字母大写，多个单词组合在一起构成一个变量名，这种方式叫做*驼峰命名法*。这是因为小写和大写字母的模式看起来像骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-3405
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-3406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-3407
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你可以选择变量或常量保存什么样的数据——即*数据类型*。还记得我们说过，你可以把变量当作一个容器吗？好吧，数据类型就像容器类型。计算机需要知道我们会在每个容器中放入什么。
    在 Swift 编程中，一旦你告诉计算机你希望变量或常量保存某种数据类型，它就不会允许你在该变量或常量中放入除该数据类型以外的任何内容。如果你有一个专门用来装土豆的篮子，那么把篮子装满水就不是个好主意——除非你喜欢水漏得到处都是！
- en: '![image](Image00047.jpg)'
  id: totrans-3408
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-3409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-3410
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，你可以告诉计算机它将保存哪种类型的数据。在我们关于教室窗户的例子中，我们知道这个变量将始终是一个*整数*（即一个完整的数字——你不可能有半个窗户），所以我们可以指定一个整数数据类型，像这样：
- en: '![Image](Image00048.jpg)'
  id: totrans-3411
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-3412
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示“是...类型”。通俗来说，这行代码的意思是：“变量 `numberOfWindowsOpen`，它是一个整数，等于 3。”所以这行代码创建了一个变量，给它命名，告诉计算机它的数据类型，并赋予它一个值。呼！一行代码做了这一切？我们有没有提到
    Swift 是一门非常*简洁*的语言？某些语言可能需要几行代码来完成相同的事情，而 Swift 设计得让你只用一行代码就能做很多事情！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-3413
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要声明一次数据类型。当我们告诉计算机一个变量将保存整数时，我们不需要再次声明。事实上，如果我们再次声明，Xcode 会给我们一个错误。数据类型一旦声明，变量或常量将永久保持该类型的数据。一旦是整数，永远是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-3414
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数据类型，还有一点你需要知道：一个变量或常量不能保存与其数据类型不匹配的内容。例如，如果你尝试将一个小数放入 `numberOfWindowsOpen`
    中，你会遇到错误，如[图 2-6](text00012.html#ch02fig6)所示。
- en: '![image](Image00049.jpg)'
  id: totrans-3415
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-3416
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：你不能把小数放入一个应该保存整数的变量中。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-3417
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `numberOfWindowsOpen = 5` 和 `numberOfWindowsOpen = 0` 是有效的并且能正常工作。但你不能设置
    `numberOfWindowsOpen = 1.5`。
- en: '**COMMON DATA TYPES**'
  id: totrans-3418
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-3419
  prefs: []
  type: TYPE_NORMAL
  zh: 如你刚刚所学，数据类型让计算机知道它正在处理什么*类型*的数据，以及如何将其存储在内存中。那么，数据类型有哪些呢？一些常见的数据类型包括 Int、Double、Float、Bool
    和 String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-3420
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨一下每个内容到底是什么吧！
- en: '**Int (Integers)**'
  id: totrans-3421
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Int（整数）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-3422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经稍微谈到了一些整数，但让我们更详细地了解它们。一个整数，在 Swift 中被称为 Int，是没有小数或分数部分的整数。你可以把它们看作是计数数字。整数是*有符号的*，意味着它们可以是负数、正数或零。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-3423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Double 和 Float（小数）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-3424
  prefs: []
  type: TYPE_NORMAL
  zh: '*小数*是有小数点后数字的数字，比如 3.14。（如果你希望 3 是一个小数，可以将其写为 3.0。）有两种数据类型可以存储小数：Double 和 Float（*浮点数*
    的简称）。在 Swift 中，Double 数据类型更常用，因为它可以存储更大的数字，所以我们将重点介绍它。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-3425
  prefs: []
  type: TYPE_NORMAL
  zh: 当你赋值给一个 Double 时，必须始终在小数点左边有一个数字，否则会出现错误。例如，假设香蕉的价格是每个19美分：
- en: '![Image](Image00050.jpg)'
  id: totrans-3426
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-3427
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码会导致错误，因为小数点左边没有数字。➋ 处的代码则能正常工作，因为它有一个前导零。（// ERROR 和 // CORRECT 是*注释*，它们是程序中的注释，计算机会忽略这些注释。有关注释的更多信息，请参见
    “[关于注释的一些快速说明](text00012.html#ch02sb01)” 在[第32页](text00012.html#page_32)上。）
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-3428
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Bool（布尔值，或真/假）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-3429
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*布尔值*只能是两种状态之一：真或假。在 Swift 中，布尔数据类型被称为 Bool。
- en: '![Image](Image00051.jpg)'
  id: totrans-3430
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-3431
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值通常用于 if-else 语句中，告诉计算机程序应该走哪条路径。（我们将在[第3章](text00013.html#ch03)中更详细地介绍布尔值和
    if-else 语句。）
- en: '**String**'
  id: totrans-3432
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符串**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-3433
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串数据类型用于存储单词和短语。一个*字符串*是由一系列字符组成，字符之间用引号括起来。例如，"Hello, playground" 就是一个字符串。字符串可以由各种字符组成：字母、数字、符号等。引号很重要，因为它们告诉计算机，所有引号之间的内容是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-3434
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串连接在一起来构建句子，这个过程叫做字符串*连接*。让我们来看看它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-3435
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-3436
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用加号 (+) 将字符串连接在一起，这段代码创建了一个名为 specialGreeting 的变量，其值为字符串 "Good Morning Jude"。请注意，我们需要在
    morningGreeting 和 friend 之间添加一个包含空格字符 (" ") 的字符串，否则 specialGreeting 的值将会是 "Good
    MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-3437
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-3438
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-3439
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，有时候我们声明变量时会包括数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-3440
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-3441
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们并不包括数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-3442
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-3443
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事？计算机实际上足够智能，大多数情况下能判断数据类型。这叫做*类型推断*——因为计算机会*推测*，或者说猜测我们使用的数据类型，依据的是我们给它的线索。当你创建一个变量并赋予初始值时，这个值就是给计算机的重要线索。以下是一些例子：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-3444
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个没有小数的数字（比如 3），计算机会认为它是一个整数（Int）。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-3445
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个带小数的数字（比如 3.14），计算机会认为它是一个 Double 类型。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-3446
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值 *true* 或 *false*（没有引号），计算机会认为它是一个布尔值（Bool）。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-3447
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个带引号的字符（比如 'a'），计算机会认为它是一个字符串（String）。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-3448
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量会被设为该数据类型，就像你自己声明了数据类型一样。这完全是为了方便。每次声明一个新的常量或变量时，你可以包含数据类型，这完全没有问题。但为什么不让计算机自动推断出来，省下时间和多余的输入呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-3449
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用类型转换转换数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-3450
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换* 是一种暂时改变变量或常量数据类型的方式。你可以把它当作给变量施了一个魔法——让它的值像另一个数据类型一样表现，但只是暂时的。要做到这一点，你需要写下新的数据类型，后面跟着圆括号，其中包含你正在转换的变量。请注意，这
    *并不会真正改变数据类型*。它只是给你在这一行代码中暂时的一个值。以下是一些在 Int 和 Double 之间进行类型转换的例子。请查看代码结果侧边栏中的结果。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-3451
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![Image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-3452
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Int 类型的变量 months 转换为 Double 类型，并将其存储在一个名为 doubleMonths 的新变量中。这为其添加了小数点，转换的结果是
    12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-3453
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将 Double 类型转换为 Int 类型：
- en: '![Image](Image00058.jpg)'
  id: totrans-3454
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-3455
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将我们的 Double 类型变量 days 转换为 Int 类型。你可以看到小数点和后面的所有数字都被去掉了：我们的数字变成了 365。这是因为
    Int 类型不能存储小数值——它只能存储整数，所以小数点后的部分会被截断。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-3456
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，类型转换并不会真正改变数据类型。在我们的例子中，即使在转换之后，days *依然*是一个 Double 类型。我们可以通过打印 days 来验证这一点：
- en: '![Image](Image00059.jpg)'
  id: totrans-3457
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-3458
  prefs: []
  type: TYPE_NORMAL
  zh: 结果侧边栏显示，days 的值依然是 365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-3459
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论一些你会使用类型转换的例子。所以如果现在还不清楚为什么要转换变量，稍等一下！
- en: '**OPERATORS**'
  id: totrans-3460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-3461
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中有许多算术运算符可以用于数学运算。你已经看到过基本的赋值运算符 = 。你可能也熟悉加法 (+)、减法 (-)、乘法 (*) 和除法 (/
    )。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-3462
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符对 Int、Float 和 Double 数据类型进行数学运算。进行运算的数字称为*操作数*。通过在 playground 中输入以下代码来实验这些数学运算符：
- en: '![Image](Image00060.jpg)'
  id: totrans-3463
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-3464
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 playground 中输入这段代码，你会在侧边栏看到每个数学表达式的结果。在代码中编写数学表达式与正常编写它们没有太大区别。例如，16 减去
    2 写作 16 – 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-3465
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数学表达式的结果保存在一个变量或常量中，这样你就可以在代码的其他地方使用它。要了解如何实现这一点，请在你的 playground 中输入以下几行代码：
- en: '![Image](Image00061.jpg)'
  id: totrans-3466
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-3467
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印 sum ➊ 时，你会在侧边栏看到 7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-3468
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在数学表达式中只使用了数字，但数学运算符也适用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-3469
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的 playground 中：
- en: '![Image](Image00062.jpg)'
  id: totrans-3470
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-3471
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以像对数字一样对变量和常量使用数学运算符。
- en: '**SPACES MATTER**'
  id: totrans-3472
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-3473
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，运算符两边的空格很重要。你可以在数学运算符两边写上空格，或者完全不写空格。但你不能只在运算符的一边放一个空格，而另一边不放。这样会导致错误。请查看[图
    2-7](text00012.html#ch02fig7)。
- en: '![image](Image00063.jpg)'
  id: totrans-3474
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-3475
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：确保运算符两边的空格数量相同。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-3476
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要事项需要注意：你只能对数据类型*相同*的变量或常量使用数学运算符。在前面的代码中，三和五都是 Int 数据类型。常量 half 和 quarter
    是 Double 数据类型，因为它们是小数。如果你尝试将 Int 和 Double 相加或相乘，你将得到类似[图 2-8](text00012.html#ch02fig8)中的错误。
- en: '![image](Image00064.jpg)'
  id: totrans-3477
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-3478
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-8：在 Swift 中，您不能对混合数据类型进行数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-3479
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你真的想对混合数据类型进行数学运算怎么办？例如，假设你想计算你年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-3480
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-3481
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行会出现错误，因为我们试图将一个 Int 与一个 Double 相乘。但不用担心！你有几种方法可以确保你的操作数是相同的数据类型。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-3482
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选项是将 myAge 声明为 Double，如下所示：
- en: '![Image](Image00066.jpg)'
  id: totrans-3483
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-3484
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有效，因为我们正在乘以两个 Double 数据类型。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-3485
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是使用类型转换。（我告诉过你我们会回到这个问题！）类型转换在这种情况下是一个很好的解决方案，因为我们不想永久性地把myAge改成Double类型，我们只是希望能像Double类型一样进行运算。让我们看一个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-3486
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-3487
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们在进行乘法运算之前将myAge转换为Double类型。这意味着我们不再有混合类型，因此代码能够正常工作。但是在➋处，我们会遇到错误。原因是myAge仍然是Int类型。将它在➊处转换为Double并没有永久性地改变它的类型。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-3488
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能把乘数转换为Int类型吗？当然可以！这样，我们就在对两个整数进行运算，这没问题。然而，这会导致计算精度下降，因为我们会丢失小数部分。当你将一个Double类型的变量转换为Int时，计算机会简单地去掉小数点后的所有数字，把它变成一个整数。在这种情况下，0.1的乘数会转换为Int类型的0。让我们在游乐场中转换一些变量，看看结果如何：
- en: '![Image](Image00068.jpg)'
  id: totrans-3489
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-3490
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，将我们的Double类型变量乘数转换为Int类型后得到的值是0。这个值在转换后变化很大，因为我们丢失了小数点：0.1变成了0。如果我们没有预料到这种情况，这可能在我们的代码中会引发严重的问题。进行类型转换时必须小心，确保不会意外地改变变量的值。在➋处，又有一个将Double转换为Int的例子，正如你所看到的，1.9并没有被四舍五入到2，它的小数部分直接被去掉，我们剩下的是1。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-3491
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种数学运算符，*取模运算符*（%），它可能对你来说比较陌生。取模运算符（也叫*模数运算符*）返回除法后的余数。例如，7 % 2 = 1，因为7除以2余1。尝试在你的游乐场中使用取模运算符，示例如下。
- en: '![Image](Image00069.jpg)'
  id: totrans-3492
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-3493
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，取模运算符对于判断一个数字是偶数（evenNumber % 2 等于0）➊还是奇数（oddNumber % 2 等于1）➋ 很有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-3494
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算顺序**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-3495
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在每一行代码中只做了一次数学运算，但通常会在一行代码中做多个运算。让我们来看一个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-3496
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元的钞票和两张一美元的钞票，你有多少钱？让我们在一行中计算：
- en: '![Image](Image00070.jpg)'
  id: totrans-3497
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-3498
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把17的值赋给myMoney。计算机首先计算5乘以3，然后再加上2。但计算机是如何知道先乘法然后*再*加2的呢？它只是从左到右做运算吗？不是！来看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-3499
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-3500
  prefs: []
  type: TYPE_NORMAL
  zh: 我们改变了数字的位置，结果仍然是 17。如果计算机只是从左到右执行，它会先计算 2 + 5，得到 7。然后它会将这个结果 7 乘以 3，得到 21。尽管我们改变了数学表达式中数字的顺序，但计算机仍然首先进行乘法运算（得到
    15），然后加上 2 得到 17。*计算机总是先执行乘法和除法，再进行加法和减法。* 这被称为 *运算顺序*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-3501
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号的运算顺序**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-3502
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必像我们在货币示例中那样依赖计算机来确定首先执行哪一步。你，作为程序员，拥有决定的权力！你可以使用括号将操作组合在一起。当你在某个操作周围加上括号时，你是在告诉计算机首先执行这一步：
- en: '![Image](Image00072.jpg)'
  id: totrans-3503
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-3504
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，括号告诉计算机首先计算 5 乘 3，然后加 2。这将得到 17。在 ➋ 处，括号告诉计算机首先计算 2 加 5，然后将结果乘以 3，得到 21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-3505
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在其他括号内部使用括号，使你的代码更加具体。计算机会先计算内层括号的内容，然后再计算外层括号的内容。试试这个例子：
- en: '![Image](Image00073.jpg)'
  id: totrans-3506
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-3507
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，计算机会在内层括号中将 2 和 3 相加。然后，它会将结果乘以 4，因为这是外层括号中的操作。最后，它会将 1 相加，因为它位于两个括号之外。最终结果是
    21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-3508
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值操作符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-3509
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会使用另一类操作符，即 *复合赋值操作符*。这些是将数学运算符与赋值操作符（=）结合在一起的“快捷”操作符。例如，以下表达式
- en: '[PRE100]'
  id: totrans-3510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: becomes
  id: totrans-3511
  prefs: []
  type: TYPE_NORMAL
  zh: 变成
- en: '[PRE101]'
  id: totrans-3512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-3513
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些操作符通过对变量或常量进行操作来更新它的值。用简单的英语来说，像 `a += b` 这样的表达式表示“将 b 加到 a 上，并将新值存储在
    a 中。”[表 2-1](text00012.html#ch2tab1) 显示了使用复合赋值操作符的数学表达式以及相同表达式的长形式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-3514
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-1：** 简短形式赋值操作符与长形式表达式'
- en: '| **Short form** | **Long form** |'
  id: totrans-3515
  prefs: []
  type: TYPE_TB
  zh: '| **简短形式** | **长形式** |'
- en: '| --- | --- |'
  id: totrans-3516
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-3517
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-3518
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-3519
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-3520
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-3521
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 `+=` 操作符的实际应用。假设我们正在编写一个程序来计算方舟上的动物数量。首先，我们创建一个名为 animalsOnArk 的变量，并将其初始化为
    0，因为方舟上还没有动物。当不同种类的动物登上方舟时，我们希望增加 animalsOnArk 的值以计算所有的动物。如果两只长颈鹿登上方舟，那么我们需要将
    animalsOnArk 增加 2。如果两只大象登上方舟，我们需要再次增加 2。如果四只羚羊登上方舟，我们需要将 animalsOnArk 增加 4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-3522
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00074.jpg)![Image](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-3523
  prefs: []
  type: TYPE_NORMAL
  zh: 在两只长颈鹿、两只大象和四只羚羊登上方舟后，animalsOnArk的最终值是8。真是一个动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-3524
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的一些快速说明**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-3525
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都提供了在代码中插入内联注释的方式。注释是被计算机忽略的备注，目的是帮助阅读代码的人理解代码的内容。虽然程序即使没有注释也能正常运行，但在代码的某些部分添加注释是一个好习惯，尤其是那些可能不清晰或容易引起混淆的部分。即使你不打算将程序展示给他人，注释也能帮助你记住自己在编写代码时的思路或想法。即便是几个月或几年后回过头来看你写的代码，也很常见会对当时的思路毫无头绪。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-3526
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中有两种添加注释的方法。第一种方法是在你想要添加的文本前面放两个正斜杠（//）。这些注释可以单独放在一行，就像这样：
- en: '[PRE102]'
  id: totrans-3527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-3528
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以与一行代码放在同一行——只要注释在代码的*后面*：
- en: '[PRE103]'
  id: totrans-3529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-3530
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式用于长注释或*多行*注释，其中注释的开始和结束分别由/*和*/标记。（注意，在本书中我们将使用-- *snip* --来表示省略的代码行，因空间问题未展示。）
- en: '[PRE104]'
  id: totrans-3531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-3532
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不希望计算机执行某部分代码，因为你正在找出一个 bug，但又不想删除所有辛苦写的代码，你可以使用多行注释来*暂时注释掉*某些代码段。当你将一段代码格式化为注释时，计算机会像忽略任何其他注释一样忽略这些代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-3534
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在Swift playground中编写代码，这样你可以立即看到结果。你创建了变量和常量，并学习了如何使用基本的数据类型和运算符，这些在你编写自己的计算机程序时会一再出现。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-3535
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](text00013.html#ch03)中，你将使用条件语句，它们告诉计算机你希望它走哪条代码路径。代码路径是根据条件的值来选择的。
- en: 'Variables are handy because if you want to print the words “Hello, playground”
    all you have to do is use the command print on str , like in the following code:'
  id: totrans-3536
  prefs: []
  type: TYPE_NORMAL
  zh: 变量非常方便，因为如果你想打印“Hello, playground”这句话，你只需要在str上使用print命令，就像下面的代码一样：
- en: '![Image](Image00038.jpg)'
  id: totrans-3537
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00038.jpg)'
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  id: totrans-3538
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在结果侧边栏打印出“Hello, playground\n”。\n会自动添加到你打印的任何内容末尾。它被称为*换行符*，告诉计算机换到新的一行。
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  id: totrans-3539
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看程序实际运行时的结果，可以打开调试区域，该区域会显示在下方的两个面板下面，如[图 2-4](text00012.html#ch02fig4)所示。为此，请在Xcode菜单中选择**视图**
    ▸ **调试区域** ▸ **显示调试区域**，或按⌘ -SHIFT -Y。当`str`在调试区域的控制台中打印出来时，您会发现围绕"Hello, playground"的引号和换行符不会显示出来。这就是`str`在正式运行该程序时的实际样子！
- en: '![image](Image00039.jpg)'
  id: totrans-3540
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-3541
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：在调试区域查看程序的实际输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-3542
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以在程序中改变（或者*变化*！），因此你可以更改变量的值以保存其他内容。现在让我们试一下。将以下几行代码添加到你的playground中。
- en: '![Image](Image00040.jpg)'
  id: totrans-3543
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-3544
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改变量的值，输入其名称并使用`=`操作符将其设置为新值。我们在➊处执行此操作，将`str`的值更改为"Hello, world"。计算机会丢弃`str`原本保存的内容，并说：“好的，老板，`str`现在是Hello,
    world。”（当然，如果计算机能说话，它就会这么说！）
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-3545
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们更改`str`的值时，我们不需要再次写`var`。计算机记得我们在前一行代码中声明了`str`，并且知道`str`已经存在。所以我们不需要重新创建`str`，我们只需要在其中放入不同的内容。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-3546
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以声明*常量*。像变量一样，常量也可以存储值。常量与变量的最大区别在于，常量的值永远不能改变。变量可以变化，而常量则是**常**的！声明常量与声明变量类似，但我们使用`let`而不是`var`：
- en: '![Image](Image00041.jpg)'
  id: totrans-3547
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-3548
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们创建了一个名为`myName`的常量，并将其赋值为"Gloria"。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-3549
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个常量并赋予它一个值，它将一直保持这个值，直到永远。可以把常量看作是你刻有某个值的大石块。如果你尝试给`myName`另一个值，比如"Matt"，你会遇到如[图
    2-5](text00012.html#ch02fig5)所示的错误。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-3550
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00042.jpg)![image](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-3551
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：尝试更改常量的值是行不通的。*'
- en: '**NOTE**'
  id: totrans-3552
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-3553
  prefs: []
  type: TYPE_NORMAL
  zh: '*在playground中，错误将显示为一个带有小白点的红色圆圈。点击错误标记将显示错误信息，并告诉你出了什么问题。如果你打开了调试区域，你还应该会看到描述发生了什么的信息，有时甚至会告诉你如何修复它。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-3554
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**什么时候使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-3555
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量—做得好！但什么时候应该使用常量，什么时候使用变量呢？在Swift中，最佳实践是使用常量而不是变量，除非你预期该值会发生变化。常量有助于让代码“更安全”。如果你知道某个值永远不会改变，为什么不把它刻在石头上，避免将来可能出现的任何混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-3556
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，假设你想跟踪教室里的窗户总数和今天开着的窗户数量。教室里的窗户数量是不会改变的，因此你应该使用常量来存储这个值。而今天开着的窗户数量会根据天气和时间的不同而变化，所以你应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-3557
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00044.jpg)![Image](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-3558
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 numberOfWindows 设置为常量并赋值为 8，因为窗户总数永远是 8。我们将 numberOfWindowsOpen 设置为变量并赋值为
    3，因为我们在开关窗户时需要更改这个值。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-3559
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用 var 来声明变量，使用 let 来声明常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-3560
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**命名常量和变量**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-3561
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为变量或常量命名几乎任何你想要的名称，但有几个例外。你不能将它们命名为 Swift 中已经存在的关键字。例如，你不能命名一个变量为 var。写 var
    var 会让你和计算机都感到困惑。如果你尝试使用 Swift 的保留字命名变量或常量，你会得到一个错误。你也不能在同一段代码块中使用相同名称的两个变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-3562
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则，还有一些其他好的编程规范可以遵循，尤其是在 Swift 中命名事物时。你的命名应该始终以小写字母开头。使用*非常*具有描述性的名称也是一个好主意（它们可以根据需要长）。当你使用一个描述性的名称时，理解这个变量或常量的含义会容易得多。如果你在查看别人的代码，哪个变量名你会觉得更容易理解：numKids
    还是 numberOfKidsInMyClass？第一个比较模糊，而第二个则很具描述性。常见的做法是使用由多个单词拼接在一起的变量或常量名，比如 numberOfKidsInMyClass。这种大写样式，即多个单词拼接成变量名时每个单词的首字母大写，称为*驼峰命名法*。因为这种大小写字母的组合看起来像骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-3563
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-3564
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-3565
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你可以选择变量或常量要存储的数据类型。记得我们之前说过，变量就像一个容器，用来存放某些东西？好吧，数据类型就像容器的类型。计算机需要知道我们将把什么放入每个容器中。在
    Swift 编程中，一旦你告诉计算机一个变量或常量要存储某种数据类型，它就不会允许你将其他类型的东西放入该变量或常量。如果你有一个专门用来装土豆的篮子，把水倒进篮子里显然是个坏主意——除非你喜欢水洒到鞋子上！
- en: '![image](Image00047.jpg)'
  id: totrans-3566
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-3567
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-3568
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，你可以告诉计算机它将保存什么类型的数据。在我们关于教室窗户的例子中，我们知道这个变量将始终是一个*整数*（即，整数——你不可能有半扇窗户），所以我们可以指定一个整数数据类型，像这样：
- en: '![Image](Image00048.jpg)'
  id: totrans-3569
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-3570
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示“是某种类型”。用简单的英语来说，这行代码的意思是：“变量 numberOfWindowsOpen，它是一个整数，等于 3。”所以这行代码创建了一个变量，给它命名，告诉计算机它的数据类型，并给它赋值。呼！一行代码做了这一切？我们有没有提到
    Swift 是一种非常*简洁*的语言？一些语言可能需要好几行代码才能完成相同的事情。Swift 被设计成可以用一行代码做很多事情！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-3571
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需声明一次数据类型。当我们告诉计算机一个变量将保存整数时，我们不需要再次告诉它。事实上，如果我们再告诉它，Xcode 会报错。数据类型一旦声明，变量或常量将永远保持该数据类型。一次是整数，永远是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-3572
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事你需要知道关于数据类型的事情：一个变量或常量不能存储与其数据类型不匹配的东西。例如，如果你尝试将一个小数放入 numberOfWindowsOpen
    中，你会遇到错误，如[图 2-6](text00012.html#ch02fig6)所示。
- en: '![image](Image00049.jpg)'
  id: totrans-3573
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-3574
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：你不能将小数放入一个应该保存整数的变量中。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-3575
  prefs: []
  type: TYPE_NORMAL
  zh: 将 numberOfWindowsOpen = 5 和 numberOfWindowsOpen = 0 是有效的，且可以正常工作。但是你不能将 numberOfWindowsOpen
    设置为 1.5。
- en: '**COMMON DATA TYPES**'
  id: totrans-3576
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-3577
  prefs: []
  type: TYPE_NORMAL
  zh: 如你刚刚所学，数据类型让计算机知道它正在处理的数据是什么*类型*，以及如何在内存中存储它。那么，数据类型有哪些呢？一些常见的类型包括 Int、Double、Float、Bool
    和 String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-3578
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下这些数据类型到底是什么！
- en: '**Int (Integers)**'
  id: totrans-3579
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Int（整数）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-3580
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经稍微讲了一些整数的知识，但让我们更详细地讨论它们。整数，在 Swift 中称为 Int，是一个没有小数或分数部分的整数。你可以把它们当作计数数字。整数是*有符号*的，这意味着它们可以是负数、正数或零。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-3581
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Double 和 Float（小数）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-3582
  prefs: []
  type: TYPE_NORMAL
  zh: '*小数*是指有小数点后数字的数字，例如 3.14。（像 3 这样的整数如果想变成小数应该写成 3.0。）有两种数据类型可以存储小数：Double 和
    Float（即*浮动小数点数*）。在 Swift 中，Double 类型更常用，因为它可以存储更大的数字，所以我们将重点讲解 Double。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-3583
  prefs: []
  type: TYPE_NORMAL
  zh: 当你赋值一个 Double 时，必须在小数点左侧有数字，否则会出现错误。例如，假设香蕉每个价格是 19 美分：
- en: '![Image](Image00050.jpg)'
  id: totrans-3584
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-3585
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码会导致错误，因为它没有小数点左边的数字。➋ 处的代码则正常运行，因为它有一个前导零。（短语 // ERROR 和 // CORRECT 是*注释*，它们是程序中的说明，计算机会忽略它们。请参见
    “[关于注释的一些快速说明](text00012.html#ch02sb01)” 在[第32页](text00012.html#page_32)。）
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-3586
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Bool（布尔值，或者是 True/False）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-3587
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*布尔值*只能是两种情况之一：true 或 false。在 Swift 中，布尔数据类型叫做 Bool。
- en: '![Image](Image00051.jpg)'
  id: totrans-3588
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-3589
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值通常用于 if-else 语句中，以告诉计算机程序应采取哪条路径。（我们将在[第3章](text00013.html#ch03)中更详细地讲解布尔值和
    if-else 语句。）
- en: '**String**'
  id: totrans-3590
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**String**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-3591
  prefs: []
  type: TYPE_NORMAL
  zh: '**String** 数据类型用于存储单词和短语。一个*字符串*是由被引号括起来的字符集合。例如，"Hello, playground" 是一个字符串。字符串可以由各种各样的字符组成：字母、数字、符号等等。引号非常重要，因为它们告诉计算机，引号之间的所有内容都是你正在创建的字符串的一部分。'
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-3592
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串连接在一起的方式来构建句子，这个过程叫做字符串*连接*。让我们看看它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-3593
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-3594
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用加号（+）将字符串连接在一起，这段代码创建了一个名为 specialGreeting 的变量，并将字符串 "Good Morning Jude"
    作为其值。请注意，我们需要在 morningGreeting 和 friend 之间添加一个包含空格字符（" "）的字符串，否则 specialGreeting
    的值将是 "Good MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-3595
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-3596
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-3597
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，有时我们在声明变量时，会包括数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-3598
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-3599
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们不包括数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-3600
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-3601
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事？计算机实际上足够智能，通常能够推断出数据类型。这被称为*类型推断*——因为计算机会根据我们提供的线索*推测*我们使用的数据类型。当你创建一个变量并为其赋一个初值时，这个初值是计算机的重要线索。以下是一些例子：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-3602
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋予一个没有小数点的数字（比如 3），计算机会认为它是一个 Int。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-3603
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋予一个带小数点的数字（比如 3.14），计算机会认为它是一个 Double。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-3604
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋予单词*true*或*false*（不带引号），计算机会认为它是一个 Bool。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-3605
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋予一个或多个用引号括起来的字符，计算机会认为它是一个 String。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-3606
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量会被设置为该数据类型，就像你自己声明数据类型一样。这是为了方便。你每次声明新常量或变量时，都可以指定数据类型，这完全没问题。但为什么不让计算机自动推断出来，这样既节省了时间，又少打字呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-3607
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**通过类型转换变换数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-3608
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换* 是一种暂时改变变量或常量数据类型的方法。你可以把它当作是对变量施法——让它的值像不同的数据类型一样工作，但只是暂时的。要实现这一点，你需要写出新的数据类型，后跟括号，括号中包含你正在转换的变量。请注意，这
    *并不会实际改变数据类型*。它只是为这一行代码提供一个临时的值。这里有一些 Int 和 Double 之间类型转换的示例。你可以查看代码执行结果侧边栏中的结果。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-3609
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![Image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-3610
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Int 类型的变量 months 转换为 Double 类型，并将其存储在一个名为 doubleMonths 的新变量中。这时会增加一个小数点，转换后的结果是
    12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-3611
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将一个 Double 类型转换为 Int 类型：
- en: '![Image](Image00058.jpg)'
  id: totrans-3612
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-3613
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将我们的 Double 类型的 days 转换为 Int 类型。你可以看到小数点和其后的所有数字都被去掉了：我们的数字变成了 365。这是因为
    Int 类型无法存储小数，它只能包含整数，所以小数点后面的部分被去除。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-3614
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，类型转换实际上并不会改变数据类型。在我们的示例中，即使进行了类型转换，days *仍然*是一个 Double。我们可以通过打印 days 来验证这一点：
- en: '![Image](Image00059.jpg)'
  id: totrans-3615
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-3616
  prefs: []
  type: TYPE_NORMAL
  zh: 结果侧边栏显示，days 仍然等于 365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-3617
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍一些你在何时何地使用类型转换的示例。所以如果现在还不清楚为什么要进行类型转换，稍等一下，我们会解释得更清楚！
- en: '**OPERATORS**'
  id: totrans-3618
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-3619
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中有许多算术运算符可以用来进行数学计算。你已经见过基本的赋值运算符 = 。你可能也熟悉加法 (+)、减法 (-)、乘法 (*) 和除法 (/)。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-3620
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符对 Int、Float 和 Double 数据类型进行数学运算。被运算的数字叫做 *操作数*。你可以通过在 Playground 中输入类似以下的代码来实验这些数学运算符：
- en: '![Image](Image00060.jpg)'
  id: totrans-3621
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-3622
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Playground 中输入这段代码，你会在侧边栏看到每个数学表达式的结果。在代码中写数学表达式与正常写法并没有太大区别。例如，16 减去 2
    写作 16 – 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-3623
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数学表达式的结果保存在变量或常量中，以便在代码的其他地方使用。要了解其工作原理，请在 Playground 中输入以下几行代码：
- en: '![Image](Image00061.jpg)'
  id: totrans-3624
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-3625
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印 sum ➊ 时，侧边栏中会显示 7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-3626
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在数学表达式中使用了数字，但数学运算符也可以作用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-3627
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的 Playground 中：
- en: '![Image](Image00062.jpg)'
  id: totrans-3628
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-3629
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以像对待数字一样，在变量和常量上使用数学运算符。
- en: '**SPACES MATTER**'
  id: totrans-3630
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-3631
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，运算符两边的空格非常重要。你可以在运算符的两边都留一个空格，或者干脆不留空格。但你不能只在一边留空格，另一边不留空格。这样会导致错误。看看
    [图 2-7](text00012.html#ch02fig7)。
- en: '![image](Image00063.jpg)'
  id: totrans-3632
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-3633
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：确保在运算符两边的空格数量相同。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-3634
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点非常重要：你只能对相同数据类型的变量或常量使用数学运算符。在之前的代码中，三和五都是 Int 类型。常量 half 和 quarter 是 Double
    类型，因为它们是小数。如果你尝试将 Int 和 Double 相加或相乘，你会得到像 [图 2-8](text00012.html#ch02fig8) 中那样的错误。
- en: '![image](Image00064.jpg)'
  id: totrans-3635
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-3636
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-8：在 Swift 中，不能对混合数据类型进行数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-3637
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你真的想对混合数据类型进行数学运算呢？例如，假设你想计算自己年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-3638
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-3639
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行会报错，因为我们正在尝试将 Int 与 Double 相乘。但不用担心！你有几个选项可以确保操作数的数据类型一致。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-3640
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是将 myAge 声明为 Double 类型，如下所示：
- en: '![Image](Image00066.jpg)'
  id: totrans-3641
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-3642
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码之所以有效，是因为我们在乘以两个 Double 数据类型。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-3643
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是使用类型转换。（我之前告诉过你，我们会回到这个话题！）类型转换在这种情况下是一个很好的解决方案，因为我们不想永久地将 myAge 转换为 Double
    类型，我们只是希望能够像对待 Double 类型一样对它进行数学运算。让我们看一个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-3644
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-3645
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊，我们在乘法运算前将 myAge 转换为 Double。这意味着我们不再有混合数据类型，所以代码可以正常工作。但在 ➋，我们会遇到错误。这是因为
    myAge 仍然是 Int 类型。在 ➊ 将其转换为 Double 并不会永久改变它的类型。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-3646
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能将乘数转换为 Int 吗？当然可以！这样我们就能对两个整数进行数学运算，这样也是可以的。不过，这样会导致计算结果不够精确，因为我们会丢失小数部分。当你将一个变量从
    Double 转换为 Int 时，计算机会简单地去掉小数点后的数字，使其变成一个整数。在这种情况下，乘数 0.1 会被转换为 0 的 Int。让我们在 Playground
    中转换一些变量，看看结果如何：
- en: '![Image](Image00068.jpg)'
  id: totrans-3647
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-3648
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，将我们的Double类型数据转换为Int类型后，得到的结果是0。转换后这个值与原值大不相同，因为我们丢失了小数点：0.1变成了0。如果我们没有预料到这种情况，它可能会在我们的代码中引发严重问题。进行类型转换时，必须小心，确保不会无意中改变值。在➋处，另一个Double转Int的例子，如你所见，1.9并没有四舍五入成2，而是其小数部分被去掉，结果只剩下1。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-3649
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种数学运算符，即*取模运算符*（%），你可能不太熟悉。取模运算符（也叫*模运算*）给出除法的余数。例如，7 % 2 = 1，因为7除以2的余数是1。你可以在你的游乐场中尝试一下取模运算符，如下所示。
- en: '![Image](Image00069.jpg)'
  id: totrans-3650
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-3651
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，取模运算符在判断一个数字是偶数（evenNumber % 2 等于0）➊还是奇数（oddNumber % 2 等于1）➋时非常有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-3652
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算顺序**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-3653
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们每行代码中只做了一次数学运算，但在实际情况中，通常会在一行代码中进行多次运算。让我们看一个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-3654
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元和两张一美元的钞票，你有多少钱？让我们在一行中计算出来：
- en: '![Image](Image00070.jpg)'
  id: totrans-3655
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-3656
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将17赋值给myMoney。计算机先执行5乘以3，然后加上2。那么，计算机是如何知道先乘后加的呢？它只是从左到右依次执行吗？不是！请看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-3657
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-3658
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调整了数字的位置，结果仍然是17。如果计算机仅仅从左到右执行，它会先计算2 + 5得到7，然后再将这个结果7乘以3，得到21。即使我们改变了数学表达式中数字的顺序，计算机仍然先执行乘法（得到15），再加上2，结果是17。*计算机总是先进行乘法和除法运算，然后进行加法和减法运算。*这就是*运算顺序*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-3659
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号确定运算顺序**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-3660
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必像我们在货币例子中那样依赖计算机去决定先做哪一步。你，作为程序员，拥有决定权！你可以使用括号将操作分组。当你给某个操作加上括号时，你告诉计算机首先执行这个步骤：
- en: '![Image](Image00072.jpg)'
  id: totrans-3661
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-3662
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，括号告诉计算机先计算5乘以3，然后再加上2。这将得到17。在➋处，括号告诉计算机先加上2和5，然后将结果乘以3，得到21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-3663
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在括号内嵌套括号来使代码更具针对性。计算机会先计算内部的括号，然后再计算外部的。试试这个例子：
- en: '![Image](Image00073.jpg)'
  id: totrans-3664
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-3665
  prefs: []
  type: TYPE_NORMAL
  zh: 首先计算机在内层括号内加上了 2 和 3。然后它将结果乘以 4，因为这在外层括号内。最后，它将 1 加到结果中，因为它在外面。最终的结果是 21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-3666
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值运算符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-3667
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的另一类运算符是*复合赋值运算符*。这些是“快捷”运算符，将数学运算符与赋值运算符（=）结合起来。例如，这个表达式：
- en: '[PRE105]'
  id: totrans-3668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: becomes
  id: totrans-3669
  prefs: []
  type: TYPE_NORMAL
  zh: 变成
- en: '[PRE106]'
  id: totrans-3670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-3671
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符通过对变量或常量进行操作来更新它的值。通俗来说，像 a += b 这样的表达式意思是“将 b 加到 a 中，并将新的值存储回 a 中”。[表
    2-1](text00012.html#ch2tab1) 显示了使用复合赋值运算符的数学表达式及其长形式表达式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-3672
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-1：** 简短形式赋值运算符与长形式表达式'
- en: '| **Short form** | **Long form** |'
  id: totrans-3673
  prefs: []
  type: TYPE_TB
  zh: '| **简短形式** | **长形式** |'
- en: '| --- | --- |'
  id: totrans-3674
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-3675
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-3676
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-3677
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-3678
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-3679
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 += 运算符的实际应用。假设我们正在编写一个程序来计算方舟上的动物数量。首先，我们创建一个名为 animalsOnArk 的变量并将其设置为
    0，因为方舟上还没有动物。当不同种类的动物登上方舟时，我们希望增加 animalsOnArk 的值来统计所有动物。如果两只长颈鹿登上方舟，那么我们需要将 2
    加到 animalsOnArk。如果两只大象登上方舟，那么我们需要再加 2。如果四只羚羊登上方舟，我们需要将 animalsOnArk 增加 4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-3680
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00074.jpg)![Image](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-3681
  prefs: []
  type: TYPE_NORMAL
  zh: 在两只长颈鹿、两只大象和四只羚羊登上方舟后，animalsOnArk 的最终值为 8。真是一个动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-3682
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的几点快速说明**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-3683
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都提供了在代码中内联添加注释的方式。注释是被计算机忽略的备注，用来帮助阅读代码的人理解代码的作用。尽管程序在没有注释的情况下也能正常运行，但在代码中可能不清晰或让人困惑的部分添加注释是个好主意。即使你不打算把你的程序展示给别人，注释也能帮助你记住在编写代码时的思路或想法。将来回头看自己几个月或几年以前写的代码时，常常会不记得当时的思路。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-3684
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中有两种方式可以添加注释。第一种方法是将两个斜杠（//）放在你想要添加注释的文本前面。这些注释可以单独放在一行中，像这样：
- en: '[PRE107]'
  id: totrans-3685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-3686
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它们可以与一行代码放在同一行——只要注释位于代码*之后*：
- en: '[PRE108]'
  id: totrans-3687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-3688
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式用于长注释，或*多行*注释，其中注释的开始和结束由 /* 和 */ 标记。（注意，在本书中，我们会使用 -- *snip* -- 来显示为节省空间而省略的更多代码行。）
- en: '[PRE109]'
  id: totrans-3689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-3690
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不希望计算机运行你代码的某一部分，因为你正在尝试查找错误，但又不想删除你所有的辛苦工作，你可以使用多行注释来*临时注释掉*代码块。当你将一段代码格式化为注释时，计算机会像忽略任何其他注释一样忽略这段代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3691
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-3692
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何在 Swift playground 中编写代码，它让你能够立即看到结果。你创建了变量和常量，并学会了如何使用基本数据类型和操作符，这些将在你编写自己的计算机程序时反复出现。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-3693
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](text00013.html#ch03)中，你将使用条件语句，它告诉计算机你希望它走哪条代码路径。代码路径是根据条件的值来选择的。
- en: '![Image](Image00038.jpg)'
  id: totrans-3694
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00038.jpg)'
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  id: totrans-3695
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在结果侧边栏中打印 "Hello, playground\n"。\n 会自动添加到你打印的内容的末尾。它被称为*换行符*，告诉计算机换到新的一行。
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  id: totrans-3696
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看程序的实际运行结果，请打开调试区域，调试区域将出现在两个面板下方，如[图 2-4](text00012.html#ch02fig4)所示。为此，请在
    Xcode 菜单中选择 **视图** ▸ **调试区域** ▸ **显示调试区域**，或者按 ⌘ -SHIFT -Y。当 str 在调试区域的控制台中打印时，你可以看到
    Hello, playground 周围的引号和换行符不会出现。这就是如果你正式运行这个程序时，str 实际上会是什么样子！
- en: '![image](Image00039.jpg)'
  id: totrans-3697
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-3698
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：在调试区域查看程序的真实输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-3699
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在你的程序中是可以变化的（或*变化的*！），所以你可以改变变量的值来保存其他内容。现在我们来试试。将以下代码行添加到你的 playground 中。
- en: '![Image](Image00040.jpg)'
  id: totrans-3700
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-3701
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变变量的值，输入变量名并使用 = 操作符将其设置为新值。我们在 ➊ 处做了这件事，将 str 的值更改为 "Hello, world" 。计算机会丢弃
    str 原本存储的内容，然后说：“好的，老板，str 现在是 Hello, world ”（当然，如果它能说话的话！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-3702
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们改变 str 的值时，我们并没有再写 var。计算机会记住我们在之前的代码行中声明了 str，并知道 str 已经存在。所以我们不需要重新创建
    str，只需要在其中放入不同的内容。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-3703
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以声明*常量*。和变量一样，常量也保存值。常量与变量之间的最大区别是，常量的值永远无法改变。变量的值可以变化，而常量是，嗯，常量！声明常量与声明变量类似，但我们使用的是let而不是var：
- en: '![Image](Image00041.jpg)'
  id: totrans-3704
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-3705
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为myName的常量，并将其值赋为"Gloria"。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-3706
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个常量并赋予它一个值，它将一直保持该值，直到永远。把常量想象成一块大石头，你在上面刻下了你的值。如果你试图给myName另一个值，比如"Matt"，你会遇到类似于[图2-5](text00012.html#ch02fig5)中的错误。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-3707
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00042.jpg)![image](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-3708
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-5：尝试更改常量的值将不起作用。*'
- en: '**NOTE**'
  id: totrans-3709
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-3710
  prefs: []
  type: TYPE_NORMAL
  zh: '*在Playground中，错误会以一个红色圆圈和一个小的白色圆圈的形式出现。点击错误标记会显示错误消息，并告诉你哪里出错。如果你显示了调试区域，你还应该会看到描述发生了什么的信息，有时甚至会告诉你如何修复它。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-3711
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-3712
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量——做得好！但是，什么时候应该使用常量，什么时候应该使用变量呢？在Swift中，除非你预计值会发生变化，否则最好使用常量而不是变量。常量有助于让代码“更安全”。如果你知道某个值永远不会改变，为什么不把它刻在石头上，避免以后可能的混乱呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-3713
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想跟踪你教室里窗户的总数以及今天打开的窗户数。教室里窗户的总数不会改变，因此你应该使用常量来存储这个值。教室里打开的窗户数会根据天气和一天中的时间而变化，因此你应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-3714
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00044.jpg)![image](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-3715
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将numberOfWindows设为常量，并将其值设为8，因为窗户的总数始终为8。我们将numberOfWindowsOpen设为变量，并将其值设为3，因为我们希望在开关窗户时更改该值。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-3716
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用var声明变量，使用let声明常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-3717
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常量和变量命名**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-3718
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以几乎随意给变量或常量命名，但有一些例外。你不能将其命名为Swift中已经是关键字的词语。例如，你不能将一个变量命名为var。写作var var会让你和计算机都感到困惑。如果你尝试用Swift的保留字命名变量或常量，程序会报错。此外，同一段代码中不能有两个同名的变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-3719
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则外，在 Swift 中为事物命名时，还有一些其他好的编程规范。你的变量名应该始终以小写字母开头。使用*非常*具有描述性的名字也是个好主意（它们可以很长）。当你使用描述性名称时，更容易理解这个变量或常量应该是什么。如果你在看别人写的代码，你更容易理解哪个变量名：numKids
    还是 numberOfKidsInMyClass？第一个比较模糊，而第二个则很有描述性。常见的做法是，变量和常量名由一串单词组合而成，比如 numberOfKidsInMyClass。这个命名风格，在多个单词组合成变量名时，每个单词的首字母大写，就叫做*驼峰命名法*。这是因为这种大小写字母交替的模式看起来像是骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-3720
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-3721
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-3722
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你可以选择变量或常量要持有的**数据类型**。还记得我们说过你可以把变量当作一个容器来装东西吗？数据类型就像是容器的类型。计算机需要知道我们将把什么样的东西放入每个容器中。在
    Swift 编程中，一旦你告诉计算机某个变量或常量要持有某种数据类型，它就不会允许你在这个变量或常量中放入其他类型的数据。如果你有一个设计用来装土豆的篮子，填满水就不是一个好主意——除非你喜欢水洒得到处都是！
- en: '![image](Image00047.jpg)'
  id: totrans-3723
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-3724
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-3725
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，你可以告诉计算机它将持有的数据类型。在我们关于教室窗户的例子中，我们知道这个变量将始终是一个*整数*（也就是说，整数——你不可能有一半窗户），所以我们可以像这样指定一个整数数据类型：
- en: '![Image](Image00048.jpg)'
  id: totrans-3726
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-3727
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示“是...类型的”。通俗来说，这行代码的意思是：“变量 numberOfWindowsOpen，它是一个整数，等于 3。”所以这行代码创建了一个变量，给它命名，告诉计算机它的数据类型，并为它赋值。呼！一行代码就做到了这些？我们提到过
    Swift 是一个非常*简洁*的语言吗？有些语言可能需要几行代码才能完成同样的操作。而 Swift 设计的初衷就是让你通过一行代码就能完成很多事情！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-3728
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要声明一次数据类型。当我们告诉计算机某个变量会持有整数时，我们不需要再告诉它一次。事实上，如果我们再告诉它，Xcode 会给我们报错。一旦声明了数据类型，变量或常量就会永久持有这种类型的数据。一次是整数，永远都是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-3729
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要了解一件关于数据类型的事情：一个变量或常量不能存储它数据类型以外的内容。例如，如果你尝试将一个小数赋值给 numberOfWindowsOpen，就会出现错误，正如在
    [图 2-6](text00012.html#ch02fig6) 中所示。
- en: '![image](Image00049.jpg)'
  id: totrans-3730
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-3731
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：你不能将一个小数赋值给一个应存储整数的变量。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-3732
  prefs: []
  type: TYPE_NORMAL
  zh: 将 numberOfWindowsOpen 设置为 5 或 0 都是有效的，并且可以正常工作。但你不能将 numberOfWindowsOpen 设置为
    1.5。
- en: '**COMMON DATA TYPES**'
  id: totrans-3733
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-3734
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所学，数据类型告诉计算机它正在处理的是什么*类型*的数据，以及如何将其存储在内存中。那么，数据类型具体有哪些呢？一些常见的数据类型包括：Int、Double、Float、Bool
    和 String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-3735
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下这些数据类型的具体含义！
- en: '**Int (Integers)**'
  id: totrans-3736
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Int（整数）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-3737
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经稍微讲过整数了，但现在让我们更详细地讨论它们。整数，在 Swift 中被称为 Int，是没有小数或分数部分的整数。你可以把它们看作是计数数字。整数是
    *有符号* 的，这意味着它们可以是负数、正数或零。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-3738
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Double 和 Float（小数）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-3739
  prefs: []
  type: TYPE_NORMAL
  zh: '*小数*是指小数点后有数字的数值，例如 3.14。（如果你想将整数 3 表示为小数，应该写成 3.0。）有两种数据类型可以存储小数：Double 和
    Float（即 *浮点数*）。由于 Double 数据类型能存储更大的数字，它在 Swift 中更为常见，因此我们将重点讲解这个数据类型。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-3740
  prefs: []
  type: TYPE_NORMAL
  zh: 当你赋值给 Double 时，小数点左侧必须有一个数字，否则会出现错误。例如，假设香蕉每个 19 分：
- en: '![Image](Image00050.jpg)'
  id: totrans-3741
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-3742
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码会报错，因为它的小数点左侧没有数字。➋ 处的代码则没有问题，因为它有一个前导零。（// ERROR 和 // CORRECT 是 *注释*，是程序中的备注，计算机会忽略它们。关于注释的更多信息，请参见
    “[关于注释的一些快速说明](text00012.html#ch02sb01)” 第 [32 页](text00012.html#page_32)。）
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-3743
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Bool（布尔值，或真/假）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-3744
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值* 只能是两者之一：true 或 false。在 Swift 中，布尔数据类型被称为 Bool。'
- en: '![Image](Image00051.jpg)'
  id: totrans-3745
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-3746
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值通常用于 if-else 语句中，指示计算机应该执行程序的哪条路径。（我们将在 [第 3 章](text00013.html#ch03) 中详细讲解布尔值和
    if-else 语句。）
- en: '**String**'
  id: totrans-3747
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**String**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-3748
  prefs: []
  type: TYPE_NORMAL
  zh: String 数据类型用于存储单词和短语。*字符串*是由一系列字符组成的，字符之间用引号括起来。例如，“Hello, playground”就是一个字符串。字符串可以由各种各样的字符组成：字母、数字、符号等。引号非常重要，因为它们告诉计算机，引号中的所有内容都是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-3749
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串连接在一起来构建句子，这个过程叫做字符串*拼接*。让我们看看它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-3750
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-3751
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用加号（+）将字符串连接起来，这段代码创建了一个名为specialGreeting的变量，值为字符串"Good Morning Jude"。注意，我们需要在morningGreeting和friend之间添加一个包含空格字符（"
    "）的字符串，否则specialGreeting的值会是"Good MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-3752
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-3753
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-3754
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，有时候我们在声明一个变量时，会包括数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-3755
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-3756
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们不会指定数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-3757
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-3758
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事？计算机实际上足够聪明，大多数时候可以自己判断数据类型。这叫做*类型推断*——因为计算机会*推断*，或者说猜测我们正在使用的数据类型，基于我们给出的线索。当你创建一个变量并赋予它初始值时，这个值就是给计算机的一个重要线索。下面是一些示例：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-3759
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个没有小数的数字（比如3），计算机会认为它是一个Int类型。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-3760
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个带小数的数字（比如3.14），计算机会认为它是一个Double类型。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-3761
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值布尔值*true*或*false*（没有引号），计算机会认为它是一个Bool类型。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-3762
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你为一个或多个字符加上引号，计算机会认为它是一个字符串（String）。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-3763
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量会被设置为该数据类型，就好像你自己声明了数据类型一样。这纯粹是为了方便。你可以每次声明新常量或变量时都包括数据类型，这样完全没问题。但为什么不让计算机自己判断出来，省下你一些时间和额外的输入呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-3764
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**通过强制转换变换数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-3765
  prefs: []
  type: TYPE_NORMAL
  zh: '*强制转换*是一种暂时改变变量或常量数据类型的方法。你可以把它想象成对变量施下的魔法——让它的值暂时表现得像不同的数据类型，但仅仅是短暂的。要做到这一点，你需要写出一个新的数据类型，后面跟上括号，括号内是你要转换的变量。注意，这*并不会真正改变数据类型*。它只会在那一行代码中为你提供一个临时值。这里有几个Int和Double之间强制转换的例子。看看代码执行后的结果。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-3766
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![Image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-3767
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将Int类型的变量months强制转换为Double类型，并将其存储在一个叫做doubleMonths的新变量中。这添加了一个小数位，强制转换的结果是12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-3768
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将一个Double类型转换为Int类型：
- en: '![Image](Image00058.jpg)'
  id: totrans-3769
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-3770
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将Double类型的days强制转换为Int。你可以看到小数点和后面的所有数字都被去除了：我们的数字变成了365。这是因为Int无法容纳小数，它只能存储整数，因此小数点后的内容会被截断。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-3771
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，强制转换并不会实际改变数据类型。在我们的示例中，即使进行了强制转换，days *依然*是一个Double类型。我们可以通过打印days来验证这一点：
- en: '![Image](Image00059.jpg)'
  id: totrans-3772
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-3773
  prefs: []
  type: TYPE_NORMAL
  zh: 结果侧边栏显示days仍然等于365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-3774
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将展示一些使用强制转换的示例。所以，如果你现在不清楚为什么需要强制转换变量，请稍等片刻！
- en: '**OPERATORS**'
  id: totrans-3775
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-3776
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中有许多算术运算符，你可以用它们进行数学运算。你已经见过基本的赋值运算符=。你可能也熟悉加法（+）、减法（-）、乘法（*）和除法（/）。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-3777
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符对Int、Float和Double数据类型进行数学运算。进行运算的数字被称为*操作数*。通过在你的游乐场中输入以下代码，来尝试这些数学运算符：
- en: '![Image](Image00060.jpg)'
  id: totrans-3778
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-3779
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在你的游乐场中输入这段代码，你将看到每个数学表达式的结果出现在侧边栏中。在代码中书写数学表达式与平常写数学表达式并没有太大区别。例如，16减去2就写作16
    – 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-3780
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数学表达式的结果保存到变量或常量中，以便在代码的其他地方使用。要了解这一点，请在你的游乐场中输入以下代码：
- en: '![Image](Image00061.jpg)'
  id: totrans-3781
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-3782
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印sum➊时，你将在侧边栏看到7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-3783
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在数学表达式中使用了数字，但数学运算符也适用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-3784
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的游乐场中：
- en: '![Image](Image00062.jpg)'
  id: totrans-3785
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-3786
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以像对待数字一样对变量和常量使用数学运算符。
- en: '**SPACES MATTER**'
  id: totrans-3787
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-3788
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，运算符两边的空格非常重要。你可以在数学运算符的两侧写一个空格，或者完全不写空格。但你不能只在运算符的一侧加空格，另一侧不加，这样会导致错误。请看[图
    2-7](text00012.html#ch02fig7)。
- en: '![image](Image00063.jpg)'
  id: totrans-3789
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-3790
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：确保你的运算符两边有相同数量的空格。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-3791
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点非常重要：你只能对相同数据类型的变量或常量使用数学运算符。在之前的代码中，三和五都是Int类型。常量half和quarter是Double类型，因为它们是小数。如果你尝试将Int和Double相加或相乘，你会遇到像[图
    2-8](text00012.html#ch02fig8)中的错误。
- en: '![image](Image00064.jpg)'
  id: totrans-3792
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-3793
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-8：在Swift中，无法对不同数据类型进行数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-3794
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你真的想对混合数据类型做数学运算呢？例如，假设你想计算你年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-3795
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-3796
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行会导致错误，因为我们试图将一个整数与一个 Double 相乘。但别担心！你有几种方法可以确保操作数是相同的数据类型。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-3797
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是将 myAge 声明为 Double 类型，如下所示：
- en: '![Image](Image00066.jpg)'
  id: totrans-3798
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-3799
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码之所以能工作，是因为我们在乘两个 Double 类型的数。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-3800
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是使用类型转换。（我说过我们会回到这个问题的！）在这种情况下，类型转换是一个很好的解决方案，因为我们不想永久性地将 myAge 改为 Double
    类型，我们只是想能够像对待 Double 类型一样对其进行数学运算。让我们看一个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-3801
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-3802
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们在进行乘法运算之前将 myAge 转换为 Double。这意味着我们不再有混合类型，所以代码能够正常工作。但在 ➋ 处，我们会遇到一个错误。这是因为
    myAge 仍然是 Int 类型。在 ➊ 处将它转换为 Double 并不会永久性地改变它的类型。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-3803
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能把乘数转换成整数吗？当然可以！那么我们就在两个整数上做数学运算，这样是没问题的。然而，这样会导致计算结果不够精确，因为我们会丢失小数点。当你将一个变量从
    Double 转换成 Int 时，计算机会简单地去掉小数点后的数字，使其变为整数。在这种情况下，你的乘数 0.1 会被转换成整数 0。让我们在 Playground
    中转换一些变量，看看结果：
- en: '![Image](Image00068.jpg)'
  id: totrans-3804
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-3805
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，将我们的 Double 类型乘数转换为 Int 得到 0。转换后的值与原值有很大不同，因为我们丢失了小数点：0.1 变成了 0。如果我们没预料到这一点，这可能会在代码中造成非常严重的问题。你在进行类型转换时必须小心，以确保你不会意外地改变了值。在
    ➋ 处，还有另一个将 Double 转换为 Int 的例子，正如你所看到的，1.9 并没有四舍五入为 2。它的小数部分被直接去掉，我们剩下了 1。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-3806
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个数学运算符，*模运算符*（%），你可能不太熟悉。模运算符（也叫做*余数*）返回除法后的余数。例如，7 % 2 = 1，因为 7 除以 2 的余数是
    1。你可以在 Playground 中尝试一下模运算符，方法如下：
- en: '![Image](Image00069.jpg)'
  id: totrans-3807
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-3808
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，模运算符对于确定一个数字是偶数（evenNumber % 2 等于 0）➊ 还是奇数（oddNumber % 2 等于 1）➋ 很有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-3809
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算顺序**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-3810
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在每行代码上只进行了一个数学运算，但通常在一行上会做多个运算。让我们看一个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-3811
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元钞票和两张一美元钞票，你有多少钱？让我们在一行内计算这个：
- en: '![Image](Image00070.jpg)'
  id: totrans-3812
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-3813
  prefs: []
  type: TYPE_NORMAL
  zh: 这将值 17 赋给 myMoney。计算机先将 5 乘以 3，然后加上 2。但计算机是如何知道先乘法后加法的呢？它仅仅是从左到右执行吗？不是！看看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-3814
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-3815
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调换了数字，结果依然是 17。如果计算机从左到右执行，它会先将 2 + 5 相加得到 7，然后将这个结果 7 乘以 3，得到 21。即使我们改变了数学表达式中数字的顺序，计算机仍然先执行乘法（得到
    15），然后加上 2 得到 17。*计算机总是先执行乘法和除法，然后执行加法和减法。* 这就是所谓的 *运算顺序*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-3816
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号排序操作**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-3817
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必像我们在金钱示例中那样依赖计算机来决定应该先执行哪个步骤。你，作为程序员，拥有决定的权力！你可以使用括号来将操作分组。当你把括号放在某个操作周围时，你告诉计算机先执行这个步骤：
- en: '![Image](Image00072.jpg)'
  id: totrans-3818
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-3819
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，括号告诉计算机先执行 5 乘 3，再加 2。这样得到 17。在 ➋ 处，括号告诉计算机先将 2 加上 5，然后再乘以 3，结果是 21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-3820
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在其他括号内使用括号来使代码更加具体。计算机会先计算内层括号中的内容，然后计算外层括号中的内容。试试这个例子：
- en: '![Image](Image00073.jpg)'
  id: totrans-3821
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-3822
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，计算机会先将内层括号中的 2 和 3 相加。然后它会将结果乘以 4，因为那在外层括号内。最后它会加上外层括号外的 1。最终结果是 21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-3823
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值运算符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-3824
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的另一个运算符类别是 *复合赋值运算符*。这些是将数学运算符与赋值运算符（=）结合的“快捷”运算符。例如，这个表达式
- en: '[PRE110]'
  id: totrans-3825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: becomes
  id: totrans-3826
  prefs: []
  type: TYPE_NORMAL
  zh: 变成
- en: '[PRE111]'
  id: totrans-3827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-3828
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符通过对变量或常量执行操作来更新它们的值。通俗来说，像 a += b 这样的表达式表示“将 b 加到 a 上，并将新值存储在 a 中。”[表
    2-1](text00012.html#ch2tab1) 显示了使用复合赋值运算符的数学表达式及其更长形式的表达式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-3829
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-1：** 短格式赋值运算符与长格式表达式'
- en: '| **Short form** | **Long form** |'
  id: totrans-3830
  prefs: []
  type: TYPE_TB
  zh: '| **短格式** | **长格式** |'
- en: '| --- | --- |'
  id: totrans-3831
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-3832
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-3833
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-3834
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-3835
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-3836
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看+=运算符是如何运作的。假设我们正在编写一个程序来计算方舟上的动物数量。首先，我们创建一个名为animalsOnArk的变量，并将其设为0，因为方舟上还没有动物。当不同种类的动物登上方舟时，我们希望增加animalsOnArk的值，以便计算所有动物的数量。如果两只长颈鹿登上方舟，那么我们需要将animalsOnArk加2。如果两只大象登上方舟，那么我们需要再加2。如果四只羚羊登上方舟，那么我们需要将animalsOnArk增加4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-3837
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00074.jpg)![Image](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-3838
  prefs: []
  type: TYPE_NORMAL
  zh: 在两只长颈鹿、两只大象和四只羚羊登上方舟后，animalsOnArk的最终值是8。真是个动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-3839
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的一些快速说明**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-3840
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都提供了一种在代码中嵌入注释的方式。注释是计算机会忽略的注解，目的是帮助阅读代码的人理解代码的内容。尽管没有注释程序也能正常运行，但对于可能不太清晰或容易混淆的代码部分，最好加上注释。即使你不打算将程序展示给别人，注释也能帮助你记住在编写代码时自己在做什么或在想什么。回头看看几个月甚至几年前写的代码，发现自己完全不记得当时的思路，这并不罕见。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-3841
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中有两种添加注释的方法。第一种方法是在你想添加的文本前加上两个斜杠（//）。这些注释可以单独放在一行，比如这样：
- en: '[PRE112]'
  id: totrans-3842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-3843
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它们也可以与代码行放在同一行——只要注释出现在代码*之后*：
- en: '[PRE113]'
  id: totrans-3844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-3845
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法适用于长注释，或者*多行*注释，注释的开始和结束分别用/*和*/标记。（注意，在本书中我们会使用-- *snip* -- 来表示为了节省空间而省略的代码行。）
- en: '[PRE114]'
  id: totrans-3846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-3847
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不希望计算机运行代码的某部分，因为你正在试图找出一个 bug，但又不想删除所有的辛苦工作，你可以使用多行注释暂时*注释掉*代码的某些部分。当你将一段代码格式化为注释时，计算机会像忽略任何其他注释一样忽略这段代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-3848
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-3849
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何在 Swift playground 中编写代码，这让你可以立即看到结果。你创建了变量和常量，并学习了如何使用基本的数据类型和运算符，这些在你编写自己程序时会反复遇到。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-3850
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](text00013.html#ch03)中，你将使用条件语句，它告诉计算机你希望它执行的代码路径。代码路径是根据条件的值来选择的。
- en: This prints "Hello, playground\n" in the results sidebar. The \n is added automatically
    to the end of whatever you print. It is known as the *newline* character and tells
    the computer to go to a new line.
  id: totrans-3851
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在结果侧边栏中打印 "Hello, playground\n"。\n 会自动添加到你打印的内容的末尾。它被称为*换行符*，告诉计算机换到新的一行。
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  id: totrans-3852
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看程序实际运行时的结果，打开调试区域，它会显示在两个面板下方，如[图 2-4](text00012.html#ch02fig4)所示。你可以通过在
    Xcode 菜单中选择 **视图** ▸ **调试区域** ▸ **显示调试区域**，或者按 ⌘-SHIFT-Y 来实现。当 str 在调试区域的控制台中打印出来时，你会看到
    Hello, playground 周围的引号和换行符不会出现。这就是如果你正式运行这个程序时，str 实际显示的样子！
- en: '![image](Image00039.jpg)'
  id: totrans-3853
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-3854
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：在调试区域查看程序的真实输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-3855
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在你的程序中可以改变（或*变化*！），因此你可以更改一个变量的值来存储其他内容。现在我们就来试试。将以下几行代码添加到你的 Playground 中。
- en: '![Image](Image00040.jpg)'
  id: totrans-3856
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-3857
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改一个变量的值，输入变量名，并使用 = 运算符将其设置为新值。我们在 ➊ 处执行此操作，将 str 的值更改为 "Hello, world"。计算机会丢弃
    str 原本的值，并说：“好的，老板，str 现在是 Hello, world”（如果计算机能说话的话！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-3858
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们更改 str 的值时，并没有再次写 var。计算机会记住我们之前在代码中的某一行声明了 str，并知道 str 已经存在。所以我们不需要再次创建
    str，只需要给它赋予不同的值。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-3859
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以声明*常量*。像变量一样，常量也保存值。常量和变量的最大区别在于，常量的值永远不能改变。而变量是可以变化的，常量则是恒定的！声明常量和声明变量类似，不过我们用的是
    let，而不是 var：
- en: '![Image](Image00041.jpg)'
  id: totrans-3860
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-3861
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们创建了一个名为 myName 的常量，并将其值设置为 "Gloria"。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-3862
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了常量并给它赋了值，它将保持这个值直到永远。可以把常量看作是一块大石头，你在上面雕刻了一个值。如果你试图给 myName 赋另一个值，比如 "Matt"，你会得到一个像[图
    2-5](text00012.html#ch02fig5)中那样的错误。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-3863
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00042.jpg)![image](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-3864
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：尝试更改常量的值是行不通的。*'
- en: '**NOTE**'
  id: totrans-3865
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-3866
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 Playground 中，错误会以一个红色圆圈和里面的小白点的形式显示。点击错误标记会显示错误信息，并告诉你哪里出错。如果你打开了调试区域，你还应该能看到描述发生了什么的详细信息，有时甚至会显示如何修复它。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-3867
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-3868
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量——干得好！但什么时候应该使用变量而不是常量呢？在 Swift 中，除非你预计值会改变，否则最好使用常量而非变量。常量有助于让代码“更安全”。如果你知道某个值永远不会改变，为什么不将它写死，避免以后产生任何可能的混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-3869
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你想跟踪教室里的窗户总数以及今天开着的窗户数量。教室里的窗户总数不会改变，因此你应该使用常量来存储这个值。至于开着的窗户数量会根据天气和时间的不同而变化，因此你应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-3870
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00044.jpg)![Image](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-3871
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 numberOfWindows 设置为常量并赋值为 8，因为窗户的总数始终为 8。我们将 numberOfWindowsOpen 设置为变量并赋值为
    3，因为当我们开关窗户时，这个值会发生变化。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-3872
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用 var 来定义变量，使用 let 来定义常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-3873
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常量和变量命名**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-3874
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以给变量或常量命名几乎任何你想要的名字，但有一些例外。你不能使用 Swift 中已经是关键字的单词命名变量。例如，你不能命名变量为 var。写 var
    var 会让你和计算机都感到困惑。如果你尝试使用 Swift 的保留字来命名变量或常量，会导致错误。此外，在同一个代码块中，你不能有两个相同名字的变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-3875
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则外，还有一些其他好的编程指导原则，可以帮助你命名 Swift 中的变量或常量。你的名字应该总是以小写字母开头。给变量或常量起一个*非常*描述性的名字也是个好主意（名字可以尽可能长）。使用描述性名称时，更容易理解该变量或常量的作用。如果你正在查看别人的代码，你更容易理解哪个变量名：numKids
    还是 numberOfKidsInMyClass？第一个名称含糊不清，但第二个名称很有描述性。常见的做法是，变量和常量的名字由多个单词组成，例如 numberOfKidsInMyClass。这个命名风格是*驼峰式命名法*，因为多个单词合并后的首字母大写的样子，像骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-3876
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-3877
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-3878
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你可以选择变量或常量保存哪种类型的数据——*数据类型*。记得我们说过可以把变量看作一个容器，里面装着某些东西吗？那么数据类型就像是容器的类型。计算机需要知道我们将把什么类型的东西放进每个容器中。在
    Swift 编程中，一旦你告诉计算机你希望某个变量或常量保存某个数据类型，它就不会让你放入其他类型的内容。如果你有一个设计用来装土豆的篮子，那么把它装满水肯定不是个好主意——除非你喜欢水洒到鞋子上！
- en: '![image](Image00047.jpg)'
  id: totrans-3879
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-3880
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-3881
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，你可以告诉计算机它将保存哪种类型的数据。在我们关于教室窗户的例子中，我们知道这个变量将永远是一个*整数*（即一个整数——你不可能有半个窗户），所以我们可以像这样指定整数数据类型：
- en: '![Image](Image00048.jpg)'
  id: totrans-3882
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-3883
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示“是类型”。用通俗的话来说，这行代码的意思是，“变量 numberOfWindowsOpen，类型是整数，等于 3。”所以这一行代码创建了一个变量，给它命名，告诉计算机它的数据类型，并赋值。呼！一行代码就做了这些？我们提到过
    Swift 是一种非常*简洁*的语言吗？有些语言可能需要几行代码才能完成同样的事情。而 Swift 设计得让你可以用一行代码做很多事！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-3884
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要声明一次数据类型。当我们告诉计算机一个变量将保存整数时，我们不需要再告诉它一次。事实上，如果我们再告诉它，Xcode 会给我们报错。一旦数据类型被声明，变量或常量将永远保持该数据类型。一次整数，永远是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-3885
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事你需要了解关于数据类型的：变量或常量不能保存与其数据类型不符的内容。例如，如果你尝试将一个小数放入 numberOfWindowsOpen 中，你将会得到一个错误，如
    [图 2-6](text00012.html#ch02fig6) 所示。
- en: '![image](Image00049.jpg)'
  id: totrans-3886
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-3887
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：你不能将小数放入应该保存整数的变量中。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-3888
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 numberOfWindowsOpen = 5 和 numberOfWindowsOpen = 0 是有效的并且可以正常工作。但是你不能设置 numberOfWindowsOpen
    = 1.5。
- en: '**COMMON DATA TYPES**'
  id: totrans-3889
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-3890
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚刚学到的，数据类型让计算机知道它正在处理什么*类型*的数据，并且如何将其存储在内存中。那么，数据类型是什么呢？一些常见的数据类型包括 Int、Double、Float、Bool
    和 String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-3891
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下这些到底是什么！
- en: '**Int (Integers)**'
  id: totrans-3892
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Int（整数）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-3893
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经稍微提到过整数，现在让我们更详细地讨论它们。整数（在 Swift 中称为 Int）是没有小数部分或分数部分的整数。你可以把它们看作是计数数字。整数是
    *有符号* 的，意味着它们可以是负数、正数或零。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-3894
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Double 和 Float（小数）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-3895
  prefs: []
  type: TYPE_NORMAL
  zh: '*小数* 是指小数点后有数字的数字，例如 3.14。（如果你想将整数 3 作为小数表示，它应该写作 3.0。）有两种数据类型可以存储小数：Double
    和 Float（即 *浮动点数*）。Double 数据类型在 Swift 中更常见，因为它可以存储更大的数字，因此我们将重点讨论它。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-3896
  prefs: []
  type: TYPE_NORMAL
  zh: 当你赋值给一个 Double 时，必须始终在小数点左边有一个数字，否则会出现错误。例如，假设香蕉的价格是每个 19 美分：
- en: '![Image](Image00050.jpg)'
  id: totrans-3897
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-3898
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码会导致错误，因为它没有小数点左边的数字。➋ 处的代码运行正常，因为它有一个前导零。（// ERROR 和 // CORRECT 是 *注释*，是程序中的备注，计算机会忽略这些内容。详见
    “[关于注释的一些快速说明](text00012.html#ch02sb01)” 在 [第 32 页](text00012.html#page_32)）
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-3899
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Bool（布尔值，或真/假）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-3900
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值*只能是两种情况之一：真或假。在 Swift 中，布尔数据类型称为 Bool。'
- en: '![Image](Image00051.jpg)'
  id: totrans-3901
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-3902
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值通常用于 if-else 语句中，告诉计算机程序应该采取哪条路径。（我们将在 [第 3 章](text00013.html#ch03) 中更详细地讲解布尔值和
    if-else 语句。）
- en: '**String**'
  id: totrans-3903
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符串**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-3904
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串数据类型用于存储单词和短语。*字符串* 是由字符组成的集合，并用引号括起来。例如，"Hello, playground" 就是一个字符串。字符串可以由各种字符组成：字母、数字、符号等。引号很重要，因为它们告诉计算机，引号之间的所有内容都是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-3905
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串连接起来，使用字符串 *连接* 的方法来构建句子。我们来看一下它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-3906
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-3907
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用加号（+）将字符串连接起来，这段代码创建了一个名为 specialGreeting 的变量，其值为字符串 "Good Morning Jude"。注意，这里我们需要在
    morningGreeting 和 friend 之间加一个包含空格字符（" "）的字符串，否则 specialGreeting 将变成 "Good MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-3908
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-3909
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-3910
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，有时当我们声明一个变量时，会包含数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-3911
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-3912
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们没有包含数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-3913
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-3914
  prefs: []
  type: TYPE_NORMAL
  zh: 这是怎么回事？实际上，计算机足够聪明，能够在大多数情况下自动推断数据类型。这就叫做 *类型推断* ——因为计算机会根据我们给出的线索 *推断* 或猜测我们使用的数据类型。当你创建一个变量并给它一个初始值时，这个值就是给计算机的一个重要线索。以下是一些例子：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-3915
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值给一个没有小数部分的数字（像 3），计算机会认为它是一个 Int 类型。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-3916
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值给一个带有小数值的数字（像 3.14），计算机会认为它是一个 Double 类型。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-3917
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值给单词 *true* 或 *false*（没有引号），计算机会认为它是一个 Bool 类型。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-3918
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值给一个或多个带引号的字符，计算机会认为它是一个 String 类型。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-3919
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量会被设置为该数据类型，就好像你自己声明了数据类型一样。这是为了方便而做的。你可以在每次声明新常量或变量时都包括数据类型，这也是完全可以的。但是为什么不让计算机来推断呢，省下时间并减少输入呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-3920
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**通过强制转换改变数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-3921
  prefs: []
  type: TYPE_NORMAL
  zh: '*强制转换* 是一种临时转换变量或常量数据类型的方法。你可以把它当作对变量施法——你让它的值表现得像其他数据类型，但仅仅是暂时的。为了做到这一点，你写上新的数据类型，后面跟着括号，括号内是你要转换的变量。请注意，这
    *并不会真正改变数据类型* 。它只是为那一行代码提供了一个临时的值。以下是一些在 Int 和 Double 之间进行强制转换的例子。看看你代码在结果侧边栏中的显示。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-3922
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![Image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-3923
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Int 类型的变量 months 转换为 Double 类型，并将其存储在一个新的变量 doubleMonths 中。这为结果添加了小数位，转换后的结果是
    12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-3924
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将一个 Double 转换为 Int：
- en: '![Image](Image00058.jpg)'
  id: totrans-3925
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-3926
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将我们的 Double 类型的 days 转换为 Int 类型。你可以看到，小数点和后面的所有数字都被去掉了：我们的数字变成了 365。这是因为
    Int 类型无法存储小数——它只能包含整数，所以小数点后的部分被截断了。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-3927
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，强制转换并不会真正改变数据类型。在我们的例子中，即使进行了强制转换，days *仍然*是 Double 类型。我们可以通过打印 days 来验证这一点：
- en: '![Image](Image00059.jpg)'
  id: totrans-3928
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-3929
  prefs: []
  type: TYPE_NORMAL
  zh: 结果侧边栏显示，days 仍然等于 365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-3930
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将展示一些使用强制类型转换的例子。所以如果你现在还不明白为什么要进行类型转换，请稍等一下！
- en: '**OPERATORS**'
  id: totrans-3931
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**操作符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-3932
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中有许多算术运算符可以用来进行数学运算。你已经看过基本的赋值运算符=。你可能也熟悉加法（+）、减法（-）、乘法（*）和除法（/）。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-3933
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符对Int、Float和Double数据类型进行数学运算。正在进行运算的数字称为*操作数*。通过输入如下代码，你可以在Playground中实验这些数学运算符：
- en: '![Image](Image00060.jpg)'
  id: totrans-3934
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-3935
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在你的Playground中输入这段代码，你将在侧边栏看到每个数学表达式的结果。在代码中编写数学表达式与正常书写并没有太大区别。例如，16减去2写作16
    – 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-3936
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数学表达式的结果保存在一个变量或常量中，以便在代码的其他地方使用。要了解它是如何工作的，请在Playground中输入以下代码：
- en: '![Image](Image00061.jpg)'
  id: totrans-3937
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-3938
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印sum ➊时，你将在侧边栏看到7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-3939
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的数学表达式中只使用了数字，但数学运算符也适用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-3940
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的Playground中：
- en: '![Image](Image00062.jpg)'
  id: totrans-3941
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-3942
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以像对待数字一样对变量和常量使用数学运算符。
- en: '**SPACES MATTER**'
  id: totrans-3943
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-3944
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，运算符周围的空格很重要。你可以在数学运算符的两侧写上空格，或者完全不写空格。但你不能只在运算符的一侧加空格，另一侧不加。这将导致错误。请查看[图2-7](text00012.html#ch02fig7)。
- en: '![image](Image00063.jpg)'
  id: totrans-3945
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-3946
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-7：确保在每个运算符的两侧有相同数量的空格。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-3947
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件重要的事情需要注意：你只能对*相同*数据类型的变量或常量使用数学运算符。在之前的代码中，数字三和五都是整数（Int）数据类型。常量half和quarter是双精度浮点数（Double）数据类型，因为它们是小数。如果你尝试将一个Int与一个Double相加或相乘，你将遇到类似[图2-8](text00012.html#ch02fig8)中的错误。
- en: '![image](Image00064.jpg)'
  id: totrans-3948
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-3949
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-8：在Swift中，你不能对混合数据类型进行数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-3950
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果你真的想对混合数据类型进行数学运算呢？例如，假设你想计算你年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-3951
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-3952
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行将导致错误，因为我们试图将一个Int与一个Double相乘。但别担心！你有几种选择来确保你的操作数是相同的数据类型。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-3953
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是将myAge声明为Double，像这样：
- en: '![Image](Image00066.jpg)'
  id: totrans-3954
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-3955
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码之所以能工作，是因为我们正在相乘两个Double数据类型。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-3956
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是使用类型转换。（我告诉过你我们会回到这个问题！）类型转换在这种情况下是一个很好的解决方案，因为我们不希望将 myAge 永久地转换为 Double，只是希望能够像处理
    Double 类型一样对它进行数学运算。让我们来看一个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-3957
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-3958
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们在进行乘法运算之前将 myAge 转换为 Double。这意味着我们不再有混合类型，因此代码可以正常工作。但是在 ➋ 处，我们会得到一个错误。这是因为
    myAge 仍然是一个 Int。在 ➊ 处将它转换为 Double 并没有永久地将其改变为 Double 类型。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-3959
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将乘数转换为整数（Int）吗？当然可以！这样我们就可以对两个整数进行数学运算，这样没问题。然而，这样会导致计算不够精确，因为我们会丢失小数部分。当你将一个变量从
    Double 转换为 Int 时，计算机会简单地去掉小数点后的任何数字，将其转换为整数。在这种情况下，你的 0.1 乘数会转换为 0 的整数。让我们在 Playground
    中尝试转换一些变量，看看会得到什么结果：
- en: '![Image](Image00068.jpg)'
  id: totrans-3960
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-3961
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，将我们的 Double 类型的 multiplier 转换为 Int 后得到 0。这个值在转换后差异很大，因为我们丢失了小数部分：0.1 变成了
    0。如果我们没有预料到这种情况，这可能会在代码中造成很大的问题。在进行类型转换时必须小心，确保不会意外地更改值。在 ➋ 处，我们又看到一个将 Double
    转换为 Int 的例子，正如你所见，1.9 没有被四舍五入到 2，而是直接去掉了小数部分，剩下 1。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-3962
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个数学运算符，*取模运算符*（%），你可能不太熟悉。取模运算符（也叫*模*）给出除法后的余数。例如，7 % 2 = 1，因为 7 除以 2 的余数是
    1。试试在 Playground 中使用取模运算符，像下面这样。
- en: '![Image](Image00069.jpg)'
  id: totrans-3963
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-3964
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，取模运算符在判断一个数字是偶数（evenNumber % 2 等于 0）➊ 还是奇数（oddNumber % 2 等于 1）➋ 时非常有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-3965
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算顺序**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-3966
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在每行代码中只做了一次数学运算，但在一行代码中进行多个运算是很常见的。让我们来看一个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-3967
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元和两张一美元的钞票，你有多少钱？让我们用一行代码计算一下：
- en: '![Image](Image00070.jpg)'
  id: totrans-3968
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-3969
  prefs: []
  type: TYPE_NORMAL
  zh: 这将值 17 赋给 myMoney。计算机先计算 5 乘以 3 然后加上 2。但计算机怎么知道先乘法再加法呢？它是按从左到右的顺序工作吗？不是的！看看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-3970
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-3971
  prefs: []
  type: TYPE_NORMAL
  zh: 我们改变了数字的位置，结果依然是 17。如果计算机从左到右进行运算，它会先将 2 和 5 相加得到 7，然后将这个结果 7 乘以 3 得到 21。即使我们改变了数学表达式中的数字顺序，计算机仍然会先进行乘法运算（得到
    15），然后再加上 2 得到 17。*计算机会始终先执行乘法和除法运算，然后再进行加法和减法运算。* 这被称为 *运算顺序*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-3972
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号排列运算顺序**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-3973
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要像在货币示例中那样依赖计算机来决定先做哪一步。你，作为程序员，有权决定！你可以使用括号将操作分组。当你将括号放在某个部分时，你告诉计算机首先执行那部分操作：
- en: '![Image](Image00072.jpg)'
  id: totrans-3974
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-3975
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 中，括号告诉计算机首先进行 5 乘以 3 的运算，然后加上 2。这样得到 17。在 ➋ 中，括号告诉计算机首先将 2 和 5 相加，然后再乘以
    3，结果为 21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-3976
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在括号中使用其他括号来使代码更加具体。计算机会首先评估内层的括号，然后评估外层括号。试试这个例子：
- en: '![Image](Image00073.jpg)'
  id: totrans-3977
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-3978
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，计算机会在内层括号之间进行 2 和 3 的加法运算。然后它会将结果乘以 4，因为它在外层括号内。最后，它会加上外部括号的 1。最终结果是 21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-3979
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值运算符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-3980
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的另一类运算符是 *复合赋值运算符*。这些是将数学运算符与赋值运算符 (=) 结合的“快捷”运算符。例如，这个表达式
- en: '[PRE115]'
  id: totrans-3981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: becomes
  id: totrans-3982
  prefs: []
  type: TYPE_NORMAL
  zh: 变为
- en: '[PRE116]'
  id: totrans-3983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-3984
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符通过对变量或常量执行运算来更新其值。简单来说，像 a += b 这样的表达式表示“将 b 加到 a 中，并将新值存储到 a 中”。[表
    2-1](text00012.html#ch2tab1) 显示了使用复合赋值运算符的数学表达式以及其长形式表达式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-3985
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 2-1：** 简短形式赋值运算符与长形式表达式'
- en: '| **Short form** | **Long form** |'
  id: totrans-3986
  prefs: []
  type: TYPE_TB
  zh: '| **简短形式** | **长形式** |'
- en: '| --- | --- |'
  id: totrans-3987
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-3988
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-3989
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-3990
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-3991
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-3992
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 += 运算符的使用。假设我们正在编写一个程序来计算方舟上的动物数量。首先，我们创建一个名为 animalsOnArk 的变量，并将其初始化为
    0，因为方舟上还没有动物。随着不同种类的动物登上方舟，我们希望增加 animalsOnArk 来计算所有动物。如果两只长颈鹿登上方舟，那么我们需要将 2 加到
    animalsOnArk 中。如果两只大象登上方舟，我们需要再次加上 2。如果四只羚羊登上方舟，我们需要将 animalsOnArk 增加 4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-3993
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00074.jpg)![Image](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-3994
  prefs: []
  type: TYPE_NORMAL
  zh: 在两只长颈鹿、两只大象和四只羚羊登上方舟后，animalsOnArk 的最终值为 8 。真是一个动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-3995
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的一些简短评论**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-3996
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都提供了与代码内联的注释方式。注释是计算机忽略的文本，旨在帮助阅读代码的人理解代码的作用。尽管没有注释程序也能正常运行，但对于那些可能不太清楚或容易混淆的代码段，添加注释是个好主意。即使你不打算把程序展示给别人，注释也能帮助你记住当初编写代码时的思路。我们常常会回过头来看几个月或几年前写的代码，结果完全记不起当时在想什么。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-3997
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中有两种添加注释的方式。第一种方式是在你想要添加文本的前面放置两个斜杠（//）。这些注释可以单独占一行，像这样：
- en: '[PRE117]'
  id: totrans-3998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-3999
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它们可以与一行代码放在同一行，只要注释*位于代码之后*：
- en: '[PRE118]'
  id: totrans-4000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-4001
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式用于长注释或*多行*注释，注释的开始和结束分别用 /* 和 */ 标记。（注意，在本书中我们会使用 -- *省略部分代码* -- 来表示因为篇幅问题省略的代码行。）
- en: '[PRE119]'
  id: totrans-4002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-4003
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不想让计算机运行代码的某一部分，因为你正在尝试找出一个 bug，但又不想删除你辛辛苦苦写的代码，你可以使用多行注释暂时*注释掉*某些代码部分。当你将一段代码格式化为注释时，计算机会像忽略其他注释一样忽略这部分代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4004
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-4005
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何在 Swift playground 中编写代码，这样你可以立即看到结果。你创建了变量和常量，并学习了如何使用基础数据类型和运算符，这些内容在你编写自己的计算机程序时会反复遇到。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-4006
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](text00013.html#ch03)中，你将使用条件语句，它们告诉计算机你希望它执行哪条代码路径。代码路径的选择是根据条件的值来决定的。
- en: To see the results of your program as it would actually run, bring up the debug
    area, which will appear below the two panels, as shown in [Figure 2-4](text00012.html#ch02fig4)
    . To do this, go to **View** ▸ **Debug Area** ▸ **Show Debug Area** in the Xcode
    menu or press ⌘ -SHIFT -Y. When str is printed in the console of the debug area,
    you can see that the quotes around Hello, playground and the newline character
    don’t appear. This is what str would really look like if you were to officially
    run this program!
  id: totrans-4007
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看程序实际运行时的结果，调出调试区域，该区域会出现在两个面板下方，如[图 2-4](text00012.html#ch02fig4)所示。为此，点击
    **视图** ▸ **调试区域** ▸ **显示调试区域**，或者按 ⌘-SHIFT-Y。在调试区域的控制台中打印出 str 时，你可以看到围绕 “Hello,
    playground” 的引号和换行符都没有出现。如果你正式运行该程序，str 的输出就会是这样的样子！
- en: '![image](Image00039.jpg)'
  id: totrans-4008
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-4009
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：在调试区域查看程序的真实输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-4010
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在程序中是可以变化的（或者说*变化*！），因此你可以更改变量的值以保存其他内容。让我们现在尝试一下。在你的工作区添加以下几行代码。
- en: '![Image](Image00040.jpg)'
  id: totrans-4011
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-4012
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改变量的值，输入其名称并使用=运算符将其设置为新值。我们在➊处这样做，将str的值更改为"Hello, world"。计算机会丢弃str之前存储的任何内容，并说：“好的，老板，str现在是Hello,
    world”（当然，如果它能说话的话！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-4013
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们更改str的值时，我们不需要再次写var。计算机会记住我们在之前的代码行中声明了str，并知道str已经存在。因此，我们不需要重新创建str。我们只需要将不同的内容放入其中。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-4014
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以声明*常量*。像变量一样，常量也存储值。常量和变量的最大区别是，常量的值永远无法更改。变量可以变化，而常量则是恒定的！声明常量与声明变量类似，但我们使用let而不是var：
- en: '![Image](Image00041.jpg)'
  id: totrans-4015
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-4016
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为myName的常量，并将其赋值为"Gloria"。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-4017
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个常量并给它赋了一个值，它将一直保持该值，直到永远。可以把常量看作是你刻入其中的一个大石块。如果你尝试给myName赋另一个值，比如"Matt"，你会遇到一个错误，正如[图2-5](text00012.html#ch02fig5)中所示。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-4018
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00042.jpg)![图片](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-4019
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-5：尝试更改常量的值将不起作用。*'
- en: '**NOTE**'
  id: totrans-4020
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-4021
  prefs: []
  type: TYPE_NORMAL
  zh: '*在工作区中，错误会以一个红圈加上一个小白圈的形式出现。点击错误标记会显示错误信息并告诉你哪里出错了。如果你开启了调试区域，你还应该能看到描述发生了什么的信息，有时甚至会给出如何修复的建议。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-4022
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-4023
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量——干得好！但是，什么时候应该使用一个而不是另一个呢？在Swift中，最佳实践是使用常量而不是变量，除非你预计该值会改变。常量有助于使代码“更安全”。如果你知道某个值永远不会改变，为什么不把它刻在石头上，避免以后可能的混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-4024
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你想记录教室中窗户的总数以及今天打开的窗户数。教室中窗户的数量是不会改变的，所以你应该使用常量来存储这个值。然而，教室中打开的窗户数量会根据天气和一天中的时间而变化，所以你应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-4025
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00044.jpg)![图片](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-4026
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将numberOfWindows设置为常量并设定为8，因为窗口的总数将始终为8。我们将numberOfWindowsOpen设为变量并设定为3，因为在打开或关闭窗口时，我们会想要更改这个值。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-4027
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用var声明变量，使用let声明常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-4028
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**命名常量和变量**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-4029
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以将变量或常量命名为你想要的任何名称，但有一些例外。你不能将它们命名为Swift中已存在的关键字。例如，你不能命名一个变量为var。写var var会让你和计算机都感到困惑。如果你试图使用Swift的保留字命名变量或常量，系统会报错。你也不能在同一代码块中有两个同名的变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-4030
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则外，还有一些其他良好的编程指南，在Swift中命名时应该遵循。你的变量名应该始终以小写字母开头。使用*非常*具有描述性的名称也是一个好主意（名称长度可以随意）。当你使用描述性名称时，更容易弄清楚该变量或常量的作用。如果你在查看别人的代码，你会觉得哪个变量名更容易理解：numKids
    还是 numberOfKidsInMyClass？第一个名字模糊，而第二个则很具描述性。常见的做法是看到像numberOfKidsInMyClass这样的多个单词组合起来的变量或常量名称。这种大小写风格，多个单词组合成变量名时，每个单词的首字母都大写，被称为*驼峰命名法*。这是因为小写字母和大写字母的交替排列，看起来像骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-4031
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-4032
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-4033
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，你可以选择变量或常量所持有的数据类型—*数据类型*。还记得我们说过，你可以把变量想象成一个容器吗？那么数据类型就像是容器的类型。计算机需要知道我们将会往每个容器里放些什么。在Swift编程中，一旦你告诉计算机你希望一个变量或常量持有某种数据类型，它就不会允许你将其他类型的数据放入这个变量或常量里。如果你有一个设计用来装土豆的篮子，把水放进篮子里就不是个好主意——除非你喜欢水漏到鞋子里！
- en: '![image](Image00047.jpg)'
  id: totrans-4034
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-4035
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-4036
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，你可以告诉计算机它将持有哪种类型的数据。在我们关于教室窗户的例子中，我们知道这个变量将始终是*整数*（即一个整数——你不可能有半个窗户），所以我们可以指定整数数据类型，像这样：
- en: '![Image](Image00048.jpg)'
  id: totrans-4037
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-4038
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示“是某种类型”。通俗地说，这行代码的意思是，“变量 numberOfWindowsOpen，它是一个整数，等于 3。” 所以，这行代码创建了一个变量，给它命名，告诉计算机它的数据类型，并赋值。呼！一行代码完成了这些？我们提到过
    Swift 是一种非常*简洁*的语言吗？有些语言可能需要几行代码才能完成同样的操作。而 Swift 设计得可以通过一行代码做很多事情！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-4039
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要声明一次数据类型。当我们告诉计算机某个变量将存储整数时，之后就不需要再告诉它了。事实上，如果我们再告诉它，Xcode 会给我们一个错误。一旦数据类型被声明，变量或常量将永远存储该类型的数据。一旦是整数，永远是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-4040
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件关于数据类型的事需要知道：一个变量或常量不能存储与其数据类型不匹配的内容。例如，如果你试图把一个十进制数字赋值给 numberOfWindowsOpen，你将会得到一个错误，如[图
    2-6](text00012.html#ch02fig6)所示。
- en: '![image](Image00049.jpg)'
  id: totrans-4041
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-4042
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：你不能把十进制数字赋值给一个应该存储整数的变量。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-4043
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 numberOfWindowsOpen = 5 和 numberOfWindowsOpen = 0 是有效的并且可以正常工作。但你不能设置 numberOfWindowsOpen
    = 1.5。
- en: '**COMMON DATA TYPES**'
  id: totrans-4044
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-4045
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚才学到的，数据类型让计算机知道它正在处理什么*类型*的数据以及如何将其存储在内存中。那么，数据类型有哪些呢？一些常见的数据类型包括 Int、Double、Float、Bool
    和 String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-4046
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下这些到底是什么！
- en: '**Int (Integers)**'
  id: totrans-4047
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Int（整数）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-4048
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经简要讨论过整数，但让我们再详细讲解一下。整数，在 Swift 中被称为 Int，是没有小数部分或分数部分的整数。你可以把它们看作是计数数字。整数是*有符号的*，意味着它们可以是负数、正数（或零）。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-4049
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Double 和 Float（十进制数字）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-4050
  prefs: []
  type: TYPE_NORMAL
  zh: '*十进制数字*是指小数点后有数字的数字，比如 3.14。 （像 3 这样的整数如果你想将其作为十进制数字写，就需要写成 3.0。）有两种数据类型可以存储十进制数字：Double
    和 Float（即*浮动点数*的缩写）。在 Swift 中，Double 数据类型更常见，因为它可以存储更大的数字，所以我们将重点讲解 Double。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-4051
  prefs: []
  type: TYPE_NORMAL
  zh: 当你给 Double 赋值时，必须始终在小数点左侧有一个数字，否则会出现错误。例如，假设每个香蕉的价格是 19 分：
- en: '![Image](Image00050.jpg)'
  id: totrans-4052
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-4053
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码会导致错误，因为它没有在小数点左侧有数字。➋ 处的代码正常工作，因为它有一个前导零。（// ERROR 和 // CORRECT 是*注释*，是程序中的注释，计算机会忽略它们。请参见
    “[关于注释的简短说明](text00012.html#ch02sb01)” 在[第 32 页](text00012.html#page_32)。）
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-4054
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Bool（布尔值，或True/False）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-4055
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值*只能是两种状态之一：true或false。在Swift中，布尔数据类型被称为Bool。'
- en: '![Image](Image00051.jpg)'
  id: totrans-4056
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-4057
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值通常用于if-else语句中，告诉计算机程序应该走哪条路径。（我们将在[第3章](text00013.html#ch03)中更详细地讨论布尔值和if-else语句。）
- en: '**String**'
  id: totrans-4058
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**String**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-4059
  prefs: []
  type: TYPE_NORMAL
  zh: String数据类型用于存储单词和短语。一个*字符串*是由引号括起来的一组字符。例如，"Hello, playground"就是一个字符串。字符串可以由各种字符组成：字母、数字、符号等等。引号很重要，因为它们告诉计算机，引号中的所有内容都是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-4060
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串连接在一起的方式构建句子，这个过程称为字符串*连接*。让我们看看它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-4061
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-4062
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用加号（+）将字符串连接在一起，这段代码创建了一个名为specialGreeting的变量，其值为字符串"Good Morning Jude"。请注意，我们需要在morningGreeting和friend之间添加一个包含空格字符（"
    "）的字符串，否则specialGreeting将是"Good MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-4063
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-4064
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-4065
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，有时我们声明变量时会包括数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-4066
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-4067
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们也不包括数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-4068
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-4069
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事？实际上，计算机足够智能，大多数情况下能推断出数据类型。这就是*类型推断*——计算机会根据我们提供的线索来*推断*，或者说猜测我们使用的数据类型。当你创建一个变量并给它一个初始值时，这个值就是计算机的重要线索。以下是一些例子：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-4070
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你分配一个没有小数点的数字（如3），计算机会认为它是一个Int类型。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-4071
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你分配一个带有小数点的数字（如3.14），计算机会认为它是一个Double类型。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-4072
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你分配*true*或*false*（没有引号），计算机会认为它是一个Bool类型。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-4073
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你分配一个或多个用引号括起来的字符，计算机会认为它是一个String类型。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-4074
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量会被设置为该数据类型，就像你自己声明数据类型一样。这是为了方便起见。你可以在每次声明新的常量或变量时都包括数据类型，这完全没问题。但是为什么不让计算机自己推断出来，节省时间和额外的输入呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-4075
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**通过类型转换变换数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-4076
  prefs: []
  type: TYPE_NORMAL
  zh: '*转换* 是一种暂时改变变量或常量数据类型的方法。你可以把它当作对变量施下的一个魔法——它使得变量的值暂时表现得像另一种数据类型，但仅仅是短暂的。为了实现这一点，你需要写出新的数据类型，后面跟上括号，括号内是你要转换的变量。请注意，这
    *并不会实际改变数据类型*。它只是为那一行代码提供了一个临时的值。这里有一些 Int 和 Double 之间转换的示例。查看代码运行后的结果。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-4077
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![Image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-4078
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Int 类型的变量 months 转换为 Double 类型，并将结果存储在一个新的变量 doubleMonths 中。这添加了一个小数点，转换后的结果是
    12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-4079
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将 Double 转换为 Int：
- en: '![Image](Image00058.jpg)'
  id: totrans-4080
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-4081
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Double 类型的变量 days 转换为 Int 类型。你可以看到，小数点和所有后面的数字都被移除了：我们的数字变成了 365。这是因为
    Int 类型无法容纳小数值——它只能存储整数，所以小数点后的部分被去掉了。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-4082
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，转换并不会真正改变数据类型。在我们的示例中，即使经过转换，days *仍然*是一个 Double 类型。我们可以通过打印 days 来验证这一点。
- en: '![Image](Image00059.jpg)'
  id: totrans-4083
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-4084
  prefs: []
  type: TYPE_NORMAL
  zh: 结果侧边栏显示 days 仍然等于 365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-4085
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将展示一些何时使用转换的示例。所以如果你现在还不清楚为什么要转换变量，稍等片刻就会明白！
- en: '**OPERATORS**'
  id: totrans-4086
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-4087
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中有许多算术运算符可供你使用来做数学运算。你已经见过基本的赋值运算符 = 。你可能也很熟悉加法 (+)、减法 (-)、乘法 (*) 和除法
    (/ )。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-4088
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符对 Int、Float 和 Double 数据类型进行数学运算。进行运算的数字被称为 *操作数*。通过在 playground 中输入类似以下的代码来实验这些数学运算符：
- en: '![Image](Image00060.jpg)'
  id: totrans-4089
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-4090
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 playground 中输入这段代码，你将在侧边栏看到每个数学表达式的结果。编写数学表达式的代码与正常书写没有太大区别。例如，16 减 2 写作
    16 – 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-4091
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数学表达式的结果保存在一个变量或常量中，以便在代码的其他地方使用。要查看如何操作，请在 playground 中输入以下代码：
- en: '![Image](Image00061.jpg)'
  id: totrans-4092
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-4093
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印 sum ➊ 时，你将在侧边栏看到 7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-4094
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们仅在数学表达式中使用了数字，但数学运算符也适用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-4095
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的 playground 中：
- en: '![Image](Image00062.jpg)'
  id: totrans-4096
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-4097
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以像对数字一样，对变量和常量使用数学运算符。
- en: '**SPACES MATTER**'
  id: totrans-4098
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-4099
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，运算符两边的空格很重要。你可以在数学运算符的两边都写一个空格，或者完全不加空格。但不能只在运算符的一侧加空格，而另一侧不加。这会导致错误。看看[图2-7](text00012.html#ch02fig7)。
- en: '![image](Image00063.jpg)'
  id: totrans-4100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-4101
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-7：确保在运算符的两侧有相同数量的空格。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-4102
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点需要注意：你只能对**相同**数据类型的变量或常量使用数学运算符。在前面的代码中，`3`和`5`都是`Int`类型，常量`half`和`quarter`是`Double`类型，因为它们是小数。如果你尝试将`Int`和`Double`相加或相乘，你会遇到像[图2-8](text00012.html#ch02fig8)中那样的错误。
- en: '![image](Image00064.jpg)'
  id: totrans-4103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-4104
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-8：在Swift中，不能在不同数据类型之间做数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-4105
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你真的想在不同数据类型之间做数学运算怎么办？例如，假设你想计算自己年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-4106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-4107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行会导致错误，因为我们尝试将`Int`类型与`Double`类型相乘。但别担心！你有几个选项来确保操作数的数据类型一致。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-4108
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是将`myAge`声明为`Double`类型，如下所示：
- en: '![Image](Image00066.jpg)'
  id: totrans-4109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-4110
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以正常工作，因为我们正在乘以两个`Double`类型的数据。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-4111
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是使用类型转换。（我告诉过你我们会回到这个话题！）在这种情况下，类型转换是一个很好的解决方案，因为我们不想永久性地将`myAge`更改为`Double`类型，我们只是希望能够像处理`Double`类型一样进行数学运算。让我们看一个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-4112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-4113
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们在乘法之前将`myAge`转换为`Double`。这意味着我们不再有混合类型，因此代码可以正常运行。但在➋处我们将会得到一个错误。这是因为`myAge`仍然是`Int`类型。将其在➊处转换为`Double`并没有永久地将其改变为`Double`类型。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-4114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`multiplier`转换为`Int`吗？当然可以！那样我们就可以在两个整数上进行运算，这样也能正常工作。然而，这会导致计算结果不够精确，因为我们会丢失小数部分。当你将一个`Double`类型的变量转换为`Int`时，计算机会简单地去掉小数点后的数字，使它成为一个整数。在这种情况下，`0.1`会被转换为`Int`类型的`0`。让我们在playground中转换一些变量，看看会得到什么：
- en: '![Image](Image00068.jpg)'
  id: totrans-4115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-4116
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，将我们的`Double`类型的`multiplier`转换为`Int`后得到0。这个值在转换后有很大不同，因为我们丢失了小数部分：0.1变成了0。如果我们没有预料到这种情况，这在代码中可能会是一个非常糟糕的情况。你在进行类型转换时必须小心，确保不会意外改变你的值。在➋处，还有另一个将`Double`类型转换为`Int`的例子，如你所见，1.9没有被四舍五入为2。它的小数部分被去掉，我们只剩下1。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-4117
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个数学运算符，*取模运算符*（%），你可能不太熟悉。取模运算符（也叫 *模*）返回除法的余数。例如，7 % 2 = 1，因为 7 除以 2 的余数是
    1。你可以在你的开发环境中尝试一下取模运算符，如下所示。
- en: '![Image](Image00069.jpg)'
  id: totrans-4118
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-4119
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，取模运算符对于确定一个数字是偶数（evenNumber % 2 等于 0）➊ 或奇数（oddNumber % 2 等于 1）➋ 非常有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-4120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算顺序**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-4121
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们每行代码只进行了一次数学运算，但在一行代码中进行多次运算是很常见的。我们来看一个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-4122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元的钞票和两张一美元的钞票，你有多少钱？我们在一行内计算一下：
- en: '![Image](Image00070.jpg)'
  id: totrans-4123
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-4124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将值 17 赋给 myMoney。计算机先计算 5 乘以 3，然后再加上 2。但是，计算机怎么知道先进行乘法，再加 2 呢？它只是从左到右计算吗？不！看看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-4125
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-4126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调整了数字的位置，但结果仍然是 17。如果计算机只是从左到右进行计算，它会先加上 2 + 5 得到 7。然后，它会将结果 7 乘以 3 得到 21。尽管我们改变了数学表达式中数字的顺序，计算机仍然先进行乘法（得到
    15），然后加上 2 得到 17。*计算机始终会先做乘法和除法，再做加法和减法*。这就是所谓的 *运算顺序*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-4127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号来排列运算顺序**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-4128
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要像我们在钱的例子中那样依赖计算机来决定先做哪一步。你，程序员，才是决定的权力所在！你可以使用括号将运算分组。当你给某个部分加上括号时，你是在告诉计算机先做那一步：
- en: '![Image](Image00072.jpg)'
  id: totrans-4129
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-4130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，括号告诉计算机先计算 5 乘以 3，再加 2。这将得到 17。在 ➋ 处，括号告诉计算机先将 2 和 5 相加，然后再将结果乘以 3，得到
    21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-4131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在括号内再嵌套括号来使代码更加具体。计算机会先计算内层括号中的内容，然后再计算外层括号中的内容。试试看这个例子：
- en: '![Image](Image00073.jpg)'
  id: totrans-4132
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-4133
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机会先在内层括号内计算 2 和 3 的和。然后，它会将结果乘以 4，因为这个运算是在外层括号中。最后，它会将 1 加到结果中，因为 1 在两个括号外面。最终结果是
    21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-4134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值运算符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-4135
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的另一个运算符类别是 *复合赋值运算符*。这些是将数学运算符与赋值运算符（=）结合的“快捷”运算符。例如，下面的表达式
- en: '[PRE120]'
  id: totrans-4136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: becomes
  id: totrans-4137
  prefs: []
  type: TYPE_NORMAL
  zh: 变成
- en: '[PRE121]'
  id: totrans-4138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-4139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符通过对变量或常量执行操作来更新其值。用简单的语言来说，像a += b这样的表达式意味着“将b加到a上，并将新值存储回a。”[表2-1](text00012.html#ch2tab1)展示了使用复合赋值运算符的数学表达式及其长形式的表达式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-4140
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-1：** 简短形式赋值运算符与长形式表达式'
- en: '| **Short form** | **Long form** |'
  id: totrans-4141
  prefs: []
  type: TYPE_TB
  zh: '| **简短形式** | **长形式** |'
- en: '| --- | --- |'
  id: totrans-4142
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-4143
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-4144
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-4145
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-4146
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-4147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下+=运算符的实际应用。假设我们正在写一个程序来计算方舟上的动物数量。首先，我们创建一个名为animalsOnArk的变量并将其设置为0，因为方舟上还没有动物。当不同种类的动物登上方舟时，我们想增加animalsOnArk的值，以便统计所有动物的数量。如果两只长颈鹿登上了方舟，我们就需要将2加到animalsOnArk中。如果两只大象登上了方舟，我们也需要再加2。如果四只羚羊登上了方舟，我们就需要将animalsOnArk增加4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-4148
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00074.jpg)![Image](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-4149
  prefs: []
  type: TYPE_NORMAL
  zh: 在两只长颈鹿、两只大象和四只羚羊登上方舟后，animalsOnArk的最终值为8。真是个动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-4150
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的一些快速评论**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-4151
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都提供了一种方式，可以将注释写在代码中。注释是计算机会忽略的备注，用来帮助阅读代码的人理解代码的作用。虽然没有注释程序也能正常运行，但在代码中不明确或容易混淆的部分加上注释是一个好主意。即使你不打算把程序展示给别人，注释也能帮助你记住写这段代码时的思路和目的。你可能会发现，几个月或几年前写的代码再看时，已经完全不记得当时的思考过程。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-4152
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中有两种添加注释的方式。第一种方式是在你想添加的文本前面加上两个斜杠（//）。这些注释可以单独放在一行，比如这样：
- en: '[PRE122]'
  id: totrans-4153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-4154
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它们也可以与代码行放在同一行——只要注释出现在代码*之后*：
- en: '[PRE123]'
  id: totrans-4155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-4156
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式用于长注释，或*多行*注释，其中注释的开始和结束由/*和*/标记。（注意，本书中我们会使用-- *snip* --来表示省略了的代码行，以节省空间。）
- en: '[PRE124]'
  id: totrans-4157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-4158
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不希望计算机运行某部分代码，因为你正在寻找bug，但又不想删除你辛苦写的所有代码，你可以使用多行注释来*暂时注释掉*代码段。当你把一段代码格式化为注释时，计算机会像忽略其他注释一样忽略这段代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-4160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在 Swift 游乐场中编写代码，它可以让你立刻看到结果。你创建了变量和常量，并学会了如何使用基本的数据类型和运算符，这些你在编写程序时会反复使用。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-4161
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](text00013.html#ch03)中，你将使用条件语句，它告诉计算机你希望它执行哪个代码路径。代码路径的选择是基于条件的值。
- en: '![image](Image00039.jpg)'
  id: totrans-4162
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00039.jpg)'
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-4163
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-4：在调试区域查看程序的实际输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-4164
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以在你的程序中改变（或*变化*！），所以你可以改变变量的值来存储其他内容。现在我们来试试。将以下几行代码添加到你的游乐场。
- en: '![Image](Image00040.jpg)'
  id: totrans-4165
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-4166
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变一个变量的值，输入其名称并使用 = 运算符将其设置为新值。我们在 ➊ 处这样做，将 str 的值改为 "Hello, world"。计算机会丢弃
    str 原本存储的内容，并说：“好的，老板，str 现在是 Hello, world” （如果它能说话的话！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-4167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们改变 str 的值时，并没有再次写 var。计算机会记得我们之前声明了 str，并知道 str 已经存在。所以我们不需要再次创建 str。我们只需要给它放入不同的内容。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-4168
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以声明*常量*。像变量一样，常量也可以存储值。常量与变量的最大区别在于，常量的值永远不能改变。变量可以变化，而常量则是，嗯，恒定不变的！声明常量与声明变量类似，但我们使用
    let 而不是 var：
- en: '![Image](Image00041.jpg)'
  id: totrans-4169
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-4170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 myName 的常量，并赋值为 "Gloria"。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-4171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个常量并赋值，它将一直保持这个值，直到时间的尽头。可以把常量想象成一块大岩石，你把值刻在了岩石上。如果你尝试给 myName 赋另一个值，比如
    "Matt"，你会看到像 [图 2-5](text00012.html#ch02fig5) 中那样的错误。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-4172
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00042.jpg)![image](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-4173
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：尝试改变常量的值是行不通的。*'
- en: '**NOTE**'
  id: totrans-4174
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-4175
  prefs: []
  type: TYPE_NORMAL
  zh: '*在游乐场中，错误会以一个红色圆圈和其中的小白点显示。点击错误标记会显示错误信息，并告诉你哪里出错了。如果你显示了调试区域，你还应该能看到描述发生了什么的消息，有时甚至会告诉你如何修复它。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-4176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-4177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量——做得好！但是，什么时候应该使用变量，什么时候使用常量呢？在 Swift 中，最好是使用常量而非变量，除非你预计该值会发生变化。常量有助于使代码更加“安全”。如果你知道某个值永远不会改变，为什么不把它刻在石头上，避免以后可能的混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-4178
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想跟踪教室中窗户的总数以及今天打开的窗户数量。教室中的窗户数量不会变化，因此应该使用常量来存储这个值。而教室中打开的窗户数量会根据天气和时间变化，因此应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-4179
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00044.jpg)![Image](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-4180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 numberOfWindows 设置为常量并将其值设为 8，因为总窗户数始终为 8。我们将 numberOfWindowsOpen 设置为变量并将其值设为
    3，因为我们希望在开关窗户时更改这个值。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-4181
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用 var 来声明变量，使用 let 来声明常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-4182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**命名常量和变量**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-4183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以给变量或常量命名几乎任何你想要的名字，但有一些例外。你不能使用 Swift 中已经是保留字的名称。例如，你不能命名一个变量为 var。写 var
    var 会让你和计算机都感到困惑。如果你尝试使用 Swift 的保留字来命名变量或常量，编译器会报错。此外，在同一段代码中，你也不能使用相同的名字命名两个变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-4184
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则之外，在 Swift 中命名时，还有一些其他的良好编程规范。你的变量名应该始终以小写字母开头。使用*非常*具有描述性的名字也是一个好主意（它们可以长到你想要的程度）。当你使用描述性名称时，理解这个变量或常量的含义会容易得多。如果你在查看别人写的代码，你会更容易理解哪个变量名：numKids
    还是 numberOfKidsInMyClass？第一个名字比较模糊，而第二个名字则更具描述性。常见的做法是将多个单词连接在一起作为变量名，例如 numberOfKidsInMyClass。这个命名风格，其中每个单词的首字母大写，当多个单词连接在一起构成变量名时，叫做*驼峰式命名*。之所以叫做驼峰式命名，是因为这种大小写字母的交替看起来像骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-4185
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-4186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-4187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，你可以选择变量或常量所持有的数据类型—即*数据类型*。记得我们之前说过，你可以把变量看作一个容器，它用来存放某些东西？那么，数据类型就像是容器的类型。计算机需要知道我们将要放入每个容器中的东西是什么。在
    Swift 编程中，一旦你告诉计算机某个变量或常量要持有某种数据类型，它就不会允许你将除该数据类型以外的任何东西放入该变量或常量。如果你有一个专门用来装土豆的篮子，把篮子装满水肯定是不合适的—除非你喜欢水洒得到处都是！
- en: '![image](Image00047.jpg)'
  id: totrans-4188
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-4189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-4190
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，你可以告诉计算机它将保存什么类型的数据。在我们关于教室窗户的示例中，我们知道这个变量将始终是一个*整数*（也就是说，一个整数——你不可能有半个窗户），因此我们可以指定一个整数数据类型，如下所示：
- en: '![Image](Image00048.jpg)'
  id: totrans-4191
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-4192
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号意味着“是某种类型”。用通俗的话来说，这行代码表示：“变量 numberOfWindowsOpen，是一个整数，等于 3。”因此，这行代码创建了一个变量，给它命名，告诉计算机它的数据类型，并为它赋值。呼！一行代码完成了这一切？我们提到过
    Swift 是一门非常*简洁*的语言吗？有些语言可能需要几行代码才能完成同样的事情。Swift 的设计理念是让你只用一行代码就能做很多事情！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-4193
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要声明一次数据类型。当我们告诉计算机一个变量将保存整数时，我们不需要再次告诉它。事实上，如果我们这么做，Xcode 会给我们一个错误。一旦数据类型被声明，变量或常量将永远保存该类型的数据。一旦是整数，永远是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-4194
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要知道关于数据类型的一件事：变量或常量不能保存不属于其数据类型的内容。例如，如果你尝试将一个小数放入 numberOfWindowsOpen 中，你会得到一个错误，如
    [图 2-6](text00012.html#ch02fig6) 所示。
- en: '![image](Image00049.jpg)'
  id: totrans-4195
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-4196
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：你不能将小数放入本应保存整数的变量中。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-4197
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 numberOfWindowsOpen = 5 和 numberOfWindowsOpen = 0 是有效的并且可以正常工作。但是你不能设置 numberOfWindowsOpen
    = 1.5。
- en: '**COMMON DATA TYPES**'
  id: totrans-4198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-4199
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚刚学到的，数据类型让计算机知道它正在处理的是哪种*类型*的数据，以及如何将其存储在内存中。那么，数据类型有哪些呢？一些常见的数据类型包括 Int、Double、Float、Bool
    和 String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-4200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下这些数据类型到底是什么！
- en: '**Int (Integers)**'
  id: totrans-4201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Int（整数）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-4202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经稍微提到过整数了，但让我们更详细地了解它们。整数，在 Swift 中称为 Int，是没有小数或分数部分的整数。你可以将它们看作是计数数字。整数是*有符号*的，意味着它们可以是负数、正数或零。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-4203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Double 和 Float（小数）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-4204
  prefs: []
  type: TYPE_NORMAL
  zh: '*小数*是那些小数点后有数字的数字，如 3.14（如果你想将整数 3 作为小数表示，可以写作 3.0）。有两种数据类型可以存储小数：Double 和
    Float（即*浮动点数*）。由于 Double 类型可以存储更大的数字，因此它在 Swift 中更为常见，所以我们将重点介绍 Double。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-4205
  prefs: []
  type: TYPE_NORMAL
  zh: 当你赋值一个 Double 类型时，必须始终在小数点左边有一个数字，否则会出现错误。例如，假设香蕉每个成本 19 分钱：
- en: '![Image](Image00050.jpg)'
  id: totrans-4206
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-4207
  prefs: []
  type: TYPE_NORMAL
  zh: ➊处的代码将会报错，因为它没有小数点左侧的数字。➋处的代码运行正常，因为它有一个前导零。（“// ERROR”和“// CORRECT”是*注释*，它们是程序中的注释，计算机会忽略这些注释。详情请见[“关于注释的简短说明”](text00012.html#ch02sb01)，位于[第32页](text00012.html#page_32)。）
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-4208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Bool（布尔值，或真/假）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-4209
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*布尔值*只能是两者之一：true 或 false。在Swift中，布尔数据类型被称为Bool。
- en: '![Image](Image00051.jpg)'
  id: totrans-4210
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-4211
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值通常用于if-else语句中，告诉计算机程序应该走哪条路径。（我们将在[第3章](text00013.html#ch03)中更详细地讨论布尔值和if-else语句。）
- en: '**String**'
  id: totrans-4212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**String**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-4213
  prefs: []
  type: TYPE_NORMAL
  zh: String数据类型用于存储单词和短语。*字符串*是由引号括起来的一组字符。例如，"Hello, playground"就是一个字符串。字符串可以由各种字符组成：字母、数字、符号等等。引号非常重要，因为它们告诉计算机，引号之间的所有内容都是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-4214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串连接在一起的方式来构建句子，这个过程叫做字符串*连接*。让我们看看它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-4215
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-4216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用加号（+）将字符串连接起来，这段代码创建了一个名为specialGreeting的变量，并将字符串"Good Morning Jude"作为其值。请注意，在morningGreeting和friend之间需要添加一个包含空格字符（"
    "）的字符串，否则specialGreeting的值将是"Good MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-4217
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-4218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-4219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，当我们声明一个变量时，有时会包括数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-4220
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-4221
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们并不包括数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-4222
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-4223
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事？计算机实际上足够聪明，能够大部分时间根据我们提供的线索推断数据类型。这叫做*类型推断* ——因为计算机会*推断*或猜测我们使用的数据类型。每当你创建一个变量并给它一个初始值时，这个值就是计算机的一大线索。以下是一些例子：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-4224
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你分配一个没有小数值的数字（比如3），计算机将假定它是一个Int。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-4225
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你分配一个带小数值的数字（比如3.14），计算机将假定它是一个Double。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-4226
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你分配单词*true*或*false*（没有引号），计算机将假定它是一个Bool。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-4227
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你分配一个或多个带引号的字符，计算机将假定它是一个String。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-4228
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型是推断出来时，变量或常量会被设置为该数据类型，就像你自己声明了数据类型一样。这完全是为了方便。你可以在每次声明新常量或变量时都指定数据类型，这完全没有问题。但是，为什么不让计算机自动推断出来，节省时间并减少额外的输入呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-4229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**通过强制类型转换改变数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-4230
  prefs: []
  type: TYPE_NORMAL
  zh: '*强制类型转换*是一种临时改变变量或常量数据类型的方式。你可以把它当作给变量施了一个“魔法”——让它的值暂时像其他数据类型一样，但只在短时间内。要做到这一点，你需要写一个新的数据类型，并在后面加上括号，括号中是你要转换的变量。请注意，这*并不会真正改变数据类型*。它只是为那一行代码提供了一个临时值。以下是一些Int和Double之间的强制类型转换示例。查看代码结果的侧边栏，看看它们的表现。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-4231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00056.jpg)![图片](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-4232
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将Int类型的变量months转换为Double类型，并将其存储在一个名为doubleMonths的新变量中。这为结果添加了一个小数位，转换的结果是12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-4233
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将Double类型转换为Int类型：
- en: '![Image](Image00058.jpg)'
  id: totrans-4234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-4235
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，我们将Double类型的变量days强制转换为Int类型。你可以看到小数点及其后面的所有数字都被去掉了：我们的数字变成了365。这是因为Int类型无法存储小数—它只能包含整数，因此小数点后的任何内容都会被舍去。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-4236
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，强制类型转换并不会真正改变数据类型。在我们的示例中，即使进行了强制类型转换，days*依然*是Double类型。我们可以通过打印days来验证这一点：
- en: '![Image](Image00059.jpg)'
  id: totrans-4237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-4238
  prefs: []
  type: TYPE_NORMAL
  zh: 结果侧边栏显示，days仍然等于365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-4239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍一些使用强制类型转换的示例。所以，如果你现在还不清楚为什么要强制转换变量，稍等一下，继续看下去！
- en: '**OPERATORS**'
  id: totrans-4240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-4241
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中有许多算术运算符，你可以用来进行数学计算。你已经见过基本的赋值运算符=。你可能也熟悉加法（+）、减法（-）、乘法（*）和除法（/）。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-4242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符对Int、Float和Double数据类型进行数学运算。正在操作的数字被称为*操作数*。通过在你的Playground中输入如下代码，来实验这些数学运算符：
- en: '![Image](Image00060.jpg)'
  id: totrans-4243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-4244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Playground中输入此代码，你将看到每个数学表达式的结果出现在侧边栏。编写数学表达式的代码与正常写法并没有太大区别。例如，16减去2写作16
    - 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-4245
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数学表达式的结果保存到一个变量或常量中，这样你就可以在代码的其他地方使用它。要查看这如何工作，请在你的 Playground 中输入以下几行：
- en: '![Image](Image00061.jpg)'
  id: totrans-4246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-4247
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印sum➊时，你会在侧边栏看到7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-4248
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在数学表达式中只使用了数字，但数学运算符也可以作用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-4249
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的 Playground 中：
- en: '![Image](Image00062.jpg)'
  id: totrans-4250
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-4251
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你可以像对待数字一样在变量和常量上使用数学运算符。
- en: '**SPACES MATTER**'
  id: totrans-4252
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-4253
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，运算符两边的空格很重要。你可以在数学运算符的两侧写空格，或者完全不写空格。但不能只在运算符的一侧放空格，而另一侧不放空格。这样会导致错误。请查看
    [图 2-7](text00012.html#ch02fig7)。
- en: '![image](Image00063.jpg)'
  id: totrans-4254
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-4255
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：确保运算符两边的空格数量相同。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-4256
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件重要的事情需要注意：你只能对*相同*数据类型的变量或常量使用数学运算符。在前面的代码中，三和五都是 Int 数据类型。常量 half 和 quarter
    是 Double 数据类型，因为它们是小数。如果你试图将 Int 和 Double 相加或相乘，你会得到一个像 [图 2-8](text00012.html#ch02fig8)
    中的错误。
- en: '![image](Image00064.jpg)'
  id: totrans-4257
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-4258
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-8：在 Swift 中，混合数据类型不能进行数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-4259
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你真的想对混合数据类型进行数学运算呢？例如，假设你想计算你年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-4260
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-4261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行会出现错误，因为我们试图将 Int 和 Double 相乘。但不用担心！你有几个选项可以确保操作数是相同的数据类型。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-4262
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是将 myAge 声明为 Double 类型，像这样：
- en: '![Image](Image00066.jpg)'
  id: totrans-4263
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-4264
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码能正常工作，因为我们在乘法中使用了两个 Double 类型的数据。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-4265
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是使用类型转换。（我告诉过你我们会回来讲这个！）类型转换在这种情况下是一个很好的解决方案，因为我们不想永久地将 myAge 转换为 Double
    类型，我们只是希望能够像对待 Double 类型一样进行数学运算。让我们来看一个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-4266
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-4267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们在乘法之前将 myAge 转换为 Double 类型。这意味着我们不再有混合数据类型，因此代码能正常工作。但在 ➋ 处，我们将遇到一个错误。那是因为
    myAge 仍然是 Int 类型。在 ➊ 处将其转换为 Double 并没有永久改变其数据类型。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-4268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能将 multiplier 转换为 Int 吗？当然可以！然后我们就在做两个整数的数学运算，这样是可以的。不过，这样会导致计算不够精确，因为我们会丢失小数点。当你将
    Double 类型的变量转换为 Int 类型时，计算机会简单地去掉小数部分，使其变成整数。在这个例子中，你的 multiplier 0.1 会被转换为 Int
    类型的 0。让我们在 Playground 中转换一些变量，看看会得到什么结果：
- en: '![Image](Image00068.jpg)'
  id: totrans-4269
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-4270
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，将我们的 Double 类型的乘数转换为 Int 类型，结果是0。这个值在转换后发生了很大的变化，因为我们丢失了小数部分：0.1变成了0。如果我们没有预料到这个情况，这可能会在代码中造成很大的问题。进行类型转换时，你必须小心，以确保不会意外更改值。在
    ➋ 处，这是另一个将 Double 转换为 Int 的例子，正如你所看到的，1.9没有被四舍五入到2。它的小数部分被直接去除，结果是1。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-4271
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个数学运算符，*取模运算符*（%），可能对你来说并不那么熟悉。取模运算符（也叫*模数*）在除法运算后返回余数。例如，7 % 2 = 1，因为7除以2的余数是1。你可以在你的练习环境中尝试一下取模运算符，具体如下。
- en: '![Image](Image00069.jpg)'
  id: totrans-4272
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-4273
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，取模运算符对于判断一个数字是偶数（evenNumber % 2 等于0）➊ 还是奇数（oddNumber % 2 等于1）➋ 非常有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-4274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算顺序**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-4275
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们每行代码只进行了一个数学运算，但在一行代码中做多个运算是很常见的。我们来看一个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-4276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元的纸币和两张一美元的纸币，你有多少钱？我们可以在一行代码中计算这个：
- en: '![Image](Image00070.jpg)'
  id: totrans-4277
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-4278
  prefs: []
  type: TYPE_NORMAL
  zh: 这将一个值17赋给myMoney。计算机会先做5乘3的运算，再加2。但计算机是如何知道先乘法再加2的呢？它是仅仅从左到右做吗？不！看看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-4279
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-4280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调整了数字顺序，结果仍然是17。如果计算机只是从左到右执行，它会先加2 + 5，得到7。然后，它会将这个结果7乘以3，得到21。即使我们改变了数学表达式中数字的顺序，计算机仍然会先进行乘法（得到15），然后再加上2，最终得到17。*计算机总是先做乘法和除法，然后做加法和减法。*
    这就是*运算顺序*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-4281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号排列运算**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-4282
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要像在钱的例子中那样依赖计算机来决定先做哪个步骤。你，作为程序员，拥有决定权！你可以使用括号将运算组合在一起。当你在某个步骤周围加上括号时，你告诉计算机先做那一步：
- en: '![Image](Image00072.jpg)'
  id: totrans-4283
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-4284
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，括号告诉计算机先做5乘3的运算，再加2。这样你会得到17。在 ➋ 处，括号告诉计算机先做2加5的运算，然后将结果乘以3，这样你会得到21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-4285
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在括号内使用其他括号来让代码更加精确。计算机会先计算内层的括号，然后计算外层的括号。试试这个例子：
- en: '![Image](Image00073.jpg)'
  id: totrans-4286
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-4287
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-4288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-4289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-4290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: becomes
  id: totrans-4291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-4292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-4293
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-4294
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-4295
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-4296
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-4297
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-4298
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-4299
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-4300
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-4301
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-4302
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-4303
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-4304
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-4305
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-4306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-4307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-4308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-4309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-4310
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式用于长注释或*多行*注释，注释的开始和结束由 /* 和 */ 标记。（注意，在本书中，我们将使用 -- *snip* -- 来表示由于篇幅问题省略的更多代码行。）
- en: '[PRE129]'
  id: totrans-4311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-4312
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不希望计算机运行代码的某一部分，因为你正在找 bug，但又不想删除你所有的努力成果，你可以使用多行注释来*临时注释掉*代码的部分内容。当你将一段代码格式化为注释时，计算机会忽略这些代码，就像它忽略其他注释一样。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-4314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在 Swift Playground 中编写代码，这样你可以立刻看到结果。你创建了变量和常量，并学习了如何使用基本的数据类型和操作符，这些会在你编写自己的计算机程序时反复出现。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-4315
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](text00013.html#ch03)中，你将使用条件语句，这些语句告诉计算机你希望它执行哪条代码路径。代码路径是根据条件的值来选择的。
- en: '*Figure 2-4: Viewing the real output of your program in the debug area*'
  id: totrans-4316
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-4：在调试区域查看程序的实际输出*'
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-4317
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以在你的程序中改变（或*变化*！），所以你可以更改一个变量的值来存储其他内容。我们现在就试试这个。将以下几行添加到你的 Playground 中。
- en: '![Image](Image00040.jpg)'
  id: totrans-4318
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-4319
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改变量的值，输入其名称并使用 = 运算符将其设置为新值。我们在 ➊ 处这样做，以将 str 的值更改为 "Hello, world"。计算机会丢弃
    str 之前保存的任何内容，并说：“好的，老板，str 现在是 Hello, world”（如果它能说话的话，它会这么说！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-4320
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们更改 str 的值时，我们并没有再次写 var。计算机会记得我们在之前的代码行中声明了 str，并知道 str 已经存在。所以我们不需要重新创建
    str。我们只是想给它赋予一个不同的值。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-4321
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以声明*常量*。像变量一样，常量也保存值。常量和变量的最大区别在于，常量的值永远不能更改。变量可以变化，而常量则是恒定的！声明常量与声明变量类似，但我们使用
    let 而不是 var：
- en: '![Image](Image00041.jpg)'
  id: totrans-4322
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-4323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 myName 的常量，并将其赋值为 "Gloria"。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-4324
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个常量并赋予它一个值，它将一直保持这个值，直到永远。你可以把常量想象成一块大石头，你把你的值雕刻在其中。如果你试图给 myName 赋另一个值，比如
    "Matt"，你会遇到像[图2-5](text00012.html#ch02fig5)中的错误。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-4325
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00042.jpg)![image](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-4326
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-5：尝试更改常量的值是行不通的。*'
- en: '**NOTE**'
  id: totrans-4327
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-4328
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 playground 中，错误会显示为一个红色圆圈，里面有一个小白点。点击错误标记会显示错误信息，并告诉你哪里出了问题。如果你显示了调试区域，你还应该能看到描述发生了什么的信息，有时甚至能看到如何修复它。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-4329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**何时使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-4330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经成功地创建了一个变量和一个常量——做得好！但是，什么时候应该使用常量而不是变量呢？在 Swift 中，最佳实践是使用常量而非变量，除非你预计该值会发生变化。常量有助于使代码更加“安全”。如果你知道某个值永远不会改变，为什么不将其刻在石碑上，避免以后可能出现的混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-4331
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想跟踪教室中窗户的总数以及今天打开的窗户数量。教室中窗户的数量不会改变，因此你应该使用常量来存储这个值。然而，今天教室中打开的窗户数量会根据天气和时间变化，因此你应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-4332
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00044.jpg)![Image](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-4333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 numberOfWindows 设置为常量并赋值为 8，因为窗户的总数始终是 8。我们将 numberOfWindowsOpen 设置为变量并赋值为
    3，因为当我们打开或关闭窗户时，我们需要改变这个值。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-4334
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用 var 来表示变量，使用 let 来表示常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-4335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常量和变量命名**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-4336
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将变量或常量命名为几乎任何你想要的名称，但有几个例外。你不能将它们命名为 Swift 中已经存在的关键词。例如，你不能将一个变量命名为 var。写成
    var var 会让你和计算机都感到困惑。如果你尝试用 Swift 的保留字命名变量或常量，系统会报错。你也不能在同一个代码块中有两个同名的变量或常量。
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-4337
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些规则外，还有一些良好的编程规范在 Swift 中命名时应该遵循。你的命名应该始终以小写字母开头。使用*非常*具有描述性的名称也是一个好主意（它们可以尽可能长）。当你使用描述性名称时，更容易理解该变量或常量的用途。如果你在查看别人的代码时，你觉得哪个变量名更容易理解：numKids
    还是 numberOfKidsInMyClass？第一个变量名模糊不清，但第二个则描述得更清楚。常见的做法是将多个单词连在一起作为变量或常量的名称，比如 numberOfKidsInMyClass。这样命名的方式，即多个单词连接在一起时，每个单词的首字母都大写，这种命名风格被称为
    *驼峰命名法*。因为小写字母和大写字母的交替模式看起来像骆驼背上的驼峰。
- en: '![image](Image00046.jpg)'
  id: totrans-4338
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00046.jpg)'
- en: '**DATA TYPES**'
  id: totrans-4339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据类型**'
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-4340
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，你可以选择变量或常量要存储什么类型的数据——*数据类型*。记得我们说过，变量就像是一个容器，用来存储某些东西吗？那么，数据类型就像是容器的类型。计算机需要知道我们将在每个容器中放什么东西。在Swift编程中，一旦你告诉计算机一个变量或常量将存储某种数据类型，它就不允许你往这个变量或常量中放入其他类型的内容。如果你有一个专门用来装土豆的篮子，把它装满水就不是一个好主意——除非你喜欢水洒得到处都是！
- en: '![image](Image00047.jpg)'
  id: totrans-4341
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00047.jpg)'
- en: '**DECLARING DATA TYPES**'
  id: totrans-4342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**声明数据类型**'
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-4343
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个变量或常量时，你可以告诉计算机它将存储哪种类型的数据。在我们关于教室窗户的例子中，我们知道这个变量始终是一个*整数*（即一个完整的数字——你不可能有半个窗户），所以我们可以像这样指定一个整数数据类型：
- en: '![Image](Image00048.jpg)'
  id: totrans-4344
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00048.jpg)'
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-4345
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号表示“是……类型”。用通俗的语言来说，这行代码的意思是，“变量numberOfWindowsOpen是一个整数，其值为3。”所以这一行代码创建了一个变量，给它命名，告诉计算机它的数据类型，并为其赋值。呼！一行代码就完成了这些操作？我们有提到过Swift是一种非常*简洁*的语言吗？有些语言可能需要多行代码才能完成相同的操作。Swift的设计让你能够用一行代码做很多事！
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-4346
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需声明数据类型一次。当我们告诉计算机一个变量将存储整数时，不需要再次告诉它。事实上，如果我们这样做，Xcode会给出错误提示。数据类型一旦声明，变量或常量将永远保存该类型的数据。一旦是整数，永远是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-4347
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要了解数据类型的另一点：变量或常量不能存储不属于其数据类型的内容。例如，如果你尝试将一个小数值放入numberOfWindowsOpen中，你会遇到错误，如[图2-6](text00012.html#ch02fig6)所示。
- en: '![image](Image00049.jpg)'
  id: totrans-4348
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-4349
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-6：你不能将一个小数值放入应该存储整数的变量中。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-4350
  prefs: []
  type: TYPE_NORMAL
  zh: 设置numberOfWindowsOpen = 5和numberOfWindowsOpen = 0是有效的，也能正常工作。但你不能设置numberOfWindowsOpen
    = 1.5。
- en: '**COMMON DATA TYPES**'
  id: totrans-4351
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-4352
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚刚学到的，数据类型让计算机知道它正在处理哪种*类型*的数据，以及如何将其存储在内存中。那么，数据类型有哪些呢？一些常见的数据类型包括Int、Double、Float、Bool和String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-4353
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨一下每个部分到底是什么！
- en: '**Int (Integers)**'
  id: totrans-4354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Int（整数）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-4355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经简要讨论过整数，但让我们再详细讲一下。整数，在Swift中叫做Int，是没有小数或分数部分的整数。你可以把它们看作是计数数字。整数是*有符号*的，意味着它们可以是负数、正数或零。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-4356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**Double和Float（十进制数字）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-4357
  prefs: []
  type: TYPE_NORMAL
  zh: '*十进制数字*是指在小数点后有数字的数字，比如3.14。（如果你想把整数3写成十进制数字，它应该写作3.0。）有两种数据类型可以存储十进制数字：Double和Float（即*浮点数*）。由于Double数据类型能够存储更大的数字，所以在Swift中更为常见，因此我们将重点讲解Double。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-4358
  prefs: []
  type: TYPE_NORMAL
  zh: 当你赋值给一个Double时，必须确保小数点左侧有一个数字，否则会导致错误。例如，假设香蕉每个售价19美分：
- en: '![Image](Image00050.jpg)'
  id: totrans-4359
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-4360
  prefs: []
  type: TYPE_NORMAL
  zh: 代码➊会导致错误，因为它小数点左侧没有数字。代码➋则没有问题，因为它有一个前导零。（// ERROR和// CORRECT是*注释*，即程序中的注释，计算机会忽略这些内容。请参阅[《关于注释的简短说明》](text00012.html#ch02sb01)，位于[第32页](text00012.html#page_32)。）
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-4361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**布尔值（Boolean，或真/假）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-4362
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值*只能是两个值之一：true或false。在Swift中，布尔数据类型叫做Bool。'
- en: '![Image](Image00051.jpg)'
  id: totrans-4363
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-4364
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值常常用于if-else语句中，告诉计算机程序应该执行哪条路径。（我们将在[第3章](text00013.html#ch03)中更详细地讲解布尔值和if-else语句。）
- en: '**String**'
  id: totrans-4365
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符串（String）**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-4366
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串数据类型用于存储单词和短语。*字符串*是由一系列字符组成，并且这些字符被引号括起来。例如，“Hello, playground”就是一个字符串。字符串可以由各种字符组成：字母、数字、符号等。引号很重要，因为它告诉计算机，所有在引号之间的内容都是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-4367
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串相加来构建句子，这个过程叫做字符串*连接*。让我们看看它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-4368
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-4369
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用加号（+）将字符串连接在一起，这段代码创建了一个叫做specialGreeting的变量，并将"Good Morning Jude"作为它的值。注意，我们需要在morningGreeting和friend之间加上一个包含空格字符（"
    "）的字符串，否则specialGreeting的值将是"Good MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-4370
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-4371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-4372
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，有时我们声明变量时会包含数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-4373
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-4374
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们不会显式声明数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-4375
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-4376
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么回事？计算机实际上足够聪明，能在大多数情况下推断出数据类型。这被称为 *类型推断* ——因为计算机会*推断*，或者说猜测，我们使用的数据类型是基于我们提供的线索。当你创建一个变量并赋一个初始值时，这个值就是给计算机的一个重要线索。以下是一些例子：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-4377
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个没有小数的数字（如 3），计算机会认为它是一个 Int。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-4378
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个有小数值的数字（如 3.14），计算机会认为它是一个 Double。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-4379
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值的是单词 *true* 或 *false*（没有引号），计算机会认为它是一个 Bool。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-4380
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个或多个带引号的字符，计算机会认为它是一个 String。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-4381
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量会被设置为该数据类型，就像你自己声明了数据类型一样。这是出于方便考虑。你每次声明新的常量或变量时都可以包括数据类型，这完全没问题。但为什么不让计算机自动推断出来，省下时间和打字呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-4382
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**通过类型转换转换数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-4383
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换* 是一种临时转换变量或常量数据类型的方法。你可以把它想象成对变量施法——你让它的值像不同的数据类型一样表现，但只是短暂的。要做到这一点，你需要在括号中写上要转换的变量，括号前面写上新的数据类型。请注意，这*并不会实际改变数据类型*。它只是在那一行代码中提供一个临时的值。以下是一些在
    Int 和 Double 之间转换的例子。请查看代码结果旁边的结果。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-4384
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![Image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-4385
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Int 类型的变量 months 转换为 Double，并将结果存储在一个名为 doubleMonths 的新变量中。这添加了一个小数位，转换结果是
    12.0。
- en: 'You can also cast a Double to an Int :'
  id: totrans-4386
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将 Double 转换为 Int：
- en: '![Image](Image00058.jpg)'
  id: totrans-4387
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00058.jpg)'
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-4388
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，我们将 Double 类型的变量 days 转换为 Int。你可以看到小数位和它后面的所有数字都被去掉了：我们的数字变成了 365。这是因为
    Int 类型无法保存小数，它只能包含整数，所以小数点后面的部分会被截去。
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-4389
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，类型转换并不会真正改变数据类型。在我们的例子中，即使经过转换，days *仍然*是一个 Double。我们可以通过打印 days 来验证这一点：
- en: '![Image](Image00059.jpg)'
  id: totrans-4390
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00059.jpg)'
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-4391
  prefs: []
  type: TYPE_NORMAL
  zh: 结果旁边的显示结果表明，days 仍然等于 365.25。
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-4392
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将展示一些你在何时以及如何使用类型转换的例子。所以，如果你现在还不清楚为什么要转换变量，稍等片刻！
- en: '**OPERATORS**'
  id: totrans-4393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**运算符**'
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-4394
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中有许多算术运算符，你可以用它们进行数学运算。你已经见过基本的赋值运算符 =。你可能也熟悉加法（+）、减法（-）、乘法（*）和除法（/）。
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-4395
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符对 Int、Float 和 Double 数据类型进行数学运算。被操作的数字称为 *操作数*。通过在 Playground 中输入类似以下的代码来尝试这些数学运算符：
- en: '![Image](Image00060.jpg)'
  id: totrans-4396
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00060.jpg)'
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-4397
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Playground 中输入这段代码，你将在侧边栏看到每个数学表达式的结果。编写数学表达式与通常书写它们并没有太大区别。例如，16 减去 2
    写作 16 – 2。
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-4398
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以将数学表达式的结果保存在一个变量或常量中，以便在代码的其他地方使用。要查看如何操作，请在 Playground 中输入以下代码：
- en: '![Image](Image00061.jpg)'
  id: totrans-4399
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00061.jpg)'
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-4400
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印 sum ➊ 时，你会在侧边栏看到 7.6。
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-4401
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的数学表达式只用了数字，但数学运算符同样适用于变量和常量。
- en: 'Add the following code to your playground:'
  id: totrans-4402
  prefs: []
  type: TYPE_NORMAL
  zh: 向你的 Playground 添加以下代码：
- en: '![Image](Image00062.jpg)'
  id: totrans-4403
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00062.jpg)'
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-4404
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以像对数字进行运算那样使用数学运算符对变量和常量进行运算。
- en: '**SPACES MATTER**'
  id: totrans-4405
  prefs: []
  type: TYPE_NORMAL
  zh: '**空格很重要**'
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-4406
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，运算符两侧的空格是很重要的。你可以在数学运算符的两边各留一个空格，或者完全不留空格。但你不能只在运算符的一侧留空格，而另一侧不留空格。这样会导致错误。请查看
    [图 2-7](text00012.html#ch02fig7)。
- en: '![image](Image00063.jpg)'
  id: totrans-4407
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00063.jpg)'
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-4408
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：确保运算符两侧有相同数量的空格。*'
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-4409
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点非常重要：你只能对相同数据类型的变量或常量使用数学运算符。在前面的代码中，三和五都是 Int 类型。常量 half 和 quarter 是 Double
    类型，因为它们是小数。如果你尝试将 Int 和 Double 相加或相乘，你会得到像 [图 2-8](text00012.html#ch02fig8) 中那样的错误。
- en: '![image](Image00064.jpg)'
  id: totrans-4410
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00064.jpg)'
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-4411
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-8：在 Swift 中，你不能对混合数据类型进行数学运算。*'
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-4412
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果你真的想对混合数据类型进行数学运算呢？例如，假设你想计算自己年龄的十分之一：
- en: '![Image](Image00065.jpg)'
  id: totrans-4413
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00065.jpg)'
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-4414
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行将导致错误，因为我们试图将一个 Int 和一个 Double 相乘。但别担心！你有几种方法可以确保操作数是相同的数据类型。
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-4415
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是将 myAge 声明为 Double 类型，如下所示：
- en: '![Image](Image00066.jpg)'
  id: totrans-4416
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00066.jpg)'
- en: This code works because we’re multiplying two Double data types.
  id: totrans-4417
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有效，因为我们在相乘的是两个 Double 类型的数据。
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-4418
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是使用类型转换。（我告诉过你我们会回到这个问题！）类型转换在这种情况下是一个很好的解决方案，因为我们不想永久地将 myAge 改为 Double
    类型，我们只希望能够像处理 Double 类型一样进行数学运算。让我们看一个例子：
- en: '![Image](Image00067.jpg)'
  id: totrans-4419
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00067.jpg)'
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-4420
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ ，我们在乘法之前将 myAge 转换为 Double。这意味着我们不再有混合类型，因此代码可以正常运行。但是在 ➋ 时，我们会得到一个错误。因为
    myAge 仍然是 Int 类型。将它在 ➊ 处转换为 Double 并不会永久地将它改为 Double 类型。
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-4421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将乘数转换为 Int 吗？当然可以！然后我们就在两个整数之间进行数学运算，这样没问题。然而，这会导致计算精度降低，因为我们会失去小数部分。当你将一个变量从
    Double 转换为 Int 时，计算机会简单地去掉小数点后的所有数字，变成一个整数。在这种情况下，你的 0.1 乘数会被转换为 0。让我们在 Playground
    中进行一些变量的转换，看看会得到什么：
- en: '![Image](Image00068.jpg)'
  id: totrans-4422
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00068.jpg)'
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-4423
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ ，将我们的 Double 类型的乘数转换为 Int 后得到 0。这个值转换后有很大变化，因为我们失去了小数位：0.1 变成了 0。如果我们没有预料到这种情况，这可能会对我们的代码造成非常不好的影响。在进行类型转换时必须小心，以确保不会意外地改变你的值。在
    ➋ ，这是另一个将 Double 转换为 Int 的例子，正如你所看到的，1.9 没有被四舍五入到 2。它的小数部分被直接去除，我们得到的是 1。
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-4424
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个数学运算符，*取余运算符*（%），它可能对你来说不太熟悉。取余运算符（也叫 *模运算*）在除法后给出余数。例如，7 % 2 = 1，因为 7
    除以 2 的余数是 1。你可以在 Playground 中尝试使用取余运算符，代码如下。
- en: '![Image](Image00069.jpg)'
  id: totrans-4425
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00069.jpg)'
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-4426
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，取余操作符对于判断一个数是否为偶数（evenNumber % 2 等于 0）➊ 或奇数（oddNumber % 2 等于 1）➋ 很有用。
- en: '**ORDER OF OPERATIONS**'
  id: totrans-4427
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**运算顺序**'
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-4428
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们每行代码只做了一次数学运算，但通常会在一行中进行多次运算。让我们看一个例子。
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-4429
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有三张五美元钞票和两张一美元钞票，你有多少钱？让我们在一行中计算一下：
- en: '![Image](Image00070.jpg)'
  id: totrans-4430
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00070.jpg)'
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-4431
  prefs: []
  type: TYPE_NORMAL
  zh: 这将值 17 分配给 myMoney。计算机会先将 5 乘以 3，然后再加上 2。那么计算机是如何知道先乘法再加法的呢？它只是从左到右操作吗？不！看看这个：
- en: '![Image](Image00071.jpg)'
  id: totrans-4432
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Image00071.jpg)'
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-4433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调整了数字的位置，结果依然是17。如果计算机从左到右处理，它会先计算2 + 5得到7，然后将7乘以3得到21。即使我们改变了数学表达式中数字的顺序，计算机仍然先做乘法（得到15），再加2得到17。*计算机总是先进行乘法和除法，然后再进行加法和减法。*
    这叫做*运算顺序*。
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-4434
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用括号来排序运算**'
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-4435
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必像我们在金钱示例中那样依赖计算机来决定首先执行哪个步骤。你，程序员，拥有决定权！你可以使用括号将操作组合在一起。当你将括号放在某个部分时，你是在告诉计算机先执行那一步：
- en: '![Image](Image00072.jpg)'
  id: totrans-4436
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00072.jpg)'
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-4437
  prefs: []
  type: TYPE_NORMAL
  zh: 在➊处，括号告诉计算机先将5乘以3，然后再加2。这样得到的结果是17。在➋处，括号告诉计算机先将2加5，然后再将其乘以3，结果是21。
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-4438
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在括号中嵌套括号来使代码更加精确。计算机会先计算内层的括号，然后再计算外层的括号。试试这个例子：
- en: '![Image](Image00073.jpg)'
  id: totrans-4439
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00073.jpg)'
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-4440
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，计算机会在内层括号中先计算2和3的和。然后，它会将结果乘以4，因为这个操作是在外层括号内进行的。最后，它会加上1，因为它在两个括号之外。最终结果是21。
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-4441
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**复合赋值运算符**'
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-4442
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用的另一类运算符是*复合赋值运算符*。这些是将数学运算符与赋值运算符（=）结合的“快捷”运算符。例如，这个表达式
- en: '[PRE130]'
  id: totrans-4443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: becomes
  id: totrans-4444
  prefs: []
  type: TYPE_NORMAL
  zh: 变为
- en: '[PRE131]'
  id: totrans-4445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-4446
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些运算符通过对变量或常量执行操作来更新其值。用通俗的话来说，像a += b这样的表达式表示“将b加到a中，并将新值存储在a中。”[表2-1](text00012.html#ch2tab1)展示了使用复合赋值运算符的数学表达式及其长写形式。
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-4447
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-1：** 简写赋值运算符与长写表达式对比'
- en: '| **Short form** | **Long form** |'
  id: totrans-4448
  prefs: []
  type: TYPE_TB
  zh: '| **简写形式** | **长写形式** |'
- en: '| --- | --- |'
  id: totrans-4449
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| a += b | a = a + b |'
  id: totrans-4450
  prefs: []
  type: TYPE_TB
  zh: '| a += b | a = a + b |'
- en: '| a -= b | a = a - b |'
  id: totrans-4451
  prefs: []
  type: TYPE_TB
  zh: '| a -= b | a = a - b |'
- en: '| a *= b | a = a * b |'
  id: totrans-4452
  prefs: []
  type: TYPE_TB
  zh: '| a *= b | a = a * b |'
- en: '| a /= b | a = a / b |'
  id: totrans-4453
  prefs: []
  type: TYPE_TB
  zh: '| a /= b | a = a / b |'
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-4454
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看+=运算符是如何工作的。假设我们正在编写一个程序来计算方舟上的动物数量。首先，我们创建一个名为animalsOnArk的变量，并将其设置为0，因为方舟上还没有动物。随着不同种类的动物登上方舟，我们想要增加animalsOnArk来统计所有动物。如果两只长颈鹿登上了方舟，那么我们需要将2加到animalsOnArk中。如果两只大象登上方舟，我们需要再加2。如果四只羚羊登上方舟，那么我们需要将animalsOnArk增加4。
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-4455
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00074.jpg)![Image](Image00075.jpg)'
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-4456
  prefs: []
  type: TYPE_NORMAL
  zh: 当两只长颈鹿、两只大象和四只羚羊登上方舟时，动物在方舟上的最终数量是8。真是一个动物园！
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-4457
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于注释的几个简要说明**'
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-4458
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都有一种写注释的方式，注释可以与代码行内嵌在一起。注释是被计算机忽略的注解，用于帮助阅读代码的人理解发生了什么。虽然程序没有注释也能正常运行，但在代码中可能不清楚或难以理解的部分加入注释是个好主意。即使你不打算向别人展示你的程序，注释也能帮助你记住在写代码时你的思路或目的。当你几个月甚至几年后再回到一段代码时，可能会完全忘记当时在想什么，这时候注释就显得非常有用了。
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-4459
  prefs: []
  type: TYPE_NORMAL
  zh: Swift有两种方式添加注释。第一种方式是将两个斜杠（//）放在你想要添加的文本前面。这些注释可以单独放在一行上，像这样：
- en: '[PRE132]'
  id: totrans-4460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-4461
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将注释放在与代码行相同的一行上——只要注释出现在代码之后：
- en: '[PRE133]'
  id: totrans-4462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-4463
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式用于长注释，或*多行*注释，注释的开始和结束分别由/*和*/标记。（请注意，我们在本书中会使用-- *snip* --来表示为了节省空间我们省略了更多的代码行。）
- en: '[PRE134]'
  id: totrans-4464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-4465
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释在调试代码时非常有用。例如，如果你不希望计算机执行你代码中的某部分，因为你正在找一个错误，但又不想删除所有的辛苦工作，你可以使用多行注释来*注释掉*代码的部分内容。当你将一块代码格式化为注释时，计算机会像忽略其他注释一样忽略这部分代码。
- en: '**WHAT YOU LEARNED**'
  id: totrans-4466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到了什么**'
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-4467
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何在Swift游乐场中编写代码，这让你可以立刻看到结果。你创建了变量和常量，并学习了如何使用基本的数据类型和运算符，这些你在编写自己的计算机程序时会一遍又一遍地使用。
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-4468
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](text00013.html#ch03)中，你将使用条件语句，指示计算机应该走哪条代码路径。代码路径的选择基于条件的值。
- en: Variables can change (or *vary* !) in your programs, so you can change the value
    of a variable to hold something else. Let’s try that now. Add the following lines
    to your playground.
  id: totrans-4469
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在你的程序中是可以变化（或*变化*！）的，所以你可以改变变量的值来保存其他内容。现在让我们试一下。将以下几行添加到你的游乐场中。
- en: '![Image](Image00040.jpg)'
  id: totrans-4470
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00040.jpg)'
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-4471
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变变量的值，输入其名称，并使用=操作符将其设置为新值。我们在➊处这样做，把str的值更改为“Hello, world”。计算机会丢弃str之前存储的任何内容，并说：“好的，老板，str现在是Hello,
    world”（当然，如果它能说话的话！）。
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-4472
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们更改str的值时，我们不会再次写var。计算机会记住我们之前在代码行中声明过str，并知道str已经存在。所以我们不需要重新创建str。我们只需要在里面放入不同的内容。
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-4473
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以声明*常量*。像变量一样，常量也可以存储值。常量和变量之间的最大区别是常量的值永远不能改变。变量可以变化，而常量则是固定的！声明常量类似于声明变量，但我们使用let而不是var：
- en: '![Image](Image00041.jpg)'
  id: totrans-4474
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00041.jpg)'
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-4475
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为myName的常量，并将其值设置为"Gloria"。
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-4476
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个常量并赋予它一个值，它将一直保持这个值，直到永远。可以把常量想象成一块大石头，上面雕刻着你的值。如果你试图给myName赋另一个值，比如"Matt"，你将遇到如[图2-5](text00012.html#ch02fig5)所示的错误。
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-4477
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00042.jpg)![image](Image00043.jpg)'
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-4478
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-5：尝试改变常量的值是行不通的。*'
- en: '**NOTE**'
  id: totrans-4479
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-4480
  prefs: []
  type: TYPE_NORMAL
  zh: '*在游乐场中，错误将以一个红色圆圈和其中一个小白圈的形式显示。点击错误标记将显示错误信息，并告诉你哪里出了问题。如果你打开了调试区域，你应该还能看到描述发生了什么的详细信息，有时甚至会告诉你如何修复它。*'
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-4481
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**什么时候使用常量与变量**'
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-4482
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个变量和一个常量，做得好！但是，你应该在什么情况下使用一个而不是另一个呢？在Swift中，最佳实践是除非你预期值会改变，否则最好使用常量而不是变量。常量帮助使代码“更安全”。如果你知道某个值永远不会改变，为什么不把它刻在石头上，避免以后可能的混淆呢？
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-4483
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想跟踪你教室里的窗户总数和今天打开的窗户数量。教室里的窗户数量不会改变，所以你应该使用常量来存储这个值。然而，教室里打开的窗户数量会根据天气和时间的不同而变化，因此你应该使用变量来存储这个值。
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-4484
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00044.jpg)![Image](Image00045.jpg)'
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-4485
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将numberOfWindows设为常量并将其值设置为8，因为总窗户数将始终为8。我们将numberOfWindowsOpen设为变量并将其值设置为3，因为当我们打开或关闭窗户时，我们需要改变这个值。
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-4486
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用var来声明变量，使用let来声明常量！
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-4487
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常量和变量的命名**'
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-4488
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-4489
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  id: totrans-4490
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  id: totrans-4491
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-4492
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-4493
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-4494
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-4495
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-4496
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-4497
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-4498
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要声明数据类型一次。当我们告诉计算机一个变量将保存整数时，不需要再次声明。事实上，如果我们重复声明，Xcode 会给我们一个错误。一旦声明了数据类型，变量或常量将永远保存该类型的数据。整数一旦确定，永远是整数！
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-4499
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要知道一件关于数据类型的事：变量或常量不能保存不属于其数据类型的内容。例如，如果你尝试将一个小数放入 numberOfWindowsOpen，你会得到一个错误，如[图
    2-6](text00012.html#ch02fig6)所示。
- en: '![image](Image00049.jpg)'
  id: totrans-4500
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00049.jpg)'
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-4501
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：你不能把一个小数放入一个本应保存整数的变量中。*'
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-4502
  prefs: []
  type: TYPE_NORMAL
  zh: 将 numberOfWindowsOpen 设置为 5 和 numberOfWindowsOpen 设置为 0 是有效的，并且可以正常工作。但是，你不能将
    numberOfWindowsOpen 设置为 1.5。
- en: '**COMMON DATA TYPES**'
  id: totrans-4503
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**常见数据类型**'
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-4504
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚刚学到的，数据类型让计算机知道它正在处理什么*类型*的数据，以及如何将其存储在内存中。那么，数据类型有哪些呢？一些常见的包括 Int、Double、Float、Bool
    和 String。
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-4505
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下这些数据类型到底是什么！
- en: '**Int (Integers)**'
  id: totrans-4506
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**整数（Int）**'
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-4507
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过整数，接下来让我们更详细地了解它们。在 Swift 中，整数（Int）是没有小数或分数部分的整数。你可以将其视为计数数字。整数是*有符号*的，这意味着它们可以是负数、正数或零。
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-4508
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**双精度浮点数和浮点数（Decimal Numbers）**'
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-4509
  prefs: []
  type: TYPE_NORMAL
  zh: '*小数*是指小数点后有数字的数字，比如 3.14。（如果你希望一个整数像 3 那样成为小数，可以写作 3.0。）有两种数据类型可以存储小数：Double
    和 Float（浮动点数的缩写）。Double 数据类型在 Swift 中更常见，因为它可以存储更大的数字，所以我们将重点讲解 Double 类型。'
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-4510
  prefs: []
  type: TYPE_NORMAL
  zh: 当你赋值给 Double 类型时，必须在小数点左侧有一个数字，否则会报错。例如，假设香蕉每个 19 美分：
- en: '![Image](Image00050.jpg)'
  id: totrans-4511
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00050.jpg)'
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-4512
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 处的代码会导致错误，因为它没有小数点左边的数字。➋ 处的代码没有问题，因为它有一个前导零。（// ERROR 和 // CORRECT 是*注释*，它们是程序中的注释，计算机会忽略它们。详见
    “[关于注释的一些快速说明](text00012.html#ch02sb01)” [第32页](text00012.html#page_32)。）
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-4513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**布尔值（布尔类型，或真/假）**'
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-4514
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔值*只有两种可能的值：true 或 false。在 Swift 中，布尔数据类型称为 Bool。'
- en: '![Image](Image00051.jpg)'
  id: totrans-4515
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00051.jpg)'
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-4516
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值通常用于 if-else 语句中，告诉计算机程序应该选择哪个路径。（我们将在[第3章](text00013.html#ch03)中更详细地讲解布尔值和
    if-else 语句。）
- en: '**String**'
  id: totrans-4517
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符串（String）**'
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-4518
  prefs: []
  type: TYPE_NORMAL
  zh: String数据类型用于存储单词和短语。一个*字符串*是由一系列字符组成，并且这些字符被引号括起来。例如，"Hello, playground"是一个字符串。字符串可以由各种字符组成：字母、数字、符号等等。引号很重要，因为它告诉计算机，所有引号之间的内容都是你正在创建的字符串的一部分。
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-4519
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将字符串连接起来来构建句子，这个过程叫做字符串*拼接*。让我们来看看它是如何工作的！
- en: '![Image](Image00052.jpg)'
  id: totrans-4520
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00052.jpg)'
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-4521
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用加号（+）将字符串连接起来，这段代码创建了一个名为specialGreeting的变量，它的值是字符串"Good Morning Jude"。注意，我们需要在morningGreeting和friend之间加一个包含空格字符（"
    "）的字符串，否则specialGreeting将会是"Good MorningJude"。
- en: '![Image](Image00053.jpg)'
  id: totrans-4522
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00053.jpg)'
- en: '**TYPE INFERENCE**'
  id: totrans-4523
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**类型推断**'
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-4524
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，当我们声明一个变量时，有时会包含数据类型：
- en: '![Image](Image00054.jpg)'
  id: totrans-4525
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00054.jpg)'
- en: 'And sometimes we do not include the data type:'
  id: totrans-4526
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们不包含数据类型：
- en: '![Image](Image00055.jpg)'
  id: totrans-4527
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Image00055.jpg)'
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-4528
  prefs: []
  type: TYPE_NORMAL
  zh: 这是怎么回事？计算机实际上足够聪明，通常能推断出数据类型。这被称为*类型推断*——因为计算机会根据我们提供的线索*推断*，或者说猜测我们使用的数据类型。当你创建一个变量并给它一个初始值时，这个值就是给计算机的一个重要线索。这里有一些例子：
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-4529
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个没有小数点的数字（比如3），计算机会认为它是一个Int。
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-4530
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个带小数点的数字（比如3.14），计算机会认为它是一个Double。
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-4531
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值单词*true*或*false*（没有引号），计算机会认为它是一个Bool。
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-4532
  prefs: []
  type: TYPE_NORMAL
  zh: • 如果你赋值一个或多个带引号的字符，计算机会认为它是一个String。
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-4533
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型被推断时，变量或常量会被设置为该数据类型，就好像你自己声明了数据类型一样。这完全是为了方便。你可以每次声明新常量或变量时都包含数据类型，这完全没问题。但为什么不让计算机自己推断出来，从而节省时间和减少打字呢？
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-4534
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**通过类型转换变换数据类型**'
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-4535
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换*是一种暂时转换变量或常量数据类型的方法。你可以将其想象成对变量施放一个魔法——让它的值像另一种数据类型一样，但仅仅是短暂的。为此，你写下一个新的数据类型，后面跟上括号，括号里是你要转换类型的变量。注意，这*并不会真正改变数据类型*。它只是给你在那一行代码中一个临时值。下面是一些在Int和Double之间转换类型的例子。查看代码结果的侧边栏以查看结果。'
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-4536
  prefs: []
  type: TYPE_IMG
  zh: '![image](Image00056.jpg)![Image](Image00057.jpg)'
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-4537
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-4538
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-4539
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-4540
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-4541
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-4542
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-4543
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-4544
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-4545
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-4546
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-4547
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-4548
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-4549
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-4550
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-4551
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-4552
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-4553
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-4554
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-4555
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-4556
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-4557
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-4558
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-4559
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-4560
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-4561
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-4562
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-4563
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-4564
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-4565
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-4566
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-4567
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-4568
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-4569
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-4570
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-4571
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-4572
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-4573
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-4574
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-4575
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-4576
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-4577
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-4578
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-4579
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-4580
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-4581
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-4582
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-4583
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-4584
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-4585
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-4586
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-4587
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-4588
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-4589
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-4590
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-4591
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-4592
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-4593
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-4594
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-4595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: becomes
  id: totrans-4596
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-4597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-4598
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-4599
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-4600
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-4601
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-4602
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-4603
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-4604
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-4605
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-4606
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-4607
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-4608
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-4609
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-4610
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-4611
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-4612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-4613
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-4614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-4615
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-4616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-4617
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4618
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-4619
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-4620
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00040.jpg)'
  id: totrans-4621
  prefs: []
  type: TYPE_IMG
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-4622
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-4623
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-4624
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  id: totrans-4625
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-4626
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-4627
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-4628
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-4629
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-4630
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-4631
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-4632
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-4633
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-4634
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-4635
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-4636
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-4637
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-4638
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-4639
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-4640
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  id: totrans-4641
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  id: totrans-4642
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-4643
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-4644
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-4645
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-4646
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-4647
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-4648
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-4649
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-4650
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-4651
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-4652
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-4653
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-4654
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-4655
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-4656
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-4657
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-4658
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-4659
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-4660
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-4661
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-4662
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-4663
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-4664
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-4665
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-4666
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-4667
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-4668
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-4669
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-4670
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-4671
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-4672
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-4673
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-4674
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-4675
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-4676
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-4677
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-4678
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-4679
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-4680
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-4681
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-4682
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-4683
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-4684
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-4685
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-4686
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-4687
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-4688
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-4689
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-4690
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-4691
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-4692
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-4693
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-4694
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-4695
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-4696
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-4697
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-4698
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-4699
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-4700
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-4701
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-4702
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-4703
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-4704
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-4705
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-4706
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-4707
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-4708
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-4709
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-4710
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-4711
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-4712
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-4713
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-4714
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-4715
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-4716
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-4717
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-4718
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-4719
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-4720
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-4721
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-4722
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-4723
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-4724
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-4725
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-4726
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-4727
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-4728
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-4729
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-4730
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-4731
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-4732
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-4733
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-4734
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-4735
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-4736
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-4737
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-4738
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-4739
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-4740
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-4741
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-4742
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-4743
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-4744
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-4745
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-4746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: becomes
  id: totrans-4747
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-4748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-4749
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-4750
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-4751
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-4752
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-4753
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-4754
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-4755
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-4756
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-4757
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-4758
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-4759
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-4760
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-4761
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-4762
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-4763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-4764
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-4765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-4766
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-4767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-4768
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4769
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-4770
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-4771
  prefs: []
  type: TYPE_NORMAL
- en: To change the value of a variable, type its name and use the = operator to set
    it to a new value. We do this at ➊ to change the value of str to "Hello, world"
    . The computer throws away whatever str used to hold, and says, “Okay, boss, str
    is now Hello, world ” (that is, it would say that if it could talk!).
  id: totrans-4772
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-4773
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-4774
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  id: totrans-4775
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-4776
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-4777
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-4778
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-4779
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-4780
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-4781
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-4782
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-4783
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-4784
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-4785
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-4786
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-4787
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-4788
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-4789
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-4790
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  id: totrans-4791
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  id: totrans-4792
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-4793
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-4794
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-4795
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-4796
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-4797
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-4798
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-4799
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-4800
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-4801
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-4802
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-4803
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-4804
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-4805
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-4806
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-4807
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-4808
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-4809
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-4810
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-4811
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-4812
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-4813
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-4814
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-4815
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-4816
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-4817
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-4818
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-4819
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-4820
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-4821
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-4822
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-4823
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-4824
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-4825
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-4826
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-4827
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-4828
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-4829
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-4830
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-4831
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-4832
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-4833
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-4834
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-4835
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-4836
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-4837
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-4838
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-4839
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-4840
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-4841
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-4842
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-4843
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-4844
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-4845
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-4846
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-4847
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-4848
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-4849
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-4850
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-4851
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-4852
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-4853
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-4854
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-4855
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-4856
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-4857
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-4858
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-4859
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-4860
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-4861
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-4862
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-4863
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-4864
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-4865
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-4866
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-4867
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-4868
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-4869
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-4870
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-4871
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-4872
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-4873
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-4874
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-4875
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-4876
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-4877
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-4878
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-4879
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-4880
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-4881
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-4882
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-4883
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-4884
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-4885
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-4886
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-4887
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-4888
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-4889
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-4890
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-4891
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-4892
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-4893
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-4894
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-4895
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-4896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: becomes
  id: totrans-4897
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-4898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-4899
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-4900
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-4901
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-4902
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-4903
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-4904
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-4905
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-4906
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-4907
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-4908
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-4909
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-4910
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-4911
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-4912
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-4913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-4914
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-4915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-4916
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-4917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-4918
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-4919
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-4920
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-4921
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we change the value of str , we don’t write var again. The
    computer remembers that we declared str in a previous line of code and knows that
    str already exists. So we don’t need to create str again. We just want to put
    something different in it.
  id: totrans-4922
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-4923
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  id: totrans-4924
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-4925
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-4926
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-4927
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-4928
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-4929
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-4930
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-4931
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-4932
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-4933
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-4934
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-4935
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-4936
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-4937
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-4938
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-4939
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  id: totrans-4940
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  id: totrans-4941
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-4942
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-4943
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-4944
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-4945
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-4946
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-4947
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-4948
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-4949
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-4950
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-4951
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-4952
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-4953
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-4954
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-4955
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-4956
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-4957
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-4958
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-4959
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-4960
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-4961
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-4962
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-4963
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-4964
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-4965
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-4966
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-4967
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-4968
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-4969
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-4970
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-4971
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-4972
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-4973
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-4974
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-4975
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-4976
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-4977
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-4978
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-4979
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-4980
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-4981
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-4982
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-4983
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-4984
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-4985
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-4986
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-4987
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-4988
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-4989
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-4990
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-4991
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-4992
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-4993
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-4994
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-4995
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-4996
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-4997
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-4998
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-4999
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-5000
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-5001
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-5002
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-5003
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-5004
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-5005
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-5006
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-5007
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-5008
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-5009
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-5010
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-5011
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-5012
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-5013
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-5014
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-5015
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-5016
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-5017
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-5018
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-5019
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-5020
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-5021
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-5022
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-5023
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-5024
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-5025
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-5026
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-5027
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-5028
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-5029
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-5030
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-5031
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-5032
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-5033
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-5034
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-5035
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-5036
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-5037
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-5038
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-5039
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-5040
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-5041
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-5042
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-5043
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-5044
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-5045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: becomes
  id: totrans-5046
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-5047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-5048
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-5049
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-5050
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-5051
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-5052
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-5053
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-5054
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-5055
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-5056
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-5057
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-5058
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-5059
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-5060
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-5061
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-5062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-5063
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-5064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-5065
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-5066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-5067
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-5068
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-5069
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-5070
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also declare *constants.* Like variables, constants hold values. The
    big difference between a constant and a variable is that a constant can never
    change its value. Variables can vary, and constants are, well, constant! Declaring
    a constant is similar to declaring a variable, but we use the word let instead
    of var :'
  id: totrans-5071
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  id: totrans-5072
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-5073
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-5074
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-5075
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-5076
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-5077
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-5078
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-5079
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-5080
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-5081
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-5082
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-5083
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-5084
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-5085
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-5086
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-5087
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  id: totrans-5088
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  id: totrans-5089
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-5090
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-5091
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-5092
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-5093
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-5094
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-5095
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-5096
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-5097
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-5098
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-5099
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-5100
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-5101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-5102
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-5103
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-5104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-5105
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-5106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-5107
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-5108
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-5109
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-5110
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-5111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-5112
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-5113
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-5114
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-5115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-5116
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-5117
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-5118
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-5119
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-5120
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-5121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-5122
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-5123
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-5124
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-5125
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-5126
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-5127
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-5128
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-5129
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-5130
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-5131
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-5132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-5133
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-5134
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-5135
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-5136
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-5137
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-5138
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-5139
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-5140
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-5141
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-5142
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-5143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-5144
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-5145
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-5146
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-5147
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-5148
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-5149
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-5150
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-5151
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-5152
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-5153
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-5154
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-5155
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-5156
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-5157
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-5158
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-5159
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-5160
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-5161
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-5162
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-5163
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-5164
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-5165
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-5166
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-5167
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-5168
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-5169
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-5170
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-5171
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-5172
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-5173
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-5174
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-5175
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-5176
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-5177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-5178
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-5179
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-5180
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-5181
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-5182
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-5183
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-5184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-5185
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-5186
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-5187
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-5188
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-5189
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-5190
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-5191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-5192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-5193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: becomes
  id: totrans-5194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-5195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-5196
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-5197
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-5198
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-5199
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-5200
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-5201
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-5202
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-5203
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-5204
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-5205
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-5206
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-5207
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-5208
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-5209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-5210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-5211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-5212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-5213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-5214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-5215
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-5216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-5217
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-5218
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00041.jpg)'
  id: totrans-5219
  prefs: []
  type: TYPE_IMG
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-5220
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-5221
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-5222
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-5223
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-5224
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-5225
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-5226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-5227
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-5228
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-5229
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-5230
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-5231
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-5232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-5233
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-5234
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  id: totrans-5235
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  id: totrans-5236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-5237
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-5238
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-5239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-5240
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-5241
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-5242
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-5243
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-5244
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-5245
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-5246
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-5247
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-5248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-5249
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-5250
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-5251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-5252
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-5253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-5254
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-5255
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-5256
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-5257
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-5258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-5259
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-5260
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-5261
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-5262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-5263
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-5264
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-5265
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-5266
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-5267
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-5268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-5269
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-5270
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-5271
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-5272
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-5273
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-5274
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-5275
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-5276
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-5277
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-5278
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-5279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-5280
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-5281
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-5282
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-5283
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-5284
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-5285
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-5286
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-5287
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-5288
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-5289
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-5290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-5291
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-5292
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-5293
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-5294
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-5295
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-5296
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-5297
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-5298
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-5299
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-5300
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-5301
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-5302
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-5303
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-5304
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-5305
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-5306
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-5307
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-5308
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-5309
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-5310
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-5311
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-5312
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-5313
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-5314
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-5315
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-5316
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-5317
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-5318
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-5319
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-5320
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-5321
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-5322
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-5323
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-5324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-5325
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-5326
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-5327
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-5328
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-5329
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-5330
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-5331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-5332
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-5333
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-5334
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-5335
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-5336
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-5337
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-5338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-5339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-5340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: becomes
  id: totrans-5341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-5342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-5343
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-5344
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-5345
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-5346
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-5347
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-5348
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-5349
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-5350
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-5351
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-5352
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-5353
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-5354
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-5355
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-5356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-5357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-5358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-5359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-5360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-5361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-5362
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-5363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-5364
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-5365
  prefs: []
  type: TYPE_NORMAL
- en: Here we create a constant called myName and assign it the value of "Gloria"
    .
  id: totrans-5366
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-5367
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-5368
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-5369
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-5370
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-5371
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-5372
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-5373
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-5374
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-5375
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-5376
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-5377
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-5378
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-5379
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-5380
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  id: totrans-5381
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  id: totrans-5382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-5383
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-5384
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-5385
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-5386
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-5387
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-5388
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-5389
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-5390
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-5391
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-5392
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-5393
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-5394
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-5395
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-5396
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-5397
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-5398
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-5399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-5400
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-5401
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-5402
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-5403
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-5404
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-5405
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-5406
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-5407
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-5408
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-5409
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-5410
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-5411
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-5412
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-5413
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-5414
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-5415
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-5416
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-5417
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-5418
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-5419
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-5420
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-5421
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-5422
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-5423
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-5424
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-5425
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-5426
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-5427
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-5428
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-5429
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-5430
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-5431
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-5432
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-5433
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-5434
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-5435
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-5436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-5437
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-5438
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-5439
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-5440
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-5441
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-5442
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-5443
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-5444
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-5445
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-5446
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-5447
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-5448
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-5449
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-5450
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-5451
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-5452
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-5453
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-5454
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-5455
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-5456
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-5457
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-5458
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-5459
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-5460
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-5461
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-5462
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-5463
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-5464
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-5465
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-5466
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-5467
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-5468
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-5469
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-5470
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-5471
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-5472
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-5473
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-5474
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-5475
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-5476
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-5477
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-5478
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-5479
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-5480
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-5481
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-5482
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-5483
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-5484
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-5485
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-5486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: becomes
  id: totrans-5487
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-5488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-5489
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-5490
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-5491
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-5492
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-5493
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-5494
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-5495
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-5496
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-5497
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-5498
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-5499
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-5500
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-5501
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-5502
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-5503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-5504
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-5505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-5506
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-5507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-5508
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-5509
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-5510
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-5511
  prefs: []
  type: TYPE_NORMAL
- en: Once you create a constant and give it a value, it will have that value until
    the end of time. Think of a constant as a big rock into which you’ve carved your
    value. If you try to give myName another value, like "Matt" , you’ll get an error
    like the one in [Figure 2-5](text00012.html#ch02fig5) .
  id: totrans-5512
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-5513
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-5514
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-5515
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-5516
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-5517
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-5518
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-5519
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-5520
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-5521
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-5522
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-5523
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-5524
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-5525
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  id: totrans-5526
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  id: totrans-5527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-5528
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-5529
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-5530
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-5531
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-5532
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-5533
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-5534
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-5535
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-5536
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-5537
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-5538
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-5539
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-5540
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-5541
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-5542
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-5543
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-5544
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-5545
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-5546
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-5547
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-5548
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-5549
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-5550
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-5551
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-5552
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-5553
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-5554
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-5555
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-5556
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-5557
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-5558
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-5559
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-5560
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-5561
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-5562
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-5563
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-5564
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-5565
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-5566
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-5567
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-5568
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-5569
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-5570
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-5571
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-5572
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-5573
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-5574
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-5575
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-5576
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-5577
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-5578
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-5579
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-5580
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-5581
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-5582
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-5583
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-5584
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-5585
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-5586
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-5587
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-5588
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-5589
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-5590
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-5591
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-5592
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-5593
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-5594
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-5595
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-5596
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-5597
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-5598
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-5599
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-5600
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-5601
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-5602
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-5603
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-5604
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-5605
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-5606
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-5607
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-5608
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-5609
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-5610
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-5611
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-5612
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-5613
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-5614
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-5615
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-5616
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-5617
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-5618
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-5619
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-5620
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-5621
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-5622
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-5623
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-5624
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-5625
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-5626
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-5627
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-5628
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-5629
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-5630
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-5631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: becomes
  id: totrans-5632
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-5633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-5634
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-5635
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-5636
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-5637
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-5638
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-5639
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-5640
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-5641
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-5642
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-5643
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-5644
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-5645
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-5646
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-5647
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-5648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-5649
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-5650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-5651
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-5652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-5653
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-5654
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-5655
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-5656
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00042.jpg)![image](Image00043.jpg)'
  id: totrans-5657
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-5658
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-5659
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-5660
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-5661
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-5662
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-5663
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-5664
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-5665
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-5666
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-5667
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-5668
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-5669
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  id: totrans-5670
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  id: totrans-5671
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-5672
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-5673
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-5674
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-5675
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-5676
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-5677
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-5678
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-5679
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-5680
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-5681
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-5682
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-5683
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-5684
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-5685
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-5686
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-5687
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-5688
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-5689
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-5690
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-5691
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-5692
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-5693
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-5694
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-5695
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-5696
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-5697
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-5698
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-5699
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-5700
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-5701
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-5702
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-5703
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-5704
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-5705
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-5706
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-5707
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-5708
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-5709
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-5710
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-5711
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-5712
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-5713
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-5714
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-5715
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-5716
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-5717
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-5718
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-5719
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-5720
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-5721
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-5722
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-5723
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-5724
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-5725
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-5726
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-5727
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-5728
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-5729
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-5730
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-5731
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-5732
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-5733
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-5734
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-5735
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-5736
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-5737
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-5738
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-5739
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-5740
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-5741
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-5742
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-5743
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-5744
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-5745
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-5746
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-5747
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-5748
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-5749
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-5750
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-5751
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-5752
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-5753
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-5754
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-5755
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-5756
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-5757
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-5758
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-5759
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-5760
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-5761
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-5762
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-5763
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-5764
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-5765
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-5766
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-5767
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-5768
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-5769
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-5770
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-5771
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-5772
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-5773
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-5774
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-5775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: becomes
  id: totrans-5776
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-5777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-5778
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-5779
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-5780
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-5781
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-5782
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-5783
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-5784
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-5785
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-5786
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-5787
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-5788
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-5789
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-5790
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-5791
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-5792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-5793
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-5794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-5795
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-5796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-5797
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-5798
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-5799
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-5800
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00043.jpg)'
  id: totrans-5801
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-5802
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-5803
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-5804
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-5805
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-5806
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-5807
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-5808
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-5809
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-5810
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-5811
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-5812
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-5813
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  id: totrans-5814
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  id: totrans-5815
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-5816
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-5817
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-5818
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-5819
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-5820
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-5821
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-5822
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-5823
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-5824
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-5825
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-5826
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-5827
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-5828
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-5829
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-5830
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-5831
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-5832
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-5833
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-5834
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-5835
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-5836
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-5837
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-5838
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-5839
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-5840
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-5841
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-5842
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-5843
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-5844
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-5845
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-5846
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-5847
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-5848
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-5849
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-5850
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-5851
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-5852
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-5853
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-5854
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-5855
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-5856
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-5857
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-5858
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-5859
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-5860
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-5861
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-5862
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-5863
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-5864
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-5865
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-5866
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-5867
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-5868
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-5869
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-5870
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-5871
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-5872
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-5873
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-5874
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-5875
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-5876
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-5877
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-5878
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-5879
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-5880
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-5881
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-5882
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-5883
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-5884
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-5885
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-5886
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-5887
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-5888
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-5889
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-5890
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-5891
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-5892
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-5893
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-5894
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-5895
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-5896
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-5897
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-5898
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-5899
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-5900
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-5901
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-5902
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-5903
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-5904
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-5905
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-5906
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-5907
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-5908
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-5909
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-5910
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-5911
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-5912
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-5913
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-5914
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-5915
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-5916
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-5917
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-5918
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-5919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: becomes
  id: totrans-5920
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-5921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-5922
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-5923
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-5924
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-5925
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-5926
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-5927
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-5928
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-5929
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-5930
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-5931
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-5932
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-5933
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-5934
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-5935
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-5936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-5937
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-5938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-5939
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-5940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-5941
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-5942
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-5943
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-5944
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2-5: Trying to change the value of a constant won’t work.*'
  id: totrans-5945
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-5946
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-5947
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-5948
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-5949
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-5950
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-5951
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-5952
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-5953
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-5954
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-5955
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-5956
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  id: totrans-5957
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  id: totrans-5958
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-5959
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-5960
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-5961
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-5962
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-5963
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-5964
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-5965
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-5966
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-5967
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-5968
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-5969
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-5970
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-5971
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-5972
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-5973
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-5974
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-5975
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-5976
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-5977
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-5978
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-5979
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-5980
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-5981
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-5982
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-5983
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-5984
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-5985
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-5986
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-5987
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-5988
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-5989
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-5990
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-5991
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-5992
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-5993
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-5994
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-5995
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-5996
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-5997
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-5998
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-5999
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-6000
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-6001
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-6002
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-6003
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-6004
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-6005
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-6006
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-6007
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-6008
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-6009
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-6010
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-6011
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-6012
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-6013
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-6014
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-6015
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-6016
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-6017
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-6018
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-6019
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-6020
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-6021
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-6022
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-6023
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-6024
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-6025
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-6026
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-6027
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-6028
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-6029
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-6030
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-6031
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-6032
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-6033
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-6034
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-6035
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-6036
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-6037
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-6038
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-6039
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-6040
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-6041
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-6042
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-6043
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-6044
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-6045
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-6046
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-6047
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-6048
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-6049
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-6050
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-6051
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-6052
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-6053
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-6054
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-6055
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-6056
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-6057
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-6058
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-6059
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-6060
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-6061
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-6062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: becomes
  id: totrans-6063
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-6064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-6065
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-6066
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-6067
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-6068
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-6069
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-6070
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-6071
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-6072
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-6073
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-6074
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-6075
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-6076
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-6077
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-6078
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-6079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-6080
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-6081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-6082
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-6083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-6084
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-6085
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-6086
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-6087
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-6088
  prefs: []
  type: TYPE_NORMAL
- en: '*In the playground, an error will appear as a red circle with a tiny white
    circle inside it. Clicking the error mark will show the error message and tell
    you what’s wrong. If you have your debug area showing, you should also see information
    describing what happened and sometimes even how to fix it.*'
  id: totrans-6089
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-6090
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-6091
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-6092
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-6093
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-6094
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-6095
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-6096
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-6097
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-6098
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  id: totrans-6099
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  id: totrans-6100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-6101
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-6102
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-6103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-6104
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-6105
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-6106
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-6107
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-6108
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-6109
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-6110
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-6111
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-6112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-6113
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-6114
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-6115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-6116
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-6117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-6118
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-6119
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-6120
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-6121
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-6122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-6123
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-6124
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-6125
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-6126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-6127
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-6128
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-6129
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-6130
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-6131
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-6132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-6133
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-6134
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-6135
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-6136
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-6137
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-6138
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-6139
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-6140
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-6141
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-6142
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-6143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-6144
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-6145
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-6146
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-6147
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-6148
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-6149
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-6150
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-6151
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-6152
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-6153
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-6154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-6155
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-6156
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-6157
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-6158
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-6159
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-6160
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-6161
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-6162
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-6163
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-6164
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-6165
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-6166
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-6167
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-6168
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-6169
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-6170
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-6171
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-6172
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-6173
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-6174
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-6175
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-6176
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-6177
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-6178
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-6179
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-6180
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-6181
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-6182
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-6183
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-6184
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-6185
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-6186
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-6187
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-6188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-6189
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-6190
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-6191
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-6192
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-6193
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-6194
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-6195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-6196
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-6197
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-6198
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-6199
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-6200
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-6201
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-6202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-6203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-6204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: becomes
  id: totrans-6205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-6206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-6207
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-6208
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-6209
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-6210
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-6211
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-6212
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-6213
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-6214
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-6215
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-6216
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-6217
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-6218
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-6219
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-6220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-6221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-6222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-6223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-6224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-6225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-6226
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-6227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-6228
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-6229
  prefs: []
  type: TYPE_NORMAL
- en: '**WHEN TO USE CONSTANTS VS. VARIABLES**'
  id: totrans-6230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-6231
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-6232
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-6233
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-6234
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-6235
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-6236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-6237
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-6238
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  id: totrans-6239
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  id: totrans-6240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-6241
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-6242
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-6243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-6244
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-6245
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-6246
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-6247
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-6248
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-6249
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-6250
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-6251
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-6252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-6253
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-6254
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-6255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-6256
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-6257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-6258
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-6259
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-6260
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-6261
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-6262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-6263
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-6264
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-6265
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-6266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-6267
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-6268
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-6269
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-6270
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-6271
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-6272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-6273
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-6274
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-6275
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-6276
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-6277
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-6278
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-6279
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-6280
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-6281
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-6282
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-6283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-6284
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-6285
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-6286
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-6287
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-6288
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-6289
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-6290
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-6291
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-6292
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-6293
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-6294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-6295
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-6296
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-6297
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-6298
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-6299
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-6300
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-6301
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-6302
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-6303
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-6304
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-6305
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-6306
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-6307
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-6308
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-6309
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-6310
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-6311
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-6312
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-6313
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-6314
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-6315
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-6316
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-6317
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-6318
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-6319
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-6320
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-6321
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-6322
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-6323
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-6324
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-6325
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-6326
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-6327
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-6328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-6329
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-6330
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-6331
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-6332
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-6333
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-6334
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-6335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-6336
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-6337
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-6338
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-6339
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-6340
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-6341
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-6342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-6343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-6344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: becomes
  id: totrans-6345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-6346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-6347
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-6348
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-6349
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-6350
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-6351
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-6352
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-6353
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-6354
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-6355
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-6356
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-6357
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-6358
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-6359
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-6360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-6361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-6362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-6363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-6364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-6365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-6366
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-6367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-6368
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-6369
  prefs: []
  type: TYPE_NORMAL
- en: Now you’ve successfully created a variable and a constant—good job! But when
    should you use one over the other? In Swift, it’s best practice to use constants
    instead of variables unless you expect the value will change. Constants help make
    code “safer.” If you know the value of something is never going to change, why
    not etch it into stone and avoid any possible confusion later?
  id: totrans-6370
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-6371
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-6372
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-6373
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-6374
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-6375
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-6376
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-6377
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  id: totrans-6378
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  id: totrans-6379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-6380
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-6381
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-6382
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-6383
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-6384
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-6385
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-6386
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-6387
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-6388
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-6389
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-6390
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-6391
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-6392
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-6393
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-6394
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-6395
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-6396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-6397
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-6398
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-6399
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-6400
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-6401
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-6402
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-6403
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-6404
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-6405
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-6406
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-6407
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-6408
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-6409
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-6410
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-6411
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-6412
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-6413
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-6414
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-6415
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-6416
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-6417
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-6418
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-6419
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-6420
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-6421
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-6422
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-6423
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-6424
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-6425
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-6426
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-6427
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-6428
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-6429
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-6430
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-6431
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-6432
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-6433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-6434
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-6435
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-6436
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-6437
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-6438
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-6439
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-6440
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-6441
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-6442
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-6443
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-6444
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-6445
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-6446
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-6447
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-6448
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-6449
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-6450
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-6451
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-6452
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-6453
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-6454
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-6455
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-6456
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-6457
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-6458
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-6459
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-6460
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-6461
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-6462
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-6463
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-6464
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-6465
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-6466
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-6467
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-6468
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-6469
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-6470
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-6471
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-6472
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-6473
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-6474
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-6475
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-6476
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-6477
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-6478
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-6479
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-6480
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-6481
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-6482
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  id: totrans-6483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: becomes
  id: totrans-6484
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  id: totrans-6485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-6486
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-6487
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-6488
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-6489
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-6490
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-6491
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-6492
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-6493
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-6494
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-6495
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-6496
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-6497
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-6498
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-6499
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-6500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-6501
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-6502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-6503
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-6504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-6505
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-6506
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-6507
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-6508
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you want to keep track of the total number of windows in your
    classroom and the number of windows that are open today. The number of windows
    in your classroom isn’t going to change, so you should use a constant to store
    this value. The number of windows that are open in your classroom will change
    depending on the weather and time of day, however, so you should use a variable
    to store this value.
  id: totrans-6509
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-6510
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-6511
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-6512
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-6513
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-6514
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-6515
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  id: totrans-6516
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  id: totrans-6517
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-6518
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-6519
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-6520
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-6521
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-6522
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-6523
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-6524
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-6525
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-6526
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-6527
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-6528
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-6529
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-6530
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-6531
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-6532
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-6533
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-6534
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-6535
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-6536
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-6537
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-6538
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-6539
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-6540
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-6541
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-6542
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-6543
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-6544
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-6545
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-6546
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-6547
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-6548
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-6549
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-6550
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-6551
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-6552
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-6553
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-6554
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-6555
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-6556
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-6557
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-6558
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-6559
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-6560
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-6561
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-6562
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-6563
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-6564
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-6565
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-6566
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-6567
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-6568
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-6569
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-6570
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-6571
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-6572
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-6573
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-6574
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-6575
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-6576
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-6577
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-6578
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-6579
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-6580
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-6581
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-6582
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-6583
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-6584
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-6585
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-6586
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-6587
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-6588
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-6589
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-6590
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-6591
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-6592
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-6593
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-6594
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-6595
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-6596
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-6597
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-6598
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-6599
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-6600
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-6601
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-6602
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-6603
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-6604
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-6605
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-6606
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-6607
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-6608
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-6609
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-6610
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-6611
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-6612
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-6613
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-6614
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-6615
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-6616
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-6617
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-6618
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-6619
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-6620
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-6621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: becomes
  id: totrans-6622
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-6623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-6624
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-6625
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-6626
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-6627
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-6628
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-6629
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-6630
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-6631
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-6632
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-6633
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-6634
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-6635
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-6636
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-6637
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  id: totrans-6638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-6639
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-6640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-6641
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  id: totrans-6642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-6643
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-6644
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-6645
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-6646
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00044.jpg)![Image](Image00045.jpg)'
  id: totrans-6647
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-6648
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-6649
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-6650
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-6651
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-6652
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  id: totrans-6653
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  id: totrans-6654
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-6655
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-6656
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-6657
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-6658
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-6659
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-6660
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-6661
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-6662
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-6663
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-6664
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-6665
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-6666
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-6667
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-6668
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-6669
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-6670
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-6671
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-6672
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-6673
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-6674
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-6675
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-6676
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-6677
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-6678
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-6679
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-6680
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-6681
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-6682
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-6683
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-6684
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-6685
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-6686
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-6687
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-6688
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-6689
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-6690
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-6691
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-6692
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-6693
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-6694
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-6695
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-6696
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-6697
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-6698
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-6699
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-6700
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-6701
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-6702
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-6703
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-6704
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-6705
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-6706
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-6707
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-6708
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-6709
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-6710
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-6711
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-6712
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-6713
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-6714
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-6715
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-6716
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-6717
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-6718
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-6719
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-6720
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-6721
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-6722
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-6723
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-6724
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-6725
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-6726
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-6727
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-6728
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-6729
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-6730
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-6731
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-6732
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-6733
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-6734
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-6735
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-6736
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-6737
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-6738
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-6739
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-6740
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-6741
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-6742
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-6743
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-6744
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-6745
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-6746
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-6747
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-6748
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-6749
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-6750
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-6751
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-6752
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-6753
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-6754
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-6755
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-6756
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-6757
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  id: totrans-6758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: becomes
  id: totrans-6759
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  id: totrans-6760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-6761
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-6762
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-6763
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-6764
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-6765
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-6766
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-6767
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-6768
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-6769
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-6770
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-6771
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-6772
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-6773
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-6774
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  id: totrans-6775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-6776
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  id: totrans-6777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-6778
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  id: totrans-6779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-6780
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-6781
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-6782
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-6783
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00045.jpg)'
  id: totrans-6784
  prefs: []
  type: TYPE_IMG
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-6785
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-6786
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-6787
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-6788
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-6789
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  id: totrans-6790
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  id: totrans-6791
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-6792
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-6793
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-6794
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-6795
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-6796
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-6797
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-6798
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-6799
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-6800
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-6801
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-6802
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-6803
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-6804
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-6805
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-6806
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-6807
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-6808
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-6809
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-6810
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-6811
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-6812
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-6813
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-6814
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-6815
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-6816
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-6817
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-6818
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-6819
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-6820
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-6821
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-6822
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-6823
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-6824
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-6825
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-6826
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-6827
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-6828
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-6829
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-6830
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-6831
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-6832
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-6833
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-6834
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-6835
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-6836
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-6837
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-6838
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-6839
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-6840
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-6841
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-6842
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-6843
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-6844
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-6845
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-6846
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-6847
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-6848
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-6849
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-6850
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-6851
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-6852
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-6853
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-6854
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-6855
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-6856
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-6857
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-6858
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-6859
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-6860
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-6861
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-6862
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-6863
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-6864
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-6865
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-6866
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-6867
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-6868
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-6869
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-6870
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-6871
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-6872
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-6873
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-6874
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-6875
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-6876
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-6877
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-6878
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-6879
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-6880
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-6881
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-6882
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-6883
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-6884
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-6885
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-6886
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-6887
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-6888
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-6889
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-6890
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-6891
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-6892
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-6893
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-6894
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  id: totrans-6895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: becomes
  id: totrans-6896
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  id: totrans-6897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-6898
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-6899
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-6900
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-6901
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-6902
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-6903
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-6904
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-6905
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-6906
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-6907
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-6908
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-6909
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-6910
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-6911
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  id: totrans-6912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-6913
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  id: totrans-6914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-6915
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  id: totrans-6916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-6917
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-6918
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-6919
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-6920
  prefs: []
  type: TYPE_NORMAL
- en: We make numberOfWindows a constant and set it to 8 because the total number
    of windows will always be 8\. We make numberOfWindowsOpen a variable and set it
    to 3 because we’ll want to change that value when we open or close windows.
  id: totrans-6921
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-6922
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-6923
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-6924
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-6925
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  id: totrans-6926
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  id: totrans-6927
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-6928
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-6929
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-6930
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-6931
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-6932
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-6933
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-6934
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-6935
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-6936
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-6937
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-6938
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-6939
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-6940
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-6941
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-6942
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-6943
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-6944
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-6945
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-6946
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-6947
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-6948
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-6949
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-6950
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-6951
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-6952
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-6953
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-6954
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-6955
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-6956
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-6957
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-6958
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-6959
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-6960
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-6961
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-6962
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-6963
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-6964
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-6965
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-6966
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-6967
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-6968
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-6969
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-6970
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-6971
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-6972
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-6973
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-6974
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-6975
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-6976
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-6977
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-6978
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-6979
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-6980
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-6981
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-6982
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-6983
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-6984
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-6985
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-6986
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-6987
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-6988
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-6989
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-6990
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-6991
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-6992
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-6993
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-6994
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-6995
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-6996
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-6997
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-6998
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-6999
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-7000
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-7001
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-7002
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-7003
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-7004
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-7005
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-7006
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-7007
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-7008
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-7009
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-7010
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-7011
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-7012
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-7013
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-7014
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-7015
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-7016
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-7017
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-7018
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-7019
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-7020
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-7021
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-7022
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-7023
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-7024
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-7025
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-7026
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-7027
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-7028
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-7029
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-7030
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  id: totrans-7031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: becomes
  id: totrans-7032
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  id: totrans-7033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-7034
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-7035
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-7036
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-7037
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-7038
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-7039
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-7040
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-7041
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-7042
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-7043
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-7044
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-7045
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-7046
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-7047
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  id: totrans-7048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-7049
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  id: totrans-7050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-7051
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  id: totrans-7052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-7053
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-7054
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-7055
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-7056
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: use var for variables and let for constants!'
  id: totrans-7057
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-7058
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-7059
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-7060
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  id: totrans-7061
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  id: totrans-7062
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-7063
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-7064
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-7065
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-7066
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-7067
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-7068
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-7069
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-7070
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-7071
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-7072
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-7073
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-7074
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-7075
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-7076
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-7077
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-7078
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-7079
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-7080
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-7081
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-7082
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-7083
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-7084
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-7085
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-7086
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-7087
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-7088
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-7089
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-7090
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-7091
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-7092
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-7093
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-7094
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-7095
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-7096
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-7097
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-7098
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-7099
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-7100
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-7101
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-7102
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-7103
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-7104
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-7105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-7106
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-7107
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-7108
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-7109
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-7110
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-7111
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-7112
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-7113
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-7114
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-7115
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-7116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-7117
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-7118
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-7119
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-7120
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-7121
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-7122
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-7123
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-7124
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-7125
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-7126
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-7127
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-7128
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-7129
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-7130
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-7131
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-7132
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-7133
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-7134
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-7135
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-7136
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-7137
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-7138
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-7139
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-7140
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-7141
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-7142
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-7143
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-7144
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-7145
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-7146
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-7147
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-7148
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-7149
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-7150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-7151
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-7152
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-7153
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-7154
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-7155
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-7156
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-7157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-7158
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-7159
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-7160
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-7161
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-7162
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-7163
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-7164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-7165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  id: totrans-7166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: becomes
  id: totrans-7167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  id: totrans-7168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-7169
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-7170
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-7171
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-7172
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-7173
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-7174
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-7175
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-7176
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-7177
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-7178
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-7179
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-7180
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-7181
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-7182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  id: totrans-7183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-7184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  id: totrans-7185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-7186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  id: totrans-7187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-7188
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-7189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-7190
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-7191
  prefs: []
  type: TYPE_NORMAL
- en: '**NAMING CONSTANTS AND VARIABLES**'
  id: totrans-7192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-7193
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-7194
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  id: totrans-7195
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  id: totrans-7196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-7197
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-7198
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-7199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-7200
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-7201
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-7202
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-7203
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-7204
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-7205
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-7206
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-7207
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-7208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-7209
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-7210
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-7211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-7212
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-7213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-7214
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-7215
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-7216
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-7217
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-7218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-7219
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-7220
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-7221
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-7222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-7223
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-7224
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-7225
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-7226
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-7227
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-7228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-7229
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-7230
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-7231
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-7232
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-7233
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-7234
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-7235
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-7236
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-7237
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-7238
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-7239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-7240
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-7241
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-7242
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-7243
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-7244
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-7245
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-7246
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-7247
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-7248
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-7249
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-7250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-7251
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-7252
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-7253
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-7254
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-7255
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-7256
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-7257
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-7258
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-7259
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-7260
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-7261
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-7262
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-7263
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-7264
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-7265
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-7266
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-7267
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-7268
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-7269
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-7270
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-7271
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-7272
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-7273
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-7274
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-7275
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-7276
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-7277
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-7278
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-7279
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-7280
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-7281
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-7282
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-7283
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-7284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-7285
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-7286
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-7287
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-7288
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-7289
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-7290
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-7291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-7292
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-7293
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-7294
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-7295
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-7296
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-7297
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-7298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-7299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  id: totrans-7300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: becomes
  id: totrans-7301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  id: totrans-7302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-7303
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-7304
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-7305
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-7306
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-7307
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-7308
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-7309
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-7310
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-7311
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-7312
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-7313
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-7314
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-7315
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-7316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  id: totrans-7317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-7318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  id: totrans-7319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-7320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  id: totrans-7321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-7322
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-7323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-7324
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-7325
  prefs: []
  type: TYPE_NORMAL
- en: You can name a variable or constant almost anything you want, with a few exceptions.
    You can’t name them something that is already a word in Swift. For example, you
    can’t name a variable var . Writing var var would just be confusing, to you and
    the computer. You’ll get an error if you try to name a variable or constant using
    one of Swift’s reserved words. You also can’t have two variables or constants
    with the same name in the same block of code.
  id: totrans-7326
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-7327
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  id: totrans-7328
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  id: totrans-7329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-7330
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-7331
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-7332
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-7333
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-7334
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-7335
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-7336
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-7337
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-7338
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-7339
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-7340
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-7341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-7342
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-7343
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-7344
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-7345
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-7346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-7347
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-7348
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-7349
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-7350
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-7351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-7352
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-7353
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-7354
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-7355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-7356
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-7357
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-7358
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-7359
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-7360
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-7361
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-7362
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-7363
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-7364
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-7365
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-7366
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-7367
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-7368
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-7369
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-7370
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-7371
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-7372
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-7373
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-7374
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-7375
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-7376
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-7377
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-7378
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-7379
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-7380
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-7381
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-7382
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-7383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-7384
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-7385
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-7386
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-7387
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-7388
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-7389
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-7390
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-7391
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-7392
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-7393
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-7394
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-7395
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-7396
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-7397
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-7398
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-7399
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-7400
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-7401
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-7402
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-7403
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-7404
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-7405
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-7406
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-7407
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-7408
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-7409
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-7410
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-7411
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-7412
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-7413
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-7414
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-7415
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-7416
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-7417
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-7418
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-7419
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-7420
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-7421
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-7422
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-7423
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-7424
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-7425
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-7426
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-7427
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-7428
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-7429
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-7430
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-7431
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-7432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  id: totrans-7433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: becomes
  id: totrans-7434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  id: totrans-7435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-7436
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-7437
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-7438
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-7439
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-7440
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-7441
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-7442
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-7443
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-7444
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-7445
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-7446
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-7447
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-7448
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-7449
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  id: totrans-7450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-7451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  id: totrans-7452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-7453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  id: totrans-7454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-7455
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-7456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-7457
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-7458
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these rules, there are some other good programming guidelines
    to follow when naming things in Swift. Your names should always start with a lowercase
    letter. It’s also a good idea to have *very* descriptive names (they can be as
    long as you want). When you use a descriptive name, it’s a lot easier to figure
    out what that variable or constant is supposed to be. If you were looking at someone
    else’s code, which variable name would you find easier to understand: numKids
    or numberOfKidsInMyClass ? The first one is vague, but the second one is descriptive.
    It’s common to see variables and constants that are a bunch of words strung together,
    like numberOfKidsInMyClass . This capitalization style, where the first letter
    of each word is capitalized when multiple words are joined together to make a
    variable name, is called *camel case* . That’s because the pattern of lowercase
    and uppercase letters looks like the humps on a camel’s back.'
  id: totrans-7459
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  id: totrans-7460
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  id: totrans-7461
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-7462
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-7463
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-7464
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-7465
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-7466
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-7467
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-7468
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-7469
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-7470
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-7471
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-7472
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-7473
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-7474
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-7475
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-7476
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-7477
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-7478
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-7479
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-7480
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-7481
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-7482
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-7483
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-7484
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-7485
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-7486
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-7487
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-7488
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-7489
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-7490
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-7491
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-7492
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-7493
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-7494
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-7495
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-7496
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-7497
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-7498
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-7499
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-7500
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-7501
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-7502
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-7503
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-7504
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-7505
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-7506
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-7507
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-7508
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-7509
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-7510
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-7511
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-7512
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-7513
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-7514
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-7515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-7516
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-7517
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-7518
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-7519
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-7520
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-7521
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-7522
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-7523
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-7524
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-7525
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-7526
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-7527
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-7528
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-7529
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-7530
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-7531
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-7532
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-7533
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-7534
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-7535
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-7536
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-7537
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-7538
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-7539
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-7540
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-7541
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-7542
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-7543
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-7544
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-7545
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-7546
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-7547
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-7548
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-7549
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-7550
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-7551
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-7552
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-7553
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-7554
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-7555
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-7556
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-7557
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-7558
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-7559
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-7560
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-7561
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-7562
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-7563
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-7564
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  id: totrans-7565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: becomes
  id: totrans-7566
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  id: totrans-7567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-7568
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-7569
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-7570
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-7571
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-7572
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-7573
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-7574
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-7575
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-7576
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-7577
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-7578
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-7579
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-7580
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-7581
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  id: totrans-7582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-7583
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  id: totrans-7584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-7585
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  id: totrans-7586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-7587
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-7588
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-7589
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-7590
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00046.jpg)'
  id: totrans-7591
  prefs: []
  type: TYPE_IMG
- en: '**DATA TYPES**'
  id: totrans-7592
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-7593
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-7594
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-7595
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-7596
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-7597
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-7598
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-7599
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-7600
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-7601
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-7602
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-7603
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-7604
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-7605
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-7606
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-7607
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-7608
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-7609
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-7610
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-7611
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-7612
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-7613
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-7614
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-7615
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-7616
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-7617
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-7618
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-7619
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-7620
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-7621
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-7622
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-7623
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-7624
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-7625
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-7626
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-7627
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-7628
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-7629
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-7630
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-7631
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-7632
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-7633
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-7634
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-7635
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-7636
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-7637
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-7638
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-7639
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-7640
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-7641
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-7642
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-7643
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-7644
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-7645
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-7646
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-7647
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-7648
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-7649
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-7650
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-7651
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-7652
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-7653
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-7654
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-7655
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-7656
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-7657
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-7658
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-7659
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-7660
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-7661
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-7662
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-7663
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-7664
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-7665
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-7666
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-7667
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-7668
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-7669
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-7670
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-7671
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-7672
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-7673
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-7674
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-7675
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-7676
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-7677
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-7678
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-7679
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-7680
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-7681
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-7682
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-7683
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-7684
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-7685
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-7686
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-7687
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-7688
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-7689
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-7690
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-7691
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-7692
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-7693
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-7694
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-7695
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  id: totrans-7696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: becomes
  id: totrans-7697
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  id: totrans-7698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-7699
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-7700
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-7701
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-7702
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-7703
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-7704
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-7705
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-7706
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-7707
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-7708
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-7709
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-7710
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-7711
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-7712
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  id: totrans-7713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-7714
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  id: totrans-7715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-7716
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  id: totrans-7717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-7718
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-7719
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-7720
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-7721
  prefs: []
  type: TYPE_NORMAL
- en: '**DATA TYPES**'
  id: totrans-7722
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-7723
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-7724
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-7725
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-7726
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-7727
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-7728
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-7729
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-7730
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-7731
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-7732
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-7733
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-7734
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-7735
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-7736
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-7737
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-7738
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-7739
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-7740
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-7741
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-7742
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-7743
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-7744
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-7745
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-7746
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-7747
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-7748
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-7749
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-7750
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-7751
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-7752
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-7753
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-7754
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-7755
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-7756
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-7757
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-7758
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-7759
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-7760
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-7761
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-7762
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-7763
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-7764
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-7765
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-7766
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-7767
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-7768
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-7769
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-7770
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-7771
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-7772
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-7773
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-7774
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-7775
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-7776
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-7777
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-7778
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-7779
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-7780
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-7781
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-7782
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-7783
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-7784
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-7785
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-7786
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-7787
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-7788
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-7789
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-7790
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-7791
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-7792
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-7793
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-7794
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-7795
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-7796
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-7797
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-7798
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-7799
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-7800
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-7801
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-7802
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-7803
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-7804
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-7805
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-7806
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-7807
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-7808
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-7809
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-7810
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-7811
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-7812
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-7813
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-7814
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-7815
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-7816
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-7817
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-7818
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-7819
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-7820
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-7821
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-7822
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-7823
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-7824
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-7825
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  id: totrans-7826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: becomes
  id: totrans-7827
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  id: totrans-7828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-7829
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-7830
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-7831
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-7832
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-7833
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-7834
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-7835
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-7836
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-7837
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-7838
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-7839
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-7840
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-7841
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-7842
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  id: totrans-7843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-7844
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  id: totrans-7845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-7846
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  id: totrans-7847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-7848
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-7849
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-7850
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-7851
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, you can choose what kind of data—the *data type* —you want a variable
    or constant to hold. Remember how we said you can think of a variable as a container
    that holds something? Well, the data type is like the container type. The computer
    needs to know what kind of things we’ll put in each container. In Swift programming,
    once you tell the computer you want a variable or constant to hold a certain data
    type, it won’t let you put anything but that data type in that variable or constant.
    If you have a basket designed to hold potatoes, it’d be a bad idea to fill that
    basket with water—unless you like water leaking all over your shoes!
  id: totrans-7852
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-7853
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-7854
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-7855
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-7856
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-7857
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-7858
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-7859
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-7860
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-7861
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-7862
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-7863
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-7864
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-7865
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-7866
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-7867
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-7868
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-7869
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-7870
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-7871
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-7872
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-7873
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-7874
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-7875
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-7876
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-7877
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-7878
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-7879
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-7880
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-7881
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-7882
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-7883
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-7884
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-7885
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-7886
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-7887
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-7888
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-7889
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-7890
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-7891
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-7892
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-7893
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-7894
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-7895
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-7896
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-7897
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-7898
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-7899
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-7900
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-7901
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-7902
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-7903
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-7904
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-7905
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-7906
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-7907
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-7908
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-7909
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-7910
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-7911
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-7912
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-7913
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-7914
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-7915
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-7916
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-7917
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-7918
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-7919
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-7920
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-7921
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-7922
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-7923
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-7924
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-7925
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-7926
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-7927
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-7928
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-7929
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-7930
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-7931
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-7932
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-7933
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-7934
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-7935
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-7936
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-7937
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-7938
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-7939
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-7940
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-7941
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-7942
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-7943
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-7944
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-7945
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-7946
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-7947
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-7948
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-7949
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-7950
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-7951
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-7952
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-7953
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-7954
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  id: totrans-7955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: becomes
  id: totrans-7956
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  id: totrans-7957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-7958
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-7959
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-7960
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-7961
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-7962
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-7963
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-7964
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-7965
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-7966
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-7967
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-7968
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-7969
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-7970
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-7971
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  id: totrans-7972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-7973
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  id: totrans-7974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-7975
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  id: totrans-7976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-7977
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-7978
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-7979
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-7980
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00047.jpg)'
  id: totrans-7981
  prefs: []
  type: TYPE_IMG
- en: '**DECLARING DATA TYPES**'
  id: totrans-7982
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-7983
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-7984
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-7985
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-7986
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-7987
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-7988
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-7989
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-7990
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-7991
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-7992
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-7993
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-7994
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-7995
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-7996
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-7997
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-7998
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-7999
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-8000
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-8001
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-8002
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-8003
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-8004
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-8005
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-8006
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-8007
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-8008
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-8009
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-8010
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-8011
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-8012
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-8013
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-8014
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-8015
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-8016
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-8017
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-8018
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-8019
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-8020
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-8021
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-8022
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-8023
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-8024
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-8025
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-8026
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-8027
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-8028
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-8029
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-8030
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-8031
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-8032
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-8033
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-8034
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-8035
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-8036
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-8037
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-8038
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-8039
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-8040
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-8041
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-8042
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-8043
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-8044
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-8045
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-8046
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-8047
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-8048
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-8049
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-8050
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-8051
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-8052
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-8053
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-8054
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-8055
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-8056
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-8057
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-8058
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-8059
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-8060
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-8061
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-8062
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-8063
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-8064
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-8065
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-8066
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-8067
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-8068
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-8069
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-8070
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-8071
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-8072
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-8073
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-8074
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-8075
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-8076
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-8077
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-8078
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-8079
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-8080
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-8081
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-8082
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  id: totrans-8083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: becomes
  id: totrans-8084
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  id: totrans-8085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-8086
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-8087
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-8088
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-8089
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-8090
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-8091
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-8092
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-8093
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-8094
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-8095
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-8096
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-8097
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-8098
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-8099
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  id: totrans-8100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-8101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  id: totrans-8102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-8103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  id: totrans-8104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-8105
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-8106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-8107
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-8108
  prefs: []
  type: TYPE_NORMAL
- en: '**DECLARING DATA TYPES**'
  id: totrans-8109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-8110
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-8111
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-8112
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-8113
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-8114
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-8115
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-8116
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-8117
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-8118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-8119
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-8120
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-8121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-8122
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-8123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-8124
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-8125
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-8126
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-8127
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-8128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-8129
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-8130
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-8131
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-8132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-8133
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-8134
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-8135
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-8136
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-8137
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-8138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-8139
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-8140
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-8141
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-8142
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-8143
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-8144
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-8145
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-8146
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-8147
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-8148
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-8149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-8150
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-8151
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-8152
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-8153
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-8154
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-8155
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-8156
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-8157
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-8158
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-8159
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-8160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-8161
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-8162
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-8163
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-8164
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-8165
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-8166
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-8167
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-8168
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-8169
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-8170
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-8171
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-8172
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-8173
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-8174
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-8175
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-8176
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-8177
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-8178
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-8179
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-8180
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-8181
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-8182
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-8183
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-8184
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-8185
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-8186
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-8187
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-8188
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-8189
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-8190
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-8191
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-8192
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-8193
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-8194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-8195
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-8196
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-8197
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-8198
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-8199
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-8200
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-8201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-8202
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-8203
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-8204
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-8205
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-8206
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-8207
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-8208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-8209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  id: totrans-8210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: becomes
  id: totrans-8211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  id: totrans-8212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-8213
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-8214
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-8215
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-8216
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-8217
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-8218
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-8219
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-8220
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-8221
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-8222
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-8223
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-8224
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-8225
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-8226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  id: totrans-8227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-8228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  id: totrans-8229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-8230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  id: totrans-8231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-8232
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-8233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-8234
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-8235
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create a variable or a constant, you can tell the computer what type
    of data it will hold. In our example about classroom windows, we know this variable
    will always be an *integer* (that is, a whole number—you can’t really have half
    a window), so we could specify an integer data type, like this:'
  id: totrans-8236
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-8237
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-8238
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-8239
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-8240
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-8241
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-8242
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-8243
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-8244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-8245
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-8246
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-8247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-8248
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-8249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-8250
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-8251
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-8252
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-8253
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-8254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-8255
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-8256
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-8257
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-8258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-8259
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-8260
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-8261
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-8262
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-8263
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-8264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-8265
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-8266
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-8267
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-8268
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-8269
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-8270
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-8271
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-8272
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-8273
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-8274
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-8275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-8276
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-8277
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-8278
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-8279
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-8280
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-8281
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-8282
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-8283
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-8284
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-8285
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-8286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-8287
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-8288
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-8289
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-8290
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-8291
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-8292
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-8293
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-8294
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-8295
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-8296
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-8297
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-8298
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-8299
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-8300
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-8301
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-8302
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-8303
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-8304
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-8305
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-8306
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-8307
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-8308
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-8309
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-8310
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-8311
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-8312
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-8313
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-8314
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-8315
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-8316
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-8317
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-8318
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-8319
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-8320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-8321
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-8322
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-8323
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-8324
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-8325
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-8326
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-8327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-8328
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-8329
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-8330
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-8331
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-8332
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-8333
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-8334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-8335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  id: totrans-8336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: becomes
  id: totrans-8337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  id: totrans-8338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-8339
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-8340
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-8341
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-8342
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-8343
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-8344
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-8345
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-8346
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-8347
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-8348
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-8349
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-8350
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-8351
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-8352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  id: totrans-8353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-8354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  id: totrans-8355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-8356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  id: totrans-8357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-8358
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-8359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-8360
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-8361
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00048.jpg)'
  id: totrans-8362
  prefs: []
  type: TYPE_IMG
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-8363
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-8364
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-8365
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-8366
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-8367
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-8368
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-8369
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-8370
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-8371
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-8372
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-8373
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-8374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-8375
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-8376
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-8377
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-8378
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-8379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-8380
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-8381
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-8382
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-8383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-8384
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-8385
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-8386
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-8387
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-8388
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-8389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-8390
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-8391
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-8392
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-8393
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-8394
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-8395
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-8396
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-8397
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-8398
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-8399
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-8400
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-8401
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-8402
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-8403
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-8404
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-8405
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-8406
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-8407
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-8408
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-8409
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-8410
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-8411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-8412
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-8413
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-8414
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-8415
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-8416
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-8417
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-8418
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-8419
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-8420
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-8421
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-8422
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-8423
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-8424
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-8425
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-8426
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-8427
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-8428
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-8429
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-8430
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-8431
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-8432
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-8433
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-8434
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-8435
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-8436
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-8437
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-8438
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-8439
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-8440
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-8441
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-8442
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-8443
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-8444
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-8445
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-8446
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-8447
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-8448
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-8449
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-8450
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-8451
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-8452
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-8453
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-8454
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-8455
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-8456
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-8457
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-8458
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-8459
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-8460
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  id: totrans-8461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: becomes
  id: totrans-8462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  id: totrans-8463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-8464
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-8465
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-8466
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-8467
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-8468
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-8469
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-8470
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-8471
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-8472
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-8473
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-8474
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-8475
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-8476
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-8477
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  id: totrans-8478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-8479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  id: totrans-8480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-8481
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  id: totrans-8482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-8483
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-8484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-8485
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-8486
  prefs: []
  type: TYPE_NORMAL
- en: The colon means “is of type.” In plain English, this line of code says, “the
    variable numberOfWindowsOpen , which is an integer, is equal to 3.” So this line
    of code creates a variable, gives it a name, tells the computer its data type,
    and assigns it a value. Phew! One line of code did all that? Did we mention that
    Swift is a very *concise* language? Some languages might require several lines
    of code to do this same thing. Swift is designed so that you can do a bunch of
    things with just one line of code!
  id: totrans-8487
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-8488
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-8489
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-8490
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-8491
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-8492
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-8493
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-8494
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-8495
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-8496
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-8497
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-8498
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-8499
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-8500
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-8501
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-8502
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-8503
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-8504
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-8505
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-8506
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-8507
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-8508
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-8509
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-8510
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-8511
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-8512
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-8513
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-8514
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-8515
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-8516
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-8517
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-8518
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-8519
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-8520
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-8521
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-8522
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-8523
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-8524
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-8525
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-8526
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-8527
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-8528
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-8529
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-8530
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-8531
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-8532
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-8533
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-8534
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-8535
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-8536
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-8537
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-8538
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-8539
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-8540
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-8541
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-8542
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-8543
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-8544
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-8545
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-8546
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-8547
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-8548
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-8549
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-8550
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-8551
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-8552
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-8553
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-8554
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-8555
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-8556
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-8557
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-8558
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-8559
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-8560
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-8561
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-8562
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-8563
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-8564
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-8565
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-8566
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-8567
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-8568
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-8569
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-8570
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-8571
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-8572
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-8573
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-8574
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-8575
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-8576
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-8577
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-8578
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-8579
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-8580
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-8581
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-8582
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-8583
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-8584
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  id: totrans-8585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: becomes
  id: totrans-8586
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  id: totrans-8587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-8588
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-8589
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-8590
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-8591
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-8592
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-8593
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-8594
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-8595
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-8596
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-8597
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-8598
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-8599
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-8600
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-8601
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  id: totrans-8602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-8603
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  id: totrans-8604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-8605
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  id: totrans-8606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-8607
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-8608
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-8609
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-8610
  prefs: []
  type: TYPE_NORMAL
- en: You only have to declare the data type once. When we tell the computer that
    a variable will hold integers, we don’t have to tell it again. In fact, if we
    do, Xcode will give us an error. Once the data type is declared, a variable or
    constant will hold that type of data forever. Once an integer, always an integer!
  id: totrans-8611
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-8612
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-8613
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-8614
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-8615
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-8616
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-8617
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-8618
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-8619
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-8620
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-8621
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-8622
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-8623
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-8624
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-8625
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-8626
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-8627
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-8628
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-8629
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-8630
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-8631
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-8632
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-8633
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-8634
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-8635
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-8636
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-8637
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-8638
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-8639
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-8640
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-8641
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-8642
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-8643
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-8644
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-8645
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-8646
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-8647
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-8648
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-8649
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-8650
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-8651
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-8652
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-8653
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-8654
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-8655
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-8656
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-8657
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-8658
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-8659
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-8660
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-8661
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-8662
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-8663
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-8664
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-8665
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-8666
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-8667
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-8668
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-8669
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-8670
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-8671
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-8672
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-8673
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-8674
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-8675
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-8676
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-8677
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-8678
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-8679
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-8680
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-8681
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-8682
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-8683
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-8684
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-8685
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-8686
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-8687
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-8688
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-8689
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-8690
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-8691
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-8692
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-8693
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-8694
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-8695
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-8696
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-8697
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-8698
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-8699
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-8700
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-8701
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-8702
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-8703
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-8704
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-8705
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-8706
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-8707
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  id: totrans-8708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: becomes
  id: totrans-8709
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  id: totrans-8710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-8711
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-8712
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-8713
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-8714
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-8715
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-8716
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-8717
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-8718
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-8719
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-8720
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-8721
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-8722
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-8723
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-8724
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  id: totrans-8725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-8726
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  id: totrans-8727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-8728
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  id: totrans-8729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-8730
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-8731
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-8732
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-8733
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more thing you need to know about data types: a variable or constant
    can’t hold something that isn’t its data type. For example, if you try to put
    a decimal number into numberOfWindowsOpen , you’ll get an error, as shown in [Figure
    2-6](text00012.html#ch02fig6) .'
  id: totrans-8734
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-8735
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-8736
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-8737
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-8738
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-8739
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-8740
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-8741
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-8742
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-8743
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-8744
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-8745
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-8746
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-8747
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-8748
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-8749
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-8750
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-8751
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-8752
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-8753
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-8754
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-8755
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-8756
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-8757
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-8758
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-8759
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-8760
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-8761
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-8762
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-8763
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-8764
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-8765
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-8766
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-8767
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-8768
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-8769
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-8770
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-8771
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-8772
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-8773
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-8774
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-8775
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-8776
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-8777
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-8778
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-8779
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-8780
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-8781
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-8782
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-8783
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-8784
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-8785
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-8786
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-8787
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-8788
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-8789
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-8790
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-8791
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-8792
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-8793
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-8794
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-8795
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-8796
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-8797
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-8798
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-8799
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-8800
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-8801
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-8802
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-8803
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-8804
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-8805
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-8806
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-8807
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-8808
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-8809
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-8810
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-8811
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-8812
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-8813
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-8814
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-8815
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-8816
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-8817
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-8818
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-8819
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-8820
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-8821
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-8822
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-8823
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-8824
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-8825
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-8826
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-8827
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-8828
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-8829
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  id: totrans-8830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: becomes
  id: totrans-8831
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  id: totrans-8832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-8833
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-8834
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-8835
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-8836
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-8837
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-8838
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-8839
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-8840
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-8841
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-8842
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-8843
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-8844
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-8845
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-8846
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  id: totrans-8847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-8848
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  id: totrans-8849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-8850
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  id: totrans-8851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-8852
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-8853
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-8854
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-8855
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00049.jpg)'
  id: totrans-8856
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-8857
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-8858
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-8859
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-8860
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-8861
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-8862
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-8863
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-8864
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-8865
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-8866
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-8867
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-8868
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-8869
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-8870
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-8871
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-8872
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-8873
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-8874
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-8875
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-8876
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-8877
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-8878
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-8879
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-8880
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-8881
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-8882
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-8883
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-8884
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-8885
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-8886
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-8887
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-8888
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-8889
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-8890
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-8891
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-8892
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-8893
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-8894
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-8895
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-8896
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-8897
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-8898
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-8899
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-8900
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-8901
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-8902
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-8903
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-8904
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-8905
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-8906
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-8907
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-8908
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-8909
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-8910
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-8911
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-8912
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-8913
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-8914
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-8915
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-8916
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-8917
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-8918
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-8919
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-8920
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-8921
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-8922
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-8923
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-8924
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-8925
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-8926
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-8927
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-8928
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-8929
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-8930
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-8931
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-8932
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-8933
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-8934
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-8935
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-8936
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-8937
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-8938
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-8939
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-8940
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-8941
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-8942
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-8943
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-8944
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-8945
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-8946
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-8947
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-8948
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-8949
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-8950
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  id: totrans-8951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: becomes
  id: totrans-8952
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  id: totrans-8953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-8954
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-8955
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-8956
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-8957
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-8958
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-8959
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-8960
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-8961
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-8962
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-8963
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-8964
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-8965
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-8966
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-8967
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  id: totrans-8968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-8969
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  id: totrans-8970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-8971
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  id: totrans-8972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-8973
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-8974
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-8975
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-8976
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2-6: You can’t put a decimal number into a variable that is supposed
    to hold an integer.*'
  id: totrans-8977
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-8978
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-8979
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-8980
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-8981
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-8982
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-8983
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-8984
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-8985
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-8986
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-8987
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-8988
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-8989
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-8990
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-8991
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-8992
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-8993
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-8994
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-8995
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-8996
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-8997
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-8998
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-8999
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-9000
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-9001
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-9002
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-9003
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-9004
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-9005
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-9006
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-9007
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-9008
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-9009
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-9010
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-9011
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-9012
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-9013
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-9014
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-9015
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-9016
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-9017
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-9018
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-9019
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-9020
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-9021
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-9022
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-9023
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-9024
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-9025
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-9026
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-9027
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-9028
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-9029
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-9030
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-9031
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-9032
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-9033
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-9034
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-9035
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-9036
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-9037
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-9038
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-9039
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-9040
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-9041
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-9042
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-9043
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-9044
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-9045
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-9046
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-9047
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-9048
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-9049
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-9050
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-9051
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-9052
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-9053
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-9054
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-9055
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-9056
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-9057
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-9058
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-9059
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-9060
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-9061
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-9062
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-9063
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-9064
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-9065
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-9066
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-9067
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-9068
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-9069
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-9070
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  id: totrans-9071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: becomes
  id: totrans-9072
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  id: totrans-9073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-9074
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-9075
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-9076
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-9077
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-9078
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-9079
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-9080
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-9081
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-9082
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-9083
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-9084
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-9085
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-9086
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-9087
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  id: totrans-9088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-9089
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  id: totrans-9090
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-9091
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  id: totrans-9092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-9093
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-9094
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-9095
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-9096
  prefs: []
  type: TYPE_NORMAL
- en: Setting numberOfWindowsOpen = 5 and numberOfWindowsOpen = 0 is valid and works.
    But you can’t set numberOfWindowsOpen = 1.5 .
  id: totrans-9097
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-9098
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-9099
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-9100
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-9101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-9102
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-9103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-9104
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-9105
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-9106
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-9107
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-9108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-9109
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-9110
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-9111
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-9112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-9113
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-9114
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-9115
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-9116
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-9117
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-9118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-9119
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-9120
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-9121
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-9122
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-9123
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-9124
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-9125
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-9126
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-9127
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-9128
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-9129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-9130
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-9131
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-9132
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-9133
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-9134
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-9135
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-9136
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-9137
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-9138
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-9139
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-9140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-9141
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-9142
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-9143
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-9144
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-9145
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-9146
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-9147
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-9148
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-9149
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-9150
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-9151
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-9152
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-9153
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-9154
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-9155
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-9156
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-9157
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-9158
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-9159
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-9160
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-9161
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-9162
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-9163
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-9164
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-9165
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-9166
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-9167
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-9168
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-9169
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-9170
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-9171
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-9172
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-9173
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-9174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-9175
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-9176
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-9177
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-9178
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-9179
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-9180
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-9181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-9182
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-9183
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-9184
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-9185
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-9186
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-9187
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-9188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-9189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  id: totrans-9190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: becomes
  id: totrans-9191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  id: totrans-9192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-9193
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-9194
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-9195
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-9196
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-9197
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-9198
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-9199
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-9200
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-9201
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-9202
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-9203
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-9204
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-9205
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-9206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  id: totrans-9207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-9208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  id: totrans-9209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-9210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  id: totrans-9211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-9212
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-9213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-9214
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-9215
  prefs: []
  type: TYPE_NORMAL
- en: '**COMMON DATA TYPES**'
  id: totrans-9216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-9217
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-9218
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-9219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-9220
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-9221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-9222
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-9223
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-9224
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-9225
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-9226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-9227
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-9228
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-9229
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-9230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-9231
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-9232
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-9233
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-9234
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-9235
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-9236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-9237
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-9238
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-9239
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-9240
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-9241
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-9242
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-9243
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-9244
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-9245
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-9246
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-9247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-9248
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-9249
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-9250
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-9251
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-9252
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-9253
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-9254
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-9255
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-9256
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-9257
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-9258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-9259
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-9260
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-9261
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-9262
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-9263
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-9264
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-9265
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-9266
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-9267
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-9268
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-9269
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-9270
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-9271
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-9272
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-9273
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-9274
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-9275
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-9276
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-9277
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-9278
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-9279
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-9280
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-9281
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-9282
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-9283
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-9284
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-9285
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-9286
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-9287
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-9288
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-9289
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-9290
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-9291
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-9292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-9293
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-9294
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-9295
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-9296
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-9297
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-9298
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-9299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-9300
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-9301
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-9302
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-9303
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-9304
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-9305
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-9306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-9307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  id: totrans-9308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: becomes
  id: totrans-9309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  id: totrans-9310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-9311
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-9312
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-9313
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-9314
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-9315
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-9316
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-9317
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-9318
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-9319
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-9320
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-9321
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-9322
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-9323
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-9324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  id: totrans-9325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-9326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  id: totrans-9327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-9328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  id: totrans-9329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-9330
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-9331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-9332
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-9333
  prefs: []
  type: TYPE_NORMAL
- en: As you just learned, a data type lets the computer know what *kind* of data
    it is working with and how to store it in its memory. But what are the data types?
    Some common ones include Int , Double , Float , Bool , and String .
  id: totrans-9334
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-9335
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-9336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-9337
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-9338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-9339
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-9340
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-9341
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-9342
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-9343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-9344
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-9345
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-9346
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-9347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-9348
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-9349
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-9350
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-9351
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-9352
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-9353
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-9354
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-9355
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-9356
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-9357
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-9358
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-9359
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-9360
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-9361
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-9362
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-9363
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-9364
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-9365
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-9366
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-9367
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-9368
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-9369
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-9370
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-9371
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-9372
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-9373
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-9374
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-9375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-9376
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-9377
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-9378
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-9379
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-9380
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-9381
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-9382
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-9383
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-9384
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-9385
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-9386
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-9387
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-9388
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-9389
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-9390
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-9391
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-9392
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-9393
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-9394
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-9395
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-9396
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-9397
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-9398
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-9399
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-9400
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-9401
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-9402
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-9403
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-9404
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-9405
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-9406
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-9407
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-9408
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-9409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-9410
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-9411
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-9412
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-9413
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-9414
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-9415
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-9416
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-9417
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-9418
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-9419
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-9420
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-9421
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-9422
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-9423
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-9424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  id: totrans-9425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: becomes
  id: totrans-9426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  id: totrans-9427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-9428
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-9429
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-9430
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-9431
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-9432
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-9433
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-9434
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-9435
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-9436
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-9437
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-9438
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-9439
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-9440
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-9441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  id: totrans-9442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-9443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  id: totrans-9444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-9445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  id: totrans-9446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-9447
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-9448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-9449
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-9450
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig in and see what each one of these actually is!
  id: totrans-9451
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-9452
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-9453
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-9454
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-9455
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-9456
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-9457
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-9458
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-9459
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-9460
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-9461
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-9462
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-9463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-9464
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-9465
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-9466
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-9467
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-9468
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-9469
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-9470
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-9471
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-9472
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-9473
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-9474
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-9475
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-9476
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-9477
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-9478
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-9479
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-9480
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-9481
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-9482
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-9483
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-9484
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-9485
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-9486
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-9487
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-9488
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-9489
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-9490
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-9491
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-9492
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-9493
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-9494
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-9495
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-9496
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-9497
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-9498
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-9499
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-9500
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-9501
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-9502
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-9503
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-9504
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-9505
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-9506
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-9507
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-9508
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-9509
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-9510
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-9511
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-9512
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-9513
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-9514
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-9515
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-9516
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-9517
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-9518
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-9519
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-9520
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-9521
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-9522
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-9523
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-9524
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-9525
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-9526
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-9527
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-9528
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-9529
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-9530
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-9531
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-9532
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-9533
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-9534
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-9535
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-9536
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-9537
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-9538
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-9539
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-9540
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  id: totrans-9541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: becomes
  id: totrans-9542
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  id: totrans-9543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-9544
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-9545
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-9546
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-9547
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-9548
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-9549
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-9550
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-9551
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-9552
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-9553
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-9554
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-9555
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-9556
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-9557
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  id: totrans-9558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-9559
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  id: totrans-9560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-9561
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  id: totrans-9562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-9563
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-9564
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-9565
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-9566
  prefs: []
  type: TYPE_NORMAL
- en: '**Int (Integers)**'
  id: totrans-9567
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-9568
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-9569
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-9570
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-9571
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-9572
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-9573
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-9574
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-9575
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-9576
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-9577
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-9578
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-9579
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-9580
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-9581
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-9582
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-9583
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-9584
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-9585
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-9586
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-9587
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-9588
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-9589
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-9590
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-9591
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-9592
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-9593
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-9594
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-9595
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-9596
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-9597
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-9598
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-9599
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-9600
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-9601
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-9602
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-9603
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-9604
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-9605
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-9606
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-9607
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-9608
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-9609
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-9610
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-9611
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-9612
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-9613
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-9614
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-9615
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-9616
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-9617
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-9618
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-9619
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-9620
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-9621
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-9622
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-9623
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-9624
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-9625
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-9626
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-9627
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-9628
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-9629
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-9630
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-9631
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-9632
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-9633
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-9634
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-9635
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-9636
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-9637
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-9638
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-9639
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-9640
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-9641
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-9642
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-9643
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-9644
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-9645
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-9646
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-9647
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-9648
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-9649
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-9650
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-9651
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-9652
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-9653
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-9654
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-9655
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  id: totrans-9656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: becomes
  id: totrans-9657
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  id: totrans-9658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-9659
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-9660
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-9661
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-9662
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-9663
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-9664
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-9665
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-9666
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-9667
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-9668
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-9669
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-9670
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-9671
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-9672
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  id: totrans-9673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-9674
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  id: totrans-9675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-9676
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  id: totrans-9677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-9678
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-9679
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-9680
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-9681
  prefs: []
  type: TYPE_NORMAL
- en: We already talked a little bit about integers, but let’s go over them in more
    detail. An integer, called an Int in Swift, is a whole number that has no decimal
    or fractional part. You can think of them as counting numbers. Integers are *signed*
    , meaning that they can be negative or positive (or zero).
  id: totrans-9682
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-9683
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-9684
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-9685
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-9686
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-9687
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-9688
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-9689
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-9690
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-9691
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-9692
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-9693
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-9694
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-9695
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-9696
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-9697
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-9698
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-9699
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-9700
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-9701
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-9702
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-9703
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-9704
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-9705
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-9706
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-9707
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-9708
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-9709
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-9710
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-9711
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-9712
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-9713
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-9714
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-9715
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-9716
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-9717
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-9718
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-9719
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-9720
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-9721
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-9722
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-9723
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-9724
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-9725
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-9726
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-9727
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-9728
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-9729
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-9730
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-9731
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-9732
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-9733
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-9734
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-9735
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-9736
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-9737
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-9738
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-9739
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-9740
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-9741
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-9742
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-9743
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-9744
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-9745
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-9746
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-9747
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-9748
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-9749
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-9750
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-9751
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-9752
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-9753
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-9754
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-9755
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-9756
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-9757
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-9758
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-9759
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-9760
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-9761
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-9762
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-9763
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-9764
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-9765
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-9766
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-9767
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-9768
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-9769
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  id: totrans-9770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: becomes
  id: totrans-9771
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  id: totrans-9772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-9773
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-9774
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-9775
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-9776
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-9777
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-9778
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-9779
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-9780
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-9781
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-9782
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-9783
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-9784
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-9785
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-9786
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  id: totrans-9787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-9788
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  id: totrans-9789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-9790
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  id: totrans-9791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-9792
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-9793
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-9794
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-9795
  prefs: []
  type: TYPE_NORMAL
- en: '**Double and Float (Decimal Numbers)**'
  id: totrans-9796
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-9797
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-9798
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-9799
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-9800
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-9801
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-9802
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-9803
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-9804
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-9805
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-9806
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-9807
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-9808
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-9809
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-9810
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-9811
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-9812
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-9813
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-9814
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-9815
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-9816
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-9817
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-9818
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-9819
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-9820
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-9821
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-9822
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-9823
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-9824
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-9825
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-9826
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-9827
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-9828
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-9829
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-9830
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-9831
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-9832
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-9833
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-9834
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-9835
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-9836
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-9837
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-9838
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-9839
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-9840
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-9841
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-9842
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-9843
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-9844
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-9845
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-9846
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-9847
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-9848
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-9849
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-9850
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-9851
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-9852
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-9853
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-9854
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-9855
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-9856
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-9857
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-9858
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-9859
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-9860
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-9861
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-9862
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-9863
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-9864
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-9865
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-9866
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-9867
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-9868
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-9869
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-9870
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-9871
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-9872
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-9873
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-9874
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-9875
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-9876
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-9877
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-9878
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-9879
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-9880
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-9881
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-9882
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  id: totrans-9883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: becomes
  id: totrans-9884
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  id: totrans-9885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-9886
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-9887
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-9888
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-9889
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-9890
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-9891
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-9892
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-9893
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-9894
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-9895
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-9896
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-9897
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-9898
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-9899
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  id: totrans-9900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-9901
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  id: totrans-9902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-9903
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  id: totrans-9904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-9905
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-9906
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-9907
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-9908
  prefs: []
  type: TYPE_NORMAL
- en: '*Decimal numbers* are numbers that have digits after the decimal point, like
    3.14\. (An integer like 3 would be written as 3.0 if you wanted it to be a decimal
    number.) There are two data types that can store decimal numbers: a Double and
    a Float (short for *floating-point number* ). The Double data type is more common
    in Swift because it can hold bigger numbers, so we’ll focus on those.'
  id: totrans-9909
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-9910
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-9911
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-9912
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-9913
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-9914
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-9915
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-9916
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-9917
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-9918
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-9919
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-9920
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-9921
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-9922
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-9923
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-9924
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-9925
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-9926
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-9927
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-9928
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-9929
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-9930
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-9931
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-9932
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-9933
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-9934
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-9935
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-9936
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-9937
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-9938
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-9939
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-9940
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-9941
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-9942
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-9943
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-9944
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-9945
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-9946
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-9947
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-9948
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-9949
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-9950
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-9951
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-9952
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-9953
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-9954
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-9955
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-9956
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-9957
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-9958
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-9959
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-9960
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-9961
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-9962
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-9963
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-9964
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-9965
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-9966
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-9967
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-9968
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-9969
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-9970
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-9971
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-9972
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-9973
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-9974
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-9975
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-9976
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-9977
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-9978
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-9979
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-9980
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-9981
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-9982
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-9983
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-9984
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-9985
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-9986
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-9987
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-9988
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-9989
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-9990
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-9991
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-9992
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-9993
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-9994
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  id: totrans-9995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: becomes
  id: totrans-9996
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  id: totrans-9997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-9998
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-9999
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-10000
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-10001
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-10002
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-10003
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-10004
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-10005
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-10006
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-10007
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-10008
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-10009
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-10010
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-10011
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  id: totrans-10012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-10013
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  id: totrans-10014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-10015
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  id: totrans-10016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-10017
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-10018
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-10019
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-10020
  prefs: []
  type: TYPE_NORMAL
- en: 'When you assign a Double , you must always have a digit to the left of the
    decimal place or you will get an error. For example, suppose bananas cost 19 cents
    each:'
  id: totrans-10021
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-10022
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-10023
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-10024
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-10025
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-10026
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-10027
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-10028
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-10029
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-10030
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-10031
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-10032
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-10033
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-10034
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-10035
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-10036
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-10037
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-10038
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-10039
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-10040
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-10041
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-10042
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-10043
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-10044
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-10045
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-10046
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-10047
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-10048
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-10049
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-10050
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-10051
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-10052
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-10053
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-10054
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-10055
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-10056
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-10057
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-10058
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-10059
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-10060
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-10061
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-10062
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-10063
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-10064
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-10065
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-10066
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-10067
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-10068
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-10069
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-10070
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-10071
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-10072
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-10073
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-10074
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-10075
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-10076
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-10077
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-10078
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-10079
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-10080
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-10081
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-10082
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-10083
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-10084
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-10085
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-10086
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-10087
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-10088
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-10089
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-10090
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-10091
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-10092
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-10093
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-10094
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-10095
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-10096
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-10097
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-10098
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-10099
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-10100
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-10101
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-10102
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-10103
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-10104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-10105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  id: totrans-10106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: becomes
  id: totrans-10107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  id: totrans-10108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-10109
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-10110
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-10111
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-10112
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-10113
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-10114
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-10115
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-10116
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-10117
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-10118
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-10119
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-10120
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-10121
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-10122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  id: totrans-10123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-10124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  id: totrans-10125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-10126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  id: totrans-10127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-10128
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-10129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-10130
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-10131
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00050.jpg)'
  id: totrans-10132
  prefs: []
  type: TYPE_IMG
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-10133
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-10134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-10135
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-10136
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-10137
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-10138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-10139
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-10140
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-10141
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-10142
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-10143
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-10144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-10145
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-10146
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-10147
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-10148
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-10149
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-10150
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-10151
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-10152
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-10153
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-10154
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-10155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-10156
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-10157
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-10158
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-10159
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-10160
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-10161
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-10162
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-10163
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-10164
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-10165
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-10166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-10167
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-10168
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-10169
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-10170
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-10171
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-10172
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-10173
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-10174
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-10175
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-10176
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-10177
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-10178
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-10179
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-10180
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-10181
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-10182
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-10183
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-10184
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-10185
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-10186
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-10187
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-10188
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-10189
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-10190
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-10191
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-10192
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-10193
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-10194
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-10195
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-10196
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-10197
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-10198
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-10199
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-10200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-10201
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-10202
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-10203
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-10204
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-10205
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-10206
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-10207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-10208
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-10209
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-10210
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-10211
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-10212
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-10213
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-10214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-10215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  id: totrans-10216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: becomes
  id: totrans-10217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  id: totrans-10218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-10219
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-10220
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-10221
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-10222
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-10223
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-10224
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-10225
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-10226
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-10227
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-10228
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-10229
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-10230
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-10231
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-10232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  id: totrans-10233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-10234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  id: totrans-10235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-10236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  id: totrans-10237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-10238
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-10239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-10240
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-10241
  prefs: []
  type: TYPE_NORMAL
- en: The code at ➊ will result in an error because it doesn’t have a digit to the
    left of the decimal point. The code at ➋ works fine because it has a leading zero.
    (The phrases // ERROR and // CORRECT are *comments* , which are notes in a program
    that are ignored by the computer. See “[A Few Quick Comments About Comments](text00012.html#ch02sb01)
    ” on [page 32](text00012.html#page_32) .)
  id: totrans-10242
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-10243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-10244
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-10245
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-10246
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-10247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-10248
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-10249
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-10250
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-10251
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-10252
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-10253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-10254
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-10255
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-10256
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-10257
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-10258
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-10259
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-10260
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-10261
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-10262
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-10263
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-10264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-10265
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-10266
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-10267
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-10268
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-10269
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-10270
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-10271
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-10272
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-10273
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-10274
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-10275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-10276
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-10277
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-10278
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-10279
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-10280
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-10281
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-10282
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-10283
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-10284
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-10285
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-10286
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-10287
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-10288
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-10289
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-10290
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-10291
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-10292
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-10293
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-10294
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-10295
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-10296
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-10297
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-10298
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-10299
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-10300
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-10301
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-10302
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-10303
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-10304
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-10305
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-10306
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-10307
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-10308
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-10309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-10310
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-10311
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-10312
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-10313
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-10314
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-10315
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-10316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-10317
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-10318
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-10319
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-10320
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-10321
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-10322
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-10323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-10324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  id: totrans-10325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: becomes
  id: totrans-10326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  id: totrans-10327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-10328
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-10329
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-10330
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-10331
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-10332
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-10333
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-10334
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-10335
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-10336
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-10337
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-10338
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-10339
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-10340
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-10341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  id: totrans-10342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-10343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  id: totrans-10344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-10345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  id: totrans-10346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-10347
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-10348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-10349
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-10350
  prefs: []
  type: TYPE_NORMAL
- en: '**Bool (Booleans, or True/False)**'
  id: totrans-10351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-10352
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-10353
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-10354
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-10355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-10356
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-10357
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-10358
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-10359
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-10360
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-10361
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-10362
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-10363
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-10364
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-10365
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-10366
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-10367
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-10368
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-10369
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-10370
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-10371
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-10372
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-10373
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-10374
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-10375
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-10376
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-10377
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-10378
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-10379
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-10380
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-10381
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-10382
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-10383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-10384
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-10385
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-10386
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-10387
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-10388
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-10389
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-10390
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-10391
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-10392
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-10393
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-10394
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-10395
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-10396
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-10397
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-10398
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-10399
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-10400
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-10401
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-10402
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-10403
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-10404
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-10405
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-10406
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-10407
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-10408
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-10409
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-10410
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-10411
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-10412
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-10413
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-10414
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-10415
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-10416
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-10417
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-10418
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-10419
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-10420
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-10421
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-10422
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-10423
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-10424
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-10425
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-10426
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-10427
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-10428
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-10429
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-10430
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-10431
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-10432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  id: totrans-10433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: becomes
  id: totrans-10434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  id: totrans-10435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-10436
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-10437
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-10438
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-10439
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-10440
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-10441
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-10442
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-10443
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-10444
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-10445
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-10446
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-10447
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-10448
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-10449
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  id: totrans-10450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-10451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  id: totrans-10452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-10453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  id: totrans-10454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-10455
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-10456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-10457
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-10458
  prefs: []
  type: TYPE_NORMAL
- en: 'A *Boolean value* can only be one of two things: true or false. In Swift, the
    Boolean data type is called a Bool .'
  id: totrans-10459
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-10460
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-10461
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-10462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-10463
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-10464
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-10465
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-10466
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-10467
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-10468
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-10469
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-10470
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-10471
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-10472
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-10473
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-10474
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-10475
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-10476
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-10477
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-10478
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-10479
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-10480
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-10481
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-10482
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-10483
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-10484
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-10485
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-10486
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-10487
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-10488
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-10489
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-10490
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-10491
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-10492
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-10493
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-10494
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-10495
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-10496
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-10497
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-10498
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-10499
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-10500
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-10501
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-10502
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-10503
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-10504
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-10505
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-10506
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-10507
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-10508
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-10509
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-10510
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-10511
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-10512
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-10513
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-10514
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-10515
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-10516
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-10517
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-10518
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-10519
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-10520
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-10521
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-10522
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-10523
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-10524
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-10525
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-10526
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-10527
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-10528
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-10529
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-10530
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-10531
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-10532
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-10533
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-10534
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-10535
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-10536
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-10537
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-10538
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-10539
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  id: totrans-10540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: becomes
  id: totrans-10541
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  id: totrans-10542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-10543
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-10544
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-10545
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-10546
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-10547
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-10548
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-10549
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-10550
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-10551
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-10552
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-10553
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-10554
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-10555
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-10556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  id: totrans-10557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-10558
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  id: totrans-10559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-10560
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  id: totrans-10561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-10562
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-10563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-10564
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-10565
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00051.jpg)'
  id: totrans-10566
  prefs: []
  type: TYPE_IMG
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-10567
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-10568
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-10569
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-10570
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-10571
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-10572
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-10573
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-10574
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-10575
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-10576
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-10577
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-10578
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-10579
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-10580
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-10581
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-10582
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-10583
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-10584
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-10585
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-10586
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-10587
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-10588
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-10589
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-10590
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-10591
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-10592
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-10593
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-10594
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-10595
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-10596
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-10597
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-10598
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-10599
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-10600
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-10601
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-10602
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-10603
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-10604
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-10605
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-10606
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-10607
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-10608
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-10609
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-10610
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-10611
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-10612
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-10613
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-10614
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-10615
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-10616
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-10617
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-10618
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-10619
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-10620
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-10621
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-10622
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-10623
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-10624
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-10625
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-10626
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-10627
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-10628
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-10629
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-10630
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-10631
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-10632
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-10633
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-10634
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-10635
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-10636
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-10637
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-10638
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-10639
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-10640
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-10641
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-10642
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-10643
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-10644
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-10645
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  id: totrans-10646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: becomes
  id: totrans-10647
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  id: totrans-10648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-10649
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-10650
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-10651
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-10652
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-10653
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-10654
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-10655
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-10656
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-10657
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-10658
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-10659
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-10660
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-10661
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-10662
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  id: totrans-10663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-10664
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  id: totrans-10665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-10666
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  id: totrans-10667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-10668
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-10669
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-10670
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-10671
  prefs: []
  type: TYPE_NORMAL
- en: Booleans are often used in if-else statements to tell the computer which path
    a program should take. (We’ll cover Booleans and if-else statements in more detail
    in [Chapter 3](text00013.html#ch03) .)
  id: totrans-10672
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-10673
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-10674
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-10675
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-10676
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-10677
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-10678
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-10679
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-10680
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-10681
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-10682
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-10683
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-10684
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-10685
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-10686
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-10687
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-10688
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-10689
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-10690
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-10691
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-10692
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-10693
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-10694
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-10695
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-10696
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-10697
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-10698
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-10699
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-10700
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-10701
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-10702
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-10703
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-10704
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-10705
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-10706
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-10707
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-10708
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-10709
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-10710
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-10711
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-10712
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-10713
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-10714
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-10715
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-10716
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-10717
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-10718
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-10719
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-10720
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-10721
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-10722
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-10723
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-10724
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-10725
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-10726
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-10727
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-10728
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-10729
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-10730
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-10731
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-10732
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-10733
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-10734
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-10735
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-10736
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-10737
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-10738
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-10739
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-10740
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-10741
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-10742
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-10743
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-10744
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-10745
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-10746
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-10747
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-10748
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-10749
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-10750
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE375]'
  id: totrans-10751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: becomes
  id: totrans-10752
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  id: totrans-10753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-10754
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-10755
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-10756
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-10757
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-10758
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-10759
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-10760
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-10761
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-10762
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-10763
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-10764
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-10765
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-10766
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-10767
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  id: totrans-10768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-10769
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  id: totrans-10770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-10771
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  id: totrans-10772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-10773
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-10774
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-10775
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-10776
  prefs: []
  type: TYPE_NORMAL
- en: '**String**'
  id: totrans-10777
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-10778
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-10779
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-10780
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-10781
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-10782
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-10783
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-10784
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-10785
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-10786
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-10787
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-10788
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-10789
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-10790
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-10791
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-10792
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-10793
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-10794
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-10795
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-10796
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-10797
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-10798
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-10799
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-10800
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-10801
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-10802
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-10803
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-10804
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-10805
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-10806
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-10807
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-10808
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-10809
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-10810
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-10811
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-10812
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-10813
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-10814
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-10815
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-10816
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-10817
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-10818
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-10819
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-10820
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-10821
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-10822
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-10823
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-10824
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-10825
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-10826
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-10827
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-10828
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-10829
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-10830
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-10831
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-10832
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-10833
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-10834
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-10835
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-10836
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-10837
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-10838
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-10839
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-10840
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-10841
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-10842
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-10843
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-10844
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-10845
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-10846
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-10847
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-10848
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-10849
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-10850
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-10851
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-10852
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-10853
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-10854
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  id: totrans-10855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: becomes
  id: totrans-10856
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  id: totrans-10857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-10858
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-10859
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-10860
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-10861
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-10862
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-10863
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-10864
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-10865
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-10866
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-10867
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-10868
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-10869
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-10870
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-10871
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  id: totrans-10872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-10873
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  id: totrans-10874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-10875
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  id: totrans-10876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-10877
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-10878
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-10879
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-10880
  prefs: []
  type: TYPE_NORMAL
- en: 'The String data type is used to store words and phrases. A *string* is a collection
    of characters enclosed in quotation marks. For example, "Hello, playground" is
    a string. Strings can be made up of all sorts of characters: letters, numbers,
    symbols, and more. The quotation marks are important because they tell the computer
    that everything in between the quotes is part of a string that you’re creating.'
  id: totrans-10881
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-10882
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-10883
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-10884
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-10885
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-10886
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-10887
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-10888
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-10889
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-10890
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-10891
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-10892
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-10893
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-10894
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-10895
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-10896
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-10897
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-10898
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-10899
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-10900
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-10901
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-10902
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-10903
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-10904
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-10905
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-10906
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-10907
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-10908
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-10909
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-10910
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-10911
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-10912
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-10913
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-10914
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-10915
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-10916
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-10917
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-10918
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-10919
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-10920
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-10921
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-10922
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-10923
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-10924
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-10925
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-10926
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-10927
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-10928
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-10929
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-10930
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-10931
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-10932
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-10933
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-10934
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-10935
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-10936
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-10937
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-10938
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-10939
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-10940
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-10941
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-10942
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-10943
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-10944
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-10945
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-10946
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-10947
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-10948
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-10949
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-10950
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-10951
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-10952
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-10953
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-10954
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-10955
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-10956
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-10957
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  id: totrans-10958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: becomes
  id: totrans-10959
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  id: totrans-10960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-10961
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-10962
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-10963
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-10964
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-10965
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-10966
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-10967
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-10968
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-10969
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-10970
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-10971
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-10972
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-10973
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-10974
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  id: totrans-10975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-10976
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  id: totrans-10977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-10978
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  id: totrans-10979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-10980
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-10981
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-10982
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-10983
  prefs: []
  type: TYPE_NORMAL
- en: You can use strings to build sentences by adding strings together in a process
    called string *concatenation* . Let’s see how it works!
  id: totrans-10984
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-10985
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-10986
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-10987
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-10988
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-10989
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-10990
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-10991
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-10992
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-10993
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-10994
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-10995
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-10996
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-10997
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-10998
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-10999
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-11000
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-11001
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-11002
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-11003
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-11004
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-11005
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-11006
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-11007
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-11008
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-11009
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-11010
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-11011
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-11012
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-11013
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-11014
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-11015
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-11016
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-11017
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-11018
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-11019
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-11020
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-11021
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-11022
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-11023
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-11024
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-11025
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-11026
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-11027
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-11028
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-11029
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-11030
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-11031
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-11032
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-11033
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-11034
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-11035
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-11036
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-11037
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-11038
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-11039
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-11040
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-11041
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-11042
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-11043
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-11044
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-11045
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-11046
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-11047
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-11048
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-11049
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-11050
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-11051
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-11052
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-11053
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-11054
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-11055
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-11056
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-11057
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-11058
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-11059
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  id: totrans-11060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: becomes
  id: totrans-11061
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  id: totrans-11062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-11063
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-11064
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-11065
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-11066
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-11067
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-11068
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-11069
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-11070
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-11071
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-11072
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-11073
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-11074
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-11075
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-11076
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  id: totrans-11077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-11078
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  id: totrans-11079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-11080
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  id: totrans-11081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-11082
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-11083
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-11084
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-11085
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00052.jpg)'
  id: totrans-11086
  prefs: []
  type: TYPE_IMG
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-11087
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-11088
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-11089
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-11090
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-11091
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-11092
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-11093
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-11094
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-11095
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-11096
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-11097
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-11098
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-11099
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-11100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-11101
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-11102
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-11103
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-11104
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-11105
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-11106
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-11107
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-11108
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-11109
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-11110
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-11111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-11112
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-11113
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-11114
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-11115
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-11116
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-11117
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-11118
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-11119
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-11120
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-11121
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-11122
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-11123
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-11124
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-11125
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-11126
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-11127
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-11128
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-11129
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-11130
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-11131
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-11132
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-11133
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-11134
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-11135
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-11136
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-11137
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-11138
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-11139
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-11140
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-11141
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-11142
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-11143
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-11144
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-11145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-11146
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-11147
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-11148
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-11149
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-11150
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-11151
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-11152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-11153
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-11154
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-11155
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-11156
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-11157
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-11158
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-11159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-11160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  id: totrans-11161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: becomes
  id: totrans-11162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  id: totrans-11163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-11164
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-11165
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-11166
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-11167
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-11168
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-11169
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-11170
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-11171
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-11172
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-11173
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-11174
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-11175
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-11176
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-11177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  id: totrans-11178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-11179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE398]'
  id: totrans-11180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-11181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  id: totrans-11182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-11183
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-11184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-11185
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-11186
  prefs: []
  type: TYPE_NORMAL
- en: By adding strings together with the plus sign (+ ), this code creates a variable
    called specialGreeting with the string "Good Morning Jude" as its value. Note
    that we need to add a string containing a space character (" " ) between morningGreeting
    and friend here or else specialGreeting would be "Good MorningJude" .
  id: totrans-11187
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-11188
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-11189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-11190
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-11191
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-11192
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-11193
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-11194
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-11195
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-11196
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-11197
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-11198
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-11199
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-11200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-11201
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-11202
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-11203
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-11204
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-11205
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-11206
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-11207
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-11208
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-11209
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-11210
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-11211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-11212
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-11213
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-11214
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-11215
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-11216
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-11217
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-11218
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-11219
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-11220
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-11221
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-11222
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-11223
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-11224
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-11225
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-11226
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-11227
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-11228
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-11229
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-11230
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-11231
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-11232
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-11233
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-11234
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-11235
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-11236
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-11237
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-11238
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-11239
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-11240
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-11241
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-11242
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-11243
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-11244
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-11245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-11246
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-11247
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-11248
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-11249
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-11250
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-11251
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-11252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-11253
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-11254
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-11255
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-11256
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-11257
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-11258
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-11259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-11260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  id: totrans-11261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: becomes
  id: totrans-11262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  id: totrans-11263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-11264
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-11265
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-11266
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-11267
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-11268
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-11269
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-11270
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-11271
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-11272
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-11273
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-11274
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-11275
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-11276
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-11277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  id: totrans-11278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-11279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  id: totrans-11280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-11281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  id: totrans-11282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-11283
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-11284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-11285
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-11286
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00053.jpg)'
  id: totrans-11287
  prefs: []
  type: TYPE_IMG
- en: '**TYPE INFERENCE**'
  id: totrans-11288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-11289
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-11290
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-11291
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-11292
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-11293
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-11294
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-11295
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-11296
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-11297
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-11298
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-11299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-11300
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-11301
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-11302
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-11303
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-11304
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-11305
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-11306
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-11307
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-11308
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-11309
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-11310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-11311
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-11312
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-11313
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-11314
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-11315
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-11316
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-11317
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-11318
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-11319
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-11320
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-11321
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-11322
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-11323
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-11324
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-11325
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-11326
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-11327
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-11328
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-11329
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-11330
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-11331
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-11332
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-11333
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-11334
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-11335
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-11336
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-11337
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-11338
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-11339
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-11340
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-11341
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-11342
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-11343
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-11344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-11345
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-11346
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-11347
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-11348
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-11349
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-11350
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-11351
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-11352
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-11353
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-11354
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-11355
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-11356
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-11357
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-11358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-11359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  id: totrans-11360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: becomes
  id: totrans-11361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  id: totrans-11362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-11363
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-11364
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-11365
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-11366
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-11367
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-11368
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-11369
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-11370
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-11371
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-11372
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-11373
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-11374
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-11375
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-11376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  id: totrans-11377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-11378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  id: totrans-11379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-11380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  id: totrans-11381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-11382
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-11383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-11384
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-11385
  prefs: []
  type: TYPE_NORMAL
- en: '**TYPE INFERENCE**'
  id: totrans-11386
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-11387
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-11388
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-11389
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-11390
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-11391
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-11392
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-11393
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-11394
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-11395
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-11396
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-11397
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-11398
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-11399
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-11400
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-11401
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-11402
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-11403
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-11404
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-11405
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-11406
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-11407
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-11408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-11409
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-11410
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-11411
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-11412
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-11413
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-11414
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-11415
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-11416
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-11417
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-11418
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-11419
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-11420
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-11421
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-11422
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-11423
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-11424
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-11425
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-11426
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-11427
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-11428
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-11429
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-11430
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-11431
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-11432
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-11433
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-11434
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-11435
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-11436
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-11437
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-11438
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-11439
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-11440
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-11441
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-11442
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-11443
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-11444
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-11445
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-11446
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-11447
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-11448
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-11449
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-11450
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-11451
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-11452
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-11453
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-11454
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-11455
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-11456
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-11457
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  id: totrans-11458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: becomes
  id: totrans-11459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  id: totrans-11460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-11461
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-11462
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-11463
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-11464
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-11465
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-11466
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-11467
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-11468
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-11469
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-11470
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-11471
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-11472
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-11473
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-11474
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  id: totrans-11475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-11476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  id: totrans-11477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-11478
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  id: totrans-11479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-11480
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-11481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-11482
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-11483
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that sometimes when we declare a variable, we include
    the data type:'
  id: totrans-11484
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-11485
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-11486
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-11487
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-11488
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-11489
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-11490
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-11491
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-11492
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-11493
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-11494
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-11495
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-11496
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-11497
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-11498
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-11499
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-11500
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-11501
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-11502
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-11503
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-11504
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-11505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-11506
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-11507
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-11508
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-11509
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-11510
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-11511
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-11512
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-11513
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-11514
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-11515
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-11516
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-11517
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-11518
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-11519
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-11520
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-11521
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-11522
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-11523
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-11524
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-11525
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-11526
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-11527
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-11528
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-11529
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-11530
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-11531
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-11532
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-11533
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-11534
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-11535
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-11536
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-11537
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-11538
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-11539
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-11540
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-11541
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-11542
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-11543
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-11544
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-11545
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-11546
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-11547
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-11548
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-11549
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-11550
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-11551
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-11552
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-11553
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-11554
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  id: totrans-11555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: becomes
  id: totrans-11556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  id: totrans-11557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-11558
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-11559
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-11560
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-11561
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-11562
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-11563
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-11564
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-11565
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-11566
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-11567
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-11568
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-11569
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-11570
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-11571
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  id: totrans-11572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-11573
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  id: totrans-11574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-11575
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  id: totrans-11576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-11577
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-11578
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-11579
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-11580
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00054.jpg)'
  id: totrans-11581
  prefs: []
  type: TYPE_IMG
- en: 'And sometimes we do not include the data type:'
  id: totrans-11582
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-11583
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-11584
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-11585
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-11586
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-11587
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-11588
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-11589
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-11590
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-11591
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-11592
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-11593
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-11594
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-11595
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-11596
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-11597
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-11598
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-11599
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-11600
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-11601
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-11602
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-11603
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-11604
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-11605
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-11606
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-11607
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-11608
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-11609
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-11610
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-11611
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-11612
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-11613
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-11614
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-11615
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-11616
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-11617
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-11618
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-11619
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-11620
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-11621
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-11622
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-11623
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-11624
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-11625
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-11626
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-11627
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-11628
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-11629
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-11630
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-11631
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-11632
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-11633
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-11634
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-11635
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-11636
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-11637
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-11638
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-11639
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-11640
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-11641
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-11642
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-11643
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-11644
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-11645
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-11646
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-11647
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-11648
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-11649
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-11650
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  id: totrans-11651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: becomes
  id: totrans-11652
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE421]'
  id: totrans-11653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-11654
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-11655
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-11656
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-11657
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-11658
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-11659
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-11660
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-11661
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-11662
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-11663
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-11664
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-11665
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-11666
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-11667
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE422]'
  id: totrans-11668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-11669
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  id: totrans-11670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-11671
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  id: totrans-11672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-11673
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-11674
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-11675
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-11676
  prefs: []
  type: TYPE_NORMAL
- en: 'And sometimes we do not include the data type:'
  id: totrans-11677
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-11678
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-11679
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-11680
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-11681
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-11682
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-11683
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-11684
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-11685
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-11686
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-11687
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-11688
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-11689
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-11690
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-11691
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-11692
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-11693
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-11694
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-11695
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-11696
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-11697
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-11698
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-11699
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-11700
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-11701
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-11702
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-11703
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-11704
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-11705
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-11706
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-11707
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-11708
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-11709
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-11710
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-11711
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-11712
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-11713
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-11714
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-11715
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-11716
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-11717
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-11718
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-11719
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-11720
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-11721
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-11722
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-11723
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-11724
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-11725
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-11726
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-11727
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-11728
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-11729
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-11730
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-11731
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-11732
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-11733
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-11734
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-11735
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-11736
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-11737
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-11738
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-11739
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-11740
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-11741
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-11742
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-11743
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-11744
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-11745
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  id: totrans-11746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: becomes
  id: totrans-11747
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  id: totrans-11748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-11749
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-11750
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-11751
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-11752
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-11753
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-11754
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-11755
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-11756
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-11757
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-11758
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-11759
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-11760
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-11761
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-11762
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  id: totrans-11763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-11764
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  id: totrans-11765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-11766
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  id: totrans-11767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-11768
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-11769
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-11770
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-11771
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00055.jpg)'
  id: totrans-11772
  prefs: []
  type: TYPE_IMG
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-11773
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-11774
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-11775
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-11776
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-11777
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-11778
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-11779
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-11780
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-11781
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-11782
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-11783
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-11784
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-11785
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-11786
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-11787
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-11788
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-11789
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-11790
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-11791
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-11792
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-11793
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-11794
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-11795
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-11796
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-11797
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-11798
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-11799
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-11800
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-11801
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-11802
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-11803
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-11804
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-11805
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-11806
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-11807
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-11808
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-11809
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-11810
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-11811
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-11812
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-11813
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-11814
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-11815
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-11816
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-11817
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-11818
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-11819
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-11820
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-11821
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-11822
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-11823
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-11824
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-11825
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-11826
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-11827
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-11828
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-11829
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-11830
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-11831
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-11832
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-11833
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-11834
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-11835
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-11836
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-11837
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-11838
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-11839
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE430]'
  id: totrans-11840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: becomes
  id: totrans-11841
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  id: totrans-11842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-11843
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-11844
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-11845
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-11846
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-11847
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-11848
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-11849
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-11850
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-11851
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-11852
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-11853
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-11854
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-11855
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-11856
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE432]'
  id: totrans-11857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-11858
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  id: totrans-11859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-11860
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  id: totrans-11861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-11862
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-11863
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-11864
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-11865
  prefs: []
  type: TYPE_NORMAL
- en: 'What gives? The computer is actually smart enough to figure out the data type,
    most of the time. This is called *type inference* —because the computer will *infer*
    , or guess, the type of data we are using based on clues that we give it. When
    you create a variable and give it an initial value, that value is a big clue for
    the computer. Here are some examples:'
  id: totrans-11866
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-11867
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-11868
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-11869
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-11870
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-11871
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-11872
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-11873
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-11874
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-11875
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-11876
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-11877
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-11878
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-11879
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-11880
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-11881
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-11882
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-11883
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-11884
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-11885
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-11886
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-11887
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-11888
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-11889
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-11890
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-11891
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-11892
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-11893
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-11894
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-11895
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-11896
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-11897
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-11898
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-11899
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-11900
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-11901
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-11902
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-11903
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-11904
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-11905
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-11906
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-11907
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-11908
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-11909
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-11910
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-11911
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-11912
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-11913
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-11914
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-11915
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-11916
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-11917
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-11918
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-11919
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-11920
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-11921
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-11922
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-11923
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-11924
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-11925
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-11926
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-11927
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-11928
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-11929
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-11930
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-11931
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-11932
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE435]'
  id: totrans-11933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: becomes
  id: totrans-11934
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  id: totrans-11935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-11936
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-11937
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-11938
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-11939
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-11940
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-11941
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-11942
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-11943
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-11944
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-11945
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-11946
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-11947
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-11948
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-11949
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  id: totrans-11950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-11951
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  id: totrans-11952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-11953
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  id: totrans-11954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-11955
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-11956
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-11957
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-11958
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with no decimal value (like 3), the computer will assume
    it’s an Int .
  id: totrans-11959
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-11960
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-11961
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-11962
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-11963
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-11964
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-11965
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-11966
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-11967
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-11968
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-11969
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-11970
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-11971
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-11972
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-11973
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-11974
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-11975
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-11976
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-11977
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-11978
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-11979
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-11980
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-11981
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-11982
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-11983
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-11984
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-11985
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-11986
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-11987
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-11988
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-11989
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-11990
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-11991
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-11992
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-11993
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-11994
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-11995
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-11996
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-11997
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-11998
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-11999
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-12000
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-12001
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-12002
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-12003
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-12004
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-12005
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-12006
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-12007
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-12008
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-12009
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-12010
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-12011
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-12012
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-12013
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-12014
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-12015
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-12016
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-12017
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-12018
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-12019
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-12020
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-12021
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-12022
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-12023
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-12024
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  id: totrans-12025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: becomes
  id: totrans-12026
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  id: totrans-12027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-12028
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-12029
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-12030
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-12031
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-12032
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-12033
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-12034
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-12035
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-12036
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-12037
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-12038
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-12039
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-12040
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-12041
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  id: totrans-12042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-12043
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  id: totrans-12044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-12045
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  id: totrans-12046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-12047
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-12048
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-12049
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-12050
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign a number with a decimal value (like 3.14), the computer will
    assume it’s a Double .
  id: totrans-12051
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-12052
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-12053
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-12054
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-12055
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-12056
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-12057
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-12058
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-12059
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-12060
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-12061
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-12062
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-12063
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-12064
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-12065
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-12066
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-12067
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-12068
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-12069
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-12070
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-12071
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-12072
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-12073
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-12074
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-12075
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-12076
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-12077
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-12078
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-12079
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-12080
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-12081
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-12082
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-12083
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-12084
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-12085
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-12086
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-12087
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-12088
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-12089
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-12090
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-12091
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-12092
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-12093
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-12094
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-12095
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-12096
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-12097
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-12098
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-12099
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-12100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-12101
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-12102
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-12103
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-12104
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-12105
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-12106
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-12107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-12108
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-12109
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-12110
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-12111
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-12112
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-12113
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-12114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-12115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  id: totrans-12116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: becomes
  id: totrans-12117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  id: totrans-12118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-12119
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-12120
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-12121
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-12122
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-12123
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-12124
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-12125
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-12126
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-12127
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-12128
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-12129
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-12130
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-12131
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-12132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  id: totrans-12133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-12134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  id: totrans-12135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-12136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE449]'
  id: totrans-12137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-12138
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-12139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-12140
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-12141
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign the word *true* or *false* (with no quotes around it), the computer
    will assume it’s a Bool .
  id: totrans-12142
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-12143
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-12144
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-12145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-12146
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-12147
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-12148
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-12149
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-12150
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-12151
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-12152
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-12153
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-12154
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-12155
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-12156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-12157
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-12158
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-12159
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-12160
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-12161
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-12162
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-12163
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-12164
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-12165
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-12166
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-12167
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-12168
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-12169
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-12170
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-12171
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-12172
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-12173
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-12174
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-12175
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-12176
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-12177
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-12178
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-12179
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-12180
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-12181
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-12182
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-12183
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-12184
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-12185
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-12186
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-12187
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-12188
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-12189
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-12190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-12191
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-12192
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-12193
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-12194
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-12195
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-12196
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-12197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-12198
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-12199
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-12200
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-12201
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-12202
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-12203
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-12204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-12205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE450]'
  id: totrans-12206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: becomes
  id: totrans-12207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE451]'
  id: totrans-12208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-12209
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-12210
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-12211
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-12212
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-12213
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-12214
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-12215
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-12216
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-12217
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-12218
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-12219
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-12220
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-12221
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-12222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  id: totrans-12223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-12224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  id: totrans-12225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-12226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE454]'
  id: totrans-12227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-12228
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-12229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-12230
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-12231
  prefs: []
  type: TYPE_NORMAL
- en: • If you assign one or more characters with quotes around them, the computer
    will assume it’s a String .
  id: totrans-12232
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-12233
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-12234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-12235
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-12236
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-12237
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-12238
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-12239
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-12240
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-12241
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-12242
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-12243
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-12244
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-12245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-12246
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-12247
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-12248
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-12249
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-12250
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-12251
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-12252
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-12253
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-12254
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-12255
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-12256
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-12257
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-12258
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-12259
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-12260
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-12261
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-12262
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-12263
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-12264
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-12265
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-12266
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-12267
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-12268
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-12269
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-12270
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-12271
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-12272
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-12273
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-12274
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-12275
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-12276
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-12277
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-12278
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-12279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-12280
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-12281
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-12282
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-12283
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-12284
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-12285
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-12286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-12287
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-12288
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-12289
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-12290
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-12291
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-12292
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-12293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-12294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE455]'
  id: totrans-12295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: becomes
  id: totrans-12296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE456]'
  id: totrans-12297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-12298
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-12299
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-12300
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-12301
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-12302
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-12303
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-12304
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-12305
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-12306
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-12307
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-12308
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-12309
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-12310
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-12311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE457]'
  id: totrans-12312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-12313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  id: totrans-12314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-12315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE459]'
  id: totrans-12316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-12317
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-12318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-12319
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-12320
  prefs: []
  type: TYPE_NORMAL
- en: When the type is inferred, the variable or constant is set to that data type
    just as if you had declared the data type yourself. This is done purely for convenience.
    You can include the data type every time you declare a new constant or variable,
    and that’s perfectly fine. But why not let the computer figure it out and save
    yourself the time and extra typing?
  id: totrans-12321
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-12322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-12323
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-12324
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-12325
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-12326
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-12327
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-12328
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-12329
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-12330
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-12331
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-12332
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-12333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-12334
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-12335
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-12336
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-12337
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-12338
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-12339
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-12340
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-12341
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-12342
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-12343
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-12344
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-12345
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-12346
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-12347
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-12348
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-12349
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-12350
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-12351
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-12352
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-12353
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-12354
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-12355
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-12356
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-12357
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-12358
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-12359
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-12360
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-12361
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-12362
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-12363
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-12364
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-12365
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-12366
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-12367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-12368
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-12369
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-12370
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-12371
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-12372
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-12373
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-12374
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-12375
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-12376
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-12377
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-12378
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-12379
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-12380
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-12381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-12382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE460]'
  id: totrans-12383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: becomes
  id: totrans-12384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE461]'
  id: totrans-12385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-12386
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-12387
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-12388
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-12389
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-12390
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-12391
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-12392
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-12393
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-12394
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-12395
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-12396
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-12397
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-12398
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-12399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  id: totrans-12400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-12401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE463]'
  id: totrans-12402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-12403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE464]'
  id: totrans-12404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-12405
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-12406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-12407
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-12408
  prefs: []
  type: TYPE_NORMAL
- en: '**TRANSFORMING DATA TYPES WITH CASTING**'
  id: totrans-12409
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-12410
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-12411
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-12412
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-12413
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-12414
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-12415
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-12416
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-12417
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-12418
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-12419
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-12420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-12421
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-12422
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-12423
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-12424
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-12425
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-12426
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-12427
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-12428
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-12429
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-12430
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-12431
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-12432
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-12433
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-12434
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-12435
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-12436
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-12437
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-12438
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-12439
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-12440
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-12441
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-12442
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-12443
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-12444
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-12445
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-12446
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-12447
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-12448
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-12449
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-12450
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-12451
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-12452
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-12453
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-12454
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-12455
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-12456
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-12457
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-12458
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-12459
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-12460
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-12461
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-12462
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-12463
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-12464
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-12465
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-12466
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-12467
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-12468
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-12469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE465]'
  id: totrans-12470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: becomes
  id: totrans-12471
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE466]'
  id: totrans-12472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-12473
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-12474
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-12475
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-12476
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-12477
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-12478
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-12479
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-12480
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-12481
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-12482
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-12483
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-12484
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-12485
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-12486
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE467]'
  id: totrans-12487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-12488
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  id: totrans-12489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-12490
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  id: totrans-12491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-12492
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-12493
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-12494
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-12495
  prefs: []
  type: TYPE_NORMAL
- en: '*Casting* is a way to temporarily transform the data type of a variable or
    constant. You can think of this as casting a spell on a variable—you make its
    value behave like a different data type, but just for a short while. To do this,
    you write a new data type followed by parentheses that hold the variable you are
    casting. Note that this *doesn’t actually change the data type* . It just gives
    you a temporary value for that one line of code. Here are a few examples of casting
    between Int and Double . Take a look at the results of your code in the results
    sidebar.'
  id: totrans-12496
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-12497
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-12498
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-12499
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-12500
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-12501
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-12502
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-12503
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-12504
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-12505
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-12506
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-12507
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-12508
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-12509
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-12510
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-12511
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-12512
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-12513
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-12514
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-12515
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-12516
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-12517
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-12518
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-12519
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-12520
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-12521
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-12522
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-12523
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-12524
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-12525
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-12526
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-12527
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-12528
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-12529
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-12530
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-12531
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-12532
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-12533
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-12534
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-12535
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-12536
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-12537
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-12538
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-12539
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-12540
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-12541
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-12542
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-12543
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-12544
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-12545
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-12546
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-12547
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-12548
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-12549
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-12550
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-12551
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-12552
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-12553
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-12554
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-12555
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE470]'
  id: totrans-12556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: becomes
  id: totrans-12557
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE471]'
  id: totrans-12558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-12559
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-12560
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-12561
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-12562
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-12563
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-12564
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-12565
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-12566
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-12567
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-12568
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-12569
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-12570
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-12571
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-12572
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  id: totrans-12573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-12574
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE473]'
  id: totrans-12575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-12576
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  id: totrans-12577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-12578
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-12579
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-12580
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-12581
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00056.jpg)![Image](Image00057.jpg)'
  id: totrans-12582
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-12583
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-12584
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-12585
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-12586
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-12587
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-12588
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-12589
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-12590
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-12591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-12592
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-12593
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-12594
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-12595
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-12596
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-12597
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-12598
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-12599
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-12600
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-12601
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-12602
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-12603
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-12604
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-12605
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-12606
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-12607
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-12608
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-12609
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-12610
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-12611
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-12612
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-12613
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-12614
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-12615
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-12616
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-12617
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-12618
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-12619
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-12620
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-12621
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-12622
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-12623
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-12624
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-12625
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-12626
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-12627
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-12628
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-12629
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-12630
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-12631
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-12632
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-12633
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-12634
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-12635
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-12636
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-12637
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-12638
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-12639
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-12640
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE475]'
  id: totrans-12641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: becomes
  id: totrans-12642
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE476]'
  id: totrans-12643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-12644
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-12645
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-12646
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-12647
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-12648
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-12649
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-12650
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-12651
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-12652
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-12653
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-12654
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-12655
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-12656
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-12657
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE477]'
  id: totrans-12658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-12659
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE478]'
  id: totrans-12660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-12661
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE479]'
  id: totrans-12662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-12663
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-12664
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-12665
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-12666
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00057.jpg)'
  id: totrans-12667
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-12668
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-12669
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-12670
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-12671
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-12672
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-12673
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-12674
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-12675
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-12676
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-12677
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-12678
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-12679
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-12680
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-12681
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-12682
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-12683
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-12684
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-12685
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-12686
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-12687
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-12688
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-12689
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-12690
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-12691
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-12692
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-12693
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-12694
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-12695
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-12696
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-12697
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-12698
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-12699
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-12700
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-12701
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-12702
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-12703
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-12704
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-12705
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-12706
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-12707
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-12708
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-12709
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-12710
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-12711
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-12712
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-12713
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-12714
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-12715
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-12716
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-12717
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-12718
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-12719
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-12720
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-12721
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-12722
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-12723
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-12724
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-12725
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE480]'
  id: totrans-12726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: becomes
  id: totrans-12727
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  id: totrans-12728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-12729
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-12730
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-12731
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-12732
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-12733
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-12734
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-12735
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-12736
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-12737
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-12738
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-12739
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-12740
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-12741
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-12742
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE482]'
  id: totrans-12743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-12744
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE483]'
  id: totrans-12745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-12746
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE484]'
  id: totrans-12747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-12748
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-12749
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-12750
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-12751
  prefs: []
  type: TYPE_NORMAL
- en: At ➊ , we cast our Int variable months to a Double and store it in a new variable
    called doubleMonths . This adds a decimal place, and the result of this casting
    is 12.0 .
  id: totrans-12752
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-12753
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-12754
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-12755
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-12756
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-12757
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-12758
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-12759
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-12760
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-12761
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-12762
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-12763
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-12764
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-12765
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-12766
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-12767
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-12768
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-12769
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-12770
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-12771
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-12772
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-12773
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-12774
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-12775
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-12776
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-12777
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-12778
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-12779
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-12780
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-12781
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-12782
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-12783
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-12784
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-12785
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-12786
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-12787
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-12788
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-12789
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-12790
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-12791
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-12792
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-12793
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-12794
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-12795
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-12796
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-12797
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-12798
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-12799
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-12800
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-12801
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-12802
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-12803
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-12804
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-12805
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-12806
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-12807
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-12808
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-12809
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE485]'
  id: totrans-12810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: becomes
  id: totrans-12811
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  id: totrans-12812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-12813
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-12814
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-12815
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-12816
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-12817
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-12818
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-12819
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-12820
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-12821
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-12822
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-12823
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-12824
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-12825
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-12826
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE487]'
  id: totrans-12827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-12828
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  id: totrans-12829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-12830
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE489]'
  id: totrans-12831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-12832
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-12833
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-12834
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-12835
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also cast a Double to an Int :'
  id: totrans-12836
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-12837
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-12838
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-12839
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-12840
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-12841
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-12842
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-12843
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-12844
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-12845
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-12846
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-12847
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-12848
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-12849
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-12850
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-12851
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-12852
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-12853
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-12854
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-12855
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-12856
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-12857
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-12858
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-12859
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-12860
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-12861
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-12862
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-12863
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-12864
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-12865
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-12866
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-12867
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-12868
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-12869
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-12870
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-12871
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-12872
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-12873
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-12874
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-12875
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-12876
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-12877
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-12878
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-12879
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-12880
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-12881
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-12882
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-12883
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-12884
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-12885
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-12886
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-12887
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-12888
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-12889
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-12890
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-12891
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-12892
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE490]'
  id: totrans-12893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: becomes
  id: totrans-12894
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE491]'
  id: totrans-12895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-12896
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-12897
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-12898
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-12899
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-12900
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-12901
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-12902
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-12903
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-12904
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-12905
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-12906
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-12907
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-12908
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-12909
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE492]'
  id: totrans-12910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-12911
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE493]'
  id: totrans-12912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-12913
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE494]'
  id: totrans-12914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-12915
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-12916
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-12917
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-12918
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00058.jpg)'
  id: totrans-12919
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-12920
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-12921
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-12922
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-12923
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-12924
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-12925
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-12926
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-12927
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-12928
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-12929
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-12930
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-12931
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-12932
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-12933
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-12934
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-12935
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-12936
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-12937
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-12938
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-12939
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-12940
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-12941
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-12942
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-12943
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-12944
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-12945
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-12946
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-12947
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-12948
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-12949
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-12950
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-12951
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-12952
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-12953
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-12954
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-12955
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-12956
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-12957
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-12958
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-12959
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-12960
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-12961
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-12962
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-12963
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-12964
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-12965
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-12966
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-12967
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-12968
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-12969
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-12970
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-12971
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-12972
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-12973
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-12974
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE495]'
  id: totrans-12975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: becomes
  id: totrans-12976
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE496]'
  id: totrans-12977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-12978
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-12979
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-12980
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-12981
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-12982
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-12983
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-12984
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-12985
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-12986
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-12987
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-12988
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-12989
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-12990
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-12991
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE497]'
  id: totrans-12992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-12993
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  id: totrans-12994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-12995
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE499]'
  id: totrans-12996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-12997
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-12998
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-12999
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-13000
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➊ , we cast our Double , days , to an Int . You can see that the decimal
    place and all the digits following it were removed: our number became 365 . This
    is because an Int is not capable of holding a decimal number—it can contain only
    whole numbers, so anything after the decimal point is chopped off.'
  id: totrans-13001
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-13002
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-13003
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-13004
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-13005
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-13006
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-13007
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-13008
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-13009
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-13010
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-13011
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-13012
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-13013
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-13014
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-13015
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-13016
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-13017
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-13018
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-13019
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-13020
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-13021
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-13022
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-13023
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-13024
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-13025
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-13026
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-13027
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-13028
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-13029
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-13030
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-13031
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-13032
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-13033
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-13034
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-13035
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-13036
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-13037
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-13038
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-13039
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-13040
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-13041
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-13042
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-13043
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-13044
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-13045
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-13046
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-13047
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-13048
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-13049
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-13050
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-13051
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-13052
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-13053
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-13054
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-13055
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE500]'
  id: totrans-13056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: becomes
  id: totrans-13057
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE501]'
  id: totrans-13058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-13059
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-13060
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-13061
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-13062
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-13063
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-13064
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-13065
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-13066
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-13067
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-13068
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-13069
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-13070
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-13071
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-13072
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE502]'
  id: totrans-13073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-13074
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE503]'
  id: totrans-13075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-13076
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE504]'
  id: totrans-13077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-13078
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-13079
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-13080
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-13081
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, casting doesn’t actually change a data type. In our example, even after
    casting, days is *still* a Double . We can verify this by printing days :'
  id: totrans-13082
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-13083
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-13084
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-13085
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-13086
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-13087
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-13088
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-13089
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-13090
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-13091
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-13092
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-13093
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-13094
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-13095
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-13096
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-13097
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-13098
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-13099
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-13100
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-13101
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-13102
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-13103
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-13104
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-13105
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-13106
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-13107
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-13108
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-13109
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-13110
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-13111
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-13112
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-13113
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-13114
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-13115
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-13116
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-13117
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-13118
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-13119
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-13120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-13121
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-13122
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-13123
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-13124
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-13125
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-13126
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-13127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-13128
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-13129
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-13130
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-13131
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-13132
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-13133
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-13134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-13135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE505]'
  id: totrans-13136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: becomes
  id: totrans-13137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE506]'
  id: totrans-13138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-13139
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-13140
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-13141
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-13142
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-13143
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-13144
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-13145
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-13146
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-13147
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-13148
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-13149
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-13150
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-13151
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-13152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE507]'
  id: totrans-13153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-13154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  id: totrans-13155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-13156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE509]'
  id: totrans-13157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-13158
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-13159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-13160
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-13161
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00059.jpg)'
  id: totrans-13162
  prefs: []
  type: TYPE_IMG
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-13163
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-13164
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-13165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-13166
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-13167
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-13168
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-13169
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-13170
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-13171
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-13172
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-13173
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-13174
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-13175
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-13176
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-13177
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-13178
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-13179
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-13180
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-13181
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-13182
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-13183
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-13184
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-13185
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-13186
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-13187
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-13188
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-13189
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-13190
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-13191
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-13192
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-13193
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-13194
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-13195
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-13196
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-13197
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-13198
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-13199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-13200
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-13201
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-13202
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-13203
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-13204
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-13205
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-13206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-13207
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-13208
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-13209
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-13210
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-13211
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-13212
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-13213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-13214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE510]'
  id: totrans-13215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: becomes
  id: totrans-13216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE511]'
  id: totrans-13217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-13218
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-13219
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-13220
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-13221
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-13222
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-13223
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-13224
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-13225
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-13226
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-13227
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-13228
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-13229
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-13230
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-13231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE512]'
  id: totrans-13232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-13233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE513]'
  id: totrans-13234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-13235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE514]'
  id: totrans-13236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-13237
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-13238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-13239
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-13240
  prefs: []
  type: TYPE_NORMAL
- en: The results sidebar shows that days is still equal to 365.25 .
  id: totrans-13241
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-13242
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-13243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-13244
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-13245
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-13246
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-13247
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-13248
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-13249
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-13250
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-13251
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-13252
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-13253
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-13254
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-13255
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-13256
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-13257
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-13258
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-13259
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-13260
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-13261
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-13262
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-13263
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-13264
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-13265
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-13266
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-13267
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-13268
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-13269
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-13270
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-13271
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-13272
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-13273
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-13274
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-13275
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-13276
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-13277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-13278
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-13279
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-13280
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-13281
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-13282
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-13283
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-13284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-13285
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-13286
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-13287
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-13288
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-13289
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-13290
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-13291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-13292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE515]'
  id: totrans-13293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: becomes
  id: totrans-13294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE516]'
  id: totrans-13295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-13296
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-13297
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-13298
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-13299
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-13300
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-13301
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-13302
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-13303
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-13304
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-13305
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-13306
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-13307
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-13308
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-13309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE517]'
  id: totrans-13310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-13311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  id: totrans-13312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-13313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE519]'
  id: totrans-13314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-13315
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-13316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-13317
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-13318
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll cover some examples of where and when you would use
    casting. So if it’s not clear right now why you would cast a variable, just hold
    on a bit longer!
  id: totrans-13319
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-13320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-13321
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-13322
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-13323
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-13324
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-13325
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-13326
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-13327
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-13328
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-13329
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-13330
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-13331
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-13332
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-13333
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-13334
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-13335
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-13336
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-13337
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-13338
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-13339
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-13340
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-13341
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-13342
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-13343
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-13344
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-13345
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-13346
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-13347
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-13348
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-13349
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-13350
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-13351
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-13352
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-13353
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-13354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-13355
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-13356
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-13357
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-13358
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-13359
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-13360
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-13361
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-13362
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-13363
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-13364
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-13365
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-13366
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-13367
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-13368
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-13369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE520]'
  id: totrans-13370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: becomes
  id: totrans-13371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE521]'
  id: totrans-13372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-13373
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-13374
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-13375
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-13376
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-13377
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-13378
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-13379
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-13380
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-13381
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-13382
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-13383
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-13384
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-13385
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-13386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE522]'
  id: totrans-13387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-13388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE523]'
  id: totrans-13389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-13390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE524]'
  id: totrans-13391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-13392
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-13393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-13394
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-13395
  prefs: []
  type: TYPE_NORMAL
- en: '**OPERATORS**'
  id: totrans-13396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-13397
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-13398
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-13399
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-13400
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-13401
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-13402
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-13403
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-13404
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-13405
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-13406
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-13407
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-13408
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-13409
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-13410
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-13411
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-13412
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-13413
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-13414
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-13415
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-13416
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-13417
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-13418
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-13419
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-13420
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-13421
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-13422
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-13423
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-13424
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-13425
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-13426
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-13427
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-13428
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-13429
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-13430
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-13431
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-13432
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-13433
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-13434
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-13435
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-13436
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-13437
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-13438
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-13439
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-13440
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-13441
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-13442
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-13443
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-13444
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-13445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE525]'
  id: totrans-13446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: becomes
  id: totrans-13447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE526]'
  id: totrans-13448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-13449
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-13450
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-13451
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-13452
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-13453
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-13454
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-13455
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-13456
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-13457
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-13458
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-13459
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-13460
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-13461
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-13462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE527]'
  id: totrans-13463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-13464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE528]'
  id: totrans-13465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-13466
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE529]'
  id: totrans-13467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-13468
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-13469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-13470
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-13471
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of arithmetic operators in Swift that you can use to do math.
    You have already seen the basic assignment operator, = . You’re probably also
    familiar with addition (+ ), subtraction (- ), multiplication (* ), and division
    (/ ).
  id: totrans-13472
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-13473
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-13474
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-13475
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-13476
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-13477
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-13478
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-13479
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-13480
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-13481
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-13482
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-13483
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-13484
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-13485
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-13486
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-13487
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-13488
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-13489
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-13490
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-13491
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-13492
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-13493
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-13494
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-13495
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-13496
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-13497
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-13498
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-13499
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-13500
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-13501
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-13502
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-13503
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-13504
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-13505
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-13506
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-13507
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-13508
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-13509
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-13510
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-13511
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-13512
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-13513
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-13514
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-13515
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-13516
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-13517
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-13518
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-13519
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-13520
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE530]'
  id: totrans-13521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: becomes
  id: totrans-13522
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE531]'
  id: totrans-13523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-13524
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-13525
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-13526
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-13527
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-13528
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-13529
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-13530
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-13531
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-13532
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-13533
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-13534
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-13535
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-13536
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-13537
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE532]'
  id: totrans-13538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-13539
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE533]'
  id: totrans-13540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-13541
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE534]'
  id: totrans-13542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-13543
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-13544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-13545
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-13546
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use these operators to perform math on the Int , Float , and Double
    data types. The numbers being operated on are called *operands* . Experiment with
    these math operators in your playground by entering code like the following:'
  id: totrans-13547
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-13548
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-13549
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-13550
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-13551
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-13552
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-13553
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-13554
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-13555
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-13556
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-13557
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-13558
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-13559
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-13560
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-13561
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-13562
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-13563
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-13564
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-13565
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-13566
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-13567
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-13568
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-13569
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-13570
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-13571
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-13572
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-13573
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-13574
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-13575
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-13576
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-13577
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-13578
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-13579
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-13580
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-13581
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-13582
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-13583
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-13584
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-13585
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-13586
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-13587
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-13588
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-13589
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-13590
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-13591
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-13592
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-13593
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-13594
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE535]'
  id: totrans-13595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: becomes
  id: totrans-13596
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE536]'
  id: totrans-13597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-13598
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-13599
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-13600
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-13601
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-13602
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-13603
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-13604
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-13605
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-13606
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-13607
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-13608
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-13609
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-13610
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-13611
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE537]'
  id: totrans-13612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-13613
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE538]'
  id: totrans-13614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-13615
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE539]'
  id: totrans-13616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-13617
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-13618
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-13619
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-13620
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00060.jpg)'
  id: totrans-13621
  prefs: []
  type: TYPE_IMG
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-13622
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-13623
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-13624
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-13625
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-13626
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-13627
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-13628
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-13629
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-13630
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-13631
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-13632
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-13633
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-13634
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-13635
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-13636
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-13637
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-13638
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-13639
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-13640
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-13641
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-13642
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-13643
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-13644
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-13645
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-13646
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-13647
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-13648
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-13649
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-13650
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-13651
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-13652
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-13653
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-13654
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-13655
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-13656
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-13657
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-13658
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-13659
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-13660
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-13661
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-13662
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-13663
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-13664
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-13665
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-13666
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-13667
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE540]'
  id: totrans-13668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: becomes
  id: totrans-13669
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE541]'
  id: totrans-13670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-13671
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-13672
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-13673
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-13674
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-13675
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-13676
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-13677
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-13678
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-13679
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-13680
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-13681
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-13682
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-13683
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-13684
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE542]'
  id: totrans-13685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-13686
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE543]'
  id: totrans-13687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-13688
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE544]'
  id: totrans-13689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-13690
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-13691
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-13692
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-13693
  prefs: []
  type: TYPE_NORMAL
- en: If you enter this code in your playground, you’ll see the results of each math
    expression in the sidebar. Writing math expressions in code is not that different
    from writing them normally. For example, 16 minus 2 is written as 16 – 2 .
  id: totrans-13694
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-13695
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-13696
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-13697
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-13698
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-13699
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-13700
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-13701
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-13702
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-13703
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-13704
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-13705
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-13706
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-13707
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-13708
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-13709
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-13710
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-13711
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-13712
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-13713
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-13714
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-13715
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-13716
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-13717
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-13718
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-13719
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-13720
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-13721
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-13722
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-13723
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-13724
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-13725
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-13726
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-13727
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-13728
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-13729
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-13730
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-13731
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-13732
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-13733
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-13734
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-13735
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-13736
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-13737
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-13738
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-13739
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE545]'
  id: totrans-13740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: becomes
  id: totrans-13741
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE546]'
  id: totrans-13742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-13743
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-13744
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-13745
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-13746
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-13747
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-13748
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-13749
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-13750
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-13751
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-13752
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-13753
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-13754
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-13755
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-13756
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE547]'
  id: totrans-13757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-13758
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE548]'
  id: totrans-13759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-13760
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE549]'
  id: totrans-13761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-13762
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-13763
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-13764
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-13765
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even save the result of a math expression in a variable or constant
    so you can use it somewhere else in your code. To see how this works, enter these
    lines in your playground:'
  id: totrans-13766
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-13767
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-13768
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-13769
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-13770
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-13771
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-13772
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-13773
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-13774
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-13775
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-13776
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-13777
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-13778
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-13779
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-13780
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-13781
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-13782
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-13783
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-13784
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-13785
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-13786
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-13787
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-13788
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-13789
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-13790
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-13791
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-13792
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-13793
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-13794
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-13795
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-13796
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-13797
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-13798
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-13799
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-13800
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-13801
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-13802
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-13803
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-13804
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-13805
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-13806
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-13807
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-13808
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-13809
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-13810
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE550]'
  id: totrans-13811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: becomes
  id: totrans-13812
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE551]'
  id: totrans-13813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-13814
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-13815
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-13816
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-13817
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-13818
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-13819
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-13820
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-13821
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-13822
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-13823
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-13824
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-13825
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-13826
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-13827
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE552]'
  id: totrans-13828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-13829
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE553]'
  id: totrans-13830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-13831
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE554]'
  id: totrans-13832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-13833
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-13834
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-13835
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-13836
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00061.jpg)'
  id: totrans-13837
  prefs: []
  type: TYPE_IMG
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-13838
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-13839
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-13840
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-13841
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-13842
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-13843
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-13844
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-13845
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-13846
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-13847
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-13848
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-13849
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-13850
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-13851
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-13852
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-13853
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-13854
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-13855
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-13856
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-13857
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-13858
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-13859
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-13860
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-13861
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-13862
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-13863
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-13864
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-13865
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-13866
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-13867
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-13868
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-13869
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-13870
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-13871
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-13872
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-13873
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-13874
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-13875
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-13876
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-13877
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-13878
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-13879
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-13880
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE555]'
  id: totrans-13881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: becomes
  id: totrans-13882
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE556]'
  id: totrans-13883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-13884
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-13885
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-13886
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-13887
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-13888
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-13889
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-13890
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-13891
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-13892
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-13893
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-13894
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-13895
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-13896
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-13897
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE557]'
  id: totrans-13898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-13899
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE558]'
  id: totrans-13900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-13901
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE559]'
  id: totrans-13902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-13903
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-13904
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-13905
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-13906
  prefs: []
  type: TYPE_NORMAL
- en: When you print sum ➊ , you’ll see 7.6 in the sidebar.
  id: totrans-13907
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-13908
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-13909
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-13910
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-13911
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-13912
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-13913
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-13914
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-13915
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-13916
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-13917
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-13918
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-13919
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-13920
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-13921
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-13922
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-13923
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-13924
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-13925
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-13926
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-13927
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-13928
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-13929
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-13930
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-13931
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-13932
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-13933
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-13934
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-13935
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-13936
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-13937
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-13938
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-13939
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-13940
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-13941
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-13942
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-13943
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-13944
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-13945
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-13946
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-13947
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-13948
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-13949
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE560]'
  id: totrans-13950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: becomes
  id: totrans-13951
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE561]'
  id: totrans-13952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-13953
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-13954
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-13955
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-13956
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-13957
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-13958
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-13959
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-13960
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-13961
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-13962
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-13963
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-13964
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-13965
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-13966
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE562]'
  id: totrans-13967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-13968
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE563]'
  id: totrans-13969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-13970
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE564]'
  id: totrans-13971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-13972
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-13973
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-13974
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-13975
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve used only numbers in our math expressions, but math operators
    also work on variables and constants.
  id: totrans-13976
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-13977
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-13978
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-13979
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-13980
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-13981
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-13982
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-13983
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-13984
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-13985
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-13986
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-13987
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-13988
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-13989
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-13990
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-13991
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-13992
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-13993
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-13994
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-13995
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-13996
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-13997
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-13998
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-13999
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-14000
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-14001
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-14002
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-14003
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-14004
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-14005
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-14006
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-14007
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-14008
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-14009
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-14010
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-14011
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-14012
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-14013
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-14014
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-14015
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-14016
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-14017
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE565]'
  id: totrans-14018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE565]'
- en: becomes
  id: totrans-14019
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE566]'
  id: totrans-14020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-14021
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-14022
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-14023
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-14024
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-14025
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-14026
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-14027
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-14028
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-14029
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-14030
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-14031
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-14032
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-14033
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-14034
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE567]'
  id: totrans-14035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE567]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-14036
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE568]'
  id: totrans-14037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-14038
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE569]'
  id: totrans-14039
  prefs: []
  type: TYPE_PRE
  zh: '[PRE569]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-14040
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-14041
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-14042
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-14043
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground:'
  id: totrans-14044
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-14045
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-14046
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-14047
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-14048
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-14049
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-14050
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-14051
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-14052
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-14053
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-14054
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-14055
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-14056
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-14057
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-14058
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-14059
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-14060
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-14061
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-14062
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-14063
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-14064
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-14065
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-14066
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-14067
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-14068
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-14069
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-14070
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-14071
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-14072
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-14073
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-14074
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-14075
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-14076
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-14077
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-14078
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-14079
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-14080
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-14081
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-14082
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-14083
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-14084
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE570]'
  id: totrans-14085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: becomes
  id: totrans-14086
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE571]'
  id: totrans-14087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-14088
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-14089
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-14090
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-14091
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-14092
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-14093
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-14094
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-14095
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-14096
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-14097
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-14098
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-14099
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-14100
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-14101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE572]'
  id: totrans-14102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE572]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-14103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE573]'
  id: totrans-14104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-14105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE574]'
  id: totrans-14106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE574]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-14107
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-14108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-14109
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-14110
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00062.jpg)'
  id: totrans-14111
  prefs: []
  type: TYPE_IMG
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-14112
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-14113
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-14114
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-14115
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-14116
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-14117
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-14118
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-14119
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-14120
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-14121
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-14122
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-14123
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-14124
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-14125
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-14126
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-14127
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-14128
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-14129
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-14130
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-14131
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-14132
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-14133
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-14134
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-14135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-14136
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-14137
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-14138
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-14139
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-14140
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-14141
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-14142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-14143
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-14144
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-14145
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-14146
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-14147
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-14148
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-14149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-14150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE575]'
  id: totrans-14151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: becomes
  id: totrans-14152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE576]'
  id: totrans-14153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE576]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-14154
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-14155
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-14156
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-14157
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-14158
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-14159
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-14160
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-14161
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-14162
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-14163
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-14164
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-14165
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-14166
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-14167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE577]'
  id: totrans-14168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-14169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE578]'
  id: totrans-14170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE578]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-14171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE579]'
  id: totrans-14172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-14173
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-14174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-14175
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-14176
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you can use math operators on variables and constants like you
    did on numbers.
  id: totrans-14177
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-14178
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-14179
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-14180
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-14181
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-14182
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-14183
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-14184
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-14185
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-14186
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-14187
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-14188
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-14189
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-14190
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-14191
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-14192
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-14193
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-14194
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-14195
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-14196
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-14197
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-14198
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-14199
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-14200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-14201
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-14202
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-14203
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-14204
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-14205
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-14206
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-14207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-14208
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-14209
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-14210
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-14211
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-14212
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-14213
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-14214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-14215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE580]'
  id: totrans-14216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE580]'
- en: becomes
  id: totrans-14217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE581]'
  id: totrans-14218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-14219
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-14220
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-14221
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-14222
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-14223
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-14224
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-14225
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-14226
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-14227
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-14228
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-14229
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-14230
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-14231
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-14232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE582]'
  id: totrans-14233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE582]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-14234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE583]'
  id: totrans-14235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-14236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE584]'
  id: totrans-14237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-14238
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-14239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-14240
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-14241
  prefs: []
  type: TYPE_NORMAL
- en: '**SPACES MATTER**'
  id: totrans-14242
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the spaces around an operator are important. You can either write
    a blank space on both sides of the math operator or leave out the spaces altogether.
    But you cannot just put a space on one side of the operator and not the other.
    That will cause an error. Take a look at [Figure 2-7](text00012.html#ch02fig7)
    .
  id: totrans-14243
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00063.jpg)'
  id: totrans-14244
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: Make sure that you have the same number of spaces on each side
    of your operators.*'
  id: totrans-14245
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-14246
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-14247
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-14248
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-14249
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-14250
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-14251
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-14252
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-14253
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-14254
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-14255
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-14256
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-14257
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-14258
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-14259
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-14260
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-14261
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-14262
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-14263
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-14264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-14265
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-14266
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-14267
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-14268
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-14269
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-14270
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-14271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-14272
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-14273
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-14274
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-14275
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-14276
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-14277
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-14278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-14279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE585]'
  id: totrans-14280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE585]'
- en: becomes
  id: totrans-14281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE586]'
  id: totrans-14282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-14283
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-14284
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-14285
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-14286
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-14287
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-14288
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-14289
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-14290
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-14291
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-14292
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-14293
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-14294
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-14295
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-14296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE587]'
  id: totrans-14297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE587]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-14298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE588]'
  id: totrans-14299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE588]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-14300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE589]'
  id: totrans-14301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE589]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-14302
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-14303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-14304
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-14305
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note: you can only use a math operator on variables
    or constants that are the *same* data type. In the previous code, three and five
    are both Int data types. The constants half and quarter are Double data types
    because they are decimal numbers. If you try to add or multiply an Int and a Double
    , you’ll get an error like the one in [Figure 2-8](text00012.html#ch02fig8) .'
  id: totrans-14306
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-14307
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-14308
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-14309
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-14310
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-14311
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-14312
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-14313
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-14314
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-14315
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-14316
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-14317
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-14318
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-14319
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-14320
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-14321
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-14322
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-14323
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-14324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-14325
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-14326
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-14327
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-14328
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-14329
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-14330
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-14331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-14332
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-14333
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-14334
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-14335
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-14336
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-14337
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-14338
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-14339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE590]'
  id: totrans-14340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE590]'
- en: becomes
  id: totrans-14341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE591]'
  id: totrans-14342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE591]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-14343
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-14344
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-14345
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-14346
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-14347
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-14348
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-14349
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-14350
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-14351
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-14352
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-14353
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-14354
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-14355
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-14356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE592]'
  id: totrans-14357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE592]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-14358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE593]'
  id: totrans-14359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE593]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-14360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE594]'
  id: totrans-14361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE594]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-14362
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-14363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-14364
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-14365
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00064.jpg)'
  id: totrans-14366
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-14367
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-14368
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-14369
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-14370
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-14371
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-14372
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-14373
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-14374
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-14375
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-14376
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-14377
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-14378
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-14379
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-14380
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-14381
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-14382
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-14383
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-14384
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-14385
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-14386
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-14387
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-14388
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-14389
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-14390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-14391
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-14392
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-14393
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-14394
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-14395
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-14396
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-14397
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-14398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE595]'
  id: totrans-14399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE595]'
- en: becomes
  id: totrans-14400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE596]'
  id: totrans-14401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE596]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-14402
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-14403
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-14404
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-14405
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-14406
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-14407
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-14408
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-14409
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-14410
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-14411
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-14412
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-14413
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-14414
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-14415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE597]'
  id: totrans-14416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE597]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-14417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE598]'
  id: totrans-14418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE598]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-14419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE599]'
  id: totrans-14420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE599]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-14421
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-14422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-14423
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-14424
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2-8: In Swift, you cannot do math on mixed data types.*'
  id: totrans-14425
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-14426
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-14427
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-14428
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-14429
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-14430
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-14431
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-14432
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-14433
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-14434
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-14435
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-14436
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-14437
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-14438
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-14439
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-14440
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-14441
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-14442
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-14443
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-14444
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-14445
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-14446
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-14447
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-14448
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-14449
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-14450
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-14451
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-14452
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-14453
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-14454
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-14455
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-14456
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE600]'
  id: totrans-14457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE600]'
- en: becomes
  id: totrans-14458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE601]'
  id: totrans-14459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE601]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-14460
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-14461
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-14462
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-14463
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-14464
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-14465
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-14466
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-14467
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-14468
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-14469
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-14470
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-14471
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-14472
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-14473
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE602]'
  id: totrans-14474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE602]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-14475
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE603]'
  id: totrans-14476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE603]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-14477
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE604]'
  id: totrans-14478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE604]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-14479
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-14480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-14481
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-14482
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if you really want to do math on mixed data types? For example, let’s
    say you want to calculate one-tenth of your age:'
  id: totrans-14483
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-14484
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-14485
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-14486
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-14487
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-14488
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-14489
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-14490
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-14491
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-14492
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-14493
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-14494
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-14495
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-14496
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-14497
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-14498
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-14499
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-14500
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-14501
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-14502
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-14503
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-14504
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-14505
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-14506
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-14507
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-14508
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-14509
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-14510
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-14511
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-14512
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-14513
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE605]'
  id: totrans-14514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE605]'
- en: becomes
  id: totrans-14515
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE606]'
  id: totrans-14516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE606]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-14517
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-14518
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-14519
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-14520
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-14521
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-14522
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-14523
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-14524
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-14525
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-14526
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-14527
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-14528
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-14529
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-14530
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE607]'
  id: totrans-14531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE607]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-14532
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE608]'
  id: totrans-14533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE608]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-14534
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE609]'
  id: totrans-14535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE609]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-14536
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-14537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-14538
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-14539
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00065.jpg)'
  id: totrans-14540
  prefs: []
  type: TYPE_IMG
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-14541
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-14542
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-14543
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-14544
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-14545
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-14546
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-14547
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-14548
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-14549
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-14550
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-14551
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-14552
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-14553
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-14554
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-14555
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-14556
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-14557
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-14558
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-14559
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-14560
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-14561
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-14562
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-14563
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-14564
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-14565
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-14566
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-14567
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-14568
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-14569
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE610]'
  id: totrans-14570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE610]'
- en: becomes
  id: totrans-14571
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE611]'
  id: totrans-14572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE611]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-14573
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-14574
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-14575
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-14576
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-14577
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-14578
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-14579
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-14580
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-14581
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-14582
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-14583
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-14584
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-14585
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-14586
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE612]'
  id: totrans-14587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE612]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-14588
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE613]'
  id: totrans-14589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE613]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-14590
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE614]'
  id: totrans-14591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE614]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-14592
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-14593
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-14594
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-14595
  prefs: []
  type: TYPE_NORMAL
- en: The last line will result in an error because we’re attempting to multiply an
    Int by a Double . But don’t worry! You have a couple of options to make sure your
    operands are the same data type.
  id: totrans-14596
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-14597
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-14598
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-14599
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-14600
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-14601
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-14602
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-14603
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-14604
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-14605
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-14606
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-14607
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-14608
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-14609
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-14610
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-14611
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-14612
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-14613
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-14614
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-14615
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-14616
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-14617
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-14618
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-14619
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-14620
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-14621
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-14622
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-14623
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-14624
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE615]'
  id: totrans-14625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE615]'
- en: becomes
  id: totrans-14626
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE616]'
  id: totrans-14627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE616]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-14628
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-14629
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-14630
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-14631
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-14632
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-14633
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-14634
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-14635
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-14636
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-14637
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-14638
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-14639
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-14640
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-14641
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE617]'
  id: totrans-14642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE617]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-14643
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE618]'
  id: totrans-14644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE618]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-14645
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE619]'
  id: totrans-14646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE619]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-14647
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-14648
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-14649
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-14650
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to declare myAge as a Double , like this:'
  id: totrans-14651
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-14652
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-14653
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-14654
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-14655
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-14656
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-14657
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-14658
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-14659
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-14660
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-14661
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-14662
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-14663
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-14664
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-14665
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-14666
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-14667
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-14668
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-14669
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-14670
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-14671
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-14672
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-14673
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-14674
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-14675
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-14676
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-14677
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-14678
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE620]'
  id: totrans-14679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE620]'
- en: becomes
  id: totrans-14680
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE621]'
  id: totrans-14681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE621]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-14682
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-14683
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-14684
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-14685
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-14686
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-14687
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-14688
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-14689
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-14690
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-14691
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-14692
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-14693
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-14694
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-14695
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE622]'
  id: totrans-14696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE622]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-14697
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE623]'
  id: totrans-14698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE623]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-14699
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE624]'
  id: totrans-14700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE624]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-14701
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-14702
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-14703
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-14704
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00066.jpg)'
  id: totrans-14705
  prefs: []
  type: TYPE_IMG
- en: This code works because we’re multiplying two Double data types.
  id: totrans-14706
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-14707
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-14708
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-14709
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-14710
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-14711
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-14712
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-14713
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-14714
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-14715
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-14716
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-14717
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-14718
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-14719
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-14720
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-14721
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-14722
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-14723
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-14724
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-14725
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-14726
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-14727
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-14728
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-14729
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-14730
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-14731
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE625]'
  id: totrans-14732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE625]'
- en: becomes
  id: totrans-14733
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE626]'
  id: totrans-14734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE626]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-14735
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-14736
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-14737
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-14738
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-14739
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-14740
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-14741
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-14742
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-14743
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-14744
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-14745
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-14746
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-14747
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-14748
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE627]'
  id: totrans-14749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE627]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-14750
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE628]'
  id: totrans-14751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE628]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-14752
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE629]'
  id: totrans-14753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE629]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-14754
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-14755
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-14756
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-14757
  prefs: []
  type: TYPE_NORMAL
- en: This code works because we’re multiplying two Double data types.
  id: totrans-14758
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-14759
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-14760
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-14761
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-14762
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-14763
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-14764
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-14765
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-14766
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-14767
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-14768
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-14769
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-14770
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-14771
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-14772
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-14773
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-14774
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-14775
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-14776
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-14777
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-14778
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-14779
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-14780
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-14781
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-14782
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-14783
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE630]'
  id: totrans-14784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE630]'
- en: becomes
  id: totrans-14785
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE631]'
  id: totrans-14786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE631]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-14787
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-14788
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-14789
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-14790
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-14791
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-14792
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-14793
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-14794
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-14795
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-14796
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-14797
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-14798
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-14799
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-14800
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE632]'
  id: totrans-14801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE632]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-14802
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE633]'
  id: totrans-14803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE633]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-14804
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE634]'
  id: totrans-14805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE634]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-14806
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-14807
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-14808
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-14809
  prefs: []
  type: TYPE_NORMAL
- en: 'The second option is to use casting. (I told you we would come back to this!)
    Casting is a great solution in this case because we don’t want to permanently
    change myAge to a Double , we just want to be able to perform math with it as
    if it were a Double . Let’s take a look at an example:'
  id: totrans-14810
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-14811
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-14812
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-14813
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-14814
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-14815
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-14816
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-14817
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-14818
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-14819
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-14820
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-14821
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-14822
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-14823
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-14824
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-14825
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-14826
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-14827
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-14828
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-14829
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-14830
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-14831
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-14832
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-14833
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-14834
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE635]'
  id: totrans-14835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE635]'
- en: becomes
  id: totrans-14836
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE636]'
  id: totrans-14837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE636]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-14838
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-14839
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-14840
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-14841
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-14842
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-14843
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-14844
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-14845
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-14846
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-14847
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-14848
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-14849
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-14850
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-14851
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE637]'
  id: totrans-14852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE637]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-14853
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE638]'
  id: totrans-14854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE638]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-14855
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE639]'
  id: totrans-14856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE639]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-14857
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-14858
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-14859
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-14860
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00067.jpg)'
  id: totrans-14861
  prefs: []
  type: TYPE_IMG
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-14862
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-14863
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-14864
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-14865
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-14866
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-14867
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-14868
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-14869
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-14870
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-14871
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-14872
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-14873
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-14874
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-14875
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-14876
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-14877
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-14878
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-14879
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-14880
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-14881
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-14882
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-14883
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-14884
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE640]'
  id: totrans-14885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE640]'
- en: becomes
  id: totrans-14886
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE641]'
  id: totrans-14887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE641]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-14888
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-14889
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-14890
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-14891
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-14892
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-14893
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-14894
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-14895
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-14896
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-14897
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-14898
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-14899
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-14900
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-14901
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE642]'
  id: totrans-14902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE642]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-14903
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE643]'
  id: totrans-14904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE643]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-14905
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE644]'
  id: totrans-14906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE644]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-14907
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-14908
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-14909
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-14910
  prefs: []
  type: TYPE_NORMAL
- en: At ➊ , we cast myAge to a Double before multiplying it. This means we no longer
    have mixed types, so the code works. But at ➋ we will get an error. That’s because
    myAge is still an Int . Casting it to a Double at ➊ did not permanently change
    it to a Double .
  id: totrans-14911
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-14912
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-14913
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-14914
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-14915
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-14916
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-14917
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-14918
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-14919
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-14920
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-14921
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-14922
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-14923
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-14924
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-14925
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-14926
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-14927
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-14928
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-14929
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-14930
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-14931
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-14932
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-14933
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE645]'
  id: totrans-14934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE645]'
- en: becomes
  id: totrans-14935
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE646]'
  id: totrans-14936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE646]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-14937
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-14938
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-14939
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-14940
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-14941
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-14942
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-14943
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-14944
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-14945
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-14946
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-14947
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-14948
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-14949
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-14950
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE647]'
  id: totrans-14951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE647]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-14952
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE648]'
  id: totrans-14953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE648]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-14954
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE649]'
  id: totrans-14955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE649]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-14956
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-14957
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-14958
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-14959
  prefs: []
  type: TYPE_NORMAL
- en: 'Could we cast multiplier to an Int ? You bet! Then we are doing math on two
    integers, which works fine. However, this results in a less precise calculation
    because we’ll lose the decimal place. When you cast a variable from a Double to
    an Int , the computer simply removes any digits after the decimal to make it a
    whole number. In this case, your multiplier of 0.1 would cast to an Int of 0 .
    Let’s cast some variables in the playground and see what we get:'
  id: totrans-14960
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-14961
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-14962
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-14963
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-14964
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-14965
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-14966
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-14967
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-14968
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-14969
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-14970
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-14971
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-14972
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-14973
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-14974
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-14975
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-14976
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-14977
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-14978
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-14979
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-14980
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-14981
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE650]'
  id: totrans-14982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE650]'
- en: becomes
  id: totrans-14983
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE651]'
  id: totrans-14984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE651]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-14985
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-14986
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-14987
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-14988
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-14989
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-14990
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-14991
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-14992
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-14993
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-14994
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-14995
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-14996
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-14997
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-14998
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE652]'
  id: totrans-14999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE652]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15000
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE653]'
  id: totrans-15001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE653]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15002
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE654]'
  id: totrans-15003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE654]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15004
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15005
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15006
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15007
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00068.jpg)'
  id: totrans-15008
  prefs: []
  type: TYPE_IMG
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-15009
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-15010
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-15011
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-15012
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-15013
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-15014
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-15015
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-15016
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-15017
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-15018
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-15019
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-15020
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-15021
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-15022
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-15023
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-15024
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-15025
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-15026
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-15027
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-15028
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE655]'
  id: totrans-15029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE655]'
- en: becomes
  id: totrans-15030
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE656]'
  id: totrans-15031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE656]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-15032
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15033
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15034
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15035
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15036
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15037
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15038
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15039
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15040
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15041
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15042
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15043
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15044
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15045
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE657]'
  id: totrans-15046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE657]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15047
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE658]'
  id: totrans-15048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE658]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15049
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE659]'
  id: totrans-15050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE659]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15051
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15052
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15053
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15054
  prefs: []
  type: TYPE_NORMAL
- en: 'At ➊ , casting our Double , multiplier , to an Int gives us 0 . This value
    is quite different after casting, because we lost the decimal place: 0.1 became
    0 . This could be a very bad thing in our code if we were not expecting it to
    happen. You must be careful when casting to make sure you aren’t unexpectedly
    changing your values. At ➋ , there’s another example of casting a Double to an
    Int , and as you can see, 1.9 does not get rounded up to 2 . Its decimal value
    just gets removed and we are left with 1 .'
  id: totrans-15055
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-15056
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-15057
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-15058
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-15059
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-15060
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-15061
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-15062
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-15063
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-15064
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-15065
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-15066
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-15067
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-15068
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-15069
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-15070
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-15071
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-15072
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-15073
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-15074
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE660]'
  id: totrans-15075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE660]'
- en: becomes
  id: totrans-15076
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE661]'
  id: totrans-15077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE661]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-15078
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15079
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15080
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15081
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15082
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15083
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15084
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15085
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15086
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15087
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15088
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15089
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15090
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15091
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE662]'
  id: totrans-15092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE662]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15093
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE663]'
  id: totrans-15094
  prefs: []
  type: TYPE_PRE
  zh: '[PRE663]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15095
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE664]'
  id: totrans-15096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE664]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15097
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15098
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15099
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15100
  prefs: []
  type: TYPE_NORMAL
- en: There’s another math operator, the *modulo operator* (% ), which might not be
    as familiar to you. The modulo operator (also called *modulus* ) gives the remainder
    after division. For example, 7 % 2 = 1 because 7 divided by 2 has a remainder
    of 1\. Try out the modulo operator in your playground, as follows.
  id: totrans-15101
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-15102
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-15103
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-15104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-15105
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-15106
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-15107
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-15108
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-15109
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-15110
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-15111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-15112
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-15113
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-15114
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-15115
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-15116
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-15117
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-15118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-15119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE665]'
  id: totrans-15120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE665]'
- en: becomes
  id: totrans-15121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE666]'
  id: totrans-15122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE666]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-15123
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15124
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15125
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15126
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15127
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15128
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15129
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15130
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15131
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15132
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15133
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15134
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15135
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE667]'
  id: totrans-15137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE667]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE668]'
  id: totrans-15139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE668]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE669]'
  id: totrans-15141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE669]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15142
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15144
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15145
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00069.jpg)'
  id: totrans-15146
  prefs: []
  type: TYPE_IMG
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-15147
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-15148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-15149
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-15150
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-15151
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-15152
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-15153
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-15154
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-15155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-15156
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-15157
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-15158
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-15159
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-15160
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-15161
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-15162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-15163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE670]'
  id: totrans-15164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE670]'
- en: becomes
  id: totrans-15165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE671]'
  id: totrans-15166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE671]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-15167
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15168
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15169
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15170
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15171
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15172
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15173
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15174
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15175
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15176
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15177
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15178
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15179
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE672]'
  id: totrans-15181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE672]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE673]'
  id: totrans-15183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE673]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE674]'
  id: totrans-15185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE674]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15186
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15188
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15189
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the modulo operator is useful for determining whether a number
    is even (evenNumber % 2 equals 0) ➊ or odd (oddNumber % 2 equals 1) ➋ .
  id: totrans-15190
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-15191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-15192
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-15193
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-15194
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-15195
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-15196
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-15197
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-15198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-15199
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-15200
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-15201
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-15202
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-15203
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-15204
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-15205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-15206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE675]'
  id: totrans-15207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE675]'
- en: becomes
  id: totrans-15208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE676]'
  id: totrans-15209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE676]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-15210
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15211
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15212
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15213
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15214
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15215
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15216
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15217
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15218
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15219
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15220
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15221
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15222
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE677]'
  id: totrans-15224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE677]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE678]'
  id: totrans-15226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE678]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE679]'
  id: totrans-15228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE679]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15229
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15231
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15232
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDER OF OPERATIONS**'
  id: totrans-15233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-15234
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-15235
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-15236
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-15237
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-15238
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-15239
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-15240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-15241
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-15242
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-15243
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-15244
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-15245
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-15246
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-15247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-15248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE680]'
  id: totrans-15249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE680]'
- en: becomes
  id: totrans-15250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE681]'
  id: totrans-15251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE681]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-15252
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15253
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15254
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15255
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15256
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15257
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15258
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15259
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15260
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15261
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15262
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15263
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15264
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE682]'
  id: totrans-15266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE682]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE683]'
  id: totrans-15268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE683]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE684]'
  id: totrans-15270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE684]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15271
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15273
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15274
  prefs: []
  type: TYPE_NORMAL
- en: So far we’ve only done one math operation on each line of code, but it’s common
    to do more than one operation on a single line. Let’s look at an example.
  id: totrans-15275
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-15276
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-15277
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-15278
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-15279
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-15280
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-15281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-15282
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-15283
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-15284
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-15285
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-15286
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-15287
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-15288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-15289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE685]'
  id: totrans-15290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE685]'
- en: becomes
  id: totrans-15291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE686]'
  id: totrans-15292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE686]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-15293
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15294
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15295
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15296
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15297
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15298
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15299
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15300
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15301
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15302
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15303
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15304
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15305
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE687]'
  id: totrans-15307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE687]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE688]'
  id: totrans-15309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE688]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE689]'
  id: totrans-15311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE689]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15312
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15314
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15315
  prefs: []
  type: TYPE_NORMAL
- en: 'How much money do you have if you have three five-dollar bills and two one-dollar
    bills? Let’s calculate this on one line:'
  id: totrans-15316
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-15317
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-15318
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-15319
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-15320
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-15321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-15322
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-15323
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-15324
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-15325
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-15326
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-15327
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-15328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-15329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE690]'
  id: totrans-15330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE690]'
- en: becomes
  id: totrans-15331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE691]'
  id: totrans-15332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE691]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-15333
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15334
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15335
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15336
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15337
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15338
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15339
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15340
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15341
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15342
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15343
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15344
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15345
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE692]'
  id: totrans-15347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE692]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE693]'
  id: totrans-15349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE693]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE694]'
  id: totrans-15351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE694]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15352
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15354
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15355
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00070.jpg)'
  id: totrans-15356
  prefs: []
  type: TYPE_IMG
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-15357
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-15358
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-15359
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-15360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-15361
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-15362
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-15363
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-15364
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-15365
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-15366
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-15367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-15368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE695]'
  id: totrans-15369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE695]'
- en: becomes
  id: totrans-15370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE696]'
  id: totrans-15371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE696]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-15372
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15373
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15374
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15375
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15376
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15377
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15378
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15379
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15380
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15381
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15382
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15383
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15384
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE697]'
  id: totrans-15386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE697]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE698]'
  id: totrans-15388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE698]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE699]'
  id: totrans-15390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE699]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15391
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15393
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15394
  prefs: []
  type: TYPE_NORMAL
- en: 'This assigns a value of 17 to myMoney . The computer multiplies 5 times 3 and
    then adds 2\. But how does the computer know to multiply first and *then* add
    2? Does it just work from left to right? No! Take a look at this:'
  id: totrans-15395
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-15396
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-15397
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-15398
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-15399
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-15400
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-15401
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-15402
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-15403
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-15404
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-15405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-15406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE700]'
  id: totrans-15407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE700]'
- en: becomes
  id: totrans-15408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE701]'
  id: totrans-15409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE701]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-15410
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15411
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15412
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15413
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15414
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15415
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15416
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15417
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15418
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15419
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15420
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15421
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15422
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE702]'
  id: totrans-15424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE702]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE703]'
  id: totrans-15426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE703]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE704]'
  id: totrans-15428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE704]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15429
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15431
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15432
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00071.jpg)'
  id: totrans-15433
  prefs: []
  type: TYPE_IMG
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-15434
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-15435
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-15436
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-15437
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-15438
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-15439
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-15440
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-15441
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-15442
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-15443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE705]'
  id: totrans-15444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE705]'
- en: becomes
  id: totrans-15445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE706]'
  id: totrans-15446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE706]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-15447
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15448
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15449
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15450
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15451
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15452
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15453
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15454
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15455
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15456
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15457
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15458
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15459
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15460
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE707]'
  id: totrans-15461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE707]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE708]'
  id: totrans-15463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE708]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE709]'
  id: totrans-15465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE709]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15466
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15468
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15469
  prefs: []
  type: TYPE_NORMAL
- en: We moved the numbers around and the result is still 17\. If the computer just
    went from left to right, it would add 2 + 5 and get 7\. Then it would multiply
    that result, 7, times 3, and get 21\. Even though we changed the order of the
    numbers in our math expression, the computer still multiplies first (which gives
    us 15) and then adds the 2 to get 17\. *The computer will always do multiplication
    and division first, then addition and subtraction.* This is called the *order
    of operations* .
  id: totrans-15470
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-15471
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-15472
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-15473
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-15474
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-15475
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-15476
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-15477
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-15478
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-15479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE710]'
  id: totrans-15480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE710]'
- en: becomes
  id: totrans-15481
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE711]'
  id: totrans-15482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE711]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-15483
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15484
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15485
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15486
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15487
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15488
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15489
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15490
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15491
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15492
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15493
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15494
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15495
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15496
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE712]'
  id: totrans-15497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE712]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15498
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE713]'
  id: totrans-15499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE713]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15500
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE714]'
  id: totrans-15501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE714]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15502
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15504
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15505
  prefs: []
  type: TYPE_NORMAL
- en: '**ORDERING OPERATIONS WITH PARENTHESES**'
  id: totrans-15506
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-15507
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-15508
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-15509
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-15510
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-15511
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-15512
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-15513
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-15514
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE715]'
  id: totrans-15515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE715]'
- en: becomes
  id: totrans-15516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE716]'
  id: totrans-15517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE716]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-15518
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15519
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15520
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15521
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15522
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15523
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15524
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15525
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15526
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15527
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15528
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15529
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15530
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15531
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE717]'
  id: totrans-15532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE717]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15533
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE718]'
  id: totrans-15534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE718]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15535
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE719]'
  id: totrans-15536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE719]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15537
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15538
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15539
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15540
  prefs: []
  type: TYPE_NORMAL
- en: 'You don’t have to rely on the computer to figure out which step to do first
    like we did in the money example. You, the programmer, have the power to decide!
    You can use parentheses to group operations together. When you put parentheses
    around something, you tell the computer to do that step first:'
  id: totrans-15541
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-15542
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-15543
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-15544
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-15545
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-15546
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-15547
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-15548
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE720]'
  id: totrans-15549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE720]'
- en: becomes
  id: totrans-15550
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE721]'
  id: totrans-15551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE721]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-15552
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15553
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15554
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15555
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15556
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15557
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15558
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15559
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15560
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15561
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15562
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15563
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15564
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15565
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE722]'
  id: totrans-15566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE722]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15567
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE723]'
  id: totrans-15568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE723]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15569
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE724]'
  id: totrans-15570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE724]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15571
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15572
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15573
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15574
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00072.jpg)'
  id: totrans-15575
  prefs: []
  type: TYPE_IMG
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-15576
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-15577
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-15578
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-15579
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-15580
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-15581
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE725]'
  id: totrans-15582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE725]'
- en: becomes
  id: totrans-15583
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE726]'
  id: totrans-15584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE726]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-15585
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15586
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15587
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15588
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15589
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15590
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15591
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15592
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15593
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15594
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15595
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15596
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15597
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15598
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE727]'
  id: totrans-15599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE727]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15600
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE728]'
  id: totrans-15601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE728]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15602
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE729]'
  id: totrans-15603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE729]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15604
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15605
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15606
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15607
  prefs: []
  type: TYPE_NORMAL
- en: At ➊ , the parentheses tell the computer to multiply 5 times 3 first and then
    add 2\. This will give you 17\. At ➋ , the parentheses tell the computer to add
    2 plus 5 first and then multiply that by 3, which gives you 21.
  id: totrans-15608
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-15609
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-15610
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-15611
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-15612
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-15613
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE730]'
  id: totrans-15614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE730]'
- en: becomes
  id: totrans-15615
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE731]'
  id: totrans-15616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE731]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-15617
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15618
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15619
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15620
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15621
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15622
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15623
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15624
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15625
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15626
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15627
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15628
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15629
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15630
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE732]'
  id: totrans-15631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE732]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15632
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE733]'
  id: totrans-15633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE733]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15634
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE734]'
  id: totrans-15635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE734]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15636
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15637
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15638
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15639
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make your code even more specific by using parentheses inside of other
    parentheses. The computer will evaluate the inside parentheses first and then
    the outside ones. Try this example:'
  id: totrans-15640
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-15641
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-15642
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-15643
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-15644
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE735]'
  id: totrans-15645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE735]'
- en: becomes
  id: totrans-15646
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE736]'
  id: totrans-15647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE736]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-15648
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15649
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15650
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15651
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15652
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15653
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15654
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15655
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15656
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15657
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15658
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15659
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15660
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15661
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE737]'
  id: totrans-15662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE737]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15663
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE738]'
  id: totrans-15664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE738]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15665
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE739]'
  id: totrans-15666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE739]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15667
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15668
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15669
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15670
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00073.jpg)'
  id: totrans-15671
  prefs: []
  type: TYPE_IMG
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-15672
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-15673
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-15674
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE740]'
  id: totrans-15675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE740]'
- en: becomes
  id: totrans-15676
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE741]'
  id: totrans-15677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE741]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-15678
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15679
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15680
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15681
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15682
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15683
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15684
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15685
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15686
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15687
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15688
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15689
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15690
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15691
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE742]'
  id: totrans-15692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE742]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15693
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE743]'
  id: totrans-15694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE743]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15695
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE744]'
  id: totrans-15696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE744]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15697
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15698
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15699
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15700
  prefs: []
  type: TYPE_NORMAL
- en: First the computer adds 2 and 3 between the inner parentheses. Then it multiplies
    the result by 4, since that’s within the outer set of parentheses. It will add
    the 1 last because it’s outside both sets of parentheses. The final result is
    21.
  id: totrans-15701
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-15702
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-15703
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE745]'
  id: totrans-15704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE745]'
- en: becomes
  id: totrans-15705
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE746]'
  id: totrans-15706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE746]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-15707
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15708
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15709
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15710
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15711
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15712
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15713
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15714
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15715
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15716
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15717
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15718
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15719
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15720
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE747]'
  id: totrans-15721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE747]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15722
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE748]'
  id: totrans-15723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE748]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15724
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE749]'
  id: totrans-15725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE749]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15726
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15727
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15728
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15729
  prefs: []
  type: TYPE_NORMAL
- en: '**COMPOUND ASSIGNMENT OPERATORS**'
  id: totrans-15730
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-15731
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE750]'
  id: totrans-15732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE750]'
- en: becomes
  id: totrans-15733
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE751]'
  id: totrans-15734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE751]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-15735
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15736
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15737
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15738
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15739
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15740
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15741
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15742
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15743
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15744
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15745
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15746
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15747
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15748
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE752]'
  id: totrans-15749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE752]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15750
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE753]'
  id: totrans-15751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE753]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15752
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE754]'
  id: totrans-15753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE754]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15754
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15755
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15756
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15757
  prefs: []
  type: TYPE_NORMAL
- en: Another category of operators that you’ll use is the *compound assignment operators*
    . These are “shortcut” operators that combine a math operator with the assignment
    operator (= ). For example, this expression
  id: totrans-15758
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE755]'
  id: totrans-15759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE755]'
- en: becomes
  id: totrans-15760
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE756]'
  id: totrans-15761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE756]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-15762
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15763
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15764
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15765
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15766
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15767
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15768
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15769
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15770
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15771
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15772
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15773
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15774
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15775
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE757]'
  id: totrans-15776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE757]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15777
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE758]'
  id: totrans-15778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE758]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15779
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE759]'
  id: totrans-15780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE759]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15781
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15782
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15783
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15784
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE760]'
  id: totrans-15785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE760]'
- en: becomes
  id: totrans-15786
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE761]'
  id: totrans-15787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE761]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-15788
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15789
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15790
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15791
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15792
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15793
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15794
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15795
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15796
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15797
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15798
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15799
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15800
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15801
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE762]'
  id: totrans-15802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE762]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15803
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE763]'
  id: totrans-15804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE763]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15805
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE764]'
  id: totrans-15806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE764]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15807
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15808
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15809
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15810
  prefs: []
  type: TYPE_NORMAL
- en: becomes
  id: totrans-15811
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE765]'
  id: totrans-15812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE765]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-15813
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15814
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15815
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15816
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15817
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15818
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15819
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15820
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15821
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15822
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15823
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15824
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15825
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15826
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE766]'
  id: totrans-15827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE766]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15828
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE767]'
  id: totrans-15829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE767]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15830
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE768]'
  id: totrans-15831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE768]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15832
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15833
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15834
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15835
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE769]'
  id: totrans-15836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE769]'
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-15837
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15838
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15839
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15840
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15841
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15842
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15843
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15844
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15845
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15846
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15847
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15848
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15849
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15850
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE770]'
  id: totrans-15851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE770]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15852
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE771]'
  id: totrans-15853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE771]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15854
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE772]'
  id: totrans-15855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE772]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15856
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15857
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15858
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15859
  prefs: []
  type: TYPE_NORMAL
- en: You can use these operators to update the value of a variable or constant by
    performing an operation on it. In plain English, an expression like a += b says
    “add b to a and store the new value in a .” [Table 2-1](text00012.html#ch2tab1)
    shows math expressions using compound assignment operators and the same expressions
    in their longer forms.
  id: totrans-15860
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15861
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15862
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15863
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15864
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15865
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15866
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15867
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15868
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15869
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15870
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15871
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15872
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15873
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE773]'
  id: totrans-15874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE773]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15875
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE774]'
  id: totrans-15876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE774]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15877
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE775]'
  id: totrans-15878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE775]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15879
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15880
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15881
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15882
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Short Form Assignment Operators vs. Long Form Expressions'
  id: totrans-15883
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15884
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15885
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15886
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15887
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15888
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15889
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15890
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15891
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15892
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15893
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15894
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15895
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE776]'
  id: totrans-15896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE776]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15897
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE777]'
  id: totrans-15898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE777]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15899
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE778]'
  id: totrans-15900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE778]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15901
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15902
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15903
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15904
  prefs: []
  type: TYPE_NORMAL
- en: '| **Short form** | **Long form** |'
  id: totrans-15905
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-15906
  prefs: []
  type: TYPE_TB
- en: '| a += b | a = a + b |'
  id: totrans-15907
  prefs: []
  type: TYPE_TB
- en: '| a -= b | a = a - b |'
  id: totrans-15908
  prefs: []
  type: TYPE_TB
- en: '| a *= b | a = a * b |'
  id: totrans-15909
  prefs: []
  type: TYPE_TB
- en: '| a /= b | a = a / b |'
  id: totrans-15910
  prefs: []
  type: TYPE_TB
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15911
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15912
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15913
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15914
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15915
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15916
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE779]'
  id: totrans-15917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE779]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15918
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE780]'
  id: totrans-15919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE780]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15920
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE781]'
  id: totrans-15921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE781]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15922
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15923
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15924
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15925
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see the += operator in action. Imagine that we’re trying to write a program
    to calculate the number of animals on an ark. First we create a variable called
    animalsOnArk and set it to 0 because there aren’t animals on the ark yet. As the
    different types of animals board the ark, we want to increase animalsOnArk to
    count all of the animals. If two giraffes board the ark, then we need to add 2
    to animalsOnArk . If two elephants board the ark, then we need to add 2 again.
    If four antelope board the ark, then we need to increase animalsOnArk by 4.
  id: totrans-15926
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15927
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15928
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15929
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15930
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15931
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE782]'
  id: totrans-15932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE782]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15933
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE783]'
  id: totrans-15934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE783]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15935
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE784]'
  id: totrans-15936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE784]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15937
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15938
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15939
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15940
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Image00074.jpg)![Image](Image00075.jpg)'
  id: totrans-15941
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15942
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15943
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15944
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15945
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE785]'
  id: totrans-15946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE785]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15947
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE786]'
  id: totrans-15948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE786]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15949
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE787]'
  id: totrans-15950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE787]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15951
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15952
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15953
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15954
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Image00075.jpg)'
  id: totrans-15955
  prefs: []
  type: TYPE_IMG
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15956
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15957
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15958
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15959
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE788]'
  id: totrans-15960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE788]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15961
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE789]'
  id: totrans-15962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE789]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15963
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE790]'
  id: totrans-15964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE790]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15965
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15966
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15967
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15968
  prefs: []
  type: TYPE_NORMAL
- en: After two giraffes, two elephants, and four antelope board the ark, the final
    value for animalsOnArk is 8 . What a zoo!
  id: totrans-15969
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15970
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15971
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15972
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE791]'
  id: totrans-15973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE791]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15974
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE792]'
  id: totrans-15975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE792]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15976
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE793]'
  id: totrans-15977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE793]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15978
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15979
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15980
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15981
  prefs: []
  type: TYPE_NORMAL
- en: '**A FEW QUICK COMMENTS ABOUT COMMENTS**'
  id: totrans-15982
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages come with a way to write comments inline with the
    code. Comments are notes that are ignored by the computer and are there to help
    the humans reading the code understand what’s going on. Although a program will
    run fine without any comments, it’s a good idea to include them for sections of
    code that might be unclear or confusing. Even if you’re not going to show your
    program to anybody else, your comments will help you remember what you were doing
    or thinking when you wrote that code. It’s not uncommon to come back to a piece
    of code you wrote months or years ago and have no idea what you were thinking
    at the time.
  id: totrans-15983
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to add comments in Swift. The first way is to put two forward
    slashes (// ) in front of the text you want to add. These comments can be placed
    on their own line, like this:'
  id: totrans-15984
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE794]'
  id: totrans-15985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE794]'
- en: 'Or they can be placed on the same line as a line of code—as long as the comment
    comes *after* the code:'
  id: totrans-15986
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE795]'
  id: totrans-15987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE795]'
- en: The second way is used for long comments, or *multiline* comments, where the
    start and end of the comment is marked by /* and */ . (Note that we’ll use --
    *snip* -- in this book to show where there are more code lines that we’ve omitted
    for space.)
  id: totrans-15988
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE796]'
  id: totrans-15989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE796]'
- en: Multiline comments are useful when you debug your code. For example, if you
    don’t want the computer to run part of your code because you’re trying to find
    a bug, but you also don’t want to delete all of your hard work, you can use multiline
    comments to *comment out* sections of code temporarily. When you format a chunk
    of code as a comment, the computer will ignore that code just like it ignores
    any other comment.
  id: totrans-15990
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15991
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15992
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15993
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-15994
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15995
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15996
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter you learned how to write code in a Swift playground, which lets
    you see results right away. You created variables and constants and learned how
    to use the basic data types and operators that you will be seeing again and again
    as you write your own computer programs.
  id: totrans-15997
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15998
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](text00013.html#ch03) , you will be using conditional statements,
    which tell the computer which code path you want it to go down. The code path
    is chosen based on a condition’s value.
  id: totrans-15999
  prefs: []
  type: TYPE_NORMAL
